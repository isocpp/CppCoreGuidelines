# Pavel Pletenev <cpp.create@gmail.com>, 2018. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-03-13 22:55+0200\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2018-08-28 11:42+0000\n"
"Last-Translator: Pavel Pletenev <cpp.create@gmail.com>\n"
"Language-Team: Russian\n"
"Language: ru\n"
"X-Generator: Zanata 4.6.2\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"

msgid "1    # <a name=\"main\"></a>C++ Core Guidelines"
msgstr "1    # <a name=\"main\"></a>C++ Core Guidelines"

msgid "2    August 13, 2018"
msgstr "2    August 13, 2018"

msgid "3    Editors:"
msgstr "3    Редакторы:"

msgid "4    * [Bjarne Stroustrup](http://www.stroustrup.com)"
msgstr ""
"4    * [Бьёрн Страуструп (Bjarne Stroustrup)](http://www.stroustrup.com)"

msgid "5    * [Herb Sutter](http://herbsutter.com/)"
msgstr "5    * [Герб Саттер (Herb Sutter)](http://herbsutter.com/)"

msgid "6    This is a living document under continuous improvement."
msgstr "6    Это живой документ, подверженный постоянным изменениям"

msgid ""
"7    Had it been an open-source (code) project, this would have been release "
"0.8."
msgstr ""
"7    Если бы это был проект программы с открытым исходным кодом, то это была "
"бы версия 0.8."

msgid ""
"8    Copying, use, modification, and creation of derivative works from this "
"project is licensed under an MIT-style license."
msgstr ""
"8    Копирование, использование, изменение и создание проектов на основе "
"данного лицензируются под лицензией MIT-стиля."

msgid ""
"9    Contributing to this project requires agreeing to a Contributor License."
" See the accompanying [LICENSE](LICENSE) file for details."
msgstr ""
"9    Для создания дополнений в данный проект необходимо согласие с Лицензией "
"на Дополнения. Подробнее см. сопровождающий файл  [LICENSE](LICENSE)."

msgid ""
"10    We make this project available to \"friendly users\" to use, copy, "
"modify, and derive from, hoping for constructive input."
msgstr ""
"10    Мы открываем данный проект для \"дружественных пользователей\", "
"которые могут использовать, копировать, изменять и создавать своё на основе "
"в надежде на конструктивную обратную связь."

msgid "11    Comments and suggestions for improvements are most welcome."
msgstr "11    Комментарии и предложения очень приветствуются."

msgid ""
"12    We plan to modify and extend this document as our understanding "
"improves and the language and the set of available libraries improve."
msgstr ""
"12    Мы планируем изменять и расширять данный документ по мере улучшения "
"нашего понимания и расширения спектра доступных библиотек."

msgid ""
"13    When commenting, please note [the introduction](#S-introduction) that "
"outlines our aims and general approach."
msgstr ""
"13    При комментировании учитывайте, пожалуйста, [введение](#S-"
"introduction), в котором очерчены наши цели и общий подход."

msgid "14    The list of contributors is [here](#SS-ack)."
msgstr "14    Список приславших дополнения находится [здесь](#SS-ack)."

msgid "15    Problems:"
msgstr "15    Проблемы:"

msgid ""
"16    * The sets of rules have not been completely checked for completeness, "
"consistency, or enforceability."
msgstr ""
"16    *Наборы правил не проверялись на полноценность, консистентность или "
"применимость."

msgid "17    * Triple question marks (???) mark known missing information"
msgstr ""
"17    * Тройные вопросительные знаки (???) указывают на отсутствующую "
"информацию."

msgid "18    * Update reference sections; many pre-C++11 sources are too old."
msgstr ""
"18    * Обновление справочных разделов; множество исходных кодов из эры до "
"стандарта C++11 слишком старые."

msgid ""
"19    * For a more-or-less up-to-date to-do list see: [To-do: Unclassified "
"proto-rules](#S-unclassified)"
msgstr ""
"19    * Более подробный список бущущих дел см. в разделе: [To-do: "
"Unclassified proto-rules](#S-unclassified)"

msgid ""
"20    You can [read an explanation of the scope and structure of this "
"Guide](#S-abstract) or just jump straight in:"
msgstr ""
"20    Вы можете [прочитать более подробную информацию о масшабе и структуре "
"данного Руководства](#S-abstract) или начать читать сразу:"

msgid "21    * [In: Introduction](#S-introduction)"
msgstr "21    * [In: Введение](#S-introduction)"

msgid "22    * [P: Philosophy](#S-philosophy)"
msgstr "22    * [P: Философия](#S-philosophy)"

msgid "23    * [I: Interfaces](#S-interfaces)"
msgstr "23    * [I: Интерфейсы](#S-interfaces)"

msgid "24    * [F: Functions](#S-functions)"
msgstr "24    * [F: Функции](#S-functions)"

msgid "25    * [C: Classes and class hierarchies](#S-class)"
msgstr ""

msgid "26    * [Enum: Enumerations](#S-enum)"
msgstr ""

msgid "27    * [R: Resource management](#S-resource)"
msgstr ""

msgid "28    * [ES: Expressions and statements](#S-expr)"
msgstr ""

msgid "29    * [Per: Performance](#S-performance)"
msgstr ""

msgid "30    * [CP: Concurrency and parallelism](#S-concurrency)"
msgstr ""

msgid "31    * [E: Error handling](#S-errors)"
msgstr ""

msgid "32    * [Con: Constants and immutability](#S-const)"
msgstr ""

msgid "33    * [T: Templates and generic programming](#S-templates)"
msgstr ""

msgid "34    * [CPL: C-style programming](#S-cpl)"
msgstr ""

msgid "35    * [SF: Source files](#S-source)"
msgstr ""

msgid "36    * [SL: The Standard Library](#S-stdlib)"
msgstr ""

msgid "37    Supporting sections:"
msgstr ""

msgid "38    * [A: Architectural ideas](#S-A)"
msgstr ""

msgid "39    * [NR: Non-Rules and myths](#S-not)"
msgstr ""

msgid "40    * [RF: References](#S-references)"
msgstr ""

msgid "41    * [Pro: Profiles](#S-profile)"
msgstr ""

msgid "42    * [GSL: Guidelines support library](#S-gsl)"
msgstr ""

msgid "43    * [NL: Naming and layout rules](#S-naming)"
msgstr ""

msgid "44    * [FAQ: Answers to frequently asked questions](#S-faq)"
msgstr ""

msgid "45    * [Appendix A: Libraries](#S-libraries)"
msgstr ""

msgid "46    * [Appendix B: Modernizing code](#S-modernizing)"
msgstr ""

msgid "47    * [Appendix C: Discussion](#S-discussion)"
msgstr ""

msgid "48    * [Appendix D: Supporting tools](#S-tools)"
msgstr ""

msgid "49    * [Glossary](#S-glossary)"
msgstr ""

msgid "50    * [To-do: Unclassified proto-rules](#S-unclassified)"
msgstr ""

msgid "51    You can sample rules for specific language features:"
msgstr ""

msgid "52    * assignment:"
msgstr ""

msgid "53    [regular types](#Rc-regular) --"
msgstr ""

msgid "54    [prefer initialization](#Rc-initialize) --"
msgstr ""

msgid "55    [copy](#Rc-copy-semantic) --"
msgstr ""

msgid "56    [move](#Rc-move-semantic) --"
msgstr ""

msgid "57    [other operations](#Rc-matched) --"
msgstr ""

msgid "58    [default](#Rc-eqdefault)"
msgstr ""

msgid "59    * `class`:"
msgstr ""

msgid "60    [data](#Rc-org) --"
msgstr ""

msgid "61    [invariant](#Rc-struct) --"
msgstr ""

msgid "62    [members](#Rc-member) --"
msgstr ""

msgid "63    [helpers](#Rc-helper) --"
msgstr ""

msgid "64    [concrete types](#SS-concrete) --"
msgstr ""

msgid "65    [ctors, =, and dtors](#S-ctor) --"
msgstr ""

msgid "66    [hierarchy](#SS-hier) --"
msgstr ""

msgid "67    [operators](#SS-overload)"
msgstr ""

msgid "68    * `concept`:"
msgstr ""

msgid "69    [rules](#SS-concepts) --"
msgstr ""

msgid "70    [in generic programming](#Rt-raise) --"
msgstr ""

msgid "71    [template arguments](#Rt-concepts) --"
msgstr ""

msgid "72    [semantics](#Rt-low)"
msgstr ""

msgid "73    * constructor:"
msgstr ""

msgid "74    [invariant](#Rc-struct) --"
msgstr ""

msgid "75    [establish invariant](#Rc-ctor) --"
msgstr ""

msgid "76    [`throw`](#Rc-throw) --"
msgstr ""

msgid "77    [default](#Rc-default0) --"
msgstr ""

msgid "78    [not needed](#Rc-default) --"
msgstr ""

msgid "79    [`explicit`](#Rc-explicit) --"
msgstr ""

msgid "80    [delegating](#Rc-delegating) --"
msgstr ""

msgid "81    [`virtual`](#Rc-ctor-virtual)"
msgstr ""

msgid "82    * derived `class`:"
msgstr ""

msgid "83    [when to use](#Rh-domain) --"
msgstr ""

msgid "84    [as interface](#Rh-abstract) --"
msgstr ""

msgid "85    [destructors](#Rh-dtor) --"
msgstr ""

msgid "86    [copy](#Rh-copy) --"
msgstr ""

msgid "87    [getters and setters](#Rh-get) --"
msgstr ""

msgid "88    [multiple inheritance](#Rh-mi-interface) --"
msgstr ""

msgid "89    [overloading](#Rh-using) --"
msgstr ""

msgid "90    [slicing](#Rc-copy-virtual) --"
msgstr ""

msgid "91    [`dynamic_cast`](#Rh-dynamic_cast)"
msgstr ""

msgid "92    * destructor:"
msgstr ""

msgid "93    [and constructors](#Rc-matched) --"
msgstr ""

msgid "94    [when needed?](#Rc-dtor) --"
msgstr ""

msgid "95    [may not fail](#Rc-dtor-fail)"
msgstr ""

msgid "96    * exception:"
msgstr ""

msgid "97    [errors](#S-errors) --"
msgstr ""

msgid "98    [`throw`](#Re-throw) --"
msgstr ""

msgid "99    [for errors only](#Re-errors) --"
msgstr ""

msgid "100    [`noexcept`](#Re-noexcept) --"
msgstr ""

msgid "101    [minimize `try`](#Re-catch) --"
msgstr ""

msgid "102    [what if no exceptions?](#Re-no-throw-codes)"
msgstr ""

msgid "103    * `for`:"
msgstr ""

msgid "104    [range-for and for](#Res-for-range) --"
msgstr ""

msgid "105    [for and while](#Res-for-while) --"
msgstr ""

msgid "106    [for-initializer](#Res-for-init) --"
msgstr ""

msgid "107    [empty body](#Res-empty) --"
msgstr ""

msgid "108    [loop variable](#Res-loop-counter) --"
msgstr ""

msgid "109    [loop variable type ???](#Res-???)"
msgstr ""

msgid "110    * function:"
msgstr ""

msgid "111    [naming](#Rf-package) --"
msgstr ""

msgid "112    [single operation](#Rf-logical) --"
msgstr ""

msgid "113    [no throw](#Rf-noexcept) --"
msgstr ""

msgid "114    [arguments](#Rf-smart) --"
msgstr ""

msgid "115    [argument passing](#Rf-conventional) --"
msgstr ""

msgid "116    [multiple return values](#Rf-out-multi) --"
msgstr ""

msgid "117    [pointers](#Rf-return-ptr) --"
msgstr ""

msgid "118    [lambdas](#Rf-capture-vs-overload)"
msgstr ""

msgid "119    * `inline`:"
msgstr ""

msgid "120    [small functions](#Rf-inline) --"
msgstr ""

msgid "121    [in headers](#Rs-inline)"
msgstr ""

msgid "122    * initialization:"
msgstr ""

msgid "123    [always](#Res-always) --"
msgstr ""

msgid "124    [prefer `{}`](#Res-list) --"
msgstr ""

msgid "125    [lambdas](#Res-lambda-init) --"
msgstr ""

msgid "126    [in-class initializers](#Rc-in-class-initializer) --"
msgstr ""

msgid "127    [class members](#Rc-initialize) --"
msgstr ""

msgid "128    [factory functions](#Rc-factory)"
msgstr ""

msgid "129    * lambda expression:"
msgstr ""

msgid "130    [when to use](#SS-lambdas)"
msgstr ""

msgid "131    * operator:"
msgstr ""

msgid "132    [conventional](#Ro-conventional) --"
msgstr ""

msgid "133    [avoid conversion operators](#Ro-conversion) --"
msgstr ""

msgid "134    [and lambdas](#Ro-lambda)"
msgstr ""

msgid "135    * `public`, `private`, and `protected`:"
msgstr ""

msgid "136    [information hiding](#Rc-private) --"
msgstr ""

msgid "137    [consistency](#Rh-public) --"
msgstr ""

msgid "138    [`protected`](#Rh-protected)"
msgstr ""

msgid "139    * `static_assert`:"
msgstr ""

msgid "140    [compile-time checking](#Rp-compile-time) --"
msgstr ""

msgid "141    [and concepts](#Rt-check-class)"
msgstr ""

msgid "142    * `struct`:"
msgstr ""

msgid "143    [for organizing data](#Rc-org) --"
msgstr ""

msgid "144    [use if no invariant](#Rc-struct) --"
msgstr ""

msgid "145    [no private members](#Rc-class)"
msgstr ""

msgid "146    * `template`:"
msgstr ""

msgid "147    [abstraction](#Rt-raise) --"
msgstr ""

msgid "148    [containers](#Rt-cont) --"
msgstr ""

msgid "149    [concepts](#Rt-concepts)"
msgstr ""

msgid "150    * `unsigned`:"
msgstr ""

msgid "151    [and signed](#Res-mix) --"
msgstr ""

msgid "152    [bit manipulation](#Res-unsigned)"
msgstr ""

msgid "153    * `virtual`:"
msgstr ""

msgid "154    [interfaces](#Ri-abstract) --"
msgstr ""

msgid "155    [not `virtual`](#Rc-concrete) --"
msgstr ""

msgid "156    [destructor](#Rc-dtor-virtual) --"
msgstr ""

msgid "157    [never fail](#Rc-dtor-fail)"
msgstr ""

msgid "158    You can look at design concepts used to express the rules:"
msgstr ""

msgid "159    * assertion: ???"
msgstr ""

msgid "160    * error: ???"
msgstr ""

msgid "161    * exception: exception guarantee (???)"
msgstr ""

msgid "162    * failure: ???"
msgstr ""

msgid "163    * invariant: ???"
msgstr ""

msgid "164    * leak: ???"
msgstr ""

msgid "165    * library: ???"
msgstr ""

msgid "166    * precondition: ???"
msgstr ""

msgid "167    * postcondition: ???"
msgstr ""

msgid "168    * resource: ???"
msgstr ""

msgid "169    # <a name=\"S-abstract\"></a>Abstract"
msgstr ""

msgid "170    This document is a set of guidelines for using C++ well."
msgstr ""

msgid ""
"171    The aim of this document is to help people to use modern C++ "
"effectively."
msgstr ""

msgid "172    By \"modern C++\" we mean C++17, C++14, and C++11."
msgstr ""

msgid ""
"173    In other words, what would you like your code to look like in 5 "
"years' time, given that you can start now? In 10 years' time?"
msgstr ""

msgid ""
"174    The guidelines are focused on relatively high-level issues, such as "
"interfaces, resource management, memory management, and concurrency."
msgstr ""

msgid "175    Such rules affect application architecture and library design."
msgstr ""

msgid ""
"176    Following the rules will lead to code that is statically type safe, "
"has no resource leaks, and catches many more programming logic errors than "
"is common in code today."
msgstr ""

msgid "177    And it will run fast -- you can afford to do things right."
msgstr ""

msgid ""
"178    We are less concerned with low-level issues, such as naming "
"conventions and indentation style."
msgstr ""

msgid "179    However, no topic that can help a programmer is out of bounds."
msgstr ""

msgid ""
"180    Our initial set of rules emphasizes safety (of various forms) and "
"simplicity."
msgstr ""

msgid "181    They may very well be too strict."
msgstr ""

msgid ""
"182    We expect to have to introduce more exceptions to better accommodate "
"real-world needs."
msgstr ""

msgid "183    We also need more rules."
msgstr ""

msgid ""
"184    You will find some of the rules contrary to your expectations or even "
"contrary to your experience."
msgstr ""

msgid ""
"185    If we haven't suggested you change your coding style in any way, we "
"have failed!"
msgstr ""

msgid "186    Please try to verify or disprove rules!"
msgstr ""

msgid ""
"187    In particular, we'd really like to have some of our rules backed up "
"with measurements or better examples."
msgstr ""

msgid "188    You will find some of the rules obvious or even trivial."
msgstr ""

msgid ""
"189    Please remember that one purpose of a guideline is to help someone "
"who is less experienced or coming from a different background or language to "
"get up to speed."
msgstr ""

msgid ""
"190    Many of the rules are designed to be supported by an analysis tool."
msgstr ""

msgid ""
"191    Violations of rules will be flagged with references (or links) to the "
"relevant rule."
msgstr ""

msgid ""
"192    We do not expect you to memorize all the rules before trying to write "
"code."
msgstr ""

msgid ""
"193    One way of thinking about these guidelines is as a specification for "
"tools that happens to be readable by humans."
msgstr ""

msgid "194    The rules are meant for gradual introduction into a code base."
msgstr ""

msgid "195    We plan to build tools for that and hope others will too."
msgstr ""

msgid "196    Comments and suggestions for improvements are most welcome."
msgstr ""

msgid ""
"197    We plan to modify and extend this document as our understanding "
"improves and the language and the set of available libraries improve."
msgstr ""

msgid "198    # <a name=\"S-introduction\"></a>In: Introduction"
msgstr ""

msgid ""
"199    This is a set of core guidelines for modern C++, C++17, C++14, and "
"C++11, taking likely future enhancements and ISO Technical Specifications "
"(TSs) into account."
msgstr ""

msgid ""
"200    The aim is to help C++ programmers to write simpler, more efficient, "
"more maintainable code."
msgstr ""

msgid "201    Introduction summary:"
msgstr ""

msgid "202    * [In.target: Target readership](#SS-readers)"
msgstr ""

msgid "203    * [In.aims: Aims](#SS-aims)"
msgstr ""

msgid "204    * [In.not: Non-aims](#SS-non)"
msgstr ""

msgid "205    * [In.force: Enforcement](#SS-force)"
msgstr ""

msgid "206    * [In.struct: The structure of this document](#SS-struct)"
msgstr ""

msgid "207    * [In.sec: Major sections](#SS-sec)"
msgstr ""

msgid "208    ## <a name=\"SS-readers\"></a>In.target: Target readership"
msgstr ""

msgid ""
"209    All C++ programmers. This includes [programmers who might consider "
"C](#S-cpl)."
msgstr ""

msgid "210    ## <a name=\"SS-aims\"></a>In.aims: Aims"
msgstr ""

msgid ""
"211    The purpose of this document is to help developers to adopt modern "
"C++ (C++17, C++14, and C++11) and to achieve a more uniform style across "
"code bases."
msgstr ""

msgid ""
"212    We do not suffer the delusion that every one of these rules can be "
"effectively applied to every code base. Upgrading old systems is hard. "
"However, we do believe that a program that uses a rule is less error-prone "
"and more maintainable than one that does not. Often, rules also lead to "
"faster/easier initial development."
msgstr ""

msgid ""
"213    As far as we can tell, these rules lead to code that performs as well "
"or better than older, more conventional techniques; they are meant to follow "
"the zero-overhead principle (\"what you don't use, you don't pay for\" or "
"\"when you use an abstraction mechanism appropriately, you get at least as "
"good performance as if you had handcoded using lower-level language "
"constructs\")."
msgstr ""

msgid ""
"214    Consider these rules ideals for new code, opportunities to exploit "
"when working on older code, and try to approximate these ideals as closely "
"as feasible."
msgstr ""

msgid "215    Remember:"
msgstr ""

msgid "216    ### <a name=\"R0\"></a>In.0: Don't panic!"
msgstr ""

msgid ""
"217    Take the time to understand the implications of a guideline rule on "
"your program."
msgstr ""

msgid ""
"218    These guidelines are designed according to the \"subset of superset\" "
"principle ([Stroustrup05](#Stroustrup05))."
msgstr ""

msgid ""
"219    They do not simply define a subset of C++ to be used (for "
"reliability, safety, performance, or whatever)."
msgstr ""

msgid ""
"220    Instead, they strongly recommend the use of a few simple "
"\"extensions\" ([library components](#S-gsl))"
msgstr ""

msgid ""
"221    that make the use of the most error-prone features of C++ redundant, "
"so that they can be banned (in our set of rules)."
msgstr ""

msgid "222    The rules emphasize static type safety and resource safety."
msgstr ""

msgid ""
"223    For that reason, they emphasize possibilities for range checking, for "
"avoiding dereferencing `nullptr`, for avoiding dangling pointers, and the "
"systematic use of exceptions (via RAII)."
msgstr ""

msgid ""
"224    Partly to achieve that and partly to minimize obscure code as a "
"source of errors, the rules also emphasize simplicity and the hiding of "
"necessary complexity behind well-specified interfaces."
msgstr ""

msgid "225    Many of the rules are prescriptive."
msgstr ""

msgid ""
"226    We are uncomfortable with rules that simply state \"don't do that!\" "
"without offering an alternative."
msgstr ""

msgid ""
"227    One consequence of that is that some rules can be supported only by "
"heuristics, rather than precise and mechanically verifiable checks."
msgstr ""

msgid ""
"228    Other rules articulate general principles. For these more general "
"rules, more detailed and specific rules provide partial checking."
msgstr ""

msgid "229    These guidelines address the core of C++ and its use."
msgstr ""

msgid ""
"230    We expect that most large organizations, specific application areas, "
"and even large projects will need further rules, possibly further "
"restrictions, and further library support."
msgstr ""

msgid ""
"231    For example, hard-real-time programmers typically can't use free "
"store (dynamic memory) freely and will be restricted in their choice of "
"libraries."
msgstr ""

msgid ""
"232    We encourage the development of such more specific rules as addenda "
"to these core guidelines."
msgstr ""

msgid ""
"233    Build your ideal small foundation library and use that, rather than "
"lowering your level of programming to glorified assembly code."
msgstr ""

msgid ""
"234    The rules are designed to allow [gradual adoption](#S-modernizing)."
msgstr ""

msgid ""
"235    Some rules aim to increase various forms of safety while others aim "
"to reduce the likelihood of accidents, many do both."
msgstr ""

msgid ""
"236    The guidelines aimed at preventing accidents often ban perfectly "
"legal C++."
msgstr ""

msgid ""
"237    However, when there are two ways of expressing an idea and one has "
"shown itself a common source of errors and the other has not, we try to "
"guide programmers towards the latter."
msgstr ""

msgid "238    ## <a name=\"SS-non\"></a>In.not: Non-aims"
msgstr ""

msgid "239    The rules are not intended to be minimal or orthogonal."
msgstr ""

msgid "240    In particular, general rules can be simple, but unenforceable."
msgstr ""

msgid ""
"241    Also, it is often hard to understand the implications of a general "
"rule."
msgstr ""

msgid ""
"242    More specialized rules are often easier to understand and to enforce, "
"but without general rules, they would just be a long list of special cases."
msgstr ""

msgid ""
"243    We provide rules aimed at helping novices as well as rules supporting "
"expert use."
msgstr ""

msgid ""
"244    Some rules can be completely enforced, but others are based on "
"heuristics."
msgstr ""

msgid "245    These rules are not meant to be read serially, like a book."
msgstr ""

msgid "246    You can browse through them using the links."
msgstr ""

msgid "247    However, their main intended use is to be targets for tools."
msgstr ""

msgid ""
"248    That is, a tool looks for violations and the tool returns links to "
"violated rules."
msgstr ""

msgid ""
"249    The rules then provide reasons, examples of potential consequences of "
"the violation, and suggested remedies."
msgstr ""

msgid ""
"250    These guidelines are not intended to be a substitute for a tutorial "
"treatment of C++."
msgstr ""

msgid ""
"251    If you need a tutorial for some given level of experience, see [the "
"references](#S-references)."
msgstr ""

msgid ""
"252    This is not a guide on how to convert old C++ code to more modern "
"code."
msgstr ""

msgid ""
"253    It is meant to articulate ideas for new code in a concrete fashion."
msgstr ""

msgid ""
"254    However, see [the modernization section](#S-modernizing) for some "
"possible approaches to modernizing/rejuvenating/upgrading."
msgstr ""

msgid ""
"255    Importantly, the rules support gradual adoption: It is typically "
"infeasible to completely convert a large code base all at once."
msgstr ""

msgid ""
"256    These guidelines are not meant to be complete or exact in every "
"language-technical detail."
msgstr ""

msgid ""
"257    For the final word on language definition issues, including every "
"exception to general rules and every feature, see the ISO C++ standard."
msgstr ""

msgid ""
"258    The rules are not intended to force you to write in an impoverished "
"subset of C++."
msgstr ""

msgid ""
"259    They are *emphatically* not meant to define a, say, Java-like subset "
"of C++."
msgstr ""

msgid "260    They are not meant to define a single \"one true C++\" language."
msgstr ""

msgid "261    We value expressiveness and uncompromised performance."
msgstr ""

msgid "262    The rules are not value-neutral."
msgstr ""

msgid ""
"263    They are meant to make code simpler and more correct/safer than most "
"existing C++ code, without loss of performance."
msgstr ""

msgid ""
"264    They are meant to inhibit perfectly valid C++ code that correlates "
"with errors, spurious complexity, and poor performance."
msgstr ""

msgid "265    The rules are not perfect."
msgstr ""

msgid ""
"266    A rule can do harm by prohibiting something that is useful in a given "
"situation."
msgstr ""

msgid ""
"267    A rule can do harm by failing to prohibit something that enables a "
"serious error in a given situation."
msgstr ""

msgid ""
"268    A rule can do a lot of harm by being vague, ambiguous, unenforceable, "
"or by enabling every solution to a problem."
msgstr ""

msgid "269    It is impossible to completely meet the \"do no harm\" criteria."
msgstr ""

msgid ""
"270    Instead, our aim is the less ambitious: \"Do the most good for most "
"programmers\";"
msgstr ""

msgid ""
"271    if you cannot live with a rule, object to it, ignore it, but don't "
"water it down until it becomes meaningless."
msgstr ""

msgid "272    Also, suggest an improvement."
msgstr ""

msgid "273    ## <a name=\"SS-force\"></a>In.force: Enforcement"
msgstr ""

msgid ""
"274    Rules with no enforcement are unmanageable for large code bases."
msgstr ""

msgid ""
"275    Enforcement of all rules is possible only for a small weak set of "
"rules or for a specific user community."
msgstr ""

msgid ""
"276    * But we want lots of rules, and we want rules that everybody can use."
""
msgstr ""

msgid "277    * But different people have different needs."
msgstr ""

msgid "278    * But people don't like to read lots of rules."
msgstr ""

msgid "279    * But people can't remember many rules."
msgstr ""

msgid "280    So, we need subsetting to meet a variety of needs."
msgstr ""

msgid "281    * But arbitrary subsetting leads to chaos."
msgstr ""

msgid ""
"282    We want guidelines that help a lot of people, make code more uniform, "
"and strongly encourage people to modernize their code."
msgstr ""

msgid ""
"283    We want to encourage best practices, rather than leave all to "
"individual choices and management pressures."
msgstr ""

msgid ""
"284    The ideal is to use all rules; that gives the greatest benefits."
msgstr ""

msgid "285    This adds up to quite a few dilemmas."
msgstr ""

msgid "286    We try to resolve those using tools."
msgstr ""

msgid ""
"287    Each rule has an **Enforcement** section listing ideas for "
"enforcement."
msgstr ""

msgid ""
"288    Enforcement might be done by code review, by static analysis, by "
"compiler, or by run-time checks."
msgstr ""

msgid ""
"289    Wherever possible, we prefer \"mechanical\" checking (humans are "
"slow, inaccurate, and bore easily) and static checking."
msgstr ""

msgid ""
"290    Run-time checks are suggested only rarely where no alternative "
"exists; we do not want to introduce \"distributed fat\"."
msgstr ""

msgid ""
"291    Where appropriate, we label a rule (in the **Enforcement** sections) "
"with the name of groups of related rules (called \"profiles\")."
msgstr ""

msgid "292    A rule can be part of several profiles, or none."
msgstr ""

msgid ""
"293    For a start, we have a few profiles corresponding to common needs "
"(desires, ideals):"
msgstr ""

msgid ""
"294    * **type**: No type violations (reinterpreting a `T` as a `U` through "
"casts, unions, or varargs)"
msgstr ""

msgid ""
"295    * **bounds**: No bounds violations (accessing beyond the range of an "
"array)"
msgstr ""

msgid ""
"296    * **lifetime**: No leaks (failing to `delete` or multiple `delete`) "
"and no access to invalid objects (dereferencing `nullptr`, using a dangling "
"reference)."
msgstr ""

msgid ""
"297    The profiles are intended to be used by tools, but also serve as an "
"aid to the human reader."
msgstr ""

msgid ""
"298    We do not limit our comment in the **Enforcement** sections to things "
"we know how to enforce; some comments are mere wishes that might inspire "
"some tool builder."
msgstr ""

msgid ""
"299    Tools that implement these rules shall respect the following syntax "
"to explicitly suppress a rule:"
msgstr ""

msgid "300        [[gsl::suppress(tag)]]"
msgstr ""

msgid ""
"301    where \"tag\" is the anchor name of the item where the Enforcement "
"rule appears (e.g., for [C.134](#Rh-public) it is \"Rh-public\"), the"
msgstr ""

msgid ""
"302    name of a profile group-of-rules (\"type\", \"bounds\", or "
"\"lifetime\"),"
msgstr ""

msgid ""
"303    or a specific rule in a profile ([type.4](#Pro-type-cstylecast), or "
"[bounds.2](#Pro-bounds-arrayindex))."
msgstr ""

msgid ""
"304    ## <a name=\"SS-struct\"></a>In.struct: The structure of this "
"document"
msgstr ""

msgid "305    Each rule (guideline, suggestion) can have several parts:"
msgstr ""

msgid "306    * The rule itself -- e.g., **no naked `new`**"
msgstr ""

msgid ""
"307    * A rule reference number -- e.g., **C.7** (the 7th rule related to "
"classes)."
msgstr ""

msgid ""
"308      Since the major sections are not inherently ordered, we use letters "
"as the first part of a rule reference \"number\"."
msgstr ""

msgid ""
"309      We leave gaps in the numbering to minimize \"disruption\" when we "
"add or remove rules."
msgstr ""

msgid ""
"310    * **Reason**s (rationales) -- because programmers find it hard to "
"follow rules they don't understand"
msgstr ""

msgid ""
"311    * **Example**s -- because rules are hard to understand in the "
"abstract; can be positive or negative"
msgstr ""

msgid "312    * **Alternative**s -- for \"don't do this\" rules"
msgstr ""

msgid ""
"313    * **Exception**s -- we prefer simple general rules. However, many "
"rules apply widely, but not universally, so exceptions must be listed"
msgstr ""

msgid ""
"314    * **Enforcement** -- ideas about how the rule might be checked "
"\"mechanically\""
msgstr ""

msgid ""
"315    * **See also**s -- references to related rules and/or further "
"discussion (in this document or elsewhere)"
msgstr ""

msgid ""
"316    * **Note**s (comments) -- something that needs saying that doesn't "
"fit the other classifications"
msgstr ""

msgid ""
"317    * **Discussion** -- references to more extensive rationale and/or "
"examples placed outside the main lists of rules"
msgstr ""

msgid ""
"318    Some rules are hard to check mechanically, but they all meet the "
"minimal criteria that an expert programmer can spot many violations without "
"too much trouble."
msgstr ""

msgid ""
"319    We hope that \"mechanical\" tools will improve with time to "
"approximate what such an expert programmer notices."
msgstr ""

msgid ""
"320    Also, we assume that the rules will be refined over time to make them "
"more precise and checkable."
msgstr ""

msgid ""
"321    A rule is aimed at being simple, rather than carefully phrased to "
"mention every alternative and special case."
msgstr ""

msgid ""
"322    Such information is found in the **Alternative** paragraphs and the "
"[Discussion](#S-discussion) sections."
msgstr ""

msgid ""
"323    If you don't understand a rule or disagree with it, please visit its "
"**Discussion**."
msgstr ""

msgid ""
"324    If you feel that a discussion is missing or incomplete, enter an "
"[Issue](https://github.com/isocpp/CppCoreGuidelines/issues)"
msgstr ""

msgid "325    explaining your concerns and possibly a corresponding PR."
msgstr ""

msgid "326    This is not a language manual."
msgstr ""

msgid ""
"327    It is meant to be helpful, rather than complete, fully accurate on "
"technical details, or a guide to existing code."
msgstr ""

msgid ""
"328    Recommended information sources can be found in [the references](#S-"
"references)."
msgstr ""

msgid "329    ## <a name=\"SS-sec\"></a>In.sec: Major sections"
msgstr ""

msgid "330    * [In: Introduction](#S-introduction)"
msgstr ""

msgid "331    * [P: Philosophy](#S-philosophy)"
msgstr ""

msgid "332    * [I: Interfaces](#S-interfaces)"
msgstr ""

msgid "333    * [F: Functions](#S-functions)"
msgstr ""

msgid "334    * [C: Classes and class hierarchies](#S-class)"
msgstr ""

msgid "335    * [Enum: Enumerations](#S-enum)"
msgstr ""

msgid "336    * [R: Resource management](#S-resource)"
msgstr ""

msgid "337    * [ES: Expressions and statements](#S-expr)"
msgstr ""

msgid "338    * [Per: Performance](#S-performance)"
msgstr ""

msgid "339    * [CP: Concurrency and parallelism](#S-concurrency)"
msgstr ""

msgid "340    * [E: Error handling](#S-errors)"
msgstr ""

msgid "341    * [Con: Constants and immutability](#S-const)"
msgstr ""

msgid "342    * [T: Templates and generic programming](#S-templates)"
msgstr ""

msgid "343    * [CPL: C-style programming](#S-cpl)"
msgstr ""

msgid "344    * [SF: Source files](#S-source)"
msgstr ""

msgid "345    * [SL: The Standard Library](#S-stdlib)"
msgstr ""

msgid "346    Supporting sections:"
msgstr ""

msgid "347    * [A: Architectural ideas](#S-A)"
msgstr ""

msgid "348    * [NR: Non-Rules and myths](#S-not)"
msgstr ""

msgid "349    * [RF: References](#S-references)"
msgstr ""

msgid "350    * [Pro: Profiles](#S-profile)"
msgstr ""

msgid "351    * [GSL: Guidelines support library](#S-gsl)"
msgstr ""

msgid "352    * [NL: Naming and layout rules](#S-naming)"
msgstr ""

msgid "353    * [FAQ: Answers to frequently asked questions](#S-faq)"
msgstr ""

msgid "354    * [Appendix A: Libraries](#S-libraries)"
msgstr ""

msgid "355    * [Appendix B: Modernizing code](#S-modernizing)"
msgstr ""

msgid "356    * [Appendix C: Discussion](#S-discussion)"
msgstr ""

msgid "357    * [Appendix D: Supporting tools](#S-tools)"
msgstr ""

msgid "358    * [Glossary](#S-glossary)"
msgstr ""

msgid "359    * [To-do: Unclassified proto-rules](#S-unclassified)"
msgstr ""

msgid "360    These sections are not orthogonal."
msgstr ""

msgid ""
"361    Each section (e.g., \"P\" for \"Philosophy\") and each subsection (e."
"g., \"C.hier\" for \"Class Hierarchies (OOP)\") have an abbreviation for "
"ease of searching and reference."
msgstr ""

msgid ""
"362    The main section abbreviations are also used in rule numbers (e.g., "
"\"C.11\" for \"Make concrete types regular\")."
msgstr ""

msgid "363    # <a name=\"S-philosophy\"></a>P: Philosophy"
msgstr ""

msgid "364    The rules in this section are very general."
msgstr ""

msgid "365    Philosophy rules summary:"
msgstr ""

msgid "366    * [P.1: Express ideas directly in code](#Rp-direct)"
msgstr ""

msgid "367    * [P.2: Write in ISO Standard C++](#Rp-Cplusplus)"
msgstr ""

msgid "368    * [P.3: Express intent](#Rp-what)"
msgstr ""

msgid ""
"369    * [P.4: Ideally, a program should be statically type safe](#Rp-"
"typesafe)"
msgstr ""

msgid ""
"370    * [P.5: Prefer compile-time checking to run-time checking](#Rp-"
"compile-time)"
msgstr ""

msgid ""
"371    * [P.6: What cannot be checked at compile time should be checkable at "
"run time](#Rp-run-time)"
msgstr ""

msgid "372    * [P.7: Catch run-time errors early](#Rp-early)"
msgstr ""

msgid "373    * [P.8: Don't leak any resources](#Rp-leak)"
msgstr ""

msgid "374    * [P.9: Don't waste time or space](#Rp-waste)"
msgstr ""

msgid "375    * [P.10: Prefer immutable data to mutable data](#Rp-mutable)"
msgstr ""

msgid ""
"376    * [P.11: Encapsulate messy constructs, rather than spreading through "
"the code](#Rp-library)"
msgstr ""

msgid "377    * [P.12: Use supporting tools as appropriate](#Rp-tools)"
msgstr ""

msgid "378    * [P.13: Use support libraries as appropriate](#Rp-lib)"
msgstr ""

msgid "379    Philosophical rules are generally not mechanically checkable."
msgstr ""

msgid ""
"380    However, individual rules reflecting these philosophical themes are."
msgstr ""

msgid ""
"381    Without a philosophical basis, the more concrete/specific/checkable "
"rules lack rationale."
msgstr ""

msgid "382    ### <a name=\"Rp-direct\"></a>P.1: Express ideas directly in code"
msgstr ""

msgid "383    ##### Reason"
msgstr ""

msgid ""
"384    Compilers don't read comments (or design documents) and neither do "
"many programmers (consistently)."
msgstr ""

msgid ""
"385    What is expressed in code has defined semantics and can (in "
"principle) be checked by compilers and other tools."
msgstr ""

msgid "386    ##### Example"
msgstr ""

msgid "387        class Date {"
msgstr ""

msgid "388            // ..."
msgstr ""

msgid "389        public:"
msgstr ""

msgid "390            Month month() const;  // do"
msgstr ""

msgid "391            int month();          // don't"
msgstr ""

msgid "392            // ..."
msgstr ""

msgid "393        };"
msgstr ""

msgid ""
"394    The first declaration of `month` is explicit about returning a "
"`Month` and about not modifying the state of the `Date` object."
msgstr ""

msgid ""
"395    The second version leaves the reader guessing and opens more "
"possibilities for uncaught bugs."
msgstr ""

msgid "396    ##### Example; bad"
msgstr ""

msgid "397    This loop is a restricted form of `std::find`:"
msgstr ""

msgid "398        void f(vector<string>& v)"
msgstr ""

msgid "399        {"
msgstr ""

msgid "400            string val;"
msgstr ""

msgid "401            cin >> val;"
msgstr ""

msgid "402            // ..."
msgstr ""

msgid ""
"403            int index = -1;                    // bad, plus should use "
"gsl::index"
msgstr ""

msgid "404            for (int i = 0; i < v.size(); ++i) {"
msgstr ""

msgid "405                if (v[i] == val) {"
msgstr ""

msgid "406                    index = i;"
msgstr ""

msgid "407                    break;"
msgstr ""

msgid "408                }"
msgstr ""

msgid "409            }"
msgstr ""

msgid "410            // ..."
msgstr ""

msgid "411        }"
msgstr ""

msgid "412    ##### Example; good"
msgstr ""

msgid "413    A much clearer expression of intent would be:"
msgstr ""

msgid "414        void f(vector<string>& v)"
msgstr ""

msgid "415        {"
msgstr ""

msgid "416            string val;"
msgstr ""

msgid "417            cin >> val;"
msgstr ""

msgid "418            // ..."
msgstr ""

msgid "419            auto p = find(begin(v), end(v), val);  // better"
msgstr ""

msgid "420            // ..."
msgstr ""

msgid "421        }"
msgstr ""

msgid ""
"422    A well-designed library expresses intent (what is to be done, rather "
"than just how something is being done) far better than direct use of "
"language features."
msgstr ""

msgid ""
"423    A C++ programmer should know the basics of the standard library, and "
"use it where appropriate."
msgstr ""

msgid ""
"424    Any programmer should know the basics of the foundation libraries of "
"the project being worked on, and use them appropriately."
msgstr ""

msgid ""
"425    Any programmer using these guidelines should know the [guidelines "
"support library](#S-gsl), and use it appropriately."
msgstr ""

msgid "426    ##### Example"
msgstr ""

msgid "427        change_speed(double s);   // bad: what does s signify?"
msgstr ""

msgid "428        // ..."
msgstr ""

msgid "429        change_speed(2.3);"
msgstr ""

msgid ""
"430    A better approach is to be explicit about the meaning of the double "
"(new speed or delta on old speed?) and the unit used:"
msgstr ""

msgid ""
"431        change_speed(Speed s);    // better: the meaning of s is "
"specified"
msgstr ""

msgid "432        // ..."
msgstr ""

msgid "433        change_speed(2.3);        // error: no unit"
msgstr ""

msgid "434        change_speed(23m / 10s);  // meters per second"
msgstr ""

msgid ""
"435    We could have accepted a plain (unit-less) `double` as a delta, but "
"that would have been error-prone."
msgstr ""

msgid ""
"436    If we wanted both absolute speed and deltas, we would have defined a "
"`Delta` type."
msgstr ""

msgid "437    ##### Enforcement"
msgstr ""

msgid "438    Very hard in general."
msgstr ""

msgid ""
"439    * use `const` consistently (check if member functions modify their "
"object; check if functions modify arguments passed by pointer or reference)"
msgstr ""

msgid "440    * flag uses of casts (casts neuter the type system)"
msgstr ""

msgid "441    * detect code that mimics the standard library (hard)"
msgstr ""

msgid "442    ### <a name=\"Rp-Cplusplus\"></a>P.2: Write in ISO Standard C++"
msgstr ""

msgid "443    ##### Reason"
msgstr ""

msgid "444    This is a set of guidelines for writing ISO Standard C++."
msgstr ""

msgid "445    ##### Note"
msgstr ""

msgid ""
"446    There are environments where extensions are necessary, e.g., to "
"access system resources."
msgstr ""

msgid ""
"447    In such cases, localize the use of necessary extensions and control "
"their use with non-core Coding Guidelines.  If possible, build interfaces "
"that encapsulate the extensions so they can be turned off or compiled away "
"on systems that do not support those extensions."
msgstr ""

msgid ""
"448    Extensions often do not have rigorously defined semantics.  Even "
"extensions that"
msgstr ""

msgid ""
"449    are common and implemented by multiple compilers may have slightly "
"different"
msgstr ""

msgid ""
"450    behaviors and edge case behavior as a direct result of *not* having a "
"rigorous"
msgstr ""

msgid ""
"451    standard definition.  With sufficient use of any such extension, "
"expected"
msgstr ""

msgid "452    portability will be impacted."
msgstr ""

msgid "453    ##### Note"
msgstr ""

msgid ""
"454    Using valid ISO C++ does not guarantee portability (let alone "
"correctness)."
msgstr ""

msgid ""
"455    Avoid dependence on undefined behavior (e.g., [undefined order of "
"evaluation](#Res-order))"
msgstr ""

msgid ""
"456    and be aware of constructs with implementation defined meaning (e.g., "
"`sizeof(int)`)."
msgstr ""

msgid "457    ##### Note"
msgstr ""

msgid ""
"458    There are environments where restrictions on use of standard C++ "
"language or library features are necessary, e.g., to avoid dynamic memory "
"allocation as required by aircraft control software standards."
msgstr ""

msgid ""
"459    In such cases, control their (dis)use with an extension of these "
"Coding Guidelines customized to the specific environment."
msgstr ""

msgid "460    ##### Enforcement"
msgstr ""

msgid ""
"461    Use an up-to-date C++ compiler (currently C++17, C++14, or C++11) "
"with a set of options that do not accept extensions."
msgstr ""

msgid "462    ### <a name=\"Rp-what\"></a>P.3: Express intent"
msgstr ""

msgid "463    ##### Reason"
msgstr ""

msgid ""
"464    Unless the intent of some code is stated (e.g., in names or "
"comments), it is impossible to tell whether the code does what it is "
"supposed to do."
msgstr ""

msgid "465    ##### Example"
msgstr ""

msgid "466        gsl::index i = 0;"
msgstr ""

msgid "467        while (i < v.size()) {"
msgstr ""

msgid "468            // ... do something with v[i] ..."
msgstr ""

msgid "469        }"
msgstr ""

msgid ""
"470    The intent of \"just\" looping over the elements of `v` is not "
"expressed here. The implementation detail of an index is exposed (so that it "
"might be misused), and `i` outlives the scope of the loop, which may or may "
"not be intended. The reader cannot know from just this section of code."
msgstr ""

msgid "471    Better:"
msgstr ""

msgid ""
"472        for (const auto& x : v) { /* do something with the value of x */ "
"}"
msgstr ""

msgid ""
"473    Now, there is no explicit mention of the iteration mechanism, and the "
"loop operates on a reference to `const` elements so that accidental "
"modification cannot happen. If modification is desired, say so:"
msgstr ""

msgid "474        for (auto& x : v) { /* modify x */ }"
msgstr ""

msgid ""
"475    For more details about for-statements, see [ES.71](#Res-for-range)."
msgstr ""

msgid "476    Sometimes better still, use a named algorithm:"
msgstr ""

msgid ""
"477        for_each(v, [](int x) { /* do something with the value of x */ "
"});"
msgstr ""

msgid ""
"478        for_each(par, v, [](int x) { /* do something with the value of x "
"*/ });"
msgstr ""

msgid ""
"479    The last variant makes it clear that we are not interested in the "
"order in which the elements of `v` are handled."
msgstr ""

msgid "480    A programmer should be familiar with"
msgstr ""

msgid "481    * [The guidelines support library](#S-gsl)"
msgstr ""

msgid "482    * [The ISO C++ Standard Library](#S-stdlib)"
msgstr ""

msgid ""
"483    * Whatever foundation libraries are used for the current project(s)"
msgstr ""

msgid "484    ##### Note"
msgstr ""

msgid ""
"485    Alternative formulation: Say what should be done, rather than just "
"how it should be done."
msgstr ""

msgid "486    ##### Note"
msgstr ""

msgid "487    Some language constructs express intent better than others."
msgstr ""

msgid "488    ##### Example"
msgstr ""

msgid ""
"489    If two `int`s are meant to be the coordinates of a 2D point, say so:"
msgstr ""

msgid "490        draw_line(int, int, int, int);  // obscure"
msgstr ""

msgid "491        draw_line(Point, Point);        // clearer"
msgstr ""

msgid "492    ##### Enforcement"
msgstr ""

msgid ""
"493    Look for common patterns for which there are better alternatives"
msgstr ""

msgid "494    * simple `for` loops vs. range-`for` loops"
msgstr ""

msgid "495    * `f(T*, int)` interfaces vs. `f(span<T>)` interfaces"
msgstr ""

msgid "496    * loop variables in too large a scope"
msgstr ""

msgid "497    * naked `new` and `delete`"
msgstr ""

msgid "498    * functions with many parameters of built-in types"
msgstr ""

msgid ""
"499    There is a huge scope for cleverness and semi-automated program "
"transformation."
msgstr ""

msgid ""
"500    ### <a name=\"Rp-typesafe\"></a>P.4: Ideally, a program should be "
"statically type safe"
msgstr ""

msgid "501    ##### Reason"
msgstr ""

msgid ""
"502    Ideally, a program would be completely statically (compile-time) type "
"safe."
msgstr ""

msgid "503    Unfortunately, that is not possible. Problem areas:"
msgstr ""

msgid "504    * unions"
msgstr ""

msgid "505    * casts"
msgstr ""

msgid "506    * array decay"
msgstr ""

msgid "507    * range errors"
msgstr ""

msgid "508    * narrowing conversions"
msgstr ""

msgid "509    ##### Note"
msgstr ""

msgid ""
"510    These areas are sources of serious problems (e.g., crashes and "
"security violations)."
msgstr ""

msgid "511    We try to provide alternative techniques."
msgstr ""

msgid "512    ##### Enforcement"
msgstr ""

msgid ""
"513    We can ban, restrain, or detect the individual problem categories "
"separately, as required and feasible for individual programs."
msgstr ""

msgid "514    Always suggest an alternative."
msgstr ""

msgid "515    For example:"
msgstr ""

msgid "516    * unions -- use `variant` (in C++17)"
msgstr ""

msgid "517    * casts -- minimize their use; templates can help"
msgstr ""

msgid "518    * array decay -- use `span` (from the GSL)"
msgstr ""

msgid "519    * range errors -- use `span`"
msgstr ""

msgid ""
"520    * narrowing conversions -- minimize their use and use `narrow` or "
"`narrow_cast` (from the GSL) where they are necessary"
msgstr ""

msgid ""
"521    ### <a name=\"Rp-compile-time\"></a>P.5: Prefer compile-time checking "
"to run-time checking"
msgstr ""

msgid "522    ##### Reason"
msgstr ""

msgid "523    Code clarity and performance."
msgstr ""

msgid ""
"524    You don't need to write error handlers for errors caught at compile "
"time."
msgstr ""

msgid "525    ##### Example"
msgstr ""

msgid "526        // Int is an alias used for integers"
msgstr ""

msgid "527        int bits = 0;         // don't: avoidable code"
msgstr ""

msgid "528        for (Int i = 1; i; i <<= 1)"
msgstr ""

msgid "529            ++bits;"
msgstr ""

msgid "530        if (bits < 32)"
msgstr ""

msgid "531            cerr << \"Int too small\\n\";"
msgstr ""

msgid ""
"532    This example fails to achieve what it is trying to achieve (because "
"overflow is undefined) and should be replaced with a simple `static_assert`:"
msgstr ""

msgid "533        // Int is an alias used for integers"
msgstr ""

msgid ""
"534        static_assert(sizeof(Int) >= 4);    // do: compile-time check"
msgstr ""

msgid ""
"535    Or better still just use the type system and replace `Int` with "
"`int32_t`."
msgstr ""

msgid "536    ##### Example"
msgstr ""

msgid "537        void read(int* p, int n);   // read max n integers into *p"
msgstr ""

msgid "538        int a[100];"
msgstr ""

msgid "539        read(a, 1000);    // bad, off the end"
msgstr ""

msgid "540    better"
msgstr ""

msgid ""
"541        void read(span<int> r); // read into the range of integers r"
msgstr ""

msgid "542        int a[100];"
msgstr ""

msgid ""
"543        read(a);        // better: let the compiler figure out the number "
"of elements"
msgstr ""

msgid ""
"544    **Alternative formulation**: Don't postpone to run time what can be "
"done well at compile time."
msgstr ""

msgid "545    ##### Enforcement"
msgstr ""

msgid "546    * Look for pointer arguments."
msgstr ""

msgid "547    * Look for run-time checks for range violations."
msgstr ""

msgid ""
"548    ### <a name=\"Rp-run-time\"></a>P.6: What cannot be checked at "
"compile time should be checkable at run time"
msgstr ""

msgid "549    ##### Reason"
msgstr ""

msgid ""
"550    Leaving hard-to-detect errors in a program is asking for crashes and "
"bad results."
msgstr ""

msgid "551    ##### Note"
msgstr ""

msgid ""
"552    Ideally, we catch all errors (that are not errors in the programmer's "
"logic) at either compile time or run time. It is impossible to catch all "
"errors at compile time and often not affordable to catch all remaining "
"errors at run time. However, we should endeavor to write programs that in "
"principle can be checked, given sufficient resources (analysis programs, run-"
"time checks, machine resources, time)."
msgstr ""

msgid "553    ##### Example, bad"
msgstr ""

msgid "554        // separately compiled, possibly dynamically loaded"
msgstr ""

msgid "555        extern void f(int* p);"
msgstr ""

msgid "556        void g(int n)"
msgstr ""

msgid "557        {"
msgstr ""

msgid "558            // bad: the number of elements is not passed to f()"
msgstr ""

msgid "559            f(new int[n]);"
msgstr ""

msgid "560        }"
msgstr ""

msgid ""
"561    Here, a crucial bit of information (the number of elements) has been "
"so thoroughly \"obscured\" that static analysis is probably rendered "
"infeasible and dynamic checking can be very difficult when `f()` is part of "
"an ABI so that we cannot \"instrument\" that pointer. We could embed helpful "
"information into the free store, but that requires global changes to a "
"system and maybe to the compiler. What we have here is a design that makes "
"error detection very hard."
msgstr ""

msgid "562    ##### Example, bad"
msgstr ""

msgid ""
"563    We can of course pass the number of elements along with the pointer:"
msgstr ""

msgid "564        // separately compiled, possibly dynamically loaded"
msgstr ""

msgid "565        extern void f2(int* p, int n);"
msgstr ""

msgid "566        void g2(int n)"
msgstr ""

msgid "567        {"
msgstr ""

msgid ""
"568            f2(new int[n], m);  // bad: a wrong number of elements can be "
"passed to f()"
msgstr ""

msgid "569        }"
msgstr ""

msgid ""
"570    Passing the number of elements as an argument is better (and far more "
"common) than just passing the pointer and relying on some (unstated) "
"convention for knowing or discovering the number of elements. However (as "
"shown), a simple typo can introduce a serious error. The connection between "
"the two arguments of `f2()` is conventional, rather than explicit."
msgstr ""

msgid ""
"571    Also, it is implicit that `f2()` is supposed to `delete` its argument "
"(or did the caller make a second mistake?)."
msgstr ""

msgid "572    ##### Example, bad"
msgstr ""

msgid ""
"573    The standard library resource management pointers fail to pass the "
"size when they point to an object:"
msgstr ""

msgid "574        // separately compiled, possibly dynamically loaded"
msgstr ""

msgid ""
"575        // NB: this assumes the calling code is ABI-compatible, using a"
msgstr ""

msgid ""
"576        // compatible C++ compiler and the same stdlib implementation"
msgstr ""

msgid "577        extern void f3(unique_ptr<int[]>, int n);"
msgstr ""

msgid "578        void g3(int n)"
msgstr ""

msgid "579        {"
msgstr ""

msgid ""
"580            f3(make_unique<int[]>(n), m);    // bad: pass ownership and "
"size separately"
msgstr ""

msgid "581        }"
msgstr ""

msgid "582    ##### Example"
msgstr ""

msgid ""
"583    We need to pass the pointer and the number of elements as an integral "
"object:"
msgstr ""

msgid ""
"584        extern void f4(vector<int>&);   // separately compiled, possibly "
"dynamically loaded"
msgstr ""

msgid ""
"585        extern void f4(span<int>);      // separately compiled, possibly "
"dynamically loaded"
msgstr ""

msgid ""
"586                                        // NB: this assumes the calling "
"code is ABI-compatible, using a"
msgstr ""

msgid ""
"587                                        // compatible C++ compiler and "
"the same stdlib implementation"
msgstr ""

msgid "588        void g3(int n)"
msgstr ""

msgid "589        {"
msgstr ""

msgid "590            vector<int> v(n);"
msgstr ""

msgid ""
"591            f4(v);                     // pass a reference, retain "
"ownership"
msgstr ""

msgid ""
"592            f4(span<int>{v});          // pass a view, retain ownership"
msgstr ""

msgid "593        }"
msgstr ""

msgid ""
"594    This design carries the number of elements along as an integral part "
"of an object, so that errors are unlikely and dynamic (run-time) checking is "
"always feasible, if not always affordable."
msgstr ""

msgid "595    ##### Example"
msgstr ""

msgid ""
"596    How do we transfer both ownership and all information needed for "
"validating use?"
msgstr ""

msgid "597        vector<int> f5(int n)    // OK: move"
msgstr ""

msgid "598        {"
msgstr ""

msgid "599            vector<int> v(n);"
msgstr ""

msgid "600            // ... initialize v ..."
msgstr ""

msgid "601            return v;"
msgstr ""

msgid "602        }"
msgstr ""

msgid "603        unique_ptr<int[]> f6(int n)    // bad: loses n"
msgstr ""

msgid "604        {"
msgstr ""

msgid "605            auto p = make_unique<int[]>(n);"
msgstr ""

msgid "606            // ... initialize *p ..."
msgstr ""

msgid "607            return p;"
msgstr ""

msgid "608        }"
msgstr ""

msgid ""
"609        owner<int*> f7(int n)    // bad: loses n and we might forget to "
"delete"
msgstr ""

msgid "610        {"
msgstr ""

msgid "611            owner<int*> p = new int[n];"
msgstr ""

msgid "612            // ... initialize *p ..."
msgstr ""

msgid "613            return p;"
msgstr ""

msgid "614        }"
msgstr ""

msgid "615    ##### Example"
msgstr ""

msgid "616    * ???"
msgstr ""

msgid ""
"617    * show how possible checks are avoided by interfaces that pass "
"polymorphic base classes around, when they actually know what they need?"
msgstr ""

msgid "618      Or strings as \"free-style\" options"
msgstr ""

msgid "619    ##### Enforcement"
msgstr ""

msgid ""
"620    * Flag (pointer, count)-style interfaces (this will flag a lot of "
"examples that can't be fixed for compatibility reasons)"
msgstr ""

msgid "621    * ???"
msgstr ""

msgid "622    ### <a name=\"Rp-early\"></a>P.7: Catch run-time errors early"
msgstr ""

msgid "623    ##### Reason"
msgstr ""

msgid "624    Avoid \"mysterious\" crashes."
msgstr ""

msgid "625    Avoid errors leading to (possibly unrecognized) wrong results."
msgstr ""

msgid "626    ##### Example"
msgstr ""

msgid "627        void increment1(int* p, int n)    // bad: error-prone"
msgstr ""

msgid "628        {"
msgstr ""

msgid "629            for (int i = 0; i < n; ++i) ++p[i];"
msgstr ""

msgid "630        }"
msgstr ""

msgid "631        void use1(int m)"
msgstr ""

msgid "632        {"
msgstr ""

msgid "633            const int n = 10;"
msgstr ""

msgid "634            int a[n] = {};"
msgstr ""

msgid "635            // ..."
msgstr ""

msgid ""
"636            increment1(a, m);   // maybe typo, maybe m <= n is supposed"
msgstr ""

msgid "637                                // but assume that m == 20"
msgstr ""

msgid "638            // ..."
msgstr ""

msgid "639        }"
msgstr ""

msgid ""
"640    Here we made a small error in `use1` that will lead to corrupted data "
"or a crash."
msgstr ""

msgid ""
"641    The (pointer, count)-style interface leaves `increment1()` with no "
"realistic way of defending itself against out-of-range errors."
msgstr ""

msgid ""
"642    If we could check subscripts for out of range access, then the error "
"would not be discovered until `p[10]` was accessed."
msgstr ""

msgid "643    We could check earlier and improve the code:"
msgstr ""

msgid "644        void increment2(span<int> p)"
msgstr ""

msgid "645        {"
msgstr ""

msgid "646            for (int& x : p) ++x;"
msgstr ""

msgid "647        }"
msgstr ""

msgid "648        void use2(int m)"
msgstr ""

msgid "649        {"
msgstr ""

msgid "650            const int n = 10;"
msgstr ""

msgid "651            int a[n] = {};"
msgstr ""

msgid "652            // ..."
msgstr ""

msgid ""
"653            increment2({a, m});    // maybe typo, maybe m <= n is "
"supposed"
msgstr ""

msgid "654            // ..."
msgstr ""

msgid "655        }"
msgstr ""

msgid ""
"656    Now, `m <= n` can be checked at the point of call (early) rather than "
"later."
msgstr ""

msgid ""
"657    If all we had was a typo so that we meant to use `n` as the bound, "
"the code could be further simplified (eliminating the possibility of an "
"error):"
msgstr ""

msgid "658        void use3(int m)"
msgstr ""

msgid "659        {"
msgstr ""

msgid "660            const int n = 10;"
msgstr ""

msgid "661            int a[n] = {};"
msgstr ""

msgid "662            // ..."
msgstr ""

msgid ""
"663            increment2(a);   // the number of elements of a need not be "
"repeated"
msgstr ""

msgid "664            // ..."
msgstr ""

msgid "665        }"
msgstr ""

msgid "666    ##### Example, bad"
msgstr ""

msgid ""
"667    Don't repeatedly check the same value. Don't pass structured data as "
"strings:"
msgstr ""

msgid "668        Date read_date(istream& is);    // read date from istream"
msgstr ""

msgid ""
"669        Date extract_date(const string& s);    // extract date from "
"string"
msgstr ""

msgid "670        void user1(const string& date)    // manipulate date"
msgstr ""

msgid "671        {"
msgstr ""

msgid "672            auto d = extract_date(date);"
msgstr ""

msgid "673            // ..."
msgstr ""

msgid "674        }"
msgstr ""

msgid "675        void user2()"
msgstr ""

msgid "676        {"
msgstr ""

msgid "677            Date d = read_date(cin);"
msgstr ""

msgid "678            // ..."
msgstr ""

msgid "679            user1(d.to_string());"
msgstr ""

msgid "680            // ..."
msgstr ""

msgid "681        }"
msgstr ""

msgid ""
"682    The date is validated twice (by the `Date` constructor) and passed as "
"a character string (unstructured data)."
msgstr ""

msgid "683    ##### Example"
msgstr ""

msgid "684    Excess checking can be costly."
msgstr ""

msgid ""
"685    There are cases where checking early is dumb because you may not ever "
"need the value, or may only need part of the value that is more easily "
"checked than the whole.  Similarly, don't add validity checks that change "
"the asymptotic behavior of your interface (e.g., don't add a `O(n)` check to "
"an interface with an average complexity of `O(1)`)."
msgstr ""

msgid ""
"686        class Jet {    // Physics says: e * e < x * x + y * y + z * z"
msgstr ""

msgid "687            float x;"
msgstr ""

msgid "688            float y;"
msgstr ""

msgid "689            float z;"
msgstr ""

msgid "690            float e;"
msgstr ""

msgid "691        public:"
msgstr ""

msgid "692            Jet(float x, float y, float z, float e)"
msgstr ""

msgid "693                :x(x), y(y), z(z), e(e)"
msgstr ""

msgid "694            {"
msgstr ""

msgid ""
"695                // Should I check here that the values are physically "
"meaningful?"
msgstr ""

msgid "696            }"
msgstr ""

msgid "697            float m() const"
msgstr ""

msgid "698            {"
msgstr ""

msgid "699                // Should I handle the degenerate case here?"
msgstr ""

msgid "700                return sqrt(x * x + y * y + z * z - e * e);"
msgstr ""

msgid "701            }"
msgstr ""

msgid "702            ???"
msgstr ""

msgid "703        };"
msgstr ""

msgid ""
"704    The physical law for a jet (`e * e < x * x + y * y + z * z`) is not "
"an invariant because of the possibility for measurement errors."
msgstr ""

msgid "705    ???"
msgstr ""

msgid "706    ##### Enforcement"
msgstr ""

msgid ""
"707    * Look at pointers and arrays: Do range-checking early and not "
"repeatedly"
msgstr ""

msgid "708    * Look at conversions: Eliminate or mark narrowing conversions"
msgstr ""

msgid "709    * Look for unchecked values coming from input"
msgstr ""

msgid ""
"710    * Look for structured data (objects of classes with invariants) being "
"converted into strings"
msgstr ""

msgid "711    * ???"
msgstr ""

msgid "712    ### <a name=\"Rp-leak\"></a>P.8: Don't leak any resources"
msgstr ""

msgid "713    ##### Reason"
msgstr ""

msgid ""
"714    Even a slow growth in resources will, over time, exhaust the "
"availability of those resources."
msgstr ""

msgid ""
"715    This is particularly important for long-running programs, but is an "
"essential piece of responsible programming behavior."
msgstr ""

msgid "716    ##### Example, bad"
msgstr ""

msgid "717        void f(char* name)"
msgstr ""

msgid "718        {"
msgstr ""

msgid "719            FILE* input = fopen(name, \"r\");"
msgstr ""

msgid "720            // ..."
msgstr ""

msgid ""
"721            if (something) return;   // bad: if something == true, a file "
"handle is leaked"
msgstr ""

msgid "722            // ..."
msgstr ""

msgid "723            fclose(input);"
msgstr ""

msgid "724        }"
msgstr ""

msgid "725    Prefer [RAII](#Rr-raii):"
msgstr ""

msgid "726        void f(char* name)"
msgstr ""

msgid "727        {"
msgstr ""

msgid "728            ifstream input {name};"
msgstr ""

msgid "729            // ..."
msgstr ""

msgid "730            if (something) return;   // OK: no leak"
msgstr ""

msgid "731            // ..."
msgstr ""

msgid "732        }"
msgstr ""

msgid "733    **See also**: [The resource management section](#S-resource)"
msgstr ""

msgid "734    ##### Note"
msgstr ""

msgid "735    A leak is colloquially \"anything that isn't cleaned up.\""
msgstr ""

msgid ""
"736    The more important classification is \"anything that can no longer be "
"cleaned up.\""
msgstr ""

msgid ""
"737    For example, allocating an object on the heap and then losing the "
"last pointer that points to that allocation."
msgstr ""

msgid ""
"738    This rule should not be taken as requiring that allocations within "
"long-lived objects must be returned during program shutdown."
msgstr ""

msgid ""
"739    For example, relying on system guaranteed cleanup such as file "
"closing and memory deallocation upon process shutdown can simplify code."
msgstr ""

msgid ""
"740    However, relying on abstractions that implicitly clean up can be as "
"simple, and often safer."
msgstr ""

msgid "741    ##### Note"
msgstr ""

msgid ""
"742    Enforcing [the lifetime safety profile](#SS-lifetime) eliminates "
"leaks."
msgstr ""

msgid ""
"743    When combined with resource safety provided by [RAII](#Rr-raii), it "
"eliminates the need for \"garbage collection\" (by generating no garbage)."
msgstr ""

msgid ""
"744    Combine this with enforcement of [the type and bounds profiles](#SS-"
"force) and you get complete type- and resource-safety, guaranteed by tools."
msgstr ""

msgid "745    ##### Enforcement"
msgstr ""

msgid ""
"746    * Look at pointers: Classify them into non-owners (the default) and "
"owners."
msgstr ""

msgid ""
"747      Where feasible, replace owners with standard-library resource "
"handles (as in the example above)."
msgstr ""

msgid ""
"748      Alternatively, mark an owner as such using `owner` from [the "
"GSL](#S-gsl)."
msgstr ""

msgid "749    * Look for naked `new` and `delete`"
msgstr ""

msgid ""
"750    * Look for known resource allocating functions returning raw pointers "
"(such as `fopen`, `malloc`, and `strdup`)"
msgstr ""

msgid "751    ### <a name=\"Rp-waste\"></a>P.9: Don't waste time or space"
msgstr ""

msgid "752    ##### Reason"
msgstr ""

msgid "753    This is C++."
msgstr ""

msgid "754    ##### Note"
msgstr ""

msgid ""
"755    Time and space that you spend well to achieve a goal (e.g., speed of "
"development, resource safety, or simplification of testing) is not wasted."
msgstr ""

msgid ""
"756    \"Another benefit of striving for efficiency is that the process "
"forces you to understand the problem in more depth.\" - Alex Stepanov"
msgstr ""

msgid "757    ##### Example, bad"
msgstr ""

msgid "758        struct X {"
msgstr ""

msgid "759            char ch;"
msgstr ""

msgid "760            int i;"
msgstr ""

msgid "761            string s;"
msgstr ""

msgid "762            char ch2;"
msgstr ""

msgid "763            X& operator=(const X& a);"
msgstr ""

msgid "764            X(const X&);"
msgstr ""

msgid "765        };"
msgstr ""

msgid "766        X waste(const char* p)"
msgstr ""

msgid "767        {"
msgstr ""

msgid "768            if (!p) throw Nullptr_error{};"
msgstr ""

msgid "769            int n = strlen(p);"
msgstr ""

msgid "770            auto buf = new char[n];"
msgstr ""

msgid "771            if (!buf) throw Allocation_error{};"
msgstr ""

msgid "772            for (int i = 0; i < n; ++i) buf[i] = p[i];"
msgstr ""

msgid "773            // ... manipulate buffer ..."
msgstr ""

msgid "774            X x;"
msgstr ""

msgid "775            x.ch = 'a';"
msgstr ""

msgid "776            x.s = string(n);    // give x.s space for *p"
msgstr ""

msgid ""
"777            for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  "
"// copy buf into x.s"
msgstr ""

msgid "778            delete[] buf;"
msgstr ""

msgid "779            return x;"
msgstr ""

msgid "780        }"
msgstr ""

msgid "781        void driver()"
msgstr ""

msgid "782        {"
msgstr ""

msgid "783            X x = waste(\"Typical argument\");"
msgstr ""

msgid "784            // ..."
msgstr ""

msgid "785        }"
msgstr ""

msgid ""
"786    Yes, this is a caricature, but we have seen every individual mistake "
"in production code, and worse."
msgstr ""

msgid ""
"787    Note that the layout of `X` guarantees that at least 6 bytes (and "
"most likely more) are wasted."
msgstr ""

msgid ""
"788    The spurious definition of copy operations disables move semantics so "
"that the return operation is slow"
msgstr ""

msgid ""
"789    (please note that the Return Value Optimization, RVO, is not "
"guaranteed here)."
msgstr ""

msgid ""
"790    The use of `new` and `delete` for `buf` is redundant; if we really "
"needed a local string, we should use a local `string`."
msgstr ""

msgid ""
"791    There are several more performance bugs and gratuitous complication."
msgstr ""

msgid "792    ##### Example, bad"
msgstr ""

msgid "793        void lower(zstring s)"
msgstr ""

msgid "794        {"
msgstr ""

msgid ""
"795            for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);"
msgstr ""

msgid "796        }"
msgstr ""

msgid "797    Yes, this is an example from production code."
msgstr ""

msgid "798    We leave it to the reader to figure out what's wasted."
msgstr ""

msgid "799    ##### Note"
msgstr ""

msgid ""
"800    An individual example of waste is rarely significant, and where it is "
"significant, it is typically easily eliminated by an expert."
msgstr ""

msgid ""
"801    However, waste spread liberally across a code base can easily be "
"significant and experts are not always as available as we would like."
msgstr ""

msgid ""
"802    The aim of this rule (and the more specific rules that support it) is "
"to eliminate most waste related to the use of C++ before it happens."
msgstr ""

msgid ""
"803    After that, we can look at waste related to algorithms and "
"requirements, but that is beyond the scope of these guidelines."
msgstr ""

msgid "804    ##### Enforcement"
msgstr ""

msgid ""
"805    Many more specific rules aim at the overall goals of simplicity and "
"elimination of gratuitous waste."
msgstr ""

msgid ""
"806    ### <a name=\"Rp-mutable\"></a>P.10: Prefer immutable data to mutable "
"data"
msgstr ""

msgid "807    ##### Reason"
msgstr ""

msgid "808    It is easier to reason about constants than about variables."
msgstr ""

msgid "809    Something immutable cannot change unexpectedly."
msgstr ""

msgid "810    Sometimes immutability enables better optimization."
msgstr ""

msgid "811    You can't have a data race on a constant."
msgstr ""

msgid "812    See [Con: Constants and immutability](#S-const)"
msgstr ""

msgid ""
"813    ### <a name=\"Rp-library\"></a>P.11: Encapsulate messy constructs, "
"rather than spreading through the code"
msgstr ""

msgid "814    ##### Reason"
msgstr ""

msgid "815    Messy code is more likely to hide bugs and harder to write."
msgstr ""

msgid "816    A good interface is easier and safer to use."
msgstr ""

msgid "817    Messy, low-level code breeds more such code."
msgstr ""

msgid "818    ##### Example"
msgstr ""

msgid "819        int sz = 100;"
msgstr ""

msgid "820        int* p = (int*) malloc(sizeof(int) * sz);"
msgstr ""

msgid "821        int count = 0;"
msgstr ""

msgid "822        // ..."
msgstr ""

msgid "823        for (;;) {"
msgstr ""

msgid ""
"824            // ... read an int into x, exit loop if end of file is "
"reached ..."
msgstr ""

msgid "825            // ... check that x is valid ..."
msgstr ""

msgid "826            if (count == sz)"
msgstr ""

msgid "827                p = (int*) realloc(p, sizeof(int) * sz * 2);"
msgstr ""

msgid "828            p[count++] = x;"
msgstr ""

msgid "829            // ..."
msgstr ""

msgid "830        }"
msgstr ""

msgid "831    This is low-level, verbose, and error-prone."
msgstr ""

msgid "832    For example, we \"forgot\" to test for memory exhaustion."
msgstr ""

msgid "833    Instead, we could use `vector`:"
msgstr ""

msgid "834        vector<int> v;"
msgstr ""

msgid "835        v.reserve(100);"
msgstr ""

msgid "836        // ..."
msgstr ""

msgid "837        for (int x; cin >> x; ) {"
msgstr ""

msgid "838            // ... check that x is valid ..."
msgstr ""

msgid "839            v.push_back(x);"
msgstr ""

msgid "840        }"
msgstr ""

msgid "841    ##### Note"
msgstr ""

msgid ""
"842    The standards library and the GSL are examples of this philosophy."
msgstr ""

msgid ""
"843    For example, instead of messing with the arrays, unions, cast, tricky "
"lifetime issues, `gsl::owner`, etc.,"
msgstr ""

msgid ""
"844    that are needed to implement key abstractions, such as `vector`, "
"`span`, `lock_guard`, and `future`, we use the libraries"
msgstr ""

msgid ""
"845    designed and implemented by people with more time and expertise than "
"we usually have."
msgstr ""

msgid ""
"846    Similarly, we can and should design and implement more specialized "
"libraries, rather than leaving the users (often ourselves)"
msgstr ""

msgid "847    with the challenge of repeatedly getting low-level code well."
msgstr ""

msgid ""
"848    This is a variant of the [subset of superset principle](#R0) that "
"underlies these guidelines."
msgstr ""

msgid "849    ##### Enforcement"
msgstr ""

msgid ""
"850    * Look for \"messy code\" such as complex pointer manipulation and "
"casting outside the implementation of abstractions."
msgstr ""

msgid ""
"851    ### <a name=\"Rp-tools\"></a>P.12: Use supporting tools as "
"appropriate"
msgstr ""

msgid "852    ##### Reason"
msgstr ""

msgid "853    There are many things that are done better \"by machine\"."
msgstr ""

msgid "854    Computers don't tire or get bored by repetitive tasks."
msgstr ""

msgid ""
"855    We typically have better things to do than repeatedly do routine "
"tasks."
msgstr ""

msgid "856    ##### Example"
msgstr ""

msgid ""
"857    Run a static analyzer to verify that your code follows the guidelines "
"you want it to follow."
msgstr ""

msgid "858    ##### Note"
msgstr ""

msgid "859    See"
msgstr ""

msgid "860    * [Static analysis tools](???)"
msgstr ""

msgid "861    * [Concurrency tools](#Rconc-tools)"
msgstr ""

msgid "862    * [Testing tools](???)"
msgstr ""

msgid ""
"863    There are many other kinds of tools, such as source code "
"repositories, build tools, etc.,"
msgstr ""

msgid "864    but those are beyond the scope of these guidelines."
msgstr ""

msgid "865    ##### Note"
msgstr ""

msgid ""
"866    Be careful not to become dependent on over-elaborate or over-"
"specialized tool chains."
msgstr ""

msgid "867    Those can make your otherwise portable code non-portable."
msgstr ""

msgid ""
"868    ### <a name=\"Rp-lib\"></a>P.13: Use support libraries as appropriate"
msgstr ""

msgid "869    ##### Reason"
msgstr ""

msgid ""
"870    Using a well-designed, well-documented, and well-supported library "
"saves time and effort;"
msgstr ""

msgid ""
"871    its quality and documentation are likely to be greater than what you "
"could do"
msgstr ""

msgid ""
"872    if the majority of your time must be spent on an implementation."
msgstr ""

msgid ""
"873    The cost (time, effort, money, etc.) of a library can be shared over "
"many users."
msgstr ""

msgid ""
"874    A widely used library is more likely to be kept up-to-date and ported "
"to new systems than an individual application."
msgstr ""

msgid ""
"875    Knowledge of a widely-used library can save time on other/future "
"projects."
msgstr ""

msgid ""
"876    So, if a suitable library exists for your application domain, use it."
msgstr ""

msgid "877    ##### Example"
msgstr ""

msgid "878        std::sort(begin(v), end(v), std::greater<>());"
msgstr ""

msgid ""
"879    Unless you are an expert in sorting algorithms and have plenty of "
"time,"
msgstr ""

msgid ""
"880    this is more likely to be correct and to run faster than anything you "
"write for a specific application."
msgstr ""

msgid ""
"881    You need a reason not to use the standard library (or whatever "
"foundational libraries your application uses) rather than a reason to use it."
""
msgstr ""

msgid "882    ##### Note"
msgstr ""

msgid "883    By default use"
msgstr ""

msgid "884    * The [ISO C++ Standard Library](#S-stdlib)"
msgstr ""

msgid "885    * The [Guidelines Support Library](#S-gsl)"
msgstr ""

msgid "886    ##### Note"
msgstr ""

msgid ""
"887    If no well-designed, well-documented, and well-supported library "
"exists for an important domain,"
msgstr ""

msgid "888    maybe you should design and implement it, and then use it."
msgstr ""

msgid "889    # <a name=\"S-interfaces\"></a>I: Interfaces"
msgstr ""

msgid ""
"890    An interface is a contract between two parts of a program. Precisely "
"stating what is expected of a supplier of a service and a user of that "
"service is essential."
msgstr ""

msgid ""
"891    Having good (easy-to-understand, encouraging efficient use, not error-"
"prone, supporting testing, etc.) interfaces is probably the most important "
"single aspect of code organization."
msgstr ""

msgid "892    Interface rule summary:"
msgstr ""

msgid "893    * [I.1: Make interfaces explicit](#Ri-explicit)"
msgstr ""

msgid "894    * [I.2: Avoid non-`const` global variables](#Ri-global)"
msgstr ""

msgid "895    * [I.3: Avoid singletons](#Ri-singleton)"
msgstr ""

msgid ""
"896    * [I.4: Make interfaces precisely and strongly typed](#Ri-typed)"
msgstr ""

msgid "897    * [I.5: State preconditions (if any)](#Ri-pre)"
msgstr ""

msgid ""
"898    * [I.6: Prefer `Expects()` for expressing preconditions](#Ri-expects)"
msgstr ""

msgid "899    * [I.7: State postconditions](#Ri-post)"
msgstr ""

msgid ""
"900    * [I.8: Prefer `Ensures()` for expressing postconditions](#Ri-"
"ensures)"
msgstr ""

msgid ""
"901    * [I.9: If an interface is a template, document its parameters using "
"concepts](#Ri-concepts)"
msgstr ""

msgid ""
"902    * [I.10: Use exceptions to signal a failure to perform a required "
"task](#Ri-except)"
msgstr ""

msgid ""
"903    * [I.11: Never transfer ownership by a raw pointer (`T*`) or "
"reference (`T&`)](#Ri-raw)"
msgstr ""

msgid ""
"904    * [I.12: Declare a pointer that must not be null as `not_null`](#Ri-"
"nullptr)"
msgstr ""

msgid "905    * [I.13: Do not pass an array as a single pointer](#Ri-array)"
msgstr ""

msgid ""
"906    * [I.22: Avoid complex initialization of global objects](#Ri-global-"
"init)"
msgstr ""

msgid "907    * [I.23: Keep the number of function arguments low](#Ri-nargs)"
msgstr ""

msgid ""
"908    * [I.24: Avoid adjacent unrelated parameters of the same type](#Ri-"
"unrelated)"
msgstr ""

msgid ""
"909    * [I.25: Prefer abstract classes as interfaces to class "
"hierarchies](#Ri-abstract)"
msgstr ""

msgid ""
"910    * [I.26: If you want a cross-compiler ABI, use a C-style subset](#Ri-"
"abi)"
msgstr ""

msgid ""
"911    * [I.27: For stable library ABI, consider the Pimpl idiom](#Ri-pimpl)"
msgstr ""

msgid "912    * [I.30: Encapsulate rule violations](#Ri-encapsulate)"
msgstr ""

msgid "913    **See also**:"
msgstr ""

msgid "914    * [F: Functions](#S-functions)"
msgstr ""

msgid "915    * [C.concrete: Concrete types](#SS-concrete)"
msgstr ""

msgid "916    * [C.hier: Class hierarchies](#SS-hier)"
msgstr ""

msgid "917    * [C.over: Overloading and overloaded operators](#SS-overload)"
msgstr ""

msgid ""
"918    * [C.con: Containers and other resource handles](#SS-containers)"
msgstr ""

msgid "919    * [E: Error handling](#S-errors)"
msgstr ""

msgid "920    * [T: Templates and generic programming](#S-templates)"
msgstr ""

msgid "921    ### <a name=\"Ri-explicit\"></a>I.1: Make interfaces explicit"
msgstr ""

msgid "922    ##### Reason"
msgstr ""

msgid ""
"923    Correctness. Assumptions not stated in an interface are easily "
"overlooked and hard to test."
msgstr ""

msgid "924    ##### Example, bad"
msgstr ""

msgid ""
"925    Controlling the behavior of a function through a global (namespace "
"scope) variable (a call mode) is implicit and potentially confusing. For "
"example:"
msgstr ""

msgid "926        int round(double d)"
msgstr ""

msgid "927        {"
msgstr ""

msgid ""
"928            return (round_up) ? ceil(d) : d;    // don't: \"invisible\" "
"dependency"
msgstr ""

msgid "929        }"
msgstr ""

msgid ""
"930    It will not be obvious to a caller that the meaning of two calls of "
"`round(7.2)` might give different results."
msgstr ""

msgid "931    ##### Exception"
msgstr ""

msgid ""
"932    Sometimes we control the details of a set of operations by an "
"environment variable, e.g., normal vs. verbose output or debug vs. optimized."
""
msgstr ""

msgid ""
"933    The use of a non-local control is potentially confusing, but controls "
"only implementation details of otherwise fixed semantics."
msgstr ""

msgid "934    ##### Example, bad"
msgstr ""

msgid ""
"935    Reporting through non-local variables (e.g., `errno`) is easily "
"ignored. For example:"
msgstr ""

msgid "936        // don't: no test of printf's return value"
msgstr ""

msgid "937        fprintf(connection, \"logging: %d %d %d\\n\", x, y, s);"
msgstr ""

msgid ""
"938    What if the connection goes down so that no logging output is "
"produced? See I.???."
msgstr ""

msgid ""
"939    **Alternative**: Throw an exception. An exception cannot be ignored."
msgstr ""

msgid ""
"940    **Alternative formulation**: Avoid passing information across an "
"interface through non-local or implicit state."
msgstr ""

msgid ""
"941    Note that non-`const` member functions pass information to other "
"member functions through their object's state."
msgstr ""

msgid ""
"942    **Alternative formulation**: An interface should be a function or a "
"set of functions."
msgstr ""

msgid ""
"943    Functions can be template functions and sets of functions can be "
"classes or class templates."
msgstr ""

msgid "944    ##### Enforcement"
msgstr ""

msgid ""
"945    * (Simple) A function should not make control-flow decisions based on "
"the values of variables declared at namespace scope."
msgstr ""

msgid ""
"946    * (Simple) A function should not write to variables declared at "
"namespace scope."
msgstr ""

msgid ""
"947    ### <a name=\"Ri-global\"></a>I.2: Avoid non-`const` global variables"
msgstr ""

msgid "948    ##### Reason"
msgstr ""

msgid ""
"949    Non-`const` global variables hide dependencies and make the "
"dependencies subject to unpredictable changes."
msgstr ""

msgid "950    ##### Example"
msgstr ""

msgid "951        struct Data {"
msgstr ""

msgid "952            // ... lots of stuff ..."
msgstr ""

msgid "953        } data;            // non-const data"
msgstr ""

msgid "954        void compute()     // don't"
msgstr ""

msgid "955        {"
msgstr ""

msgid "956            // ... use data ..."
msgstr ""

msgid "957        }"
msgstr ""

msgid "958        void output()     // don't"
msgstr ""

msgid "959        {"
msgstr ""

msgid "960            // ... use data ..."
msgstr ""

msgid "961        }"
msgstr ""

msgid "962    Who else might modify `data`?"
msgstr ""

msgid "963    ##### Note"
msgstr ""

msgid "964    Global constants are useful."
msgstr ""

msgid "965    ##### Note"
msgstr ""

msgid ""
"966    The rule against global variables applies to namespace scope "
"variables as well."
msgstr ""

msgid ""
"967    **Alternative**: If you use global (more generally namespace scope) "
"data to avoid copying, consider passing the data as an object by reference "
"to `const`."
msgstr ""

msgid ""
"968    Another solution is to define the data as the state of some object "
"and the operations as member functions."
msgstr ""

msgid ""
"969    **Warning**: Beware of data races: If one thread can access nonlocal "
"data (or data passed by reference) while another thread executes the callee, "
"we can have a data race."
msgstr ""

msgid ""
"970    Every pointer or reference to mutable data is a potential data race."
msgstr ""

msgid "971    ##### Note"
msgstr ""

msgid "972    You cannot have a race condition on immutable data."
msgstr ""

msgid ""
"973    **References**: See the [rules for calling functions](#SS-call)."
msgstr ""

msgid "974    ##### Note"
msgstr ""

msgid ""
"975    The rule is \"avoid\", not \"don't use.\" Of course there will be "
"(rare) exceptions, such as `cin`, `cout`, and `cerr`."
msgstr ""

msgid "976    ##### Enforcement"
msgstr ""

msgid ""
"977    (Simple) Report all non-`const` variables declared at namespace scope."
""
msgstr ""

msgid "978    ### <a name=\"Ri-singleton\"></a>I.3: Avoid singletons"
msgstr ""

msgid "979    ##### Reason"
msgstr ""

msgid ""
"980    Singletons are basically complicated global objects in disguise."
msgstr ""

msgid "981    ##### Example"
msgstr ""

msgid "982        class Singleton {"
msgstr ""

msgid ""
"983            // ... lots of stuff to ensure that only one Singleton object "
"is created,"
msgstr ""

msgid "984            // that it is initialized properly, etc."
msgstr ""

msgid "985        };"
msgstr ""

msgid "986    There are many variants of the singleton idea."
msgstr ""

msgid "987    That's part of the problem."
msgstr ""

msgid "988    ##### Note"
msgstr ""

msgid ""
"989    If you don't want a global object to change, declare it `const` or "
"`constexpr`."
msgstr ""

msgid "990    ##### Exception"
msgstr ""

msgid ""
"991    You can use the simplest \"singleton\" (so simple that it is often "
"not considered a singleton) to get initialization on first use, if any:"
msgstr ""

msgid "992        X& myX()"
msgstr ""

msgid "993        {"
msgstr ""

msgid "994            static X my_x {3};"
msgstr ""

msgid "995            return my_x;"
msgstr ""

msgid "996        }"
msgstr ""

msgid ""
"997    This is one of the most effective solutions to problems related to "
"initialization order."
msgstr ""

msgid ""
"998    In a multi-threaded environment, the initialization of the static "
"object does not introduce a race condition"
msgstr ""

msgid ""
"999    (unless you carelessly access a shared object from within its "
"constructor)."
msgstr ""

msgid ""
"1000    Note that the initialization of a local `static` does not imply a "
"race condition."
msgstr ""

msgid ""
"1001    However, if the destruction of `X` involves an operation that needs "
"to be synchronized we must use a less simple solution."
msgstr ""

msgid "1002    For example:"
msgstr ""

msgid "1003        X& myX()"
msgstr ""

msgid "1004        {"
msgstr ""

msgid "1005            static auto p = new X {3};"
msgstr ""

msgid "1006            return *p;  // potential leak"
msgstr ""

msgid "1007        }"
msgstr ""

msgid ""
"1008    Now someone must `delete` that object in some suitably thread-safe "
"way."
msgstr ""

msgid "1009    That's error-prone, so we don't use that technique unless"
msgstr ""

msgid "1010    * `myX` is in multi-threaded code,"
msgstr ""

msgid ""
"1011    * that `X` object needs to be destroyed (e.g., because it releases a "
"resource), and"
msgstr ""

msgid "1012    * `X`'s destructor's code needs to be synchronized."
msgstr ""

msgid ""
"1013    If you, as many do, define a singleton as a class for which only one "
"object is created, functions like `myX` are not singletons, and this useful "
"technique is not an exception to the no-singleton rule."
msgstr ""

msgid "1014    ##### Enforcement"
msgstr ""

msgid "1015    Very hard in general."
msgstr ""

msgid "1016    * Look for classes with names that include `singleton`."
msgstr ""

msgid ""
"1017    * Look for classes for which only a single object is created (by "
"counting objects or by examining constructors)."
msgstr ""

msgid ""
"1018    * If a class X has a public static function that contains a function-"
"local static of the class' type X and returns a pointer or reference to it, "
"ban that."
msgstr ""

msgid ""
"1019    ### <a name=\"Ri-typed\"></a>I.4: Make interfaces precisely and "
"strongly typed"
msgstr ""

msgid "1020    ##### Reason"
msgstr ""

msgid ""
"1021    Types are the simplest and best documentation, have well-defined "
"meaning, and are guaranteed to be checked at compile time."
msgstr ""

msgid "1022    Also, precisely typed code is often optimized better."
msgstr ""

msgid "1023    ##### Example, don't"
msgstr ""

msgid "1024    Consider:"
msgstr ""

msgid "1025        void pass(void* data);    // void* is suspicious"
msgstr ""

msgid ""
"1026    Now the callee must cast the data pointer (back) to a correct type "
"to use it. That is error-prone and often verbose."
msgstr ""

msgid "1027    Avoid `void*`, especially in interfaces."
msgstr ""

msgid "1028    Consider using a `variant` or a pointer to base instead."
msgstr ""

msgid ""
"1029    **Alternative**: Often, a template parameter can eliminate the "
"`void*` turning it into a `T*` or `T&`."
msgstr ""

msgid ""
"1030    For generic code these `T`s can be general or concept constrained "
"template parameters."
msgstr ""

msgid "1031    ##### Example, bad"
msgstr ""

msgid "1032    Consider:"
msgstr ""

msgid ""
"1033        void draw_rect(int, int, int, int);   // great opportunities for "
"mistakes"
msgstr ""

msgid ""
"1034        draw_rect(p.x, p.y, 10, 20);          // what does 10, 20 mean?"
msgstr ""

msgid ""
"1035    An `int` can carry arbitrary forms of information, so we must guess "
"about the meaning of the four `int`s."
msgstr ""

msgid ""
"1036    Most likely, the first two are an `x`,`y` coordinate pair, but what "
"are the last two?"
msgstr ""

msgid ""
"1037    Comments and parameter names can help, but we could be explicit:"
msgstr ""

msgid "1038        void draw_rectangle(Point top_left, Point bottom_right);"
msgstr ""

msgid "1039        void draw_rectangle(Point top_left, Size height_width);"
msgstr ""

msgid "1040        draw_rectangle(p, Point{10, 20});  // two corners"
msgstr ""

msgid ""
"1041        draw_rectangle(p, Size{10, 20});   // one corner and a (height, "
"width) pair"
msgstr ""

msgid ""
"1042    Obviously, we cannot catch all errors through the static type system"
msgstr ""

msgid ""
"1043    (e.g., the fact that a first argument is supposed to be a top-left "
"point is left to convention (naming and comments))."
msgstr ""

msgid "1044    ##### Example, bad"
msgstr ""

msgid ""
"1045    In the following example, it is not clear from the interface what "
"`time_to_blink` means: Seconds? Milliseconds?"
msgstr ""

msgid ""
"1046        void blink_led(int time_to_blink) // bad -- the unit is "
"ambiguous"
msgstr ""

msgid "1047        {"
msgstr ""

msgid "1048            // ..."
msgstr ""

msgid "1049            // do something with time_to_blink"
msgstr ""

msgid "1050            // ..."
msgstr ""

msgid "1051        }"
msgstr ""

msgid "1052        void use()"
msgstr ""

msgid "1053        {"
msgstr ""

msgid "1054            blink_led(2);"
msgstr ""

msgid "1055        }"
msgstr ""

msgid "1056    ##### Example, good"
msgstr ""

msgid ""
"1057    `std::chrono::duration` types (C++11) helps making the unit of time "
"duration explicit."
msgstr ""

msgid ""
"1058        void blink_led(milliseconds time_to_blink) // good -- the unit "
"is explicit"
msgstr ""

msgid "1059        {"
msgstr ""

msgid "1060            // ..."
msgstr ""

msgid "1061            // do something with time_to_blink"
msgstr ""

msgid "1062            // ..."
msgstr ""

msgid "1063        }"
msgstr ""

msgid "1064        void use()"
msgstr ""

msgid "1065        {"
msgstr ""

msgid "1066            blink_led(1500ms);"
msgstr ""

msgid "1067        }"
msgstr ""

msgid ""
"1068    The function can also be written in such a way that it will accept "
"any time duration unit."
msgstr ""

msgid "1069        template<class rep, class period>"
msgstr ""

msgid ""
"1070        void blink_led(duration<rep, period> time_to_blink) // good -- "
"accepts any unit"
msgstr ""

msgid "1071        {"
msgstr ""

msgid ""
"1072            // assuming that millisecond is the smallest relevant unit"
msgstr ""

msgid ""
"1073            auto milliseconds_to_blink = "
"duration_cast<milliseconds>(time_to_blink);"
msgstr ""

msgid "1074            // ..."
msgstr ""

msgid "1075            // do something with milliseconds_to_blink"
msgstr ""

msgid "1076            // ..."
msgstr ""

msgid "1077        }"
msgstr ""

msgid "1078        void use()"
msgstr ""

msgid "1079        {"
msgstr ""

msgid "1080            blink_led(2s);"
msgstr ""

msgid "1081            blink_led(1500ms);"
msgstr ""

msgid "1082        }"
msgstr ""

msgid "1083    ##### Enforcement"
msgstr ""

msgid ""
"1084    * (Simple) Report the use of `void*` as a parameter or return type."
msgstr ""

msgid ""
"1085    * (Hard to do well) Look for member functions with many built-in "
"type arguments."
msgstr ""

msgid "1086    ### <a name=\"Ri-pre\"></a>I.5: State preconditions (if any)"
msgstr ""

msgid "1087    ##### Reason"
msgstr ""

msgid ""
"1088    Arguments have meaning that may constrain their proper use in the "
"callee."
msgstr ""

msgid "1089    ##### Example"
msgstr ""

msgid "1090    Consider:"
msgstr ""

msgid "1091        double sqrt(double x);"
msgstr ""

msgid ""
"1092    Here `x` must be nonnegative. The type system cannot (easily and "
"naturally) express that, so we must use other means. For example:"
msgstr ""

msgid "1093        double sqrt(double x); // x must be nonnegative"
msgstr ""

msgid ""
"1094    Some preconditions can be expressed as assertions. For example:"
msgstr ""

msgid "1095        double sqrt(double x) { Expects(x >= 0); /* ... */ }"
msgstr ""

msgid ""
"1096    Ideally, that `Expects(x >= 0)` should be part of the interface of "
"`sqrt()` but that's not easily done. For now, we place it in the definition "
"(function body)."
msgstr ""

msgid "1097    **References**: `Expects()` is described in [GSL](#S-gsl)."
msgstr ""

msgid "1098    ##### Note"
msgstr ""

msgid ""
"1099    Prefer a formal specification of requirements, such as `Expects(p);`."
""
msgstr ""

msgid ""
"1100    If that is infeasible, use English text in comments, such as `// the "
"sequence [p:q) is ordered using <`."
msgstr ""

msgid "1101    ##### Note"
msgstr ""

msgid ""
"1102    Most member functions have as a precondition that some class "
"invariant holds."
msgstr ""

msgid ""
"1103    That invariant is established by a constructor and must be "
"reestablished upon exit by every member function called from outside the "
"class."
msgstr ""

msgid "1104    We don't need to mention it for each member function."
msgstr ""

msgid "1105    ##### Enforcement"
msgstr ""

msgid "1106    (Not enforceable)"
msgstr ""

msgid "1107    **See also**: The rules for passing pointers. ???"
msgstr ""

msgid ""
"1108    ### <a name=\"Ri-expects\"></a>I.6: Prefer `Expects()` for "
"expressing preconditions"
msgstr ""

msgid "1109    ##### Reason"
msgstr ""

msgid ""
"1110    To make it clear that the condition is a precondition and to enable "
"tool use."
msgstr ""

msgid "1111    ##### Example"
msgstr ""

msgid "1112        int area(int height, int width)"
msgstr ""

msgid "1113        {"
msgstr ""

msgid "1114            Expects(height > 0 && width > 0);            // good"
msgstr ""

msgid ""
"1115            if (height <= 0 || width <= 0) my_error();   // obscure"
msgstr ""

msgid "1116            // ..."
msgstr ""

msgid "1117        }"
msgstr ""

msgid "1118    ##### Note"
msgstr ""

msgid ""
"1119    Preconditions can be stated in many ways, including comments, `if`-"
"statements, and `assert()`."
msgstr ""

msgid ""
"1120    This can make them hard to distinguish from ordinary code, hard to "
"update, hard to manipulate by tools, and may have the wrong semantics (do "
"you always want to abort in debug mode and check nothing in productions "
"runs?)."
msgstr ""

msgid "1121    ##### Note"
msgstr ""

msgid ""
"1122    Preconditions should be part of the interface rather than part of "
"the implementation,"
msgstr ""

msgid "1123    but we don't yet have the language facilities to do that."
msgstr ""

msgid ""
"1124    Once language support becomes available (e.g., see the [contract "
"proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1."
"pdf)) we will adopt the standard version of preconditions, postconditions, "
"and assertions."
msgstr ""

msgid "1125    ##### Note"
msgstr ""

msgid ""
"1126    `Expects()` can also be used to check a condition in the middle of "
"an algorithm."
msgstr ""

msgid "1127    ##### Note"
msgstr ""

msgid ""
"1128    No, using `unsigned` is not a good way to sidestep the problem of "
"[ensuring that a value is nonnegative](#Res-nonnegative)."
msgstr ""

msgid "1129    ##### Enforcement"
msgstr ""

msgid ""
"1130    (Not enforceable) Finding the variety of ways preconditions can be "
"asserted is not feasible. Warning about those that can be easily identified "
"(`assert()`) has questionable value in the absence of a language facility."
msgstr ""

msgid "1131    ### <a name=\"Ri-post\"></a>I.7: State postconditions"
msgstr ""

msgid "1132    ##### Reason"
msgstr ""

msgid ""
"1133    To detect misunderstandings about the result and possibly catch "
"erroneous implementations."
msgstr ""

msgid "1134    ##### Example, bad"
msgstr ""

msgid "1135    Consider:"
msgstr ""

msgid ""
"1136        int area(int height, int width) { return height * width; }  // "
"bad"
msgstr ""

msgid ""
"1137    Here, we (incautiously) left out the precondition specification, so "
"it is not explicit that height and width must be positive."
msgstr ""

msgid ""
"1138    We also left out the postcondition specification, so it is not "
"obvious that the algorithm (`height * width`) is wrong for areas larger than "
"the largest integer."
msgstr ""

msgid "1139    Overflow can happen."
msgstr ""

msgid "1140    Consider using:"
msgstr ""

msgid "1141        int area(int height, int width)"
msgstr ""

msgid "1142        {"
msgstr ""

msgid "1143            auto res = height * width;"
msgstr ""

msgid "1144            Ensures(res > 0);"
msgstr ""

msgid "1145            return res;"
msgstr ""

msgid "1146        }"
msgstr ""

msgid "1147    ##### Example, bad"
msgstr ""

msgid "1148    Consider a famous security bug:"
msgstr ""

msgid "1149        void f()    // problematic"
msgstr ""

msgid "1150        {"
msgstr ""

msgid "1151            char buffer[MAX];"
msgstr ""

msgid "1152            // ..."
msgstr ""

msgid "1153            memset(buffer, 0, sizeof(buffer));"
msgstr ""

msgid "1154        }"
msgstr ""

msgid ""
"1155    There was no postcondition stating that the buffer should be cleared "
"and the optimizer eliminated the apparently redundant `memset()` call:"
msgstr ""

msgid "1156        void f()    // better"
msgstr ""

msgid "1157        {"
msgstr ""

msgid "1158            char buffer[MAX];"
msgstr ""

msgid "1159            // ..."
msgstr ""

msgid "1160            memset(buffer, 0, sizeof(buffer));"
msgstr ""

msgid "1161            Ensures(buffer[0] == 0);"
msgstr ""

msgid "1162        }"
msgstr ""

msgid "1163    ##### Note"
msgstr ""

msgid ""
"1164    Postconditions are often informally stated in a comment that states "
"the purpose of a function; `Ensures()` can be used to make this more "
"systematic, visible, and checkable."
msgstr ""

msgid "1165    ##### Note"
msgstr ""

msgid ""
"1166    Postconditions are especially important when they relate to "
"something that is not directly reflected in a returned result, such as a "
"state of a data structure used."
msgstr ""

msgid "1167    ##### Example"
msgstr ""

msgid ""
"1168    Consider a function that manipulates a `Record`, using a `mutex` to "
"avoid race conditions:"
msgstr ""

msgid "1169        mutex m;"
msgstr ""

msgid "1170        void manipulate(Record& r)    // don't"
msgstr ""

msgid "1171        {"
msgstr ""

msgid "1172            m.lock();"
msgstr ""

msgid "1173            // ... no m.unlock() ..."
msgstr ""

msgid "1174        }"
msgstr ""

msgid ""
"1175    Here, we \"forgot\" to state that the `mutex` should be released, so "
"we don't know if the failure to ensure release of the `mutex` was a bug or a "
"feature."
msgstr ""

msgid "1176    Stating the postcondition would have made it clear:"
msgstr ""

msgid ""
"1177        void manipulate(Record& r)    // postcondition: m is unlocked "
"upon exit"
msgstr ""

msgid "1178        {"
msgstr ""

msgid "1179            m.lock();"
msgstr ""

msgid "1180            // ... no m.unlock() ..."
msgstr ""

msgid "1181        }"
msgstr ""

msgid "1182    The bug is now obvious (but only to a human reading comments)."
msgstr ""

msgid ""
"1183    Better still, use [RAII](#Rr-raii) to ensure that the postcondition "
"(\"the lock must be released\") is enforced in code:"
msgstr ""

msgid "1184        void manipulate(Record& r)    // best"
msgstr ""

msgid "1185        {"
msgstr ""

msgid "1186            lock_guard<mutex> _ {m};"
msgstr ""

msgid "1187            // ..."
msgstr ""

msgid "1188        }"
msgstr ""

msgid "1189    ##### Note"
msgstr ""

msgid ""
"1190    Ideally, postconditions are stated in the interface/declaration so "
"that users can easily see them."
msgstr ""

msgid ""
"1191    Only postconditions related to the users can be stated in the "
"interface."
msgstr ""

msgid ""
"1192    Postconditions related only to internal state belongs in the "
"definition/implementation."
msgstr ""

msgid "1193    ##### Enforcement"
msgstr ""

msgid ""
"1194    (Not enforceable) This is a philosophical guideline that is "
"infeasible to check"
msgstr ""

msgid ""
"1195    directly in the general case. Domain specific checkers (like lock-"
"holding"
msgstr ""

msgid "1196    checkers) exist for many toolchains."
msgstr ""

msgid ""
"1197    ### <a name=\"Ri-ensures\"></a>I.8: Prefer `Ensures()` for "
"expressing postconditions"
msgstr ""

msgid "1198    ##### Reason"
msgstr ""

msgid ""
"1199    To make it clear that the condition is a postcondition and to enable "
"tool use."
msgstr ""

msgid "1200    ##### Example"
msgstr ""

msgid "1201        void f()"
msgstr ""

msgid "1202        {"
msgstr ""

msgid "1203            char buffer[MAX];"
msgstr ""

msgid "1204            // ..."
msgstr ""

msgid "1205            memset(buffer, 0, MAX);"
msgstr ""

msgid "1206            Ensures(buffer[0] == 0);"
msgstr ""

msgid "1207        }"
msgstr ""

msgid "1208    ##### Note"
msgstr ""

msgid ""
"1209    Postconditions can be stated in many ways, including comments, `if`-"
"statements, and `assert()`."
msgstr ""

msgid ""
"1210    This can make them hard to distinguish from ordinary code, hard to "
"update, hard to manipulate by tools, and may have the wrong semantics."
msgstr ""

msgid ""
"1211    **Alternative**: Postconditions of the form \"this resource must be "
"released\" are best expressed by [RAII](#Rr-raii)."
msgstr ""

msgid "1212    ##### Note"
msgstr ""

msgid ""
"1213    Ideally, that `Ensures` should be part of the interface, but that's "
"not easily done."
msgstr ""

msgid "1214    For now, we place it in the definition (function body)."
msgstr ""

msgid ""
"1215    Once language support becomes available (e.g., see the [contract "
"proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1."
"pdf)) we will adopt the standard version of preconditions, postconditions, "
"and assertions."
msgstr ""

msgid "1216    ##### Enforcement"
msgstr ""

msgid ""
"1217    (Not enforceable) Finding the variety of ways postconditions can be "
"asserted is not feasible. Warning about those that can be easily identified "
"(`assert()`) has questionable value in the absence of a language facility."
msgstr ""

msgid ""
"1218    ### <a name=\"Ri-concepts\"></a>I.9: If an interface is a template, "
"document its parameters using concepts"
msgstr ""

msgid "1219    ##### Reason"
msgstr ""

msgid ""
"1220    Make the interface precisely specified and compile-time checkable in "
"the (not so distant) future."
msgstr ""

msgid "1221    ##### Example"
msgstr ""

msgid ""
"1222    Use the ISO Concepts TS style of requirements specification. For "
"example:"
msgstr ""

msgid "1223        template<typename Iter, typename Val>"
msgstr ""

msgid ""
"1224        // requires InputIterator<Iter> && "
"EqualityComparable<ValueType<Iter>>, Val>"
msgstr ""

msgid "1225        Iter find(Iter first, Iter last, Val v)"
msgstr ""

msgid "1226        {"
msgstr ""

msgid "1227            // ..."
msgstr ""

msgid "1228        }"
msgstr ""

msgid "1229    ##### Note"
msgstr ""

msgid ""
"1230    Soon (maybe in 2018), most compilers will be able to check "
"`requires` clauses once the `//` is removed."
msgstr ""

msgid "1231    Concepts are supported in GCC 6.1 and later."
msgstr ""

msgid ""
"1232    **See also**: [Generic programming](#SS-GP) and [concepts](#SS-"
"concepts)."
msgstr ""

msgid "1233    ##### Enforcement"
msgstr ""

msgid ""
"1234    (Not yet enforceable) A language facility is under specification. "
"When the language facility is available, warn if any non-variadic template "
"parameter is not constrained by a concept (in its declaration or mentioned "
"in a `requires` clause)."
msgstr ""

msgid ""
"1235    ### <a name=\"Ri-except\"></a>I.10: Use exceptions to signal a "
"failure to perform a required task"
msgstr ""

msgid "1236    ##### Reason"
msgstr ""

msgid ""
"1237    It should not be possible to ignore an error because that could "
"leave the system or a computation in an undefined (or unexpected) state."
msgstr ""

msgid "1238    This is a major source of errors."
msgstr ""

msgid "1239    ##### Example"
msgstr ""

msgid ""
"1240        int printf(const char* ...);    // bad: return negative number "
"if output fails"
msgstr ""

msgid "1241        template <class F, class ...Args>"
msgstr ""

msgid ""
"1242        // good: throw system_error if unable to start the new thread"
msgstr ""

msgid "1243        explicit thread(F&& f, Args&&... args);"
msgstr ""

msgid "1244    ##### Note"
msgstr ""

msgid "1245    What is an error?"
msgstr ""

msgid ""
"1246    An error means that the function cannot achieve its advertised "
"purpose (including establishing postconditions)."
msgstr ""

msgid ""
"1247    Calling code that ignores an error could lead to wrong results or "
"undefined systems state."
msgstr ""

msgid ""
"1248    For example, not being able to connect to a remote server is not by "
"itself an error:"
msgstr ""

msgid ""
"1249    the server can refuse a connection for all kinds of reasons, so the "
"natural thing is to return a result that the caller should always check."
msgstr ""

msgid ""
"1250    However, if failing to make a connection is considered an error, "
"then a failure should throw an exception."
msgstr ""

msgid "1251    ##### Exception"
msgstr ""

msgid ""
"1252    Many traditional interface functions (e.g., UNIX signal handlers) "
"use error codes (e.g., `errno`) to report what are really status codes, "
"rather than errors. You don't have a good alternative to using such, so "
"calling these does not violate the rule."
msgstr ""

msgid "1253    ##### Alternative"
msgstr ""

msgid ""
"1254    If you can't use exceptions (e.g., because your code is full of old-"
"style raw-pointer use or because there are hard-real-time constraints), "
"consider using a style that returns a pair of values:"
msgstr ""

msgid "1255        int val;"
msgstr ""

msgid "1256        int error_code;"
msgstr ""

msgid "1257        tie(val, error_code) = do_something();"
msgstr ""

msgid "1258        if (error_code) {"
msgstr ""

msgid "1259            // ... handle the error or exit ..."
msgstr ""

msgid "1260        }"
msgstr ""

msgid "1261        // ... use val ..."
msgstr ""

msgid "1262    This style unfortunately leads to uninitialized variables."
msgstr ""

msgid ""
"1263    A facility [structured bindings](http://www.open-std.org/jtc1/sc22/"
"wg21/docs/papers/2016/p0144r1.pdf) to deal with that will become available "
"in C++17."
msgstr ""

msgid "1264        auto [val, error_code] = do_something();"
msgstr ""

msgid "1265        if (error_code) {"
msgstr ""

msgid "1266            // ... handle the error or exit ..."
msgstr ""

msgid "1267        }"
msgstr ""

msgid "1268        // ... use val ..."
msgstr ""

msgid "1269    ##### Note"
msgstr ""

msgid ""
"1270    We don't consider \"performance\" a valid reason not to use "
"exceptions."
msgstr ""

msgid ""
"1271    * Often, explicit error checking and handling consume as much time "
"and space as exception handling."
msgstr ""

msgid ""
"1272    * Often, cleaner code yields better performance with exceptions "
"(simplifying the tracing of paths through the program and their "
"optimization)."
msgstr ""

msgid ""
"1273    * A good rule for performance critical code is to move checking "
"outside the critical part of the code ([checking](#Rper-checking))."
msgstr ""

msgid "1274    * In the longer term, more regular code gets better optimized."
msgstr ""

msgid ""
"1275    * Always carefully [measure](#Rper-measure) before making "
"performance claims."
msgstr ""

msgid ""
"1276    **See also**: [I.5](#Ri-pre) and [I.7](#Ri-post) for reporting "
"precondition and postcondition violations."
msgstr ""

msgid "1277    ##### Enforcement"
msgstr ""

msgid ""
"1278    * (Not enforceable) This is a philosophical guideline that is "
"infeasible to check directly."
msgstr ""

msgid "1279    * Look for `errno`."
msgstr ""

msgid ""
"1280    ### <a name=\"Ri-raw\"></a>I.11: Never transfer ownership by a raw "
"pointer (`T*`) or reference (`T&`)"
msgstr ""

msgid "1281    ##### Reason"
msgstr ""

msgid ""
"1282    If there is any doubt whether the caller or the callee owns an "
"object, leaks or premature destruction will occur."
msgstr ""

msgid "1283    ##### Example"
msgstr ""

msgid "1284    Consider:"
msgstr ""

msgid "1285        X* compute(args)    // don't"
msgstr ""

msgid "1286        {"
msgstr ""

msgid "1287            X* res = new X{};"
msgstr ""

msgid "1288            // ..."
msgstr ""

msgid "1289            return res;"
msgstr ""

msgid "1290        }"
msgstr ""

msgid ""
"1291    Who deletes the returned `X`? The problem would be harder to spot if "
"`compute` returned a reference."
msgstr ""

msgid ""
"1292    Consider returning the result by value (use move semantics if the "
"result is large):"
msgstr ""

msgid "1293        vector<double> compute(args)  // good"
msgstr ""

msgid "1294        {"
msgstr ""

msgid "1295            vector<double> res(10000);"
msgstr ""

msgid "1296            // ..."
msgstr ""

msgid "1297            return res;"
msgstr ""

msgid "1298        }"
msgstr ""

msgid ""
"1299    **Alternative**: [Pass ownership](#Rr-smartptrparam) using a \"smart "
"pointer\", such as `unique_ptr` (for exclusive ownership) and `shared_ptr` "
"(for shared ownership)."
msgstr ""

msgid ""
"1300    However, that is less elegant and often less efficient than "
"returning the object itself,"
msgstr ""

msgid "1301    so use smart pointers only if reference semantics are needed."
msgstr ""

msgid ""
"1302    **Alternative**: Sometimes older code can't be modified because of "
"ABI compatibility requirements or lack of resources."
msgstr ""

msgid ""
"1303    In that case, mark owning pointers using `owner` from the "
"[guidelines support library](#S-gsl):"
msgstr ""

msgid ""
"1304        owner<X*> compute(args)    // It is now clear that ownership is "
"transferred"
msgstr ""

msgid "1305        {"
msgstr ""

msgid "1306            owner<X*> res = new X{};"
msgstr ""

msgid "1307            // ..."
msgstr ""

msgid "1308            return res;"
msgstr ""

msgid "1309        }"
msgstr ""

msgid "1310    This tells analysis tools that `res` is an owner."
msgstr ""

msgid ""
"1311    That is, its value must be `delete`d or transferred to another "
"owner, as is done here by the `return`."
msgstr ""

msgid ""
"1312    `owner` is used similarly in the implementation of resource handles."
msgstr ""

msgid "1313    ##### Note"
msgstr ""

msgid ""
"1314    Every object passed as a raw pointer (or iterator) is assumed to be "
"owned by the"
msgstr ""

msgid ""
"1315    caller, so that its lifetime is handled by the caller. Viewed "
"another way:"
msgstr ""

msgid ""
"1316    ownership transferring APIs are relatively rare compared to pointer-"
"passing APIs,"
msgstr ""

msgid "1317    so the default is \"no ownership transfer.\""
msgstr ""

msgid ""
"1318    **See also**: [Argument passing](#Rf-conventional), [use of smart "
"pointer arguments](#Rr-smartptrparam), and [value return](#Rf-value-return)."
msgstr ""

msgid "1319    ##### Enforcement"
msgstr ""

msgid ""
"1320    * (Simple) Warn on `delete` of a raw pointer that is not an "
"`owner<T>`. Suggest use of standard-library resource handle or use of "
"`owner<T>`."
msgstr ""

msgid ""
"1321    * (Simple) Warn on failure to either `reset` or explicitly `delete` "
"an `owner` pointer on every code path."
msgstr ""

msgid ""
"1322    * (Simple) Warn if the return value of `new` or a function call with "
"an `owner` return value is assigned to a raw pointer or non-`owner` "
"reference."
msgstr ""

msgid ""
"1323    ### <a name=\"Ri-nullptr\"></a>I.12: Declare a pointer that must not "
"be null as `not_null`"
msgstr ""

msgid "1324    ##### Reason"
msgstr ""

msgid "1325    To help avoid dereferencing `nullptr` errors."
msgstr ""

msgid ""
"1326    To improve performance by avoiding redundant checks for `nullptr`."
msgstr ""

msgid "1327    ##### Example"
msgstr ""

msgid ""
"1328        int length(const char* p);            // it is not clear whether "
"length(nullptr) is valid"
msgstr ""

msgid "1329        length(nullptr);                      // OK?"
msgstr ""

msgid ""
"1330        int length(not_null<const char*> p);  // better: we can assume "
"that p cannot be nullptr"
msgstr ""

msgid ""
"1331        int length(const char* p);            // we must assume that p "
"can be nullptr"
msgstr ""

msgid ""
"1332    By stating the intent in source, implementers and tools can provide "
"better diagnostics, such as finding some classes of errors through static "
"analysis, and perform optimizations, such as removing branches and null "
"tests."
msgstr ""

msgid "1333    ##### Note"
msgstr ""

msgid ""
"1334    `not_null` is defined in the [guidelines support library](#S-gsl)."
msgstr ""

msgid "1335    ##### Note"
msgstr ""

msgid ""
"1336    The assumption that the pointer to `char` pointed to a C-style "
"string (a zero-terminated string of characters) was still implicit, and a "
"potential source of confusion and errors. Use `czstring` in preference to "
"`const char*`."
msgstr ""

msgid "1337        // we can assume that p cannot be nullptr"
msgstr ""

msgid ""
"1338        // we can assume that p points to a zero-terminated array of "
"characters"
msgstr ""

msgid "1339        int length(not_null<zstring> p);"
msgstr ""

msgid "1340    Note: `length()` is, of course, `std::strlen()` in disguise."
msgstr ""

msgid "1341    ##### Enforcement"
msgstr ""

msgid ""
"1342    * (Simple) ((Foundation)) If a function checks a pointer parameter "
"against `nullptr` before access, on all control-flow paths, then warn it "
"should be declared `not_null`."
msgstr ""

msgid ""
"1343    * (Complex) If a function with pointer return value ensures it is "
"not `nullptr` on all return paths, then warn the return type should be "
"declared `not_null`."
msgstr ""

msgid ""
"1344    ### <a name=\"Ri-array\"></a>I.13: Do not pass an array as a single "
"pointer"
msgstr ""

msgid "1345    ##### Reason"
msgstr ""

msgid ""
"1346     (pointer, size)-style interfaces are error-prone. Also, a plain "
"pointer (to array) must rely on some convention to allow the callee to "
"determine the size."
msgstr ""

msgid "1347    ##### Example"
msgstr ""

msgid "1348    Consider:"
msgstr ""

msgid ""
"1349        void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:"
"q+n)"
msgstr ""

msgid ""
"1350    What if there are fewer than `n` elements in the array pointed to by "
"`q`? Then, we overwrite some probably unrelated memory."
msgstr ""

msgid ""
"1351    What if there are fewer than `n` elements in the array pointed to by "
"`p`? Then, we read some probably unrelated memory."
msgstr ""

msgid "1352    Either is undefined behavior and a potentially very nasty bug."
msgstr ""

msgid "1353    ##### Alternative"
msgstr ""

msgid "1354    Consider using explicit spans:"
msgstr ""

msgid "1355        void copy(span<const T> r, span<T> r2); // copy r to r2"
msgstr ""

msgid "1356    ##### Example, bad"
msgstr ""

msgid "1357    Consider:"
msgstr ""

msgid "1358        void draw(Shape* p, int n);  // poor interface; poor code"
msgstr ""

msgid "1359        Circle arr[10];"
msgstr ""

msgid "1360        // ..."
msgstr ""

msgid "1361        draw(arr, 10);"
msgstr ""

msgid ""
"1362    Passing `10` as the `n` argument may be a mistake: the most common "
"convention is to assume `[0:n)` but that is nowhere stated. Worse is that "
"the call of `draw()` compiled at all: there was an implicit conversion from "
"array to pointer (array decay) and then another implicit conversion from "
"`Circle` to `Shape`. There is no way that `draw()` can safely iterate "
"through that array: it has no way of knowing the size of the elements."
msgstr ""

msgid ""
"1363    **Alternative**: Use a support class that ensures that the number of "
"elements is correct and prevents dangerous implicit conversions. For example:"
""
msgstr ""

msgid "1364        void draw2(span<Circle>);"
msgstr ""

msgid "1365        Circle arr[10];"
msgstr ""

msgid "1366        // ..."
msgstr ""

msgid ""
"1367        draw2(span<Circle>(arr));  // deduce the number of elements"
msgstr ""

msgid "1368        draw2(arr);    // deduce the element type and array size"
msgstr ""

msgid "1369        void draw3(span<Shape>);"
msgstr ""

msgid ""
"1370        draw3(arr);    // error: cannot convert Circle[10] to "
"span<Shape>"
msgstr ""

msgid ""
"1371    This `draw2()` passes the same amount of information to `draw()`, "
"but makes the fact that it is supposed to be a range of `Circle`s explicit. "
"See ???."
msgstr ""

msgid "1372    ##### Exception"
msgstr ""

msgid ""
"1373    Use `zstring` and `czstring` to represent a C-style, zero-terminated "
"strings."
msgstr ""

msgid ""
"1374    But when doing so, use `string_span` from the [GSL](#GSL) to prevent "
"range errors."
msgstr ""

msgid "1375    ##### Enforcement"
msgstr ""

msgid ""
"1376    * (Simple) ((Bounds)) Warn for any expression that would rely on "
"implicit conversion of an array type to a pointer type. Allow exception for "
"zstring/czstring pointer types."
msgstr ""

msgid ""
"1377    * (Simple) ((Bounds)) Warn for any arithmetic operation on an "
"expression of pointer type that results in a value of pointer type. Allow "
"exception for zstring/czstring pointer types."
msgstr ""

msgid ""
"1378    ### <a name=\"Ri-global-init\"></a>I.22: Avoid complex "
"initialization of global objects"
msgstr ""

msgid "1379    ##### Reason"
msgstr ""

msgid ""
"1380    Complex initialization can lead to undefined order of execution."
msgstr ""

msgid "1381    ##### Example"
msgstr ""

msgid "1382        // file1.c"
msgstr ""

msgid "1383        extern const X x;"
msgstr ""

msgid "1384        const Y y = f(x);   // read x; write y"
msgstr ""

msgid "1385        // file2.c"
msgstr ""

msgid "1386        extern const Y y;"
msgstr ""

msgid "1387        const X x = g(y);   // read y; write x"
msgstr ""

msgid ""
"1388    Since `x` and `y` are in different translation units the order of "
"calls to `f()` and `g()` is undefined;"
msgstr ""

msgid "1389    one will access an uninitialized `const`."
msgstr ""

msgid ""
"1390    This shows that the order-of-initialization problem for global "
"(namespace scope) objects is not limited to global *variables*."
msgstr ""

msgid "1391    ##### Note"
msgstr ""

msgid ""
"1392    Order of initialization problems become particularly difficult to "
"handle in concurrent code."
msgstr ""

msgid ""
"1393    It is usually best to avoid global (namespace scope) objects "
"altogether."
msgstr ""

msgid "1394    ##### Enforcement"
msgstr ""

msgid ""
"1395    * Flag initializers of globals that call non-`constexpr` functions"
msgstr ""

msgid "1396    * Flag initializers of globals that access `extern` objects"
msgstr ""

msgid ""
"1397    ### <a name=\"Ri-nargs\"></a>I.23: Keep the number of function "
"arguments low"
msgstr ""

msgid "1398    ##### Reason"
msgstr ""

msgid ""
"1399    Having many arguments opens opportunities for confusion. Passing "
"lots of arguments is often costly compared to alternatives."
msgstr ""

msgid "1400    ##### Discussion"
msgstr ""

msgid ""
"1401    The two most common reasons why functions have too many parameters "
"are:"
msgstr ""

msgid "1402    1. *Missing an abstraction.*"
msgstr ""

msgid ""
"1403       There is an abstraction missing, so that a compound value is "
"being"
msgstr ""

msgid ""
"1404       passed as individual elements instead of as a single object that "
"enforces an invariant."
msgstr ""

msgid ""
"1405       This not only expands the parameter list, but it leads to errors "
"because the component values"
msgstr ""

msgid "1406       are no longer protected by an enforced invariant."
msgstr ""

msgid "1407    2. *Violating \"one function, one responsibility.\"*"
msgstr ""

msgid ""
"1408       The function is trying to do more than one job and should "
"probably be refactored."
msgstr ""

msgid "1409    ##### Example"
msgstr ""

msgid ""
"1410    The standard-library `merge()` is at the limit of what we can "
"comfortably handle:"
msgstr ""

msgid ""
"1411        template<class InputIterator1, class InputIterator2, class "
"OutputIterator, class Compare>"
msgstr ""

msgid ""
"1412        OutputIterator merge(InputIterator1 first1, InputIterator1 "
"last1,"
msgstr ""

msgid ""
"1413                             InputIterator2 first2, InputIterator2 "
"last2,"
msgstr ""

msgid "1414                             OutputIterator result, Compare comp);"
msgstr ""

msgid ""
"1415    Note that this is because of problem 1 above -- missing abstraction. "
"Instead of passing a range (abstraction), STL passed iterator pairs "
"(unencapsulated component values)."
msgstr ""

msgid ""
"1416    Here, we have four template arguments and six function arguments."
msgstr ""

msgid ""
"1417    To simplify the most frequent and simplest uses, the comparison "
"argument can be defaulted to `<`:"
msgstr ""

msgid ""
"1418        template<class InputIterator1, class InputIterator2, class "
"OutputIterator>"
msgstr ""

msgid ""
"1419        OutputIterator merge(InputIterator1 first1, InputIterator1 "
"last1,"
msgstr ""

msgid ""
"1420                             InputIterator2 first2, InputIterator2 "
"last2,"
msgstr ""

msgid "1421                             OutputIterator result);"
msgstr ""

msgid ""
"1422    This doesn't reduce the total complexity, but it reduces the surface "
"complexity presented to many users."
msgstr ""

msgid ""
"1423    To really reduce the number of arguments, we need to bundle the "
"arguments into higher-level abstractions:"
msgstr ""

msgid ""
"1424        template<class InputRange1, class InputRange2, class "
"OutputIterator>"
msgstr ""

msgid ""
"1425        OutputIterator merge(InputRange1 r1, InputRange2 r2, "
"OutputIterator result);"
msgstr ""

msgid ""
"1426    Grouping arguments into \"bundles\" is a general technique to reduce "
"the number of arguments and to increase the opportunities for checking."
msgstr ""

msgid ""
"1427    Alternatively, we could use concepts (as defined by the ISO TS) to "
"define the notion of three types that must be usable for merging:"
msgstr ""

msgid "1428        Mergeable{In1, In2, Out}"
msgstr ""

msgid "1429        OutputIterator merge(In1 r1, In2 r2, Out result);"
msgstr ""

msgid "1430    ##### Example"
msgstr ""

msgid "1431    The safety Profiles recommend replacing"
msgstr ""

msgid ""
"1432        void f(int* some_ints, int some_ints_length);  // BAD: C style, "
"unsafe"
msgstr ""

msgid "1433    with"
msgstr ""

msgid ""
"1434        void f(gsl::span<int> some_ints);              // GOOD: safe, "
"bounds-checked"
msgstr ""

msgid ""
"1435    Here, using an abstraction has safety and robustness benefits, and "
"naturally also reduces the number of parameters."
msgstr ""

msgid "1436    ##### Note"
msgstr ""

msgid ""
"1437    How many parameters are too many? Try to use fewer than four (4) "
"parameters."
msgstr ""

msgid ""
"1438    There are functions that are best expressed with four individual "
"parameters, but not many."
msgstr ""

msgid ""
"1439    **Alternative**: Use better abstraction: Group arguments into "
"meaningful objects and pass the objects (by value or by reference)."
msgstr ""

msgid ""
"1440    **Alternative**: Use default arguments or overloads to allow the "
"most common forms of calls to be done with fewer arguments."
msgstr ""

msgid "1441    ##### Enforcement"
msgstr ""

msgid ""
"1442    * Warn when a function declares two iterators (including pointers) "
"of the same type instead of a range or a view."
msgstr ""

msgid ""
"1443    * (Not enforceable) This is a philosophical guideline that is "
"infeasible to check directly."
msgstr ""

msgid ""
"1444    ### <a name=\"Ri-unrelated\"></a>I.24: Avoid adjacent unrelated "
"parameters of the same type"
msgstr ""

msgid "1445    ##### Reason"
msgstr ""

msgid ""
"1446    Adjacent arguments of the same type are easily swapped by mistake."
msgstr ""

msgid "1447    ##### Example, bad"
msgstr ""

msgid "1448    Consider:"
msgstr ""

msgid ""
"1449        void copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q "
"+ n)"
msgstr ""

msgid ""
"1450    This is a nasty variant of a K&R C-style interface. It is easy to "
"reverse the \"to\" and \"from\" arguments."
msgstr ""

msgid "1451    Use `const` for the \"from\" argument:"
msgstr ""

msgid ""
"1452        void copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to "
"[q:q + n)"
msgstr ""

msgid "1453    ##### Exception"
msgstr ""

msgid ""
"1454    If the order of the parameters is not important, there is no problem:"
""
msgstr ""

msgid "1455        int max(int a, int b);"
msgstr ""

msgid "1456    ##### Alternative"
msgstr ""

msgid ""
"1457    Don't pass arrays as pointers, pass an object representing a range "
"(e.g., a `span`):"
msgstr ""

msgid ""
"1458        void copy_n(span<const T> p, span<T> q);  // copy from p to q"
msgstr ""

msgid "1459    ##### Alternative"
msgstr ""

msgid ""
"1460    Define a `struct` as the parameter type and name the fields for "
"those parameters accordingly:"
msgstr ""

msgid "1461        struct SystemParams {"
msgstr ""

msgid "1462            string config_file;"
msgstr ""

msgid "1463            string output_path;"
msgstr ""

msgid "1464            seconds timeout;"
msgstr ""

msgid "1465        };"
msgstr ""

msgid "1466        void initialize(SystemParams p);"
msgstr ""

msgid ""
"1467    This tends to make invocations of this clear to future readers, as "
"the parameters"
msgstr ""

msgid "1468    are often filled in by name at the call site."
msgstr ""

msgid "1469    ##### Enforcement"
msgstr ""

msgid ""
"1470    (Simple) Warn if two consecutive parameters share the same type."
msgstr ""

msgid ""
"1471    ### <a name=\"Ri-abstract\"></a>I.25: Prefer abstract classes as "
"interfaces to class hierarchies"
msgstr ""

msgid "1472    ##### Reason"
msgstr ""

msgid ""
"1473    Abstract classes are more likely to be stable than base classes with "
"state."
msgstr ""

msgid "1474    ##### Example, bad"
msgstr ""

msgid "1475    You just knew that `Shape` would turn up somewhere :-)"
msgstr ""

msgid "1476        class Shape {  // bad: interface class loaded with data"
msgstr ""

msgid "1477        public:"
msgstr ""

msgid "1478            Point center() const { return c; }"
msgstr ""

msgid "1479            virtual void draw() const;"
msgstr ""

msgid "1480            virtual void rotate(int);"
msgstr ""

msgid "1481            // ..."
msgstr ""

msgid "1482        private:"
msgstr ""

msgid "1483            Point c;"
msgstr ""

msgid "1484            vector<Point> outline;"
msgstr ""

msgid "1485            Color col;"
msgstr ""

msgid "1486        };"
msgstr ""

msgid ""
"1487    This will force every derived class to compute a center -- even if "
"that's non-trivial and the center is never used. Similarly, not every "
"`Shape` has a `Color`, and many `Shape`s are best represented without an "
"outline defined as a sequence of `Point`s. Abstract classes were invented to "
"discourage users from writing such classes:"
msgstr ""

msgid "1488        class Shape {    // better: Shape is a pure interface"
msgstr ""

msgid "1489        public:"
msgstr ""

msgid ""
"1490            virtual Point center() const = 0;   // pure virtual "
"functions"
msgstr ""

msgid "1491            virtual void draw() const = 0;"
msgstr ""

msgid "1492            virtual void rotate(int) = 0;"
msgstr ""

msgid "1493            // ..."
msgstr ""

msgid "1494            // ... no data members ..."
msgstr ""

msgid "1495            // ..."
msgstr ""

msgid "1496            virtual ~Shape() = default;"
msgstr ""

msgid "1497        };"
msgstr ""

msgid "1498    ##### Enforcement"
msgstr ""

msgid ""
"1499    (Simple) Warn if a pointer/reference to a class `C` is assigned to a "
"pointer/reference to a base of `C` and the base class contains data members."
msgstr ""

msgid ""
"1500    ### <a name=\"Ri-abi\"></a>I.26: If you want a cross-compiler ABI, "
"use a C-style subset"
msgstr ""

msgid "1501    ##### Reason"
msgstr ""

msgid ""
"1502    Different compilers implement different binary layouts for classes, "
"exception handling, function names, and other implementation details."
msgstr ""

msgid "1503    ##### Exception"
msgstr ""

msgid ""
"1504    You can carefully craft an interface using a few carefully selected "
"higher-level C++ types. See ???."
msgstr ""

msgid "1505    ##### Exception"
msgstr ""

msgid ""
"1506    Common ABIs are emerging on some platforms freeing you from the more "
"draconian restrictions."
msgstr ""

msgid "1507    ##### Note"
msgstr ""

msgid ""
"1508    If you use a single compiler, you can use full C++ in interfaces. "
"That may require recompilation after an upgrade to a new compiler version."
msgstr ""

msgid "1509    ##### Enforcement"
msgstr ""

msgid ""
"1510    (Not enforceable) It is difficult to reliably identify where an "
"interface forms part of an ABI."
msgstr ""

msgid ""
"1511    ### <a name=\"Ri-pimpl\"></a>I.27: For stable library ABI, consider "
"the Pimpl idiom"
msgstr ""

msgid "1512    ##### Reason"
msgstr ""

msgid ""
"1513    Because private data members participate in class layout and private "
"member functions participate in overload resolution, changes to those"
msgstr ""

msgid ""
"1514    implementation details require recompilation of all users of a class "
"that uses them. A non-polymorphic interface class holding a pointer to"
msgstr ""

msgid ""
"1515    implementation (Pimpl) can isolate the users of a class from changes "
"in its implementation at the cost of an indirection."
msgstr ""

msgid "1516    ##### Example"
msgstr ""

msgid "1517    interface (widget.h)"
msgstr ""

msgid "1518        class widget {"
msgstr ""

msgid "1519            class impl;"
msgstr ""

msgid "1520            std::unique_ptr<impl> pimpl;"
msgstr ""

msgid "1521        public:"
msgstr ""

msgid ""
"1522            void draw(); // public API that will be forwarded to the "
"implementation"
msgstr ""

msgid "1523            widget(int); // defined in the implementation file"
msgstr ""

msgid ""
"1524            ~widget();   // defined in the implementation file, where "
"impl is a complete type"
msgstr ""

msgid "1525            widget(widget&&) = default;"
msgstr ""

msgid "1526            widget(const widget&) = delete;"
msgstr ""

msgid ""
"1527            widget& operator=(widget&&); // defined in the "
"implementation file"
msgstr ""

msgid "1528            widget& operator=(const widget&) = delete;"
msgstr ""

msgid "1529        };"
msgstr ""

msgid "1530    implementation (widget.cpp)"
msgstr ""

msgid "1531        class widget::impl {"
msgstr ""

msgid "1532            int n; // private data"
msgstr ""

msgid "1533        public:"
msgstr ""

msgid "1534            void draw(const widget& w) { /* ... */ }"
msgstr ""

msgid "1535            impl(int n) : n(n) {}"
msgstr ""

msgid "1536        };"
msgstr ""

msgid "1537        void widget::draw() { pimpl->draw(*this); }"
msgstr ""

msgid ""
"1538        widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}"
msgstr ""

msgid "1539        widget::~widget() = default;"
msgstr ""

msgid "1540        widget& widget::operator=(widget&&) = default;"
msgstr ""

msgid "1541    ##### Notes"
msgstr ""

msgid ""
"1542    See [GOTW #100](https://herbsutter.com/gotw/_100/) and "
"[cppreference](http://en.cppreference.com/w/cpp/language/pimpl) for the "
"trade-offs and additional implementation details associated with this idiom."
msgstr ""

msgid "1543    ##### Enforcement"
msgstr ""

msgid ""
"1544    (Not enforceable) It is difficult to reliably identify where an "
"interface forms part of an ABI."
msgstr ""

msgid ""
"1545    ### <a name=\"Ri-encapsulate\"></a>I.30: Encapsulate rule violations"
msgstr ""

msgid "1546    ##### Reason"
msgstr ""

msgid "1547    To keep code simple and safe."
msgstr ""

msgid ""
"1548    Sometimes, ugly, unsafe, or error-prone techniques are necessary for "
"logical or performance reasons."
msgstr ""

msgid ""
"1549    If so, keep them local, rather than \"infecting\" interfaces so that "
"larger groups of programmers have to be aware of the"
msgstr ""

msgid "1550    subtleties."
msgstr ""

msgid ""
"1551    Implementation complexity should, if at all possible, not leak "
"through interfaces into user code."
msgstr ""

msgid "1552    ##### Example"
msgstr ""

msgid ""
"1553    Consider a program that, depending on some form of input (e.g., "
"arguments to `main`), should consume input"
msgstr ""

msgid "1554    from a file, from the command line, or from standard input."
msgstr ""

msgid "1555    We might write"
msgstr ""

msgid "1556        bool owned;"
msgstr ""

msgid "1557        owner<istream*> inp;"
msgstr ""

msgid "1558        switch (source) {"
msgstr ""

msgid ""
"1559        case std_in:        owned = false; inp = &cin;                   "
"    break;"
msgstr ""

msgid ""
"1560        case command_line:  owned = true;  inp = new "
"istringstream{argv[2]}; break;"
msgstr ""

msgid ""
"1561        case file:          owned = true;  inp = new ifstream{argv[2]};  "
"    break;"
msgstr ""

msgid "1562        }"
msgstr ""

msgid "1563        istream& in = *inp;"
msgstr ""

msgid ""
"1564    This violated the rule [against uninitialized variables](#Res-"
"always),"
msgstr ""

msgid "1565    the rule against [ignoring ownership](#Ri-raw),"
msgstr ""

msgid "1566    and the rule [against magic constants](#Res-magic)."
msgstr ""

msgid "1567    In particular, someone has to remember to somewhere write"
msgstr ""

msgid "1568        if (owned) delete inp;"
msgstr ""

msgid ""
"1569    We could handle this particular example by using `unique_ptr` with a "
"special deleter that does nothing for `cin`,"
msgstr ""

msgid ""
"1570    but that's complicated for novices (who can easily encounter this "
"problem) and the example is an example of a more general"
msgstr ""

msgid ""
"1571    problem where a property that we would like to consider static "
"(here, ownership) needs infrequently be addressed"
msgstr ""

msgid "1572    at run time."
msgstr ""

msgid ""
"1573    The common, most frequent, and safest examples can be handled "
"statically, so we don't want to add cost and complexity to those."
msgstr ""

msgid ""
"1574    But we must also cope with the uncommon, less-safe, and necessarily "
"more expensive cases."
msgstr ""

msgid ""
"1575    Such examples are discussed in [[Str15]](http://www.stroustrup.com/"
"resource-model.pdf)."
msgstr ""

msgid "1576    So, we write a class"
msgstr ""

msgid "1577        class Istream { [[gsl::suppress(lifetime)]]"
msgstr ""

msgid "1578        public:"
msgstr ""

msgid "1579            enum Opt { from_line = 1 };"
msgstr ""

msgid "1580            Istream() { }"
msgstr ""

msgid ""
"1581            Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}     "
"       // read from file"
msgstr ""

msgid ""
"1582            Istream(zstring p, Opt) :owned{true}, inp{new "
"istringstream{p}} {}  // read from command line"
msgstr ""

msgid "1583            ~Istream() { if (owned) delete inp; }"
msgstr ""

msgid "1584            operator istream& () { return *inp; }"
msgstr ""

msgid "1585        private:"
msgstr ""

msgid "1586            bool owned = false;"
msgstr ""

msgid "1587            istream* inp = &cin;"
msgstr ""

msgid "1588        };"
msgstr ""

msgid ""
"1589    Now, the dynamic nature of `istream` ownership has been encapsulated."
""
msgstr ""

msgid ""
"1590    Presumably, a bit of checking for potential errors would be added in "
"real code."
msgstr ""

msgid "1591    ##### Enforcement"
msgstr ""

msgid ""
"1592    * Hard, it is hard to decide what rule-breaking code is essential"
msgstr ""

msgid ""
"1593    * Flag rule suppression that enable rule-violations to cross "
"interfaces"
msgstr ""

msgid "1594    # <a name=\"S-functions\"></a>F: Functions"
msgstr ""

msgid ""
"1595    A function specifies an action or a computation that takes the "
"system from one consistent state to the next. It is the fundamental building "
"block of programs."
msgstr ""

msgid ""
"1596    It should be possible to name a function meaningfully, to specify "
"the requirements of its argument, and clearly state the relationship between "
"the arguments and the result. An implementation is not a specification. Try "
"to think about what a function does as well as about how it does it."
msgstr ""

msgid ""
"1597    Functions are the most critical part in most interfaces, so see the "
"interface rules."
msgstr ""

msgid "1598    Function rule summary:"
msgstr ""

msgid "1599    Function definition rules:"
msgstr ""

msgid ""
"1600    * [F.1: \"Package\" meaningful operations as carefully named "
"functions](#Rf-package)"
msgstr ""

msgid ""
"1601    * [F.2: A function should perform a single logical operation](#Rf-"
"logical)"
msgstr ""

msgid "1602    * [F.3: Keep functions short and simple](#Rf-single)"
msgstr ""

msgid ""
"1603    * [F.4: If a function may have to be evaluated at compile time, "
"declare it `constexpr`](#Rf-constexpr)"
msgstr ""

msgid ""
"1604    * [F.5: If a function is very small and time-critical, declare it "
"inline](#Rf-inline)"
msgstr ""

msgid ""
"1605    * [F.6: If your function may not throw, declare it `noexcept`](#Rf-"
"noexcept)"
msgstr ""

msgid ""
"1606    * [F.7: For general use, take `T*` or `T&` arguments rather than "
"smart pointers](#Rf-smart)"
msgstr ""

msgid "1607    * [F.8: Prefer pure functions](#Rf-pure)"
msgstr ""

msgid "1608    * [F.9: Unused parameters should be unnamed](#Rf-unused)"
msgstr ""

msgid "1609    Parameter passing expression rules:"
msgstr ""

msgid ""
"1610    * [F.15: Prefer simple and conventional ways of passing "
"information](#Rf-conventional)"
msgstr ""

msgid ""
"1611    * [F.16: For \"in\" parameters, pass cheaply-copied types by value "
"and others by reference to `const`](#Rf-in)"
msgstr ""

msgid ""
"1612    * [F.17: For \"in-out\" parameters, pass by reference to non-"
"`const`](#Rf-inout)"
msgstr ""

msgid ""
"1613    * [F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::"
"move` the parameter](#Rf-consume)"
msgstr ""

msgid ""
"1614    * [F.19: For \"forward\" parameters, pass by `TP&&` and only `std::"
"forward` the parameter](#Rf-forward)"
msgstr ""

msgid ""
"1615    * [F.20: For \"out\" output values, prefer return values to output "
"parameters](#Rf-out)"
msgstr ""

msgid ""
"1616    * [F.21: To return multiple \"out\" values, prefer returning a "
"struct or tuple](#Rf-out-multi)"
msgstr ""

msgid ""
"1617    * [F.60: Prefer `T*` over `T&` when \"no argument\" is a valid "
"option](#Rf-ptr-ref)"
msgstr ""

msgid "1618    Parameter passing semantic rules:"
msgstr ""

msgid ""
"1619    * [F.22: Use `T*` or `owner<T*>` to designate a single object](#Rf-"
"ptr)"
msgstr ""

msgid ""
"1620    * [F.23: Use a `not_null<T>` to indicate that \"null\" is not a "
"valid value](#Rf-nullptr)"
msgstr ""

msgid ""
"1621    * [F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open "
"sequence](#Rf-range)"
msgstr ""

msgid ""
"1622    * [F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-"
"style string](#Rf-zstring)"
msgstr ""

msgid ""
"1623    * [F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer "
"is needed](#Rf-unique_ptr)"
msgstr ""

msgid ""
"1624    * [F.27: Use a `shared_ptr<T>` to share ownership](#Rf-shared_ptr)"
msgstr ""

msgid "1625    <a name=\"Rf-value-return\"></a>Value return semantic rules:"
msgstr ""

msgid ""
"1626    * [F.42: Return a `T*` to indicate a position (only)](#Rf-return-"
"ptr)"
msgstr ""

msgid ""
"1627    * [F.43: Never (directly or indirectly) return a pointer or a "
"reference to a local object](#Rf-dangle)"
msgstr ""

msgid ""
"1628    * [F.44: Return a `T&` when copy is undesirable and \"returning no "
"object\" isn't needed](#Rf-return-ref)"
msgstr ""

msgid "1629    * [F.45: Don't return a `T&&`](#Rf-return-ref-ref)"
msgstr ""

msgid "1630    * [F.46: `int` is the return type for `main()`](#Rf-main)"
msgstr ""

msgid ""
"1631    * [F.47: Return `T&` from assignment operators](#Rf-assignment-op)"
msgstr ""

msgid ""
"1632    * [F.48: Don't `return std::move(local)`](#Rf-return-move-local)"
msgstr ""

msgid "1633    Other function rules:"
msgstr ""

msgid ""
"1634    * [F.50: Use a lambda when a function won't do (to capture local "
"variables, or to write a local function)](#Rf-capture-vs-overload)"
msgstr ""

msgid ""
"1635    * [F.51: Where there is a choice, prefer default arguments over "
"overloading](#Rf-default-args)"
msgstr ""

msgid ""
"1636    * [F.52: Prefer capturing by reference in lambdas that will be used "
"locally, including passed to algorithms](#Rf-reference-capture)"
msgstr ""

msgid ""
"1637    * [F.53: Avoid capturing by reference in lambdas that will be used "
"nonlocally, including returned, stored on the heap, or passed to another "
"thread](#Rf-value-capture)"
msgstr ""

msgid ""
"1638    * [F.54: If you capture `this`, capture all variables explicitly (no "
"default capture)](#Rf-this-capture)"
msgstr ""

msgid "1639    * [F.55: Don't use `va_arg` arguments](#F-varargs)"
msgstr ""

msgid ""
"1640    Functions have strong similarities to lambdas and function objects."
msgstr ""

msgid ""
"1641    **See also**: [C.lambdas: Function objects and lambdas](#SS-lambdas)"
msgstr ""

msgid "1642    ## <a name=\"SS-fct-def\"></a>F.def: Function definitions"
msgstr ""

msgid ""
"1643    A function definition is a function declaration that also specifies "
"the function's implementation, the function body."
msgstr ""

msgid ""
"1644    ### <a name=\"Rf-package\"></a>F.1: \"Package\" meaningful "
"operations as carefully named functions"
msgstr ""

msgid "1645    ##### Reason"
msgstr ""

msgid ""
"1646    Factoring out common code makes code more readable, more likely to "
"be reused, and limit errors from complex code."
msgstr ""

msgid ""
"1647    If something is a well-specified action, separate it out from its "
"surrounding code and give it a name."
msgstr ""

msgid "1648    ##### Example, don't"
msgstr ""

msgid ""
"1649        void read_and_print(istream& is)    // read and print an int"
msgstr ""

msgid "1650        {"
msgstr ""

msgid "1651            int x;"
msgstr ""

msgid "1652            if (is >> x)"
msgstr ""

msgid "1653                cout << \"the int is \" << x << '\\n';"
msgstr ""

msgid "1654            else"
msgstr ""

msgid "1655                cerr << \"no int on input\\n\";"
msgstr ""

msgid "1656        }"
msgstr ""

msgid "1657    Almost everything is wrong with `read_and_print`."
msgstr ""

msgid ""
"1658    It reads, it writes (to a fixed `ostream`), it writes error messages "
"(to a fixed `ostream`), it handles only `int`s."
msgstr ""

msgid ""
"1659    There is nothing to reuse, logically separate operations are "
"intermingled and local variables are in scope after the end of their logical "
"use."
msgstr ""

msgid ""
"1660    For a tiny example, this looks OK, but if the input operation, the "
"output operation, and the error handling had been more complicated the "
"tangled"
msgstr ""

msgid "1661    mess could become hard to understand."
msgstr ""

msgid "1662    ##### Note"
msgstr ""

msgid ""
"1663    If you write a non-trivial lambda that potentially can be used in "
"more than one place, give it a name by assigning it to a (usually non-local) "
"variable."
msgstr ""

msgid "1664    ##### Example"
msgstr ""

msgid ""
"1665        sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x."
"value() < y.value(); });"
msgstr ""

msgid ""
"1666    Naming that lambda breaks up the expression into its logical parts "
"and provides a strong hint to the meaning of the lambda."
msgstr ""

msgid ""
"1667        auto lessT = [](T x, T y) { return x.rank() < y.rank() && x."
"value() < y.value(); };"
msgstr ""

msgid "1668        sort(a, b, lessT);"
msgstr ""

msgid "1669        find_if(a, b, lessT);"
msgstr ""

msgid ""
"1670    The shortest code is not always the best for performance or "
"maintainability."
msgstr ""

msgid "1671    ##### Exception"
msgstr ""

msgid ""
"1672    Loop bodies, including lambdas used as loop bodies, rarely need to "
"be named."
msgstr ""

msgid ""
"1673    However, large loop bodies (e.g., dozens of lines or dozens of "
"pages) can be a problem."
msgstr ""

msgid ""
"1674    The rule [Keep functions short and simple](#Rf-single) implies "
"\"Keep loop bodies short.\""
msgstr ""

msgid ""
"1675    Similarly, lambdas used as callback arguments are sometimes non-"
"trivial, yet unlikely to be reusable."
msgstr ""

msgid "1676    ##### Enforcement"
msgstr ""

msgid "1677    * See [Keep functions short and simple](#Rf-single)"
msgstr ""

msgid ""
"1678    * Flag identical and very similar lambdas used in different places."
msgstr ""

msgid ""
"1679    ### <a name=\"Rf-logical\"></a>F.2: A function should perform a "
"single logical operation"
msgstr ""

msgid "1680    ##### Reason"
msgstr ""

msgid ""
"1681    A function that performs a single operation is simpler to "
"understand, test, and reuse."
msgstr ""

msgid "1682    ##### Example"
msgstr ""

msgid "1683    Consider:"
msgstr ""

msgid "1684        void read_and_print()    // bad"
msgstr ""

msgid "1685        {"
msgstr ""

msgid "1686            int x;"
msgstr ""

msgid "1687            cin >> x;"
msgstr ""

msgid "1688            // check for errors"
msgstr ""

msgid "1689            cout << x << \"\\n\";"
msgstr ""

msgid "1690        }"
msgstr ""

msgid ""
"1691    This is a monolith that is tied to a specific input and will never "
"find another (different) use. Instead, break functions up into suitable "
"logical parts and parameterize:"
msgstr ""

msgid "1692        int read(istream& is)    // better"
msgstr ""

msgid "1693        {"
msgstr ""

msgid "1694            int x;"
msgstr ""

msgid "1695            is >> x;"
msgstr ""

msgid "1696            // check for errors"
msgstr ""

msgid "1697            return x;"
msgstr ""

msgid "1698        }"
msgstr ""

msgid "1699        void print(ostream& os, int x)"
msgstr ""

msgid "1700        {"
msgstr ""

msgid "1701            os << x << \"\\n\";"
msgstr ""

msgid "1702        }"
msgstr ""

msgid "1703    These can now be combined where needed:"
msgstr ""

msgid "1704        void read_and_print()"
msgstr ""

msgid "1705        {"
msgstr ""

msgid "1706            auto x = read(cin);"
msgstr ""

msgid "1707            print(cout, x);"
msgstr ""

msgid "1708        }"
msgstr ""

msgid ""
"1709    If there was a need, we could further templatize `read()` and "
"`print()` on the data type, the I/O mechanism, the response to errors, etc. "
"Example:"
msgstr ""

msgid "1710        auto read = [](auto& input, auto& value)    // better"
msgstr ""

msgid "1711        {"
msgstr ""

msgid "1712            input >> value;"
msgstr ""

msgid "1713            // check for errors"
msgstr ""

msgid "1714        };"
msgstr ""

msgid "1715        auto print(auto& output, const auto& value)"
msgstr ""

msgid "1716        {"
msgstr ""

msgid "1717            output << value << \"\\n\";"
msgstr ""

msgid "1718        }"
msgstr ""

msgid "1719    ##### Enforcement"
msgstr ""

msgid ""
"1720    * Consider functions with more than one \"out\" parameter suspicious."
" Use return values instead, including `tuple` for multiple return values."
msgstr ""

msgid ""
"1721    * Consider \"large\" functions that don't fit on one editor screen "
"suspicious. Consider factoring such a function into smaller well-named "
"suboperations."
msgstr ""

msgid "1722    * Consider functions with 7 or more parameters suspicious."
msgstr ""

msgid ""
"1723    ### <a name=\"Rf-single\"></a>F.3: Keep functions short and simple"
msgstr ""

msgid "1724    ##### Reason"
msgstr ""

msgid ""
"1725    Large functions are hard to read, more likely to contain complex "
"code, and more likely to have variables in larger than minimal scopes."
msgstr ""

msgid ""
"1726    Functions with complex control structures are more likely to be long "
"and more likely to hide logical errors"
msgstr ""

msgid "1727    ##### Example"
msgstr ""

msgid "1728    Consider:"
msgstr ""

msgid "1729        double simple_func(double val, int flag1, int flag2)"
msgstr ""

msgid ""
"1730            // simple_func: takes a value and calculates the expected "
"ASIC output,"
msgstr ""

msgid "1731            // given the two mode flags."
msgstr ""

msgid "1732        {"
msgstr ""

msgid "1733            double intermediate;"
msgstr ""

msgid "1734            if (flag1 > 0) {"
msgstr ""

msgid "1735                intermediate = func1(val);"
msgstr ""

msgid "1736                if (flag2 % 2)"
msgstr ""

msgid "1737                     intermediate = sqrt(intermediate);"
msgstr ""

msgid "1738            }"
msgstr ""

msgid "1739            else if (flag1 == -1) {"
msgstr ""

msgid "1740                intermediate = func1(-val);"
msgstr ""

msgid "1741                if (flag2 % 2)"
msgstr ""

msgid "1742                     intermediate = sqrt(-intermediate);"
msgstr ""

msgid "1743                flag1 = -flag1;"
msgstr ""

msgid "1744            }"
msgstr ""

msgid "1745            if (abs(flag2) > 10) {"
msgstr ""

msgid "1746                intermediate = func2(intermediate);"
msgstr ""

msgid "1747            }"
msgstr ""

msgid "1748            switch (flag2 / 10) {"
msgstr ""

msgid ""
"1749            case 1: if (flag1 == -1) return finalize(intermediate, 1."
"171);"
msgstr ""

msgid "1750                    break;"
msgstr ""

msgid "1751            case 2: return finalize(intermediate, 13.1);"
msgstr ""

msgid "1752            default: break;"
msgstr ""

msgid "1753            }"
msgstr ""

msgid "1754            return finalize(intermediate, 0.);"
msgstr ""

msgid "1755        }"
msgstr ""

msgid "1756    This is too complex (and long)."
msgstr ""

msgid ""
"1757    How would you know if all possible alternatives have been correctly "
"handled?"
msgstr ""

msgid "1758    Yes, it breaks other rules also."
msgstr ""

msgid "1759    We can refactor:"
msgstr ""

msgid "1760        double func1_muon(double val, int flag)"
msgstr ""

msgid "1761        {"
msgstr ""

msgid "1762            // ???"
msgstr ""

msgid "1763        }"
msgstr ""

msgid "1764        double funct1_tau(double val, int flag1, int flag2)"
msgstr ""

msgid "1765        {"
msgstr ""

msgid "1766            // ???"
msgstr ""

msgid "1767        }"
msgstr ""

msgid "1768        double simple_func(double val, int flag1, int flag2)"
msgstr ""

msgid ""
"1769            // simple_func: takes a value and calculates the expected "
"ASIC output,"
msgstr ""

msgid "1770            // given the two mode flags."
msgstr ""

msgid "1771        {"
msgstr ""

msgid "1772            if (flag1 > 0)"
msgstr ""

msgid "1773                return func1_muon(val, flag2);"
msgstr ""

msgid "1774            if (flag1 == -1)"
msgstr ""

msgid "1775                // handled by func1_tau: flag1 = -flag1;"
msgstr ""

msgid "1776                return func1_tau(-val, flag1, flag2);"
msgstr ""

msgid "1777            return 0.;"
msgstr ""

msgid "1778        }"
msgstr ""

msgid "1779    ##### Note"
msgstr ""

msgid ""
"1780    \"It doesn't fit on a screen\" is often a good practical definition "
"of \"far too large.\""
msgstr ""

msgid "1781    One-to-five-line functions should be considered normal."
msgstr ""

msgid "1782    ##### Note"
msgstr ""

msgid ""
"1783    Break large functions up into smaller cohesive and named functions."
msgstr ""

msgid ""
"1784    Small simple functions are easily inlined where the cost of a "
"function call is significant."
msgstr ""

msgid "1785    ##### Enforcement"
msgstr ""

msgid "1786    * Flag functions that do not \"fit on a screen.\""
msgstr ""

msgid ""
"1787      How big is a screen? Try 60 lines by 140 characters; that's "
"roughly the maximum that's comfortable for a book page."
msgstr ""

msgid ""
"1788    * Flag functions that are too complex. How complex is too complex?"
msgstr ""

msgid ""
"1789      You could use cyclomatic complexity. Try \"more than 10 logical "
"path through.\" Count a simple switch as one path."
msgstr ""

msgid ""
"1790    ### <a name=\"Rf-constexpr\"></a>F.4: If a function may have to be "
"evaluated at compile time, declare it `constexpr`"
msgstr ""

msgid "1791    ##### Reason"
msgstr ""

msgid ""
"1792     `constexpr` is needed to tell the compiler to allow compile-time "
"evaluation."
msgstr ""

msgid "1793    ##### Example"
msgstr ""

msgid "1794    The (in)famous factorial:"
msgstr ""

msgid "1795        constexpr int fac(int n)"
msgstr ""

msgid "1796        {"
msgstr ""

msgid ""
"1797            constexpr int max_exp = 17;      // constexpr enables "
"max_exp to be used in Expects"
msgstr ""

msgid ""
"1798            Expects(0 <= n && n < max_exp);  // prevent silliness and "
"overflow"
msgstr ""

msgid "1799            int x = 1;"
msgstr ""

msgid "1800            for (int i = 2; i <= n; ++i) x *= i;"
msgstr ""

msgid "1801            return x;"
msgstr ""

msgid "1802        }"
msgstr ""

msgid "1803    This is C++14."
msgstr ""

msgid "1804    For C++11, use a recursive formulation of `fac()`."
msgstr ""

msgid "1805    ##### Note"
msgstr ""

msgid "1806    `constexpr` does not guarantee compile-time evaluation;"
msgstr ""

msgid ""
"1807    it just guarantees that the function can be evaluated at compile "
"time for constant expression arguments if the programmer requires it or the "
"compiler decides to do so to optimize."
msgstr ""

msgid "1808        constexpr int min(int x, int y) { return x < y ? x : y; }"
msgstr ""

msgid "1809        void test(int v)"
msgstr ""

msgid "1810        {"
msgstr ""

msgid ""
"1811            int m1 = min(-1, 2);            // probably compile-time "
"evaluation"
msgstr ""

msgid ""
"1812            constexpr int m2 = min(-1, 2);  // compile-time evaluation"
msgstr ""

msgid "1813            int m3 = min(-1, v);            // run-time evaluation"
msgstr ""

msgid ""
"1814            constexpr int m4 = min(-1, v);  // error: cannot evaluate at "
"compile time"
msgstr ""

msgid "1815        }"
msgstr ""

msgid "1816    ##### Note"
msgstr ""

msgid "1817    `constexpr` functions are pure: they can have no side effects."
msgstr ""

msgid "1818        int dcount = 0;"
msgstr ""

msgid "1819        constexpr int double(int v)"
msgstr ""

msgid "1820        {"
msgstr ""

msgid ""
"1821            ++dcount;   // error: attempted side effect from constexpr "
"function"
msgstr ""

msgid "1822            return v + v;"
msgstr ""

msgid "1823        }"
msgstr ""

msgid "1824    This is usually a very good thing."
msgstr ""

msgid ""
"1825    When given a non-constant argument, a `constexpr` function can throw."
""
msgstr ""

msgid ""
"1826    If you consider exiting by throwing a side effect, a `constexpr` "
"function isn't completely pure;"
msgstr ""

msgid "1827    if not, this is not an issue."
msgstr ""

msgid ""
"1828    ??? A question for the committee: can a constructor for an exception "
"thrown by a `constexpr` function modify state?"
msgstr ""

msgid "1829    \"No\" would be a nice answer that matches most practice."
msgstr ""

msgid "1830    ##### Note"
msgstr ""

msgid "1831    Don't try to make all functions `constexpr`."
msgstr ""

msgid "1832    Most computation is best done at run time."
msgstr ""

msgid "1833    ##### Note"
msgstr ""

msgid ""
"1834    Any API that may eventually depend on high-level run-time "
"configuration or"
msgstr ""

msgid ""
"1835    business logic should not be made `constexpr`. Such customization "
"can not be"
msgstr ""

msgid ""
"1836    evaluated by the compiler, and any `constexpr` functions that "
"depended upon"
msgstr ""

msgid "1837    that API would have to be refactored or drop `constexpr`."
msgstr ""

msgid "1838    ##### Enforcement"
msgstr ""

msgid "1839    Impossible and unnecessary."
msgstr ""

msgid ""
"1840    The compiler gives an error if a non-`constexpr` function is called "
"where a constant is required."
msgstr ""

msgid ""
"1841    ### <a name=\"Rf-inline\"></a>F.5: If a function is very small and "
"time-critical, declare it `inline`"
msgstr ""

msgid "1842    ##### Reason"
msgstr ""

msgid ""
"1843    Some optimizers are good at inlining without hints from the "
"programmer, but don't rely on it."
msgstr ""

msgid ""
"1844    Measure! Over the last 40 years or so, we have been promised "
"compilers that can inline better than humans without hints from humans."
msgstr ""

msgid "1845    We are still waiting."
msgstr ""

msgid ""
"1846    Specifying `inline` encourages the compiler to do a better job."
msgstr ""

msgid "1847    ##### Example"
msgstr ""

msgid ""
"1848        inline string cat(const string& s, const string& s2) { return s "
"+ s2; }"
msgstr ""

msgid "1849    ##### Exception"
msgstr ""

msgid ""
"1850    Do not put an `inline` function in what is meant to be a stable "
"interface unless you are certain that it will not change."
msgstr ""

msgid "1851    An inline function is part of the ABI."
msgstr ""

msgid "1852    ##### Note"
msgstr ""

msgid "1853    `constexpr` implies `inline`."
msgstr ""

msgid "1854    ##### Note"
msgstr ""

msgid "1855    Member functions defined in-class are `inline` by default."
msgstr ""

msgid "1856    ##### Exception"
msgstr ""

msgid ""
"1857    Template functions (incl. template member functions) are normally "
"defined in headers and therefore inline."
msgstr ""

msgid "1858    ##### Enforcement"
msgstr ""

msgid ""
"1859    Flag `inline` functions that are more than three statements and "
"could have been declared out of line (such as class member functions)."
msgstr ""

msgid ""
"1860    ### <a name=\"Rf-noexcept\"></a>F.6: If your function may not throw, "
"declare it `noexcept`"
msgstr ""

msgid "1861    ##### Reason"
msgstr ""

msgid ""
"1862    If an exception is not supposed to be thrown, the program cannot be "
"assumed to cope with the error and should be terminated as soon as possible. "
"Declaring a function `noexcept` helps optimizers by reducing the number of "
"alternative execution paths. It also speeds up the exit after failure."
msgstr ""

msgid "1863    ##### Example"
msgstr ""

msgid ""
"1864    Put `noexcept` on every function written completely in C or in any "
"other language without exceptions."
msgstr ""

msgid ""
"1865    The C++ Standard Library does that implicitly for all functions in "
"the C Standard Library."
msgstr ""

msgid "1866    ##### Note"
msgstr ""

msgid ""
"1867    `constexpr` functions can throw when evaluated at run time, so you "
"may need `noexcept` for some of those."
msgstr ""

msgid "1868    ##### Example"
msgstr ""

msgid "1869    You can use `noexcept` even on functions that can throw:"
msgstr ""

msgid "1870        vector<string> collect(istream& is) noexcept"
msgstr ""

msgid "1871        {"
msgstr ""

msgid "1872            vector<string> res;"
msgstr ""

msgid "1873            for (string s; is >> s;)"
msgstr ""

msgid "1874                res.push_back(s);"
msgstr ""

msgid "1875            return res;"
msgstr ""

msgid "1876        }"
msgstr ""

msgid "1877    If `collect()` runs out of memory, the program crashes."
msgstr ""

msgid ""
"1878    Unless the program is crafted to survive memory exhaustion, that may "
"be just the right thing to do;"
msgstr ""

msgid ""
"1879    `terminate()` may generate suitable error log information (but after "
"memory runs out it is hard to do anything clever)."
msgstr ""

msgid "1880    ##### Note"
msgstr ""

msgid ""
"1881    You must be aware of the execution environment that your code is "
"running when"
msgstr ""

msgid ""
"1882    deciding whether to tag a function `noexcept`, especially because of "
"the issue"
msgstr ""

msgid ""
"1883    of throwing and allocation.  Code that is intended to be perfectly "
"general (like"
msgstr ""

msgid ""
"1884    the standard library and other utility code of that sort) needs to "
"support"
msgstr ""

msgid ""
"1885    environments where a `bad_alloc` exception may be handled "
"meaningfully."
msgstr ""

msgid ""
"1886    However, most programs and execution environments cannot "
"meaningfully"
msgstr ""

msgid ""
"1887    handle a failure to allocate, and aborting the program is the "
"cleanest and"
msgstr ""

msgid ""
"1888    simplest response to an allocation failure in those cases.  If you "
"know that"
msgstr ""

msgid ""
"1889    your application code cannot respond to an allocation failure, it "
"may be"
msgstr ""

msgid "1890    appropriate to add `noexcept` even on functions that allocate."
msgstr ""

msgid ""
"1891    Put another way: In most programs, most functions can throw (e.g., "
"because they"
msgstr ""

msgid ""
"1892    use `new`, call functions that do, or use library functions that "
"reports failure"
msgstr ""

msgid ""
"1893    by throwing), so don't just sprinkle `noexcept` all over the place "
"without"
msgstr ""

msgid "1894    considering whether the possible exceptions can be handled."
msgstr ""

msgid ""
"1895    `noexcept` is most useful (and most clearly correct) for frequently "
"used,"
msgstr ""

msgid "1896    low-level functions."
msgstr ""

msgid "1897    ##### Note"
msgstr ""

msgid ""
"1898    Destructors, `swap` functions, move operations, and default "
"constructors should never throw."
msgstr ""

msgid "1899    ##### Enforcement"
msgstr ""

msgid "1900    * Flag functions that are not `noexcept`, yet cannot throw."
msgstr ""

msgid ""
"1901    * Flag throwing `swap`, `move`, destructors, and default "
"constructors."
msgstr ""

msgid ""
"1902    ### <a name=\"Rf-smart\"></a>F.7: For general use, take `T*` or `T&` "
"arguments rather than smart pointers"
msgstr ""

msgid "1903    ##### Reason"
msgstr ""

msgid ""
"1904    Passing a smart pointer transfers or shares ownership and should "
"only be used when ownership semantics are intended (see [R.30](#Rr-"
"smartptrparam))."
msgstr ""

msgid ""
"1905    Passing by smart pointer restricts the use of a function to callers "
"that use smart pointers."
msgstr ""

msgid ""
"1906    Passing a shared smart pointer (e.g., `std::shared_ptr`) implies a "
"run-time cost."
msgstr ""

msgid "1907    ##### Example"
msgstr ""

msgid "1908        // accepts any int*"
msgstr ""

msgid "1909        void f(int*);"
msgstr ""

msgid ""
"1910        // can only accept ints for which you want to transfer ownership"
msgstr ""

msgid "1911        void g(unique_ptr<int>);"
msgstr ""

msgid ""
"1912        // can only accept ints for which you are willing to share "
"ownership"
msgstr ""

msgid "1913        void g(shared_ptr<int>);"
msgstr ""

msgid ""
"1914        // doesn't change ownership, but requires a particular ownership "
"of the caller"
msgstr ""

msgid "1915        void h(const unique_ptr<int>&);"
msgstr ""

msgid "1916        // accepts any int"
msgstr ""

msgid "1917        void h(int&);"
msgstr ""

msgid "1918    ##### Example, bad"
msgstr ""

msgid "1919        // callee"
msgstr ""

msgid "1920        void f(shared_ptr<widget>& w)"
msgstr ""

msgid "1921        {"
msgstr ""

msgid "1922            // ..."
msgstr ""

msgid ""
"1923            use(*w); // only use of w -- the lifetime is not used at all"
msgstr ""

msgid "1924            // ..."
msgstr ""

msgid "1925        };"
msgstr ""

msgid "1926    See further in [R.30](#Rr-smartptrparam)."
msgstr ""

msgid "1927    ##### Note"
msgstr ""

msgid ""
"1928    We can catch dangling pointers statically, so we don't need to rely "
"on resource management to avoid violations from dangling pointers."
msgstr ""

msgid "1929    **See also**:"
msgstr ""

msgid ""
"1930    * [Prefer `T*` over `T&` when \"no argument\" is a valid option](#Rf-"
"ptr-ref)"
msgstr ""

msgid "1931    * [Smart pointer rule summary](#Rr-summary-smartptrs)"
msgstr ""

msgid "1932    ##### Enforcement"
msgstr ""

msgid ""
"1933    Flag a parameter of a smart pointer type (a type that overloads "
"`operator->` or `operator*`) for which the ownership semantics are not used;"
msgstr ""

msgid "1934    that is"
msgstr ""

msgid ""
"1935    * copyable but never copied/moved from or movable but never moved"
msgstr ""

msgid ""
"1936    * and that is never modified or passed along to another function "
"that could do so."
msgstr ""

msgid "1937    ### <a name=\"Rf-pure\"></a>F.8: Prefer pure functions"
msgstr ""

msgid "1938    ##### Reason"
msgstr ""

msgid ""
"1939    Pure functions are easier to reason about, sometimes easier to "
"optimize (and even parallelize), and sometimes can be memoized."
msgstr ""

msgid "1940    ##### Example"
msgstr ""

msgid "1941        template<class T>"
msgstr ""

msgid "1942        auto square(T t) { return t * t; }"
msgstr ""

msgid "1943    ##### Note"
msgstr ""

msgid "1944    `constexpr` functions are pure."
msgstr ""

msgid ""
"1945    When given a non-constant argument, a `constexpr` function can throw."
""
msgstr ""

msgid ""
"1946    If you consider exiting by throwing a side effect, a `constexpr` "
"function isn't completely pure;"
msgstr ""

msgid "1947    if not, this is not an issue."
msgstr ""

msgid ""
"1948    ??? A question for the committee: can a constructor for an exception "
"thrown by a `constexpr` function modify state?"
msgstr ""

msgid "1949    \"No\" would be a nice answer that matches most practice."
msgstr ""

msgid "1950    ##### Enforcement"
msgstr ""

msgid "1951    Not possible."
msgstr ""

msgid ""
"1952    ### <a name=\"Rf-unused\"></a>F.9: Unused parameters should be "
"unnamed"
msgstr ""

msgid "1953    ##### Reason"
msgstr ""

msgid "1954    Readability."
msgstr ""

msgid "1955    Suppression of unused parameter warnings."
msgstr ""

msgid "1956    ##### Example"
msgstr ""

msgid ""
"1957        X* find(map<Blob>& m, const string& s, Hint);   // once upon a "
"time, a hint was used"
msgstr ""

msgid "1958    ##### Note"
msgstr ""

msgid ""
"1959    Allowing parameters to be unnamed was introduced in the early 1980 "
"to address this problem."
msgstr ""

msgid "1960    ##### Enforcement"
msgstr ""

msgid "1961    Flag named unused parameters."
msgstr ""

msgid "1962    ## <a name=\"SS-call\"></a>F.call: Parameter passing"
msgstr ""

msgid ""
"1963    There are a variety of ways to pass parameters to a function and to "
"return values."
msgstr ""

msgid ""
"1964    ### <a name=\"Rf-conventional\"></a>F.15: Prefer simple and "
"conventional ways of passing information"
msgstr ""

msgid "1965    ##### Reason"
msgstr ""

msgid ""
"1966    Using \"unusual and clever\" techniques causes surprises, slows "
"understanding by other programmers, and encourages bugs."
msgstr ""

msgid ""
"1967    If you really feel the need for an optimization beyond the common "
"techniques, measure to ensure that it really is an improvement, and document/"
"comment because the improvement may not be portable."
msgstr ""

msgid ""
"1968    The following tables summarize the advice in the following "
"Guidelines, F.16-21."
msgstr ""

msgid "1969    Normal parameter passing:"
msgstr ""

msgid ""
"1970    ![Normal parameter passing table](./param-passing-normal.png "
"\"Normal parameter passing\")"
msgstr ""

msgid "1971    Advanced parameter passing:"
msgstr ""

msgid ""
"1972    ![Advanced parameter passing table](./param-passing-advanced.png "
"\"Advanced parameter passing\")"
msgstr ""

msgid ""
"1973    Use the advanced techniques only after demonstrating need, and "
"document that need in a comment."
msgstr ""

msgid ""
"1974    ### <a name=\"Rf-in\"></a>F.16: For \"in\" parameters, pass cheaply-"
"copied types by value and others by reference to `const`"
msgstr ""

msgid "1975    ##### Reason"
msgstr ""

msgid ""
"1976    Both let the caller know that a function will not modify the "
"argument, and both allow initialization by rvalues."
msgstr ""

msgid ""
"1977    What is \"cheap to copy\" depends on the machine architecture, but "
"two or three words (doubles, pointers, references) are usually best passed "
"by value."
msgstr ""

msgid ""
"1978    When copying is cheap, nothing beats the simplicity and safety of "
"copying, and for small objects (up to two or three words) it is also faster "
"than passing by reference because it does not require an extra indirection "
"to access from the function."
msgstr ""

msgid "1979    ##### Example"
msgstr ""

msgid ""
"1980        void f1(const string& s);  // OK: pass by reference to const; "
"always cheap"
msgstr ""

msgid "1981        void f2(string s);         // bad: potentially expensive"
msgstr ""

msgid "1982        void f3(int x);            // OK: Unbeatable"
msgstr ""

msgid ""
"1983        void f4(const int& x);     // bad: overhead on access in f4()"
msgstr ""

msgid ""
"1984    For advanced uses (only), where you really need to optimize for "
"rvalues passed to \"input-only\" parameters:"
msgstr ""

msgid ""
"1985    * If the function is going to unconditionally move from the "
"argument, take it by `&&`. See [F.18](#Rf-consume)."
msgstr ""

msgid ""
"1986    * If the function is going to keep a copy of the argument, in "
"addition to passing by `const&` (for lvalues),"
msgstr ""

msgid ""
"1987      add an overload that passes the parameter by `&&` (for rvalues) "
"and in the body `std::move`s it to its destination. Essentially this "
"overloads a \"will-move-from\"; see [F.18](#Rf-consume)."
msgstr ""

msgid ""
"1988    * In special cases, such as multiple \"input + copy\" parameters, "
"consider using perfect forwarding. See [F.19](#Rf-forward)."
msgstr ""

msgid "1989    ##### Example"
msgstr ""

msgid "1990        int multiply(int, int); // just input ints, pass by value"
msgstr ""

msgid ""
"1991        // suffix is input-only but not as cheap as an int, pass by "
"const&"
msgstr ""

msgid "1992        string& concatenate(string&, const string& suffix);"
msgstr ""

msgid ""
"1993        void sink(unique_ptr<widget>);  // input only, and moves "
"ownership of the widget"
msgstr ""

msgid "1994    Avoid \"esoteric techniques\" such as:"
msgstr ""

msgid "1995    * Passing arguments as `T&&` \"for efficiency\"."
msgstr ""

msgid ""
"1996      Most rumors about performance advantages from passing by `&&` are "
"false or brittle (but see [F.18](#Rf-consume) and [F.19](#Rf-forward))."
msgstr ""

msgid ""
"1997    * Returning `const T&` from assignments and similar operations (see "
"[F.47](#Rf-assignment-op).)"
msgstr ""

msgid "1998    ##### Example"
msgstr ""

msgid ""
"1999    Assuming that `Matrix` has move operations (possibly by keeping its "
"elements in a `std::vector`):"
msgstr ""

msgid "2000        Matrix operator+(const Matrix& a, const Matrix& b)"
msgstr ""

msgid "2001        {"
msgstr ""

msgid "2002            Matrix res;"
msgstr ""

msgid "2003            // ... fill res with the sum ..."
msgstr ""

msgid "2004            return res;"
msgstr ""

msgid "2005        }"
msgstr ""

msgid "2006        Matrix x = m1 + m2;  // move constructor"
msgstr ""

msgid "2007        y = m3 + m3;         // move assignment"
msgstr ""

msgid "2008    ##### Notes"
msgstr ""

msgid ""
"2009    The return value optimization doesn't handle the assignment case, "
"but the move assignment does."
msgstr ""

msgid ""
"2010    A reference may be assumed to refer to a valid object (language "
"rule)."
msgstr ""

msgid "2011    There is no (legitimate) \"null reference.\""
msgstr ""

msgid ""
"2012    If you need the notion of an optional value, use a pointer, `std::"
"optional`, or a special value used to denote \"no value.\""
msgstr ""

msgid "2013    ##### Enforcement"
msgstr ""

msgid ""
"2014    * (Simple) ((Foundation)) Warn when a parameter being passed by "
"value has a size greater than `4 * sizeof(int)`."
msgstr ""

msgid "2015      Suggest using a reference to `const` instead."
msgstr ""

msgid ""
"2016    * (Simple) ((Foundation)) Warn when a `const` parameter being passed "
"by reference has a size less than `3 * sizeof(int)`. Suggest passing by "
"value instead."
msgstr ""

msgid ""
"2017    * (Simple) ((Foundation)) Warn when a `const` parameter being passed "
"by reference is `move`d."
msgstr ""

msgid ""
"2018    ### <a name=\"Rf-inout\"></a>F.17: For \"in-out\" parameters, pass "
"by reference to non-`const`"
msgstr ""

msgid "2019    ##### Reason"
msgstr ""

msgid ""
"2020    This makes it clear to callers that the object is assumed to be "
"modified."
msgstr ""

msgid "2021    ##### Example"
msgstr ""

msgid "2022        void update(Record& r);  // assume that update writes to r"
msgstr ""

msgid "2023    ##### Note"
msgstr ""

msgid ""
"2024    A `T&` argument can pass information into a function as well as out "
"of it."
msgstr ""

msgid ""
"2025    Thus `T&` could be an in-out-parameter. That can in itself be a "
"problem and a source of errors:"
msgstr ""

msgid "2026        void f(string& s)"
msgstr ""

msgid "2027        {"
msgstr ""

msgid "2028            s = \"New York\";  // non-obvious error"
msgstr ""

msgid "2029        }"
msgstr ""

msgid "2030        void g()"
msgstr ""

msgid "2031        {"
msgstr ""

msgid "2032            string buffer = \".................................\";"
msgstr ""

msgid "2033            f(buffer);"
msgstr ""

msgid "2034            // ..."
msgstr ""

msgid "2035        }"
msgstr ""

msgid ""
"2036    Here, the writer of `g()` is supplying a buffer for `f()` to fill, "
"but `f()` simply replaces it (at a somewhat higher cost than a simple copy "
"of the characters)."
msgstr ""

msgid ""
"2037    A bad logic error can happen if the writer of `g()` incorrectly "
"assumes the size of the `buffer`."
msgstr ""

msgid "2038    ##### Enforcement"
msgstr ""

msgid ""
"2039    * (Moderate) ((Foundation)) Warn about functions regarding reference "
"to non-`const` parameters that do *not* write to them."
msgstr ""

msgid ""
"2040    * (Simple) ((Foundation)) Warn when a non-`const` parameter being "
"passed by reference is `move`d."
msgstr ""

msgid ""
"2041    ### <a name=\"Rf-consume\"></a>F.18: For \"will-move-from\" "
"parameters, pass by `X&&` and `std::move` the parameter"
msgstr ""

msgid "2042    ##### Reason"
msgstr ""

msgid ""
"2043    It's efficient and eliminates bugs at the call site: `X&&` binds to "
"rvalues, which requires an explicit `std::move` at the call site if passing "
"an lvalue."
msgstr ""

msgid "2044    ##### Example"
msgstr ""

msgid ""
"2045        void sink(vector<int>&& v) {   // sink takes ownership of "
"whatever the argument owned"
msgstr ""

msgid "2046            // usually there might be const accesses of v here"
msgstr ""

msgid "2047            store_somewhere(std::move(v));"
msgstr ""

msgid "2048            // usually no more use of v here; it is moved-from"
msgstr ""

msgid "2049        }"
msgstr ""

msgid ""
"2050    Note that the `std::move(v)` makes it possible for "
"`store_somewhere()` to leave `v` in a moved-from state."
msgstr ""

msgid "2051    [That could be dangerous](#Rc-move-semantic)."
msgstr ""

msgid "2052    ##### Exception"
msgstr ""

msgid ""
"2053    Unique owner types that are move-only and cheap-to-move, such as "
"`unique_ptr`, can also be passed by value which is simpler to write and "
"achieves the same effect. Passing by value does generate one extra (cheap) "
"move operation, but prefer simplicity and clarity first."
msgstr ""

msgid "2054    For example:"
msgstr ""

msgid "2055        template <class T>"
msgstr ""

msgid "2056        void sink(std::unique_ptr<T> p) {"
msgstr ""

msgid ""
"2057            // use p ... possibly std::move(p) onward somewhere else"
msgstr ""

msgid "2058        }   // p gets destroyed"
msgstr ""

msgid "2059    ##### Enforcement"
msgstr ""

msgid ""
"2060    * Flag all `X&&` parameters (where `X` is not a template type "
"parameter name) where the function body uses them without `std::move`."
msgstr ""

msgid "2061    * Flag access to moved-from objects."
msgstr ""

msgid "2062    * Don't conditionally move from objects"
msgstr ""

msgid ""
"2063    ### <a name=\"Rf-forward\"></a>F.19: For \"forward\" parameters, "
"pass by `TP&&` and only `std::forward` the parameter"
msgstr ""

msgid "2064    ##### Reason"
msgstr ""

msgid ""
"2065    If the object is to be passed onward to other code and not directly "
"used by this function, we want to make this function agnostic to the "
"argument `const`-ness and rvalue-ness."
msgstr ""

msgid ""
"2066    In that case, and only that case, make the parameter `TP&&` where "
"`TP` is a template type parameter -- it both *ignores* and *preserves* "
"`const`-ness and rvalue-ness. Therefore any code that uses a `TP&&` is "
"implicitly declaring that it itself doesn't care about the variable's "
"`const`-ness and rvalue-ness (because it is ignored), but that intends to "
"pass the value onward to other code that does care about `const`-ness and "
"rvalue-ness (because it is preserved). When used as a parameter `TP&&` is "
"safe because any temporary objects passed from the caller will live for the "
"duration of the function call. A parameter of type `TP&&` should essentially "
"always be passed onward via `std::forward` in the body of the function."
msgstr ""

msgid "2067    ##### Example"
msgstr ""

msgid "2068        template <class F, class... Args>"
msgstr ""

msgid "2069        inline auto invoke(F f, Args&&... args) {"
msgstr ""

msgid "2070            return f(forward<Args>(args)...);"
msgstr ""

msgid "2071        }"
msgstr ""

msgid "2072        ??? calls ???"
msgstr ""

msgid "2073    ##### Enforcement"
msgstr ""

msgid ""
"2074    * Flag a function that takes a `TP&&` parameter (where `TP` is a "
"template type parameter name) and does anything with it other than `std::"
"forward`ing it exactly once on every static path."
msgstr ""

msgid ""
"2075    ### <a name=\"Rf-out\"></a>F.20: For \"out\" output values, prefer "
"return values to output parameters"
msgstr ""

msgid "2076    ##### Reason"
msgstr ""

msgid ""
"2077    A return value is self-documenting, whereas a `&` could be either in-"
"out or out-only and is liable to be misused."
msgstr ""

msgid ""
"2078    This includes large objects like standard containers that use "
"implicit move operations for performance and to avoid explicit memory "
"management."
msgstr ""

msgid ""
"2079    If you have multiple values to return, [use a tuple](#Rf-out-multi) "
"or similar multi-member type."
msgstr ""

msgid "2080    ##### Example"
msgstr ""

msgid "2081        // OK: return pointers to elements with the value x"
msgstr ""

msgid "2082        vector<const int*> find_all(const vector<int>&, int x);"
msgstr ""

msgid "2083        // Bad: place pointers to elements with value x in-out"
msgstr ""

msgid ""
"2084        void find_all(const vector<int>&, vector<const int*>& out, int "
"x);"
msgstr ""

msgid "2085    ##### Note"
msgstr ""

msgid ""
"2086    A `struct` of many (individually cheap-to-move) elements may be in "
"aggregate expensive to move."
msgstr ""

msgid "2087    It is not recommended to return a `const` value."
msgstr ""

msgid ""
"2088    Such older advice is now obsolete; it does not add value, and it "
"interferes with move semantics."
msgstr ""

msgid ""
"2089        const vector<int> fct();    // bad: that \"const\" is more "
"trouble than it is worth"
msgstr ""

msgid "2090        vector<int> g(const vector<int>& vx)"
msgstr ""

msgid "2091        {"
msgstr ""

msgid "2092            // ..."
msgstr ""

msgid "2093            fct() = vx;   // prevented by the \"const\""
msgstr ""

msgid "2094            // ..."
msgstr ""

msgid ""
"2095            return fct(); // expensive copy: move semantics suppressed "
"by the \"const\""
msgstr ""

msgid "2096        }"
msgstr ""

msgid ""
"2097    The argument for adding `const` to a return value is that it "
"prevents (very rare) accidental access to a temporary."
msgstr ""

msgid ""
"2098    The argument against is prevents (very frequent) use of move "
"semantics."
msgstr ""

msgid "2099    ##### Exceptions"
msgstr ""

msgid ""
"2100    * For non-value types, such as types in an inheritance hierarchy, "
"return the object by `unique_ptr` or `shared_ptr`."
msgstr ""

msgid ""
"2101    * If a type is expensive to move (e.g., `array<BigPOD>`), consider "
"allocating it on the free store and return a handle (e.g., `unique_ptr`), or "
"passing it in a reference to non-`const` target object to fill (to be used "
"as an out-parameter)."
msgstr ""

msgid ""
"2102    * To reuse an object that carries capacity (e.g., `std::string`, "
"`std::vector`) across multiple calls to the function in an inner loop: "
"[treat it as an in/out parameter and pass by reference](#Rf-out-multi)."
msgstr ""

msgid "2103    ##### Example"
msgstr ""

msgid ""
"2104        struct Package {      // exceptional case: expensive-to-move "
"object"
msgstr ""

msgid "2105            char header[16];"
msgstr ""

msgid "2106            char load[2024 - 16];"
msgstr ""

msgid "2107        };"
msgstr ""

msgid "2108        Package fill();       // Bad: large return value"
msgstr ""

msgid "2109        void fill(Package&);  // OK"
msgstr ""

msgid "2110        int val();            // OK"
msgstr ""

msgid "2111        void val(int&);       // Bad: Is val reading its argument"
msgstr ""

msgid "2112    ##### Enforcement"
msgstr ""

msgid ""
"2113    * Flag reference to non-`const` parameters that are not read before "
"being written to and are a type that could be cheaply returned; they should "
"be \"out\" return values."
msgstr ""

msgid ""
"2114    * Flag returning a `const` value. To fix: Remove `const` to return a "
"non-`const` value instead."
msgstr ""

msgid ""
"2115    ### <a name=\"Rf-out-multi\"></a>F.21: To return multiple \"out\" "
"values, prefer returning a struct or tuple"
msgstr ""

msgid "2116    ##### Reason"
msgstr ""

msgid "2117    A return value is self-documenting as an \"output-only\" value."
msgstr ""

msgid ""
"2118    Note that C++ does have multiple return values, by convention of "
"using a `tuple` (including `pair`),"
msgstr ""

msgid "2119    possibly with the extra convenience of `tie` at the call site."
msgstr ""

msgid ""
"2120    Prefer using a named struct where there are semantics to the "
"returned value. Otherwise, a nameless `tuple` is useful in generic code."
msgstr ""

msgid "2121    ##### Example"
msgstr ""

msgid "2122        // BAD: output-only parameter documented in a comment"
msgstr ""

msgid ""
"2123        int f(const string& input, /*output only*/ string& output_data)"
msgstr ""

msgid "2124        {"
msgstr ""

msgid "2125            // ..."
msgstr ""

msgid "2126            output_data = something();"
msgstr ""

msgid "2127            return status;"
msgstr ""

msgid "2128        }"
msgstr ""

msgid "2129        // GOOD: self-documenting"
msgstr ""

msgid "2130        tuple<int, string> f(const string& input)"
msgstr ""

msgid "2131        {"
msgstr ""

msgid "2132            // ..."
msgstr ""

msgid "2133            return make_tuple(status, something());"
msgstr ""

msgid "2134        }"
msgstr ""

msgid ""
"2135    C++98's standard library already used this style, because a `pair` "
"is like a two-element `tuple`."
msgstr ""

msgid "2136    For example, given a `set<string> my_set`, consider:"
msgstr ""

msgid "2137        // C++98"
msgstr ""

msgid "2138        result = my_set.insert(\"Hello\");"
msgstr ""

msgid ""
"2139        if (result.second) do_something_with(result.first);    // "
"workaround"
msgstr ""

msgid ""
"2140    With C++11 we can write this, putting the results directly in "
"existing local variables:"
msgstr ""

msgid ""
"2141        Sometype iter;                                // default "
"initialize if we haven't already"
msgstr ""

msgid ""
"2142        Someothertype success;                        // used these "
"variables for some other purpose"
msgstr ""

msgid ""
"2143        tie(iter, success) = my_set.insert(\"Hello\");   // normal "
"return value"
msgstr ""

msgid "2144        if (success) do_something_with(iter);"
msgstr ""

msgid ""
"2145    With C++17 we should be able to use \"structured bindings\" to "
"declare and initialize the multiple variables:"
msgstr ""

msgid ""
"2146        if (auto [ iter, success ] = my_set.insert(\"Hello\"); success) "
"do_something_with(iter);"
msgstr ""

msgid "2147    ##### Exception"
msgstr ""

msgid ""
"2148    Sometimes, we need to pass an object to a function to manipulate its "
"state."
msgstr ""

msgid ""
"2149    In such cases, passing the object by reference [`T&`](#Rf-inout) is "
"usually the right technique."
msgstr ""

msgid ""
"2150    Explicitly passing an in-out parameter back out again as a return "
"value is often not necessary."
msgstr ""

msgid "2151    For example:"
msgstr ""

msgid ""
"2152        istream& operator>>(istream& is, string& s);    // much like std:"
":operator>>()"
msgstr ""

msgid "2153        for (string s; cin >> s; ) {"
msgstr ""

msgid "2154            // do something with line"
msgstr ""

msgid "2155        }"
msgstr ""

msgid "2156    Here, both `s` and `cin` are used as in-out parameters."
msgstr ""

msgid ""
"2157    We pass `cin` by (non-`const`) reference to be able to manipulate "
"its state."
msgstr ""

msgid "2158    We pass `s` to avoid repeated allocations."
msgstr ""

msgid ""
"2159    By reusing `s` (passed by reference), we allocate new memory only "
"when we need to expand `s`'s capacity."
msgstr ""

msgid ""
"2160    This technique is sometimes called the \"caller-allocated out\" "
"pattern and is particularly useful for types,"
msgstr ""

msgid ""
"2161    such as `string` and `vector`, that needs to do free store "
"allocations."
msgstr ""

msgid ""
"2162    To compare, if we passed out all values as return values, we would "
"something like this:"
msgstr ""

msgid ""
"2163        pair<istream&, string> get_string(istream& is);  // not "
"recommended"
msgstr ""

msgid "2164        {"
msgstr ""

msgid "2165            string s;"
msgstr ""

msgid "2166            is >> s;"
msgstr ""

msgid "2167            return {is, s};"
msgstr ""

msgid "2168        }"
msgstr ""

msgid "2169        for (auto p = get_string(cin); p.first; ) {"
msgstr ""

msgid "2170            // do something with p.second"
msgstr ""

msgid "2171        }"
msgstr ""

msgid ""
"2172    We consider that significantly less elegant with significantly less "
"performance."
msgstr ""

msgid ""
"2173    For a truly strict reading of this rule (F.21), the exception isn't "
"really an exception because it relies on in-out parameters,"
msgstr ""

msgid "2174    rather than the plain out parameters mentioned in the rule."
msgstr ""

msgid "2175    However, we prefer to be explicit, rather than subtle."
msgstr ""

msgid "2176    ##### Note"
msgstr ""

msgid ""
"2177    In many cases, it may be useful to return a specific, user-defined "
"type."
msgstr ""

msgid "2178    For example:"
msgstr ""

msgid "2179        struct Distance {"
msgstr ""

msgid "2180            int value;"
msgstr ""

msgid "2181            int unit = 1;   // 1 means meters"
msgstr ""

msgid "2182        };"
msgstr ""

msgid ""
"2183        Distance d1 = measure(obj1);        // access d1.value and d1."
"unit"
msgstr ""

msgid ""
"2184        auto d2 = measure(obj2);            // access d2.value and d2."
"unit"
msgstr ""

msgid ""
"2185        auto [value, unit] = measure(obj3); // access value and unit; "
"somewhat redundant"
msgstr ""

msgid ""
"2186                                            // to people who know "
"measure()"
msgstr ""

msgid ""
"2187        auto [x, y] = measure(obj4);        // don't; it's likely to be "
"confusing"
msgstr ""

msgid ""
"2188    The overly-generic `pair` and `tuple` should be used only when the "
"value returned represents to independent entities rather than an abstraction."
""
msgstr ""

msgid ""
"2189    Another example, use a specific type along the lines of `variant<T, "
"error_code>`, rather than using the generic `tuple`."
msgstr ""

msgid "2190    ##### Enforcement"
msgstr ""

msgid "2191    * Output parameters should be replaced by return values."
msgstr ""

msgid ""
"2192      An output parameter is one that the function writes to, invokes a "
"non-`const` member function, or passes on as a non-`const`."
msgstr ""

msgid ""
"2193    ### <a name=\"Rf-ptr\"></a>F.22: Use `T*` or `owner<T*>` to "
"designate a single object"
msgstr ""

msgid "2194    ##### Reason"
msgstr ""

msgid "2195    Readability: it makes the meaning of a plain pointer clear."
msgstr ""

msgid "2196    Enables significant tool support."
msgstr ""

msgid "2197    ##### Note"
msgstr ""

msgid ""
"2198    In traditional C and C++ code, plain `T*` is used for many weakly-"
"related purposes, such as:"
msgstr ""

msgid ""
"2199    * Identify a (single) object (not to be deleted by this function)"
msgstr ""

msgid ""
"2200    * Point to an object allocated on the free store (and delete it "
"later)"
msgstr ""

msgid "2201    * Hold the `nullptr`"
msgstr ""

msgid ""
"2202    * Identify a C-style string (zero-terminated array of characters)"
msgstr ""

msgid "2203    * Identify an array with a length specified separately"
msgstr ""

msgid "2204    * Identify a location in an array"
msgstr ""

msgid ""
"2205    This makes it hard to understand what the code does and is supposed "
"to do."
msgstr ""

msgid "2206    It complicates checking and tool support."
msgstr ""

msgid "2207    ##### Example"
msgstr ""

msgid "2208        void use(int* p, int n, char* s, int* q)"
msgstr ""

msgid "2209        {"
msgstr ""

msgid ""
"2210            p[n - 1] = 666; // Bad: we don't know if p points to n "
"elements;"
msgstr ""

msgid "2211                            // assume it does not or use span<int>"
msgstr ""

msgid ""
"2212            cout << s;      // Bad: we don't know if that s points to a "
"zero-terminated array of char;"
msgstr ""

msgid "2213                            // assume it does not or use zstring"
msgstr ""

msgid ""
"2214            delete q;       // Bad: we don't know if *q is allocated on "
"the free store;"
msgstr ""

msgid "2215                            // assume it does not or use owner"
msgstr ""

msgid "2216        }"
msgstr ""

msgid "2217    better"
msgstr ""

msgid "2218        void use2(span<int> p, zstring s, owner<int*> q)"
msgstr ""

msgid "2219        {"
msgstr ""

msgid ""
"2220            p[p.size() - 1] = 666; // OK, a range error can be caught"
msgstr ""

msgid "2221            cout << s; // OK"
msgstr ""

msgid "2222            delete q;  // OK"
msgstr ""

msgid "2223        }"
msgstr ""

msgid "2224    ##### Note"
msgstr ""

msgid ""
"2225    `owner<T*>` represents ownership, `zstring` represents a C-style "
"string."
msgstr ""

msgid ""
"2226    **Also**: Assume that a `T*` obtained from a smart pointer to `T` (e."
"g., `unique_ptr<T>`) points to a single element."
msgstr ""

msgid "2227    **See also**: [Support library](#S-gsl)"
msgstr ""

msgid ""
"2228    **See also**: [Do not pass an array as a single pointer](#Ri-array)"
msgstr ""

msgid "2229    ##### Enforcement"
msgstr ""

msgid ""
"2230    * (Simple) ((Bounds)) Warn for any arithmetic operation on an "
"expression of pointer type that results in a value of pointer type."
msgstr ""

msgid ""
"2231    ### <a name=\"Rf-nullptr\"></a>F.23: Use a `not_null<T>` to indicate "
"that \"null\" is not a valid value"
msgstr ""

msgid "2232    ##### Reason"
msgstr ""

msgid ""
"2233    Clarity. A function with a `not_null<T>` parameter makes it clear "
"that the caller of the function is responsible for any `nullptr` checks that "
"may be necessary."
msgstr ""

msgid ""
"2234    Similarly, a function with a return value of `not_null<T>` makes it "
"clear that the caller of the function does not need to check for `nullptr`."
msgstr ""

msgid "2235    ##### Example"
msgstr ""

msgid ""
"2236    `not_null<T*>` makes it obvious to a reader (human or machine) that "
"a test for `nullptr` is not necessary before dereference."
msgstr ""

msgid ""
"2237    Additionally, when debugging, `owner<T*>` and `not_null<T>` can be "
"instrumented to check for correctness."
msgstr ""

msgid "2238    Consider:"
msgstr ""

msgid "2239        int length(Record* p);"
msgstr ""

msgid ""
"2240    When I call `length(p)` should I check if `p` is `nullptr` first? "
"Should the implementation of `length()` check if `p` is `nullptr`?"
msgstr ""

msgid "2241        // it is the caller's job to make sure p != nullptr"
msgstr ""

msgid "2242        int length(not_null<Record*> p);"
msgstr ""

msgid ""
"2243        // the implementor of length() must assume that p == nullptr is "
"possible"
msgstr ""

msgid "2244        int length(Record* p);"
msgstr ""

msgid "2245    ##### Note"
msgstr ""

msgid ""
"2246    A `not_null<T*>` is assumed not to be the `nullptr`; a `T*` may be "
"the `nullptr`; both can be represented in memory as a `T*` (so no run-time "
"overhead is implied)."
msgstr ""

msgid "2247    ##### Note"
msgstr ""

msgid ""
"2248    `not_null` is not just for built-in pointers. It works for "
"`unique_ptr`, `shared_ptr`, and other pointer-like types."
msgstr ""

msgid "2249    ##### Enforcement"
msgstr ""

msgid ""
"2250    * (Simple) Warn if a raw pointer is dereferenced without being "
"tested against `nullptr` (or equivalent) within a function, suggest it is "
"declared `not_null` instead."
msgstr ""

msgid ""
"2251    * (Simple) Error if a raw pointer is sometimes dereferenced after "
"first being tested against `nullptr` (or equivalent) within the function and "
"sometimes is not."
msgstr ""

msgid ""
"2252    * (Simple) Warn if a `not_null` pointer is tested against `nullptr` "
"within a function."
msgstr ""

msgid ""
"2253    ### <a name=\"Rf-range\"></a>F.24: Use a `span<T>` or a `span_p<T>` "
"to designate a half-open sequence"
msgstr ""

msgid "2254    ##### Reason"
msgstr ""

msgid "2255    Informal/non-explicit ranges are a source of errors."
msgstr ""

msgid "2256    ##### Example"
msgstr ""

msgid "2257        X* find(span<X> r, const X& v);    // find v in r"
msgstr ""

msgid "2258        vector<X> vec;"
msgstr ""

msgid "2259        // ..."
msgstr ""

msgid ""
"2260        auto p = find({vec.begin(), vec.end()}, X{});  // find X{} in "
"vec"
msgstr ""

msgid "2261    ##### Note"
msgstr ""

msgid ""
"2262    Ranges are extremely common in C++ code. Typically, they are "
"implicit and their correct use is very hard to ensure."
msgstr ""

msgid ""
"2263    In particular, given a pair of arguments `(p, n)` designating an "
"array `[p:p+n)`,"
msgstr ""

msgid ""
"2264    it is in general impossible to know if there really are `n` elements "
"to access following `*p`."
msgstr ""

msgid ""
"2265    `span<T>` and `span_p<T>` are simple helper classes designating a "
"`[p:q)` range and a range starting with `p` and ending with the first "
"element for which a predicate is true, respectively."
msgstr ""

msgid "2266    ##### Example"
msgstr ""

msgid ""
"2267    A `span` represents a range of elements, but how do we manipulate "
"elements of that range?"
msgstr ""

msgid "2268        void f(span<int> s)"
msgstr ""

msgid "2269        {"
msgstr ""

msgid "2270            // range traversal (guaranteed correct)"
msgstr ""

msgid "2271            for (int x : s) cout << x << '\\n';"
msgstr ""

msgid "2272            // C-style traversal (potentially checked)"
msgstr ""

msgid ""
"2273            for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << "
"'\\n';"
msgstr ""

msgid "2274            // random access (potentially checked)"
msgstr ""

msgid "2275            s[7] = 9;"
msgstr ""

msgid "2276            // extract pointers (potentially checked)"
msgstr ""

msgid "2277            std::sort(&s[0], &s[s.size() / 2]);"
msgstr ""

msgid "2278        }"
msgstr ""

msgid "2279    ##### Note"
msgstr ""

msgid ""
"2280    A `span<T>` object does not own its elements and is so small that it "
"can be passed by value."
msgstr ""

msgid ""
"2281    Passing a `span` object as an argument is exactly as efficient as "
"passing a pair of pointer arguments or passing a pointer and an integer "
"count."
msgstr ""

msgid "2282    **See also**: [Support library](#S-gsl)"
msgstr ""

msgid "2283    ##### Enforcement"
msgstr ""

msgid ""
"2284    (Complex) Warn where accesses to pointer parameters are bounded by "
"other parameters that are integral types and suggest they could use `span` "
"instead."
msgstr ""

msgid ""
"2285    ### <a name=\"Rf-zstring\"></a>F.25: Use a `zstring` or a "
"`not_null<zstring>` to designate a C-style string"
msgstr ""

msgid "2286    ##### Reason"
msgstr ""

msgid ""
"2287    C-style strings are ubiquitous. They are defined by convention: zero-"
"terminated arrays of characters."
msgstr ""

msgid ""
"2288    We must distinguish C-style strings from a pointer to a single "
"character or an old-fashioned pointer to an array of characters."
msgstr ""

msgid "2289    ##### Example"
msgstr ""

msgid "2290    Consider:"
msgstr ""

msgid "2291        int length(const char* p);"
msgstr ""

msgid ""
"2292    When I call `length(s)` should I check if `s` is `nullptr` first? "
"Should the implementation of `length()` check if `p` is `nullptr`?"
msgstr ""

msgid ""
"2293        // the implementor of length() must assume that p == nullptr is "
"possible"
msgstr ""

msgid "2294        int length(zstring p);"
msgstr ""

msgid "2295        // it is the caller's job to make sure p != nullptr"
msgstr ""

msgid "2296        int length(not_null<zstring> p);"
msgstr ""

msgid "2297    ##### Note"
msgstr ""

msgid "2298    `zstring` do not represent ownership."
msgstr ""

msgid "2299    **See also**: [Support library](#S-gsl)"
msgstr ""

msgid ""
"2300    ### <a name=\"Rf-unique_ptr\"></a>F.26: Use a `unique_ptr<T>` to "
"transfer ownership where a pointer is needed"
msgstr ""

msgid "2301    ##### Reason"
msgstr ""

msgid ""
"2302    Using `unique_ptr` is the cheapest way to pass a pointer safely."
msgstr ""

msgid ""
"2303    **See also**: [C.50](#Rc-factory) regarding when to return a "
"`shared_ptr` from a factory."
msgstr ""

msgid "2304    ##### Example"
msgstr ""

msgid ""
"2305        unique_ptr<Shape> get_shape(istream& is)  // assemble shape from "
"input stream"
msgstr ""

msgid "2306        {"
msgstr ""

msgid ""
"2307            auto kind = read_header(is); // read header and identify the "
"next shape on input"
msgstr ""

msgid "2308            switch (kind) {"
msgstr ""

msgid "2309            case kCircle:"
msgstr ""

msgid "2310                return make_unique<Circle>(is);"
msgstr ""

msgid "2311            case kTriangle:"
msgstr ""

msgid "2312                return make_unique<Triangle>(is);"
msgstr ""

msgid "2313            // ..."
msgstr ""

msgid "2314            }"
msgstr ""

msgid "2315        }"
msgstr ""

msgid "2316    ##### Note"
msgstr ""

msgid ""
"2317    You need to pass a pointer rather than an object if what you are "
"transferring is an object from a class hierarchy that is to be used through "
"an interface (base class)."
msgstr ""

msgid "2318    ##### Enforcement"
msgstr ""

msgid ""
"2319    (Simple) Warn if a function returns a locally allocated raw pointer. "
"Suggest using either `unique_ptr` or `shared_ptr` instead."
msgstr ""

msgid ""
"2320    ### <a name=\"Rf-shared_ptr\"></a>F.27: Use a `shared_ptr<T>` to "
"share ownership"
msgstr ""

msgid "2321    ##### Reason"
msgstr ""

msgid ""
"2322    Using `std::shared_ptr` is the standard way to represent shared "
"ownership. That is, the last owner deletes the object."
msgstr ""

msgid "2323    ##### Example"
msgstr ""

msgid "2324        shared_ptr<const Image> im { read_image(somewhere) };"
msgstr ""

msgid "2325        std::thread t0 {shade, args0, top_left, im};"
msgstr ""

msgid "2326        std::thread t1 {shade, args1, top_right, im};"
msgstr ""

msgid "2327        std::thread t2 {shade, args2, bottom_left, im};"
msgstr ""

msgid "2328        std::thread t3 {shade, args3, bottom_right, im};"
msgstr ""

msgid "2329        // detach threads"
msgstr ""

msgid "2330        // last thread to finish deletes the image"
msgstr ""

msgid "2331    ##### Note"
msgstr ""

msgid ""
"2332    Prefer a `unique_ptr` over a `shared_ptr` if there is never more "
"than one owner at a time."
msgstr ""

msgid "2333    `shared_ptr` is for shared ownership."
msgstr ""

msgid ""
"2334    Note that pervasive use of `shared_ptr` has a cost (atomic "
"operations on the `shared_ptr`'s reference count have a measurable aggregate "
"cost)."
msgstr ""

msgid "2335    ##### Alternative"
msgstr ""

msgid ""
"2336    Have a single object own the shared object (e.g. a scoped object) "
"and destroy that (preferably implicitly) when all users have completed."
msgstr ""

msgid "2337    ##### Enforcement"
msgstr ""

msgid ""
"2338    (Not enforceable) This is a too complex pattern to reliably detect."
msgstr ""

msgid ""
"2339    ### <a name=\"Rf-ptr-ref\"></a>F.60: Prefer `T*` over `T&` when \"no "
"argument\" is a valid option"
msgstr ""

msgid "2340    ##### Reason"
msgstr ""

msgid ""
"2341    A pointer (`T*`) can be a `nullptr` and a reference (`T&`) cannot, "
"there is no valid \"null reference\"."
msgstr ""

msgid ""
"2342    Sometimes having `nullptr` as an alternative to indicated \"no "
"object\" is useful, but if it is not, a reference is notationally simpler "
"and might yield better code."
msgstr ""

msgid "2343    ##### Example"
msgstr ""

msgid ""
"2344        string zstring_to_string(zstring p) // zstring is a char*; that "
"is a C-style string"
msgstr ""

msgid "2345        {"
msgstr ""

msgid ""
"2346            if (!p) return string{};    // p might be nullptr; remember "
"to check"
msgstr ""

msgid "2347            return string{p};"
msgstr ""

msgid "2348        }"
msgstr ""

msgid "2349        void print(const vector<int>& r)"
msgstr ""

msgid "2350        {"
msgstr ""

msgid "2351            // r refers to a vector<int>; no check needed"
msgstr ""

msgid "2352        }"
msgstr ""

msgid "2353    ##### Note"
msgstr ""

msgid ""
"2354    It is possible, but not valid C++ to construct a reference that is "
"essentially a `nullptr` (e.g., `T* p = nullptr; T& r = (T&)*p;`)."
msgstr ""

msgid "2355    That error is very uncommon."
msgstr ""

msgid "2356    ##### Note"
msgstr ""

msgid ""
"2357    If you prefer the pointer notation (`->` and/or `*` vs. `.`), "
"`not_null<T*>` provides the same guarantee as `T&`."
msgstr ""

msgid "2358    ##### Enforcement"
msgstr ""

msgid "2359    * Flag ???"
msgstr ""

msgid ""
"2360    ### <a name=\"Rf-return-ptr\"></a>F.42: Return a `T*` to indicate a "
"position (only)"
msgstr ""

msgid "2361    ##### Reason"
msgstr ""

msgid "2362    That's what pointers are good for."
msgstr ""

msgid "2363    Returning a `T*` to transfer ownership is a misuse."
msgstr ""

msgid "2364    ##### Example"
msgstr ""

msgid ""
"2365        Node* find(Node* t, const string& s)  // find s in a binary tree "
"of Nodes"
msgstr ""

msgid "2366        {"
msgstr ""

msgid "2367            if (!t || t->name == s) return t;"
msgstr ""

msgid "2368            if ((auto p = find(t->left, s))) return p;"
msgstr ""

msgid "2369            if ((auto p = find(t->right, s))) return p;"
msgstr ""

msgid "2370            return nullptr;"
msgstr ""

msgid "2371        }"
msgstr ""

msgid ""
"2372    If it isn't the `nullptr`, the pointer returned by `find` indicates "
"a `Node` holding `s`."
msgstr ""

msgid ""
"2373    Importantly, that does not imply a transfer of ownership of the "
"pointed-to object to the caller."
msgstr ""

msgid "2374    ##### Note"
msgstr ""

msgid ""
"2375    Positions can also be transferred by iterators, indices, and "
"references."
msgstr ""

msgid ""
"2376    A reference is often a superior alternative to a pointer [if there "
"is no need to use `nullptr`](#Rf-ptr-ref) or [if the object referred to "
"should not change](???)."
msgstr ""

msgid "2377    ##### Note"
msgstr ""

msgid ""
"2378    Do not return a pointer to something that is not in the caller's "
"scope; see [F.43](#Rf-dangle)."
msgstr ""

msgid ""
"2379    **See also**: [discussion of dangling pointer prevention](#???)"
msgstr ""

msgid "2380    ##### Enforcement"
msgstr ""

msgid "2381    * Flag `delete`, `std::free()`, etc. applied to a plain `T*`."
msgstr ""

msgid "2382    Only owners should be deleted."
msgstr ""

msgid "2383    * Flag `new`, `malloc()`, etc. assigned to a plain `T*`."
msgstr ""

msgid "2384    Only owners should be responsible for deletion."
msgstr ""

msgid ""
"2385    ### <a name=\"Rf-dangle\"></a>F.43: Never (directly or indirectly) "
"return a pointer or a reference to a local object"
msgstr ""

msgid "2386    ##### Reason"
msgstr ""

msgid ""
"2387    To avoid the crashes and data corruption that can result from the "
"use of such a dangling pointer."
msgstr ""

msgid "2388    ##### Example, bad"
msgstr ""

msgid ""
"2389    After the return from a function its local objects no longer exist:"
msgstr ""

msgid "2390        int* f()"
msgstr ""

msgid "2391        {"
msgstr ""

msgid "2392            int fx = 9;"
msgstr ""

msgid "2393            return &fx;  // BAD"
msgstr ""

msgid "2394        }"
msgstr ""

msgid "2395        void g(int* p)   // looks innocent enough"
msgstr ""

msgid "2396        {"
msgstr ""

msgid "2397            int gx;"
msgstr ""

msgid "2398            cout << \"*p == \" << *p << '\\n';"
msgstr ""

msgid "2399            *p = 999;"
msgstr ""

msgid "2400            cout << \"gx == \" << gx << '\\n';"
msgstr ""

msgid "2401        }"
msgstr ""

msgid "2402        void h()"
msgstr ""

msgid "2403        {"
msgstr ""

msgid "2404            int* p = f();"
msgstr ""

msgid "2405            int z = *p;  // read from abandoned stack frame (bad)"
msgstr ""

msgid ""
"2406            g(p);        // pass pointer to abandoned stack frame to "
"function (bad)"
msgstr ""

msgid "2407        }"
msgstr ""

msgid "2408    Here on one popular implementation I got the output:"
msgstr ""

msgid "2409        *p == 999"
msgstr ""

msgid "2410        gx == 999"
msgstr ""

msgid ""
"2411    I expected that because the call of `g()` reuses the stack space "
"abandoned by the call of `f()` so `*p` refers to the space now occupied by "
"`gx`."
msgstr ""

msgid ""
"2412    * Imagine what would happen if `fx` and `gx` were of different types."
""
msgstr ""

msgid ""
"2413    * Imagine what would happen if `fx` or `gx` was a type with an "
"invariant."
msgstr ""

msgid ""
"2414    * Imagine what would happen if more that dangling pointer was passed "
"around among a larger set of functions."
msgstr ""

msgid "2415    * Imagine what a cracker could do with that dangling pointer."
msgstr ""

msgid ""
"2416    Fortunately, most (all?) modern compilers catch and warn against "
"this simple case."
msgstr ""

msgid "2417    ##### Note"
msgstr ""

msgid "2418    This applies to references as well:"
msgstr ""

msgid "2419        int& f()"
msgstr ""

msgid "2420        {"
msgstr ""

msgid "2421            int x = 7;"
msgstr ""

msgid "2422            // ..."
msgstr ""

msgid ""
"2423            return x;  // Bad: returns reference to object that is about "
"to be destroyed"
msgstr ""

msgid "2424        }"
msgstr ""

msgid "2425    ##### Note"
msgstr ""

msgid "2426    This applies only to non-`static` local variables."
msgstr ""

msgid ""
"2427    All `static` variables are (as their name indicates) statically "
"allocated, so that pointers to them cannot dangle."
msgstr ""

msgid "2428    ##### Example, bad"
msgstr ""

msgid ""
"2429    Not all examples of leaking a pointer to a local variable are that "
"obvious:"
msgstr ""

msgid ""
"2430        int* glob;       // global variables are bad in so many ways"
msgstr ""

msgid "2431        template<class T>"
msgstr ""

msgid "2432        void steal(T x)"
msgstr ""

msgid "2433        {"
msgstr ""

msgid "2434            glob = x();  // BAD"
msgstr ""

msgid "2435        }"
msgstr ""

msgid "2436        void f()"
msgstr ""

msgid "2437        {"
msgstr ""

msgid "2438            int i = 99;"
msgstr ""

msgid "2439            steal([&] { return &i; });"
msgstr ""

msgid "2440        }"
msgstr ""

msgid "2441        int main()"
msgstr ""

msgid "2442        {"
msgstr ""

msgid "2443            f();"
msgstr ""

msgid "2444            cout << *glob << '\\n';"
msgstr ""

msgid "2445        }"
msgstr ""

msgid ""
"2446    Here I managed to read the location abandoned by the call of `f`."
msgstr ""

msgid ""
"2447    The pointer stored in `glob` could be used much later and cause "
"trouble in unpredictable ways."
msgstr ""

msgid "2448    ##### Note"
msgstr ""

msgid ""
"2449    The address of a local variable can be \"returned\"/leaked by a "
"return statement, by a `T&` out-parameter, as a member of a returned object, "
"as an element of a returned array, and more."
msgstr ""

msgid "2450    ##### Note"
msgstr ""

msgid ""
"2451    Similar examples can be constructed \"leaking\" a pointer from an "
"inner scope to an outer one;"
msgstr ""

msgid ""
"2452    such examples are handled equivalently to leaks of pointers out of a "
"function."
msgstr ""

msgid ""
"2453    A slightly different variant of the problem is placing pointers in a "
"container that outlives the objects pointed to."
msgstr ""

msgid ""
"2454    **See also**: Another way of getting dangling pointers is [pointer "
"invalidation](#???)."
msgstr ""

msgid "2455    It can be detected/prevented with similar techniques."
msgstr ""

msgid "2456    ##### Enforcement"
msgstr ""

msgid ""
"2457    * Compilers tend to catch return of reference to locals and could in "
"many cases catch return of pointers to locals."
msgstr ""

msgid ""
"2458    * Static analysis can catch many common patterns of the use of "
"pointers indicating positions (thus eliminating dangling pointers)"
msgstr ""

msgid ""
"2459    ### <a name=\"Rf-return-ref\"></a>F.44: Return a `T&` when copy is "
"undesirable and \"returning no object\" isn't needed"
msgstr ""

msgid "2460    ##### Reason"
msgstr ""

msgid ""
"2461    The language guarantees that a `T&` refers to an object, so that "
"testing for `nullptr` isn't necessary."
msgstr ""

msgid ""
"2462    **See also**: The return of a reference must not imply transfer of "
"ownership:"
msgstr ""

msgid ""
"2463    [discussion of dangling pointer prevention](#???) and [discussion of "
"ownership](#???)."
msgstr ""

msgid "2464    ##### Example"
msgstr ""

msgid "2465        class Car"
msgstr ""

msgid "2466        {"
msgstr ""

msgid "2467            array<wheel, 4> w;"
msgstr ""

msgid "2468            // ..."
msgstr ""

msgid "2469        public:"
msgstr ""

msgid ""
"2470            wheel& get_wheel(int i) { Expects(i < w.size()); return "
"w[i]; }"
msgstr ""

msgid "2471            // ..."
msgstr ""

msgid "2472        };"
msgstr ""

msgid "2473        void use()"
msgstr ""

msgid "2474        {"
msgstr ""

msgid "2475            Car c;"
msgstr ""

msgid ""
"2476            wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c"
msgstr ""

msgid "2477        }"
msgstr ""

msgid "2478    ##### Enforcement"
msgstr ""

msgid ""
"2479    Flag functions where no `return` expression could yield `nullptr`"
msgstr ""

msgid "2480    ### <a name=\"Rf-return-ref-ref\"></a>F.45: Don't return a `T&&`"
msgstr ""

msgid "2481    ##### Reason"
msgstr ""

msgid ""
"2482    It's asking to return a reference to a destroyed temporary object. A "
"`&&` is a magnet for temporary objects. This is fine when the reference to "
"the temporary is being passed \"downward\" to a callee, because the "
"temporary is guaranteed to outlive the function call (see [F.18](#Rf-"
"consume) and [F.19](#Rf-forward)). However, it's not fine when passing such "
"a reference \"upward\" to a larger caller scope. See also ???."
msgstr ""

msgid ""
"2483    For passthrough functions that pass in parameters (by ordinary "
"reference or by perfect forwarding) and want to return values, use simple "
"`auto` return type deduction (not `auto&&`)."
msgstr ""

msgid "2484    ##### Example, bad"
msgstr ""

msgid ""
"2485    If `F` returns by value, this function returns a reference to a "
"temporary."
msgstr ""

msgid "2486        template<class F>"
msgstr ""

msgid "2487        auto&& wrapper(F f)"
msgstr ""

msgid "2488        {"
msgstr ""

msgid "2489            log_call(typeid(f)); // or whatever instrumentation"
msgstr ""

msgid "2490            return f();"
msgstr ""

msgid "2491        }"
msgstr ""

msgid "2492    ##### Example, good"
msgstr ""

msgid "2493    Better:"
msgstr ""

msgid "2494        template<class F>"
msgstr ""

msgid "2495        auto wrapper(F f)"
msgstr ""

msgid "2496        {"
msgstr ""

msgid "2497            log_call(typeid(f)); // or whatever instrumentation"
msgstr ""

msgid "2498            return f();"
msgstr ""

msgid "2499        }"
msgstr ""

msgid "2500    ##### Exception"
msgstr ""

msgid ""
"2501    `std::move` and `std::forward` do return `&&`, but they are just "
"casts -- used by convention only in expression contexts where a reference to "
"a temporary object is passed along within the same expression before the "
"temporary is destroyed. We don't know of any other good examples of "
"returning `&&`."
msgstr ""

msgid "2502    ##### Enforcement"
msgstr ""

msgid ""
"2503    Flag any use of `&&` as a return type, except in `std::move` and "
"`std::forward`."
msgstr ""

msgid ""
"2504    ### <a name=\"Rf-main\"></a>F.46: `int` is the return type for "
"`main()`"
msgstr ""

msgid "2505    ##### Reason"
msgstr ""

msgid ""
"2506    It's a language rule, but violated through \"language extensions\" "
"so often that it is worth mentioning."
msgstr ""

msgid ""
"2507    Declaring `main` (the one global `main` of a program) `void` limits "
"portability."
msgstr ""

msgid "2508    ##### Example"
msgstr ""

msgid "2509            void main() { /* ... */ };  // bad, not C++"
msgstr ""

msgid "2510            int main()"
msgstr ""

msgid "2511            {"
msgstr ""

msgid "2512                std::cout << \"This is the way to do it\\n\";"
msgstr ""

msgid "2513            }"
msgstr ""

msgid "2514    ##### Note"
msgstr ""

msgid ""
"2515    We mention this only because of the persistence of this error in the "
"community."
msgstr ""

msgid "2516    ##### Enforcement"
msgstr ""

msgid "2517    * The compiler should do it"
msgstr ""

msgid "2518    * If the compiler doesn't do it, let tools flag it"
msgstr ""

msgid ""
"2519    ### <a name=\"Rf-assignment-op\"></a>F.47: Return `T&` from "
"assignment operators"
msgstr ""

msgid "2520    ##### Reason"
msgstr ""

msgid ""
"2521    The convention for operator overloads (especially on value types) is "
"for"
msgstr ""

msgid ""
"2522    `operator=(const T&)` to perform the assignment and then return (non-"
"`const`)"
msgstr ""

msgid ""
"2523    `*this`.  This ensures consistency with standard-library types and "
"follows the"
msgstr ""

msgid "2524    principle of \"do as the ints do.\""
msgstr ""

msgid "2525    ##### Note"
msgstr ""

msgid ""
"2526    Historically there was some guidance to make the assignment operator "
"return `const T&`."
msgstr ""

msgid ""
"2527    This was primarily to avoid code of the form `(a = b) = c` -- such "
"code is not common enough to warrant violating consistency with standard "
"types."
msgstr ""

msgid "2528    ##### Example"
msgstr ""

msgid "2529        class Foo"
msgstr ""

msgid "2530        {"
msgstr ""

msgid "2531         public:"
msgstr ""

msgid "2532            ..."
msgstr ""

msgid "2533            Foo& operator=(const Foo& rhs) {"
msgstr ""

msgid "2534              // Copy members."
msgstr ""

msgid "2535              ..."
msgstr ""

msgid "2536              return *this;"
msgstr ""

msgid "2537            }"
msgstr ""

msgid "2538        };"
msgstr ""

msgid "2539    ##### Enforcement"
msgstr ""

msgid ""
"2540    This should be enforced by tooling by checking the return type (and "
"return"
msgstr ""

msgid "2541    value) of any assignment operator."
msgstr ""

msgid ""
"2542    ### <a name=\"Rf-return-move-local\"></a>F.48: Don't `return std::"
"move(local)`"
msgstr ""

msgid "2543    ##### Reason"
msgstr ""

msgid ""
"2544    With guaranteed copy elision, it is now almost always a "
"pessimization to expressly use `std::move` in a return statement."
msgstr ""

msgid "2545    ##### Example; bad"
msgstr ""

msgid "2546        S f()"
msgstr ""

msgid "2547        {"
msgstr ""

msgid "2548          S result;"
msgstr ""

msgid "2549          return std::move(result);"
msgstr ""

msgid "2550        }"
msgstr ""

msgid "2551    ##### Example; good"
msgstr ""

msgid "2552        S f()"
msgstr ""

msgid "2553        {"
msgstr ""

msgid "2554          S result;"
msgstr ""

msgid "2555          return result;"
msgstr ""

msgid "2556        }"
msgstr ""

msgid "2557    ##### Enforcement"
msgstr ""

msgid ""
"2558    This should be enforced by tooling by checking the return expression "
"."
msgstr ""

msgid ""
"2559    ### <a name=\"Rf-capture-vs-overload\"></a>F.50: Use a lambda when a "
"function won't do (to capture local variables, or to write a local function)"
msgstr ""

msgid "2560    ##### Reason"
msgstr ""

msgid ""
"2561    Functions can't capture local variables or be declared at local "
"scope; if you need those things, prefer a lambda where possible, and a "
"handwritten function object where not. On the other hand, lambdas and "
"function objects don't overload; if you need to overload, prefer a function "
"(the workarounds to make lambdas overload are ornate). If either will work, "
"prefer writing a function; use the simplest tool necessary."
msgstr ""

msgid "2562    ##### Example"
msgstr ""

msgid ""
"2563        // writing a function that should only take an int or a string"
msgstr ""

msgid "2564        // -- overloading is natural"
msgstr ""

msgid "2565        void f(int);"
msgstr ""

msgid "2566        void f(const string&);"
msgstr ""

msgid ""
"2567        // writing a function object that needs to capture local state "
"and appear"
msgstr ""

msgid "2568        // at statement or expression scope -- a lambda is natural"
msgstr ""

msgid "2569        vector<work> v = lots_of_work();"
msgstr ""

msgid "2570        for (int tasknum = 0; tasknum < max; ++tasknum) {"
msgstr ""

msgid "2571            pool.run([=, &v]{"
msgstr ""

msgid "2572                /*"
msgstr ""

msgid "2573                ..."
msgstr ""

msgid ""
"2574                ... process 1 / max - th of v, the tasknum - th chunk"
msgstr ""

msgid "2575                ..."
msgstr ""

msgid "2576                */"
msgstr ""

msgid "2577            });"
msgstr ""

msgid "2578        }"
msgstr ""

msgid "2579        pool.join();"
msgstr ""

msgid "2580    ##### Exception"
msgstr ""

msgid ""
"2581    Generic lambdas offer a concise way to write function templates and "
"so can be useful even when a normal function template would do equally well "
"with a little more syntax. This advantage will probably disappear in the "
"future once all functions gain the ability to have Concept parameters."
msgstr ""

msgid "2582    ##### Enforcement"
msgstr ""

msgid ""
"2583    * Warn on use of a named non-generic lambda (e.g., `auto x = [](int "
"i){ /*...*/; };`) that captures nothing and appears at global scope. Write "
"an ordinary function instead."
msgstr ""

msgid ""
"2584    ### <a name=\"Rf-default-args\"></a>F.51: Where there is a choice, "
"prefer default arguments over overloading"
msgstr ""

msgid "2585    ##### Reason"
msgstr ""

msgid ""
"2586    Default arguments simply provide alternative interfaces to a single "
"implementation."
msgstr ""

msgid ""
"2587    There is no guarantee that a set of overloaded functions all "
"implement the same semantics."
msgstr ""

msgid "2588    The use of default arguments can avoid code replication."
msgstr ""

msgid "2589    ##### Note"
msgstr ""

msgid ""
"2590    There is a choice between using default argument and overloading "
"when the alternatives are from a set of arguments of the same types."
msgstr ""

msgid "2591    For example:"
msgstr ""

msgid "2592        void print(const string& s, format f = {});"
msgstr ""

msgid "2593    as opposed to"
msgstr ""

msgid "2594        void print(const string& s);  // use default format"
msgstr ""

msgid "2595        void print(const string& s, format f);"
msgstr ""

msgid ""
"2596    There is not a choice when a set of functions are used to do a "
"semantically equivalent operation to a set of types. For example:"
msgstr ""

msgid "2597        void print(const char&);"
msgstr ""

msgid "2598        void print(int);"
msgstr ""

msgid "2599        void print(zstring);"
msgstr ""

msgid "2600    ##### See also"
msgstr ""

msgid ""
"2601    [Default arguments for virtual functions](#Rh-virtual-default-arg)"
msgstr ""

msgid "2602    ##### Enforcement"
msgstr ""

msgid "2603        ???"
msgstr ""

msgid ""
"2604    ### <a name=\"Rf-reference-capture\"></a>F.52: Prefer capturing by "
"reference in lambdas that will be used locally, including passed to "
"algorithms"
msgstr ""

msgid "2605    ##### Reason"
msgstr ""

msgid ""
"2606    For efficiency and correctness, you nearly always want to capture by "
"reference when using the lambda locally. This includes when writing or "
"calling parallel algorithms that are local because they join before "
"returning."
msgstr ""

msgid "2607    ##### Discussion"
msgstr ""

msgid ""
"2608    The efficiency consideration is that most types are cheaper to pass "
"by reference than by value."
msgstr ""

msgid ""
"2609    The correctness consideration is that many calls want to perform "
"side effects on the original object at the call site (see example below). "
"Passing by value prevents this."
msgstr ""

msgid "2610    ##### Note"
msgstr ""

msgid ""
"2611    Unfortunately, there is no simple way to capture by reference to "
"`const` to get the efficiency for a local call but also prevent side effects."
""
msgstr ""

msgid "2612    ##### Example"
msgstr ""

msgid ""
"2613    Here, a large object (a network message) is passed to an iterative "
"algorithm, and is it not efficient or correct to copy the message (which may "
"not be copyable):"
msgstr ""

msgid ""
"2614        std::for_each(begin(sockets), end(sockets), [&message](auto& "
"socket)"
msgstr ""

msgid "2615        {"
msgstr ""

msgid "2616            socket.send(message);"
msgstr ""

msgid "2617        });"
msgstr ""

msgid "2618    ##### Example"
msgstr ""

msgid ""
"2619    This is a simple three-stage parallel pipeline. Each `stage` object "
"encapsulates a worker thread and a queue, has a `process` function to "
"enqueue work, and in its destructor automatically blocks waiting for the "
"queue to empty before ending the thread."
msgstr ""

msgid "2620        void send_packets(buffers& bufs)"
msgstr ""

msgid "2621        {"
msgstr ""

msgid "2622            stage encryptor([] (buffer& b){ encrypt(b); });"
msgstr ""

msgid ""
"2623            stage compressor([&](buffer& b){ compress(b); encryptor."
"process(b); });"
msgstr ""

msgid ""
"2624            stage decorator([&](buffer& b){ decorate(b); compressor."
"process(b); });"
msgstr ""

msgid "2625            for (auto& b : bufs) { decorator.process(b); }"
msgstr ""

msgid "2626        }  // automatically blocks waiting for pipeline to finish"
msgstr ""

msgid "2627    ##### Enforcement"
msgstr ""

msgid ""
"2628    Flag a lambda that captures by reference, but is used other than "
"locally within the function scope or passed to a function by reference. "
"(Note: This rule is an approximation, but does flag passing by pointer as "
"those are more likely to be stored by the callee, writing to a heap location "
"accessed via a parameter, returning the lambda, etc. The Lifetime rules will "
"also provide general rules that flag escaping pointers and references "
"including via lambdas.)"
msgstr ""

msgid ""
"2629    ### <a name=\"Rf-value-capture\"></a>F.53: Avoid capturing by "
"reference in lambdas that will be used nonlocally, including returned, "
"stored on the heap, or passed to another thread"
msgstr ""

msgid "2630    ##### Reason"
msgstr ""

msgid ""
"2631    Pointers and references to locals shouldn't outlive their scope. "
"Lambdas that capture by reference are just another place to store a "
"reference to a local object, and shouldn't do so if they (or a copy) outlive "
"the scope."
msgstr ""

msgid "2632    ##### Example, bad"
msgstr ""

msgid "2633        int local = 42;"
msgstr ""

msgid "2634        // Want a reference to local."
msgstr ""

msgid "2635        // Note, that after program exits this scope,"
msgstr ""

msgid "2636        // local no longer exists, therefore"
msgstr ""

msgid "2637        // process() call will have undefined behavior!"
msgstr ""

msgid "2638        thread_pool.queue_work([&]{ process(local); });"
msgstr ""

msgid "2639    ##### Example, good"
msgstr ""

msgid "2640        int local = 42;"
msgstr ""

msgid "2641        // Want a copy of local."
msgstr ""

msgid "2642        // Since a copy of local is made, it will"
msgstr ""

msgid "2643        // always be available for the call."
msgstr ""

msgid "2644        thread_pool.queue_work([=]{ process(local); });"
msgstr ""

msgid "2645    ##### Enforcement"
msgstr ""

msgid ""
"2646    * (Simple) Warn when capture-list contains a reference to a locally "
"declared variable"
msgstr ""

msgid ""
"2647    * (Complex) Flag when capture-list contains a reference to a locally "
"declared variable and the lambda is passed to a non-`const` and non-local "
"context"
msgstr ""

msgid ""
"2648    ### <a name=\"Rf-this-capture\"></a>F.54: If you capture `this`, "
"capture all variables explicitly (no default capture)"
msgstr ""

msgid "2649    ##### Reason"
msgstr ""

msgid ""
"2650    It's confusing. Writing `[=]` in a member function appears to "
"capture by value, but actually captures data members by reference because it "
"actually captures the invisible `this` pointer by value. If you meant to do "
"that, write `this` explicitly."
msgstr ""

msgid "2651    ##### Example"
msgstr ""

msgid "2652        class My_class {"
msgstr ""

msgid "2653            int x = 0;"
msgstr ""

msgid "2654            // ..."
msgstr ""

msgid "2655            void f() {"
msgstr ""

msgid "2656                int i = 0;"
msgstr ""

msgid "2657                // ..."
msgstr ""

msgid ""
"2658                auto lambda = [=]{ use(i, x); };   // BAD: \"looks "
"like\" copy/value capture"
msgstr ""

msgid ""
"2659                // [&] has identical semantics and copies the this "
"pointer under the current rules"
msgstr ""

msgid ""
"2660                // [=,this] and [&,this] are not much better, and "
"confusing"
msgstr ""

msgid "2661                x = 42;"
msgstr ""

msgid "2662                lambda(); // calls use(0, 42);"
msgstr ""

msgid "2663                x = 43;"
msgstr ""

msgid "2664                lambda(); // calls use(0, 43);"
msgstr ""

msgid "2665                // ..."
msgstr ""

msgid ""
"2666                auto lambda2 = [i, this]{ use(i, x); }; // ok, most "
"explicit and least confusing"
msgstr ""

msgid "2667                // ..."
msgstr ""

msgid "2668            }"
msgstr ""

msgid "2669        };"
msgstr ""

msgid "2670    ##### Note"
msgstr ""

msgid ""
"2671    This is under active discussion in standardization, and may be "
"addressed in a future version of the standard by adding a new capture mode "
"or possibly adjusting the meaning of `[=]`. For now, just be explicit."
msgstr ""

msgid "2672    ##### Enforcement"
msgstr ""

msgid ""
"2673    * Flag any lambda capture-list that specifies a default capture and "
"also captures `this` (whether explicitly or via default capture)"
msgstr ""

msgid "2674    ### <a name=\"F-varargs\"></a>F.55: Don't use `va_arg` arguments"
msgstr ""

msgid "2675    ##### Reason"
msgstr ""

msgid ""
"2676    Reading from a `va_arg` assumes that the correct type was actually "
"passed."
msgstr ""

msgid "2677    Passing to varargs assumes the correct type will be read."
msgstr ""

msgid ""
"2678    This is fragile because it cannot generally be enforced to be safe "
"in the language and so relies on programmer discipline to get it right."
msgstr ""

msgid "2679    ##### Example"
msgstr ""

msgid "2680        int sum(...) {"
msgstr ""

msgid "2681            // ..."
msgstr ""

msgid "2682            while (/*...*/)"
msgstr ""

msgid ""
"2683                result += va_arg(list, int); // BAD, assumes it will be "
"passed ints"
msgstr ""

msgid "2684            // ..."
msgstr ""

msgid "2685        }"
msgstr ""

msgid "2686        sum(3, 2); // ok"
msgstr ""

msgid "2687        sum(3.14159, 2.71828); // BAD, undefined"
msgstr ""

msgid "2688        template<class ...Args>"
msgstr ""

msgid "2689        auto sum(Args... args) { // GOOD, and much more flexible"
msgstr ""

msgid "2690            return (... + args); // note: C++17 \"fold expression\""
msgstr ""

msgid "2691        }"
msgstr ""

msgid "2692        sum(3, 2); // ok: 5"
msgstr ""

msgid "2693        sum(3.14159, 2.71828); // ok: ~5.85987"
msgstr ""

msgid "2694    ##### Alternatives"
msgstr ""

msgid "2695    * overloading"
msgstr ""

msgid "2696    * variadic templates"
msgstr ""

msgid "2697    * `variant` arguments"
msgstr ""

msgid "2698    * `initializer_list` (homogeneous)"
msgstr ""

msgid "2699    ##### Note"
msgstr ""

msgid ""
"2700    Declaring a `...` parameter is sometimes useful for techniques that "
"don't involve actual argument passing, notably to declare \"take-anything\" "
"functions so as to disable \"everything else\" in an overload set or express "
"a catchall case in a template metaprogram."
msgstr ""

msgid "2701    ##### Enforcement"
msgstr ""

msgid ""
"2702    * Issue a diagnostic for using `va_list`, `va_start`, or `va_arg`."
msgstr ""

msgid ""
"2703    * Issue a diagnostic for passing an argument to a vararg parameter "
"of a function that does not offer an overload for a more specific type in "
"the position of the vararg. To fix: Use a different function, or "
"`[[suppress(types)]]`."
msgstr ""

msgid "2704    # <a name=\"S-class\"></a>C: Classes and class hierarchies"
msgstr ""

msgid ""
"2705    A class is a user-defined type, for which a programmer can define "
"the representation, operations, and interfaces."
msgstr ""

msgid ""
"2706    Class hierarchies are used to organize related classes into "
"hierarchical structures."
msgstr ""

msgid "2707    Class rule summary:"
msgstr ""

msgid ""
"2708    * [C.1: Organize related data into structures (`struct`s or "
"`class`es)](#Rc-org)"
msgstr ""

msgid ""
"2709    * [C.2: Use `class` if the class has an invariant; use `struct` if "
"the data members can vary independently](#Rc-struct)"
msgstr ""

msgid ""
"2710    * [C.3: Represent the distinction between an interface and an "
"implementation using a class](#Rc-interface)"
msgstr ""

msgid ""
"2711    * [C.4: Make a function a member only if it needs direct access to "
"the representation of a class](#Rc-member)"
msgstr ""

msgid ""
"2712    * [C.5: Place helper functions in the same namespace as the class "
"they support](#Rc-helper)"
msgstr ""

msgid ""
"2713    * [C.7: Don't define a class or enum and declare a variable of its "
"type in the same statement](#Rc-standalone)"
msgstr ""

msgid ""
"2714    * [C.8: Use `class` rather than `struct` if any member is non-"
"public](#Rc-class)"
msgstr ""

msgid "2715    * [C.9: Minimize exposure of members](#Rc-private)"
msgstr ""

msgid "2716    Subsections:"
msgstr ""

msgid "2717    * [C.concrete: Concrete types](#SS-concrete)"
msgstr ""

msgid ""
"2718    * [C.ctor: Constructors, assignments, and destructors](#S-ctor)"
msgstr ""

msgid ""
"2719    * [C.con: Containers and other resource handles](#SS-containers)"
msgstr ""

msgid "2720    * [C.lambdas: Function objects and lambdas](#SS-lambdas)"
msgstr ""

msgid "2721    * [C.hier: Class hierarchies (OOP)](#SS-hier)"
msgstr ""

msgid "2722    * [C.over: Overloading and overloaded operators](#SS-overload)"
msgstr ""

msgid "2723    * [C.union: Unions](#SS-union)"
msgstr ""

msgid ""
"2724    ### <a name=\"Rc-org\"></a>C.1: Organize related data into "
"structures (`struct`s or `class`es)"
msgstr ""

msgid "2725    ##### Reason"
msgstr ""

msgid "2726    Ease of comprehension."
msgstr ""

msgid ""
"2727    If data is related (for fundamental reasons), that fact should be "
"reflected in code."
msgstr ""

msgid "2728    ##### Example"
msgstr ""

msgid ""
"2729        void draw(int x, int y, int x2, int y2);  // BAD: unnecessary "
"implicit relationships"
msgstr ""

msgid "2730        void draw(Point from, Point to);          // better"
msgstr ""

msgid "2731    ##### Note"
msgstr ""

msgid ""
"2732    A simple class without virtual functions implies no space or time "
"overhead."
msgstr ""

msgid "2733    ##### Note"
msgstr ""

msgid ""
"2734    From a language perspective `class` and `struct` differ only in the "
"default visibility of their members."
msgstr ""

msgid "2735    ##### Enforcement"
msgstr ""

msgid ""
"2736    Probably impossible. Maybe a heuristic looking for data items used "
"together is possible."
msgstr ""

msgid ""
"2737    ### <a name=\"Rc-struct\"></a>C.2: Use `class` if the class has an "
"invariant; use `struct` if the data members can vary independently"
msgstr ""

msgid "2738    ##### Reason"
msgstr ""

msgid "2739    Readability."
msgstr ""

msgid "2740    Ease of comprehension."
msgstr ""

msgid ""
"2741    The use of `class` alerts the programmer to the need for an "
"invariant."
msgstr ""

msgid "2742    This is a useful convention."
msgstr ""

msgid "2743    ##### Note"
msgstr ""

msgid ""
"2744    An invariant is a logical condition for the members of an object "
"that a constructor must establish for the public member functions to assume."
msgstr ""

msgid ""
"2745    After the invariant is established (typically by a constructor) "
"every member function can be called for the object."
msgstr ""

msgid ""
"2746    An invariant can be stated informally (e.g., in a comment) or more "
"formally using `Expects`."
msgstr ""

msgid ""
"2747    If all data members can vary independently of each other, no "
"invariant is possible."
msgstr ""

msgid "2748    ##### Example"
msgstr ""

msgid "2749        struct Pair {  // the members can vary independently"
msgstr ""

msgid "2750            string name;"
msgstr ""

msgid "2751            int volume;"
msgstr ""

msgid "2752        };"
msgstr ""

msgid "2753    but:"
msgstr ""

msgid "2754        class Date {"
msgstr ""

msgid "2755        public:"
msgstr ""

msgid ""
"2756            // validate that {yy, mm, dd} is a valid date and initialize"
msgstr ""

msgid "2757            Date(int yy, Month mm, char dd);"
msgstr ""

msgid "2758            // ..."
msgstr ""

msgid "2759        private:"
msgstr ""

msgid "2760            int y;"
msgstr ""

msgid "2761            Month m;"
msgstr ""

msgid "2762            char d;    // day"
msgstr ""

msgid "2763        };"
msgstr ""

msgid "2764    ##### Note"
msgstr ""

msgid ""
"2765    If a class has any `private` data, a user cannot completely "
"initialize an object without the use of a constructor."
msgstr ""

msgid ""
"2766    Hence, the class definer will provide a constructor and must specify "
"its meaning."
msgstr ""

msgid ""
"2767    This effectively means the definer need to define an invariant."
msgstr ""

msgid "2768    **See also**:"
msgstr ""

msgid "2769    * [define a class with private data as `class`](#Rc-class)"
msgstr ""

msgid "2770    * [Prefer to place the interface first in a class](#Rl-order)"
msgstr ""

msgid "2771    * [minimize exposure of members](#Rc-private)"
msgstr ""

msgid "2772    * [Avoid `protected` data](#Rh-protected)"
msgstr ""

msgid "2773    ##### Enforcement"
msgstr ""

msgid ""
"2774    Look for `struct`s with all data private and `class`es with public "
"members."
msgstr ""

msgid ""
"2775    ### <a name=\"Rc-interface\"></a>C.3: Represent the distinction "
"between an interface and an implementation using a class"
msgstr ""

msgid "2776    ##### Reason"
msgstr ""

msgid ""
"2777    An explicit distinction between interface and implementation "
"improves readability and simplifies maintenance."
msgstr ""

msgid "2778    ##### Example"
msgstr ""

msgid "2779        class Date {"
msgstr ""

msgid "2780            // ... some representation ..."
msgstr ""

msgid "2781        public:"
msgstr ""

msgid "2782            Date();"
msgstr ""

msgid ""
"2783            // validate that {yy, mm, dd} is a valid date and initialize"
msgstr ""

msgid "2784            Date(int yy, Month mm, char dd);"
msgstr ""

msgid "2785            int day() const;"
msgstr ""

msgid "2786            Month month() const;"
msgstr ""

msgid "2787            // ..."
msgstr ""

msgid "2788        };"
msgstr ""

msgid ""
"2789    For example, we can now change the representation of a `Date` "
"without affecting its users (recompilation is likely, though)."
msgstr ""

msgid "2790    ##### Note"
msgstr ""

msgid ""
"2791    Using a class in this way to represent the distinction between "
"interface and implementation is of course not the only way."
msgstr ""

msgid ""
"2792    For example, we can use a set of declarations of freestanding "
"functions in a namespace, an abstract base class, or a template function "
"with concepts to represent an interface."
msgstr ""

msgid ""
"2793    The most important issue is to explicitly distinguish between an "
"interface and its implementation \"details.\""
msgstr ""

msgid ""
"2794    Ideally, and typically, an interface is far more stable than its "
"implementation(s)."
msgstr ""

msgid "2795    ##### Enforcement"
msgstr ""

msgid "2796    ???"
msgstr ""

msgid ""
"2797    ### <a name=\"Rc-member\"></a>C.4: Make a function a member only if "
"it needs direct access to the representation of a class"
msgstr ""

msgid "2798    ##### Reason"
msgstr ""

msgid ""
"2799    Less coupling than with member functions, fewer functions that can "
"cause trouble by modifying object state, reduces the number of functions "
"that needs to be modified after a change in representation."
msgstr ""

msgid "2800    ##### Example"
msgstr ""

msgid "2801        class Date {"
msgstr ""

msgid "2802            // ... relatively small interface ..."
msgstr ""

msgid "2803        };"
msgstr ""

msgid "2804        // helper functions:"
msgstr ""

msgid "2805        Date next_weekday(Date);"
msgstr ""

msgid "2806        bool operator==(Date, Date);"
msgstr ""

msgid ""
"2807    The \"helper functions\" have no need for direct access to the "
"representation of a `Date`."
msgstr ""

msgid "2808    ##### Note"
msgstr ""

msgid ""
"2809    This rule becomes even better if C++ gets [\"uniform function "
"call\"](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf)."
""
msgstr ""

msgid "2810    ##### Exception"
msgstr ""

msgid ""
"2811    The language requires `virtual` functions to be members, and not all "
"`virtual` functions directly access data."
msgstr ""

msgid "2812    In particular, members of an abstract class rarely do."
msgstr ""

msgid ""
"2813    Note [multi-methods](https://parasol.tamu.edu/~yuriys/papers/OMM10."
"pdf)."
msgstr ""

msgid "2814    ##### Exception"
msgstr ""

msgid ""
"2815    The language requires operators `=`, `()`, `[]`, and `->` to be "
"members."
msgstr ""

msgid "2816    ##### Exception"
msgstr ""

msgid ""
"2817    An overload set may have some members that do not directly access "
"`private` data:"
msgstr ""

msgid "2818        class Foobar {"
msgstr ""

msgid "2819        public:"
msgstr ""

msgid "2820            void foo(long x)    { /* manipulate private data */ }"
msgstr ""

msgid "2821            void foo(double x) { foo(std::lround(x)); }"
msgstr ""

msgid "2822            // ..."
msgstr ""

msgid "2823        private:"
msgstr ""

msgid "2824            // ..."
msgstr ""

msgid "2825        };"
msgstr ""

msgid ""
"2826    Similarly, a set of functions may be designed to be used in a chain:"
msgstr ""

msgid "2827        x.scale(0.5).rotate(45).set_color(Color::red);"
msgstr ""

msgid ""
"2828    Typically, some but not all of such functions directly access "
"`private` data."
msgstr ""

msgid "2829    ##### Enforcement"
msgstr ""

msgid ""
"2830    * Look for non-`virtual` member functions that do not touch data "
"members directly."
msgstr ""

msgid ""
"2831    The snag is that many member functions that do not need to touch "
"data members directly do."
msgstr ""

msgid "2832    * Ignore `virtual` functions."
msgstr ""

msgid ""
"2833    * Ignore functions that are part of an overload set out of which at "
"least one function accesses `private` members."
msgstr ""

msgid "2834    * Ignore functions returning `this`."
msgstr ""

msgid ""
"2835    ### <a name=\"Rc-helper\"></a>C.5: Place helper functions in the "
"same namespace as the class they support"
msgstr ""

msgid "2836    ##### Reason"
msgstr ""

msgid ""
"2837    A helper function is a function (usually supplied by the writer of a "
"class) that does not need direct access to the representation of the class, "
"yet is seen as part of the useful interface to the class."
msgstr ""

msgid ""
"2838    Placing them in the same namespace as the class makes their "
"relationship to the class obvious and allows them to be found by argument "
"dependent lookup."
msgstr ""

msgid "2839    ##### Example"
msgstr ""

msgid "2840        namespace Chrono { // here we keep time-related services"
msgstr ""

msgid "2841            class Time { /* ... */ };"
msgstr ""

msgid "2842            class Date { /* ... */ };"
msgstr ""

msgid "2843            // helper functions:"
msgstr ""

msgid "2844            bool operator==(Date, Date);"
msgstr ""

msgid "2845            Date next_weekday(Date);"
msgstr ""

msgid "2846            // ..."
msgstr ""

msgid "2847        }"
msgstr ""

msgid "2848    ##### Note"
msgstr ""

msgid ""
"2849    This is especially important for [overloaded operators](#Ro-"
"namespace)."
msgstr ""

msgid "2850    ##### Enforcement"
msgstr ""

msgid ""
"2851    * Flag global functions taking argument types from a single "
"namespace."
msgstr ""

msgid ""
"2852    ### <a name=\"Rc-standalone\"></a>C.7: Don't define a class or enum "
"and declare a variable of its type in the same statement"
msgstr ""

msgid "2853    ##### Reason"
msgstr ""

msgid ""
"2854    Mixing a type definition and the definition of another entity in the "
"same declaration is confusing and unnecessary."
msgstr ""

msgid "2855    ##### Example; bad"
msgstr ""

msgid "2856        struct Data { /*...*/ } data{ /*...*/ };"
msgstr ""

msgid "2857    ##### Example; good"
msgstr ""

msgid "2858        struct Data { /*...*/ };"
msgstr ""

msgid "2859        Data data{ /*...*/ };"
msgstr ""

msgid "2860    ##### Enforcement"
msgstr ""

msgid ""
"2861    * Flag if the `}` of a class or enumeration definition is not "
"followed by a `;`. The `;` is missing."
msgstr ""

msgid ""
"2862    ### <a name=\"Rc-class\"></a>C.8: Use `class` rather than `struct` "
"if any member is non-public"
msgstr ""

msgid "2863    ##### Reason"
msgstr ""

msgid "2864    Readability."
msgstr ""

msgid "2865    To make it clear that something is being hidden/abstracted."
msgstr ""

msgid "2866    This is a useful convention."
msgstr ""

msgid "2867    ##### Example, bad"
msgstr ""

msgid "2868        struct Date {"
msgstr ""

msgid "2869            int d, m;"
msgstr ""

msgid "2870            Date(int i, Month m);"
msgstr ""

msgid "2871            // ... lots of functions ..."
msgstr ""

msgid "2872        private:"
msgstr ""

msgid "2873            int y;  // year"
msgstr ""

msgid "2874        };"
msgstr ""

msgid ""
"2875    There is nothing wrong with this code as far as the C++ language "
"rules are concerned,"
msgstr ""

msgid "2876    but nearly everything is wrong from a design perspective."
msgstr ""

msgid "2877    The private data is hidden far from the public data."
msgstr ""

msgid "2878    The data is split in different parts of the class declaration."
msgstr ""

msgid "2879    Different parts of the data have different access."
msgstr ""

msgid "2880    All of this decreases readability and complicates maintenance."
msgstr ""

msgid "2881    ##### Note"
msgstr ""

msgid ""
"2882    Prefer to place the interface first in a class, [see NL.16](#Rl-"
"order)."
msgstr ""

msgid "2883    ##### Enforcement"
msgstr ""

msgid ""
"2884    Flag classes declared with `struct` if there is a `private` or "
"`protected` member."
msgstr ""

msgid "2885    ### <a name=\"Rc-private\"></a>C.9: Minimize exposure of members"
msgstr ""

msgid "2886    ##### Reason"
msgstr ""

msgid "2887    Encapsulation."
msgstr ""

msgid "2888    Information hiding."
msgstr ""

msgid "2889    Minimize the chance of unintended access."
msgstr ""

msgid "2890    This simplifies maintenance."
msgstr ""

msgid "2891    ##### Example"
msgstr ""

msgid "2892        template<typename T, typename U>"
msgstr ""

msgid "2893        struct pair {"
msgstr ""

msgid "2894            T a;"
msgstr ""

msgid "2895            U b;"
msgstr ""

msgid "2896            // ..."
msgstr ""

msgid "2897        };"
msgstr ""

msgid ""
"2898    Whatever we do in the `//`-part, an arbitrary user of a `pair` can "
"arbitrarily and independently change its `a` and `b`."
msgstr ""

msgid ""
"2899    In a large code base, we cannot easily find which code does what to "
"the members of `pair`."
msgstr ""

msgid ""
"2900    This may be exactly what we want, but if we want to enforce a "
"relation among members, we need to make them `private`"
msgstr ""

msgid ""
"2901    and enforce that relation (invariant) through constructors and "
"member functions."
msgstr ""

msgid "2902    For example:"
msgstr ""

msgid "2903        class Distance {"
msgstr ""

msgid "2904        public:"
msgstr ""

msgid "2905            // ..."
msgstr ""

msgid "2906            double meters() const { return magnitude*unit; }"
msgstr ""

msgid "2907            void set_unit(double u)"
msgstr ""

msgid "2908            {"
msgstr ""

msgid "2909                    // ... check that u is a factor of 10 ..."
msgstr ""

msgid "2910                    // ... change magnitude appropriately ..."
msgstr ""

msgid "2911                    unit = u;"
msgstr ""

msgid "2912            }"
msgstr ""

msgid "2913            // ..."
msgstr ""

msgid "2914        private:"
msgstr ""

msgid "2915            double magnitude;"
msgstr ""

msgid ""
"2916            double unit;    // 1 is meters, 1000 is kilometers, 0.001 is "
"millimeters, etc."
msgstr ""

msgid "2917        };"
msgstr ""

msgid "2918    ##### Note"
msgstr ""

msgid ""
"2919    If the set of direct users of a set of variables cannot be easily "
"determined, the type or usage of that set cannot be (easily) changed/"
"improved."
msgstr ""

msgid "2920    For `public` and `protected` data, that's usually the case."
msgstr ""

msgid "2921    ##### Example"
msgstr ""

msgid "2922    A class can provide two interfaces to its users."
msgstr ""

msgid ""
"2923    One for derived classes (`protected`) and one for general users "
"(`public`)."
msgstr ""

msgid ""
"2924    For example, a derived class might be allowed to skip a run-time "
"check because it has already guaranteed correctness:"
msgstr ""

msgid "2925        class Foo {"
msgstr ""

msgid "2926        public:"
msgstr ""

msgid "2927            int bar(int x) { check(x); return do_bar(x); }"
msgstr ""

msgid "2928            // ..."
msgstr ""

msgid "2929        protected:"
msgstr ""

msgid "2930            int do_bar(int x); // do some operation on the data"
msgstr ""

msgid "2931            // ..."
msgstr ""

msgid "2932        private:"
msgstr ""

msgid "2933            // ... data ..."
msgstr ""

msgid "2934        };"
msgstr ""

msgid "2935        class Dir : public Foo {"
msgstr ""

msgid "2936            //..."
msgstr ""

msgid "2937            int mem(int x, int y)"
msgstr ""

msgid "2938            {"
msgstr ""

msgid "2939                /* ... do something ... */"
msgstr ""

msgid ""
"2940                return do_bar(x + y); // OK: derived class can bypass "
"check"
msgstr ""

msgid "2941            }"
msgstr ""

msgid "2942        };"
msgstr ""

msgid "2943        void user(Foo& x)"
msgstr ""

msgid "2944        {"
msgstr ""

msgid "2945            int r1 = x.bar(1);      // OK, will check"
msgstr ""

msgid "2946            int r2 = x.do_bar(2);   // error: would bypass check"
msgstr ""

msgid "2947            // ..."
msgstr ""

msgid "2948        }"
msgstr ""

msgid "2949    ##### Note"
msgstr ""

msgid "2950    [`protected` data is a bad idea](#Rh-protected)."
msgstr ""

msgid "2951    ##### Note"
msgstr ""

msgid ""
"2952    Prefer the order `public` members before `protected` members before "
"`private` members [see](#Rl-order)."
msgstr ""

msgid "2953    ##### Enforcement"
msgstr ""

msgid "2954    * [Flag protected data](#Rh-protected)."
msgstr ""

msgid "2955    * Flag mixtures of `public` and private `data`"
msgstr ""

msgid "2956    ## <a name=\"SS-concrete\"></a>C.concrete: Concrete types"
msgstr ""

msgid "2957    One ideal for a class is to be a regular type."
msgstr ""

msgid ""
"2958    That means roughly \"behaves like an `int`.\" A concrete type is the "
"simplest kind of class."
msgstr ""

msgid ""
"2959    A value of regular type can be copied and the result of a copy is an "
"independent object with the same value as the original."
msgstr ""

msgid ""
"2960    If a concrete type has both `=` and `==`, `a = b` should result in "
"`a == b` being `true`."
msgstr ""

msgid ""
"2961    Concrete classes without assignment and equality can be defined, but "
"they are (and should be) rare."
msgstr ""

msgid ""
"2962    The C++ built-in types are regular, and so are standard-library "
"classes, such as `string`, `vector`, and `map`."
msgstr ""

msgid ""
"2963    Concrete types are also often referred to as value types to "
"distinguish them from types used as part of a hierarchy."
msgstr ""

msgid "2964    Concrete type rule summary:"
msgstr ""

msgid ""
"2965    * [C.10: Prefer concrete types over class hierarchies](#Rc-concrete)"
msgstr ""

msgid "2966    * [C.11: Make concrete types regular](#Rc-regular)"
msgstr ""

msgid ""
"2967    ### <a name=\"Rc-concrete\"></a>C.10: Prefer concrete types over "
"class hierarchies"
msgstr ""

msgid "2968    ##### Reason"
msgstr ""

msgid "2969    A concrete type is fundamentally simpler than a hierarchy:"
msgstr ""

msgid ""
"2970    easier to design, easier to implement, easier to use, easier to "
"reason about, smaller, and faster."
msgstr ""

msgid "2971    You need a reason (use cases) for using a hierarchy."
msgstr ""

msgid "2972    ##### Example"
msgstr ""

msgid "2973        class Point1 {"
msgstr ""

msgid "2974            int x, y;"
msgstr ""

msgid "2975            // ... operations ..."
msgstr ""

msgid "2976            // ... no virtual functions ..."
msgstr ""

msgid "2977        };"
msgstr ""

msgid "2978        class Point2 {"
msgstr ""

msgid "2979            int x, y;"
msgstr ""

msgid "2980            // ... operations, some virtual ..."
msgstr ""

msgid "2981            virtual ~Point2();"
msgstr ""

msgid "2982        };"
msgstr ""

msgid "2983        void use()"
msgstr ""

msgid "2984        {"
msgstr ""

msgid "2985            Point1 p11 {1, 2};   // make an object on the stack"
msgstr ""

msgid "2986            Point1 p12 {p11};    // a copy"
msgstr ""

msgid ""
"2987            auto p21 = make_unique<Point2>(1, 2);   // make an object on "
"the free store"
msgstr ""

msgid "2988            auto p22 = p21.clone();                 // make a copy"
msgstr ""

msgid "2989            // ..."
msgstr ""

msgid "2990        }"
msgstr ""

msgid ""
"2991    If a class can be part of a hierarchy, we (in real code if not "
"necessarily in small examples) must manipulate its objects through pointers "
"or references."
msgstr ""

msgid ""
"2992    That implies more memory overhead, more allocations and "
"deallocations, and more run-time overhead to perform the resulting "
"indirections."
msgstr ""

msgid "2993    ##### Note"
msgstr ""

msgid ""
"2994    Concrete types can be stack-allocated and be members of other "
"classes."
msgstr ""

msgid "2995    ##### Note"
msgstr ""

msgid ""
"2996    The use of indirection is fundamental for run-time polymorphic "
"interfaces."
msgstr ""

msgid ""
"2997    The allocation/deallocation overhead is not (that's just the most "
"common case)."
msgstr ""

msgid ""
"2998    We can use a base class as the interface of a scoped object of a "
"derived class."
msgstr ""

msgid ""
"2999    This is done where dynamic allocation is prohibited (e.g. hard-real-"
"time) and to provide a stable interface to some kinds of plug-ins."
msgstr ""

msgid "3000    ##### Enforcement"
msgstr ""

msgid "3001    ???"
msgstr ""

msgid "3002    ### <a name=\"Rc-regular\"></a>C.11: Make concrete types regular"
msgstr ""

msgid "3003    ##### Reason"
msgstr ""

msgid ""
"3004    Regular types are easier to understand and reason about than types "
"that are not regular (irregularities requires extra effort to understand and "
"use)."
msgstr ""

msgid "3005    ##### Example"
msgstr ""

msgid "3006        struct Bundle {"
msgstr ""

msgid "3007            string name;"
msgstr ""

msgid "3008            vector<Record> vr;"
msgstr ""

msgid "3009        };"
msgstr ""

msgid "3010        bool operator==(const Bundle& a, const Bundle& b)"
msgstr ""

msgid "3011        {"
msgstr ""

msgid "3012            return a.name == b.name && a.vr == b.vr;"
msgstr ""

msgid "3013        }"
msgstr ""

msgid "3014        Bundle b1 { \"my bundle\", {r1, r2, r3}};"
msgstr ""

msgid "3015        Bundle b2 = b1;"
msgstr ""

msgid "3016        if (!(b1 == b2)) error(\"impossible!\");"
msgstr ""

msgid "3017        b2.name = \"the other bundle\";"
msgstr ""

msgid "3018        if (b1 == b2) error(\"No!\");"
msgstr ""

msgid ""
"3019    In particular, if a concrete type has an assignment also give it an "
"equals operator so that `a = b` implies `a == b`."
msgstr ""

msgid "3020    ##### Enforcement"
msgstr ""

msgid "3021    ???"
msgstr ""

msgid ""
"3022    ## <a name=\"S-ctor\"></a>C.ctor: Constructors, assignments, and "
"destructors"
msgstr ""

msgid ""
"3023    These functions control the lifecycle of objects: creation, copy, "
"move, and destruction."
msgstr ""

msgid ""
"3024    Define constructors to guarantee and simplify initialization of "
"classes."
msgstr ""

msgid "3025    These are *default operations*:"
msgstr ""

msgid "3026    * a default constructor: `X()`"
msgstr ""

msgid "3027    * a copy constructor: `X(const X&)`"
msgstr ""

msgid "3028    * a copy assignment: `operator=(const X&)`"
msgstr ""

msgid "3029    * a move constructor: `X(X&&)`"
msgstr ""

msgid "3030    * a move assignment: `operator=(X&&)`"
msgstr ""

msgid "3031    * a destructor: `~X()`"
msgstr ""

msgid ""
"3032    By default, the compiler defines each of these operations if it is "
"used, but the default can be suppressed."
msgstr ""

msgid ""
"3033    The default operations are a set of related operations that together "
"implement the lifecycle semantics of an object."
msgstr ""

msgid ""
"3034    By default, C++ treats classes as value-like types, but not all "
"types are value-like."
msgstr ""

msgid "3035    Set of default operations rules:"
msgstr ""

msgid ""
"3036    * [C.20: If you can avoid defining any default operations, do](#Rc-"
"zero)"
msgstr ""

msgid ""
"3037    * [C.21: If you define or `=delete` any default operation, define or "
"`=delete` them all](#Rc-five)"
msgstr ""

msgid "3038    * [C.22: Make default operations consistent](#Rc-matched)"
msgstr ""

msgid "3039    Destructor rules:"
msgstr ""

msgid ""
"3040    * [C.30: Define a destructor if a class needs an explicit action at "
"object destruction](#Rc-dtor)"
msgstr ""

msgid ""
"3041    * [C.31: All resources acquired by a class must be released by the "
"class's destructor](#Rc-dtor-release)"
msgstr ""

msgid ""
"3042    * [C.32: If a class has a raw pointer (`T*`) or reference (`T&`), "
"consider whether it might be owning](#Rc-dtor-ptr)"
msgstr ""

msgid ""
"3043    * [C.33: If a class has an owning pointer member, define or `="
"delete` a destructor](#Rc-dtor-ptr2)"
msgstr ""

msgid ""
"3044    * [C.35: A base class with a virtual function needs a virtual "
"destructor](#Rc-dtor-virtual)"
msgstr ""

msgid "3045    * [C.36: A destructor may not fail](#Rc-dtor-fail)"
msgstr ""

msgid "3046    * [C.37: Make destructors `noexcept`](#Rc-dtor-noexcept)"
msgstr ""

msgid "3047    Constructor rules:"
msgstr ""

msgid ""
"3048    * [C.40: Define a constructor if a class has an invariant](#Rc-ctor)"
msgstr ""

msgid ""
"3049    * [C.41: A constructor should create a fully initialized object](#Rc-"
"complete)"
msgstr ""

msgid ""
"3050    * [C.42: If a constructor cannot construct a valid object, throw an "
"exception](#Rc-throw)"
msgstr ""

msgid ""
"3051    * [C.43: Ensure that a copyable (value type) class has a default "
"constructor](#Rc-default0)"
msgstr ""

msgid ""
"3052    * [C.44: Prefer default constructors to be simple and non-"
"throwing](#Rc-default00)"
msgstr ""

msgid ""
"3053    * [C.45: Don't define a default constructor that only initializes "
"data members; use member initializers instead](#Rc-default)"
msgstr ""

msgid ""
"3054    * [C.46: By default, declare single-argument constructors "
"`explicit`](#Rc-explicit)"
msgstr ""

msgid ""
"3055    * [C.47: Define and initialize member variables in the order of "
"member declaration](#Rc-order)"
msgstr ""

msgid ""
"3056    * [C.48: Prefer in-class initializers to member initializers in "
"constructors for constant initializers](#Rc-in-class-initializer)"
msgstr ""

msgid ""
"3057    * [C.49: Prefer initialization to assignment in constructors](#Rc-"
"initialize)"
msgstr ""

msgid ""
"3058    * [C.50: Use a factory function if you need \"virtual behavior\" "
"during initialization](#Rc-factory)"
msgstr ""

msgid ""
"3059    * [C.51: Use delegating constructors to represent common actions for "
"all constructors of a class](#Rc-delegating)"
msgstr ""

msgid ""
"3060    * [C.52: Use inheriting constructors to import constructors into a "
"derived class that does not need further explicit initialization](#Rc-"
"inheriting)"
msgstr ""

msgid "3061    Copy and move rules:"
msgstr ""

msgid ""
"3062    * [C.60: Make copy assignment non-`virtual`, take the parameter by "
"`const&`, and return by non-`const&`](#Rc-copy-assignment)"
msgstr ""

msgid "3063    * [C.61: A copy operation should copy](#Rc-copy-semantic)"
msgstr ""

msgid ""
"3064    * [C.62: Make copy assignment safe for self-assignment](#Rc-copy-"
"self)"
msgstr ""

msgid ""
"3065    * [C.63: Make move assignment non-`virtual`, take the parameter by "
"`&&`, and return by non-`const&`](#Rc-move-assignment)"
msgstr ""

msgid ""
"3066    * [C.64: A move operation should move and leave its source in a "
"valid state](#Rc-move-semantic)"
msgstr ""

msgid ""
"3067    * [C.65: Make move assignment safe for self-assignment](#Rc-move-"
"self)"
msgstr ""

msgid "3068    * [C.66: Make move operations `noexcept`](#Rc-move-noexcept)"
msgstr ""

msgid ""
"3069    * [C.67: A polymorphic class should suppress copying](#Rc-copy-"
"virtual)"
msgstr ""

msgid "3070    Other default operations rules:"
msgstr ""

msgid ""
"3071    * [C.80: Use `=default` if you have to be explicit about using the "
"default semantics](#Rc-eqdefault)"
msgstr ""

msgid ""
"3072    * [C.81: Use `=delete` when you want to disable default behavior "
"(without wanting an alternative)](#Rc-delete)"
msgstr ""

msgid ""
"3073    * [C.82: Don't call virtual functions in constructors and "
"destructors](#Rc-ctor-virtual)"
msgstr ""

msgid ""
"3074    * [C.83: For value-like types, consider providing a `noexcept` swap "
"function](#Rc-swap)"
msgstr ""

msgid "3075    * [C.84: A `swap` may not fail](#Rc-swap-fail)"
msgstr ""

msgid "3076    * [C.85: Make `swap` `noexcept`](#Rc-swap-noexcept)"
msgstr ""

msgid ""
"3077    * [C.86: Make `==` symmetric with respect of operand types and "
"`noexcept`](#Rc-eq)"
msgstr ""

msgid "3078    * [C.87: Beware of `==` on base classes](#Rc-eq-base)"
msgstr ""

msgid "3079    * [C.89: Make a `hash` `noexcept`](#Rc-hash)"
msgstr ""

msgid "3080    ## <a name=\"SS-defop\"></a>C.defop: Default Operations"
msgstr ""

msgid ""
"3081    By default, the language supplies the default operations with their "
"default semantics."
msgstr ""

msgid "3082    However, a programmer can disable or replace these defaults."
msgstr ""

msgid ""
"3083    ### <a name=\"Rc-zero\"></a>C.20: If you can avoid defining default "
"operations, do"
msgstr ""

msgid "3084    ##### Reason"
msgstr ""

msgid "3085    It's the simplest and gives the cleanest semantics."
msgstr ""

msgid "3086    ##### Example"
msgstr ""

msgid "3087        struct Named_map {"
msgstr ""

msgid "3088        public:"
msgstr ""

msgid "3089            // ... no default operations declared ..."
msgstr ""

msgid "3090        private:"
msgstr ""

msgid "3091            string name;"
msgstr ""

msgid "3092            map<int, int> rep;"
msgstr ""

msgid "3093        };"
msgstr ""

msgid "3094        Named_map nm;        // default construct"
msgstr ""

msgid "3095        Named_map nm2 {nm};  // copy construct"
msgstr ""

msgid ""
"3096    Since `std::map` and `string` have all the special functions, no "
"further work is needed."
msgstr ""

msgid "3097    ##### Note"
msgstr ""

msgid "3098    This is known as \"the rule of zero\"."
msgstr ""

msgid "3099    ##### Enforcement"
msgstr ""

msgid ""
"3100    (Not enforceable) While not enforceable, a good static analyzer can "
"detect patterns that indicate a possible improvement to meet this rule."
msgstr ""

msgid ""
"3101    For example, a class with a (pointer, size) pair of member and a "
"destructor that `delete`s the pointer could probably be converted to a "
"`vector`."
msgstr ""

msgid ""
"3102    ### <a name=\"Rc-five\"></a>C.21: If you define or `=delete` any "
"default operation, define or `=delete` them all"
msgstr ""

msgid "3103    ##### Reason"
msgstr ""

msgid ""
"3104    The *special member functions* are the default constructor, copy "
"constructor,"
msgstr ""

msgid ""
"3105    copy assignment operator, move constructor, move assignment "
"operator, and"
msgstr ""

msgid "3106    destructor."
msgstr ""

msgid ""
"3107    The semantics of the special functions are closely related, so if "
"one needs to be declared, the odds are that others need consideration too."
msgstr ""

msgid ""
"3108    Declaring any special member function except a default constructor,"
msgstr ""

msgid ""
"3109    even as `=default` or `=delete`, will suppress the implicit "
"declaration"
msgstr ""

msgid "3110    of a move constructor and move assignment operator."
msgstr ""

msgid ""
"3111    Declaring a move constructor or move assignment operator, even as"
msgstr ""

msgid ""
"3112    `=default` or `=delete`, will cause an implicitly generated copy "
"constructor"
msgstr ""

msgid ""
"3113    or implicitly generated copy assignment operator to be defined as "
"deleted."
msgstr ""

msgid ""
"3114    So as soon as any of the special functions is declared, the others "
"should"
msgstr ""

msgid ""
"3115    all be declared to avoid unwanted effects like turning all potential "
"moves"
msgstr ""

msgid "3116    into more expensive copies, or making a class move-only."
msgstr ""

msgid "3117    ##### Example, bad"
msgstr ""

msgid "3118        struct M2 {   // bad: incomplete set of default operations"
msgstr ""

msgid "3119        public:"
msgstr ""

msgid "3120            // ..."
msgstr ""

msgid "3121            // ... no copy or move operations ..."
msgstr ""

msgid "3122            ~M2() { delete[] rep; }"
msgstr ""

msgid "3123        private:"
msgstr ""

msgid "3124            pair<int, int>* rep;  // zero-terminated set of pairs"
msgstr ""

msgid "3125        };"
msgstr ""

msgid "3126        void use()"
msgstr ""

msgid "3127        {"
msgstr ""

msgid "3128            M2 x;"
msgstr ""

msgid "3129            M2 y;"
msgstr ""

msgid "3130            // ..."
msgstr ""

msgid "3131            x = y;   // the default assignment"
msgstr ""

msgid "3132            // ..."
msgstr ""

msgid "3133        }"
msgstr ""

msgid ""
"3134    Given that \"special attention\" was needed for the destructor "
"(here, to deallocate), the likelihood that copy and move assignment (both "
"will implicitly destroy an object) are correct is low (here, we would get "
"double deletion)."
msgstr ""

msgid "3135    ##### Note"
msgstr ""

msgid ""
"3136    This is known as \"the rule of five\" or \"the rule of six\", "
"depending on whether you count the default constructor."
msgstr ""

msgid "3137    ##### Note"
msgstr ""

msgid ""
"3138    If you want a default implementation of a default operation (while "
"defining another), write `=default` to show you're doing so intentionally "
"for that function."
msgstr ""

msgid ""
"3139    If you don't want a default operation, suppress it with `=delete`."
msgstr ""

msgid "3140    ##### Example, good"
msgstr ""

msgid ""
"3141    When a destructor needs to be declared just to make it `virtual`, it "
"can be"
msgstr ""

msgid ""
"3142    defined as defaulted. To avoid suppressing the implicit move "
"operations"
msgstr ""

msgid ""
"3143    they must also be declared, and then to avoid the class becoming "
"move-only"
msgstr ""

msgid "3144    (and not copyable) the copy operations must be declared:"
msgstr ""

msgid "3145        class AbstractBase {"
msgstr ""

msgid "3146        public:"
msgstr ""

msgid "3147          virtual ~AbstractBase() = default;"
msgstr ""

msgid "3148          AbstractBase(const AbstractBase&) = default;"
msgstr ""

msgid "3149          AbstractBase& operator=(const AbstractBase&) = default;"
msgstr ""

msgid "3150          AbstractBase(AbstractBase&&) = default;"
msgstr ""

msgid "3151          AbstractBase& operator=(AbstractBase&&) = default;"
msgstr ""

msgid "3152        };"
msgstr ""

msgid ""
"3153    Alternatively to prevent slicing as per [C.67](#Rc-copy-virtual),"
msgstr ""

msgid "3154    the copy and move operations can all be deleted:"
msgstr ""

msgid "3155        class ClonableBase {"
msgstr ""

msgid "3156        public:"
msgstr ""

msgid "3157          virtual unique_ptr<ClonableBase> clone() const;"
msgstr ""

msgid "3158          virtual ~ClonableBase() = default;"
msgstr ""

msgid "3159          ClonableBase(const ClonableBase&) = delete;"
msgstr ""

msgid "3160          ClonableBase& operator=(const ClonableBase&) = delete;"
msgstr ""

msgid "3161          ClonableBase(ClonableBase&&) = delete;"
msgstr ""

msgid "3162          ClonableBase& operator=(ClonableBase&&) = delete;"
msgstr ""

msgid "3163        };"
msgstr ""

msgid ""
"3164    Defining only the move operations or only the copy operations would "
"have the"
msgstr ""

msgid ""
"3165    same effect here, but stating the intent explicitly for each special "
"member"
msgstr ""

msgid "3166    makes it more obvious to the reader."
msgstr ""

msgid "3167    ##### Note"
msgstr ""

msgid ""
"3168    Compilers enforce much of this rule and ideally warn about any "
"violation."
msgstr ""

msgid "3169    ##### Note"
msgstr ""

msgid ""
"3170    Relying on an implicitly generated copy operation in a class with a "
"destructor is deprecated."
msgstr ""

msgid "3171    ##### Enforcement"
msgstr ""

msgid ""
"3172    (Simple) A class should have a declaration (even a `=delete` one) "
"for either all or none of the special functions."
msgstr ""

msgid ""
"3173    ### <a name=\"Rc-matched\"></a>C.22: Make default operations "
"consistent"
msgstr ""

msgid "3174    ##### Reason"
msgstr ""

msgid ""
"3175    The default operations are conceptually a matched set. Their "
"semantics are interrelated."
msgstr ""

msgid ""
"3176    Users will be surprised if copy/move construction and copy/move "
"assignment do logically different things. Users will be surprised if "
"constructors and destructors do not provide a consistent view of resource "
"management. Users will be surprised if copy and move don't reflect the way "
"constructors and destructors work."
msgstr ""

msgid "3177    ##### Example, bad"
msgstr ""

msgid "3178        class Silly {   // BAD: Inconsistent copy operations"
msgstr ""

msgid "3179            class Impl {"
msgstr ""

msgid "3180                // ..."
msgstr ""

msgid "3181            };"
msgstr ""

msgid "3182            shared_ptr<Impl> p;"
msgstr ""

msgid "3183        public:"
msgstr ""

msgid ""
"3184            Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // deep copy"
msgstr ""

msgid ""
"3185            Silly& operator=(const Silly& a) { p = a.p; }   // shallow "
"copy"
msgstr ""

msgid "3186            // ..."
msgstr ""

msgid "3187        };"
msgstr ""

msgid ""
"3188    These operations disagree about copy semantics. This will lead to "
"confusion and bugs."
msgstr ""

msgid "3189    ##### Enforcement"
msgstr ""

msgid ""
"3190    * (Complex) A copy/move constructor and the corresponding copy/move "
"assignment operator should write to the same member variables at the same "
"level of dereference."
msgstr ""

msgid ""
"3191    * (Complex) Any member variables written in a copy/move constructor "
"should also be initialized by all other constructors."
msgstr ""

msgid ""
"3192    * (Complex) If a copy/move constructor performs a deep copy of a "
"member variable, then the destructor should modify the member variable."
msgstr ""

msgid ""
"3193    * (Complex) If a destructor is modifying a member variable, that "
"member variable should be written in any copy/move constructors or "
"assignment operators."
msgstr ""

msgid "3194    ## <a name=\"SS-dtor\"></a>C.dtor: Destructors"
msgstr ""

msgid ""
"3195    \"Does this class need a destructor?\" is a surprisingly powerful "
"design question."
msgstr ""

msgid ""
"3196    For most classes the answer is \"no\" either because the class holds "
"no resources or because destruction is handled by [the rule of zero](#Rc-"
"zero);"
msgstr ""

msgid ""
"3197    that is, its members can take care of themselves as concerns "
"destruction."
msgstr ""

msgid ""
"3198    If the answer is \"yes\", much of the design of the class follows "
"(see [the rule of five](#Rc-five))."
msgstr ""

msgid ""
"3199    ### <a name=\"Rc-dtor\"></a>C.30: Define a destructor if a class "
"needs an explicit action at object destruction"
msgstr ""

msgid "3200    ##### Reason"
msgstr ""

msgid ""
"3201    A destructor is implicitly invoked at the end of an object's "
"lifetime."
msgstr ""

msgid "3202    If the default destructor is sufficient, use it."
msgstr ""

msgid ""
"3203    Only define a non-default destructor if a class needs to execute "
"code that is not already part of its members' destructors."
msgstr ""

msgid "3204    ##### Example"
msgstr ""

msgid "3205        template<typename A>"
msgstr ""

msgid "3206        struct final_action {   // slightly simplified"
msgstr ""

msgid "3207            A act;"
msgstr ""

msgid "3208            final_action(A a) :act{a} {}"
msgstr ""

msgid "3209            ~final_action() { act(); }"
msgstr ""

msgid "3210        };"
msgstr ""

msgid "3211        template<typename A>"
msgstr ""

msgid "3212        final_action<A> finally(A act)   // deduce action type"
msgstr ""

msgid "3213        {"
msgstr ""

msgid "3214            return final_action<A>{act};"
msgstr ""

msgid "3215        }"
msgstr ""

msgid "3216        void test()"
msgstr ""

msgid "3217        {"
msgstr ""

msgid ""
"3218            auto act = finally([]{ cout << \"Exit test\\n\"; });  // "
"establish exit action"
msgstr ""

msgid "3219            // ..."
msgstr ""

msgid "3220            if (something) return;   // act done here"
msgstr ""

msgid "3221            // ..."
msgstr ""

msgid "3222        } // act done here"
msgstr ""

msgid ""
"3223    The whole purpose of `final_action` is to get a piece of code "
"(usually a lambda) executed upon destruction."
msgstr ""

msgid "3224    ##### Note"
msgstr ""

msgid ""
"3225    There are two general categories of classes that need a user-defined "
"destructor:"
msgstr ""

msgid ""
"3226    * A class with a resource that is not already represented as a class "
"with a destructor, e.g., a `vector` or a transaction class."
msgstr ""

msgid ""
"3227    * A class that exists primarily to execute an action upon "
"destruction, such as a tracer or `final_action`."
msgstr ""

msgid "3228    ##### Example, bad"
msgstr ""

msgid "3229        class Foo {   // bad; use the default destructor"
msgstr ""

msgid "3230        public:"
msgstr ""

msgid "3231            // ..."
msgstr ""

msgid "3232            ~Foo() { s = \"\"; i = 0; vi.clear(); }  // clean up"
msgstr ""

msgid "3233        private:"
msgstr ""

msgid "3234            string s;"
msgstr ""

msgid "3235            int i;"
msgstr ""

msgid "3236            vector<int> vi;"
msgstr ""

msgid "3237        };"
msgstr ""

msgid ""
"3238    The default destructor does it better, more efficiently, and can't "
"get it wrong."
msgstr ""

msgid "3239    ##### Note"
msgstr ""

msgid ""
"3240    If the default destructor is needed, but its generation has been "
"suppressed (e.g., by defining a move constructor), use `=default`."
msgstr ""

msgid "3241    ##### Enforcement"
msgstr ""

msgid ""
"3242    Look for likely \"implicit resources\", such as pointers and "
"references. Look for classes with destructors even though all their data "
"members have destructors."
msgstr ""

msgid ""
"3243    ### <a name=\"Rc-dtor-release\"></a>C.31: All resources acquired by "
"a class must be released by the class's destructor"
msgstr ""

msgid "3244    ##### Reason"
msgstr ""

msgid "3245    Prevention of resource leaks, especially in error cases."
msgstr ""

msgid "3246    ##### Note"
msgstr ""

msgid ""
"3247    For resources represented as classes with a complete set of default "
"operations, this happens automatically."
msgstr ""

msgid "3248    ##### Example"
msgstr ""

msgid "3249        class X {"
msgstr ""

msgid "3250            ifstream f;   // may own a file"
msgstr ""

msgid "3251            // ... no default operations defined or =deleted ..."
msgstr ""

msgid "3252        };"
msgstr ""

msgid ""
"3253    `X`'s `ifstream` implicitly closes any file it may have open upon "
"destruction of its `X`."
msgstr ""

msgid "3254    ##### Example, bad"
msgstr ""

msgid "3255        class X2 {     // bad"
msgstr ""

msgid "3256            FILE* f;   // may own a file"
msgstr ""

msgid "3257            // ... no default operations defined or =deleted ..."
msgstr ""

msgid "3258        };"
msgstr ""

msgid "3259    `X2` may leak a file handle."
msgstr ""

msgid "3260    ##### Note"
msgstr ""

msgid ""
"3261    What about a sockets that won't close? A destructor, close, or "
"cleanup operation [should never fail](#Rc-dtor-fail)."
msgstr ""

msgid ""
"3262    If it does nevertheless, we have a problem that has no really good "
"solution."
msgstr ""

msgid ""
"3263    For starters, the writer of a destructor does not know why the "
"destructor is called and cannot \"refuse to act\" by throwing an exception."
msgstr ""

msgid "3264    See [discussion](#Sd-never-fail)."
msgstr ""

msgid ""
"3265    To make the problem worse, many \"close/release\" operations are not "
"retryable."
msgstr ""

msgid ""
"3266    Many have tried to solve this problem, but no general solution is "
"known."
msgstr ""

msgid ""
"3267    If at all possible, consider failure to close/cleanup a fundamental "
"design error and terminate."
msgstr ""

msgid "3268    ##### Note"
msgstr ""

msgid ""
"3269    A class can hold pointers and references to objects that it does not "
"own."
msgstr ""

msgid ""
"3270    Obviously, such objects should not be `delete`d by the class's "
"destructor."
msgstr ""

msgid "3271    For example:"
msgstr ""

msgid "3272        Preprocessor pp { /* ... */ };"
msgstr ""

msgid "3273        Parser p { pp, /* ... */ };"
msgstr ""

msgid "3274        Type_checker tc { p, /* ... */ };"
msgstr ""

msgid "3275    Here `p` refers to `pp` but does not own it."
msgstr ""

msgid "3276    ##### Enforcement"
msgstr ""

msgid ""
"3277    * (Simple) If a class has pointer or reference member variables that "
"are owners"
msgstr ""

msgid ""
"3278      (e.g., deemed owners by using `gsl::owner`), then they should be "
"referenced in its destructor."
msgstr ""

msgid ""
"3279    * (Hard) Determine if pointer or reference member variables are "
"owners when there is no explicit statement of ownership"
msgstr ""

msgid "3280      (e.g., look into the constructors)."
msgstr ""

msgid ""
"3281    ### <a name=\"Rc-dtor-ptr\"></a>C.32: If a class has a raw pointer "
"(`T*`) or reference (`T&`), consider whether it might be owning"
msgstr ""

msgid "3282    ##### Reason"
msgstr ""

msgid "3283    There is a lot of code that is non-specific about ownership."
msgstr ""

msgid "3284    ##### Example"
msgstr ""

msgid "3285        ???"
msgstr ""

msgid "3286    ##### Note"
msgstr ""

msgid ""
"3287    If the `T*` or `T&` is owning, mark it `owning`. If the `T*` is not "
"owning, consider marking it `ptr`."
msgstr ""

msgid "3288    This will aid documentation and analysis."
msgstr ""

msgid "3289    ##### Enforcement"
msgstr ""

msgid ""
"3290    Look at the initialization of raw member pointers and member "
"references and see if an allocation is used."
msgstr ""

msgid ""
"3291    ### <a name=\"Rc-dtor-ptr2\"></a>C.33: If a class has an owning "
"pointer member, define a destructor"
msgstr ""

msgid "3292    ##### Reason"
msgstr ""

msgid ""
"3293    An owned object must be `deleted` upon destruction of the object "
"that owns it."
msgstr ""

msgid "3294    ##### Example"
msgstr ""

msgid "3295    A pointer member may represent a resource."
msgstr ""

msgid ""
"3296    [A `T*` should not do so](#Rr-ptr), but in older code, that's common."
""
msgstr ""

msgid "3297    Consider a `T*` a possible owner and therefore suspect."
msgstr ""

msgid "3298        template<typename T>"
msgstr ""

msgid "3299        class Smart_ptr {"
msgstr ""

msgid "3300            T* p;   // BAD: vague about ownership of *p"
msgstr ""

msgid "3301            // ..."
msgstr ""

msgid "3302        public:"
msgstr ""

msgid "3303            // ... no user-defined default operations ..."
msgstr ""

msgid "3304        };"
msgstr ""

msgid "3305        void use(Smart_ptr<int> p1)"
msgstr ""

msgid "3306        {"
msgstr ""

msgid ""
"3307            // error: p2.p leaked (if not nullptr and not owned by some "
"other code)"
msgstr ""

msgid "3308            auto p2 = p1;"
msgstr ""

msgid "3309        }"
msgstr ""

msgid ""
"3310    Note that if you define a destructor, you must define or delete [all "
"default operations](#Rc-five):"
msgstr ""

msgid "3311        template<typename T>"
msgstr ""

msgid "3312        class Smart_ptr2 {"
msgstr ""

msgid "3313            T* p;   // BAD: vague about ownership of *p"
msgstr ""

msgid "3314            // ..."
msgstr ""

msgid "3315        public:"
msgstr ""

msgid "3316            // ... no user-defined copy operations ..."
msgstr ""

msgid "3317            ~Smart_ptr2() { delete p; }  // p is an owner!"
msgstr ""

msgid "3318        };"
msgstr ""

msgid "3319        void use(Smart_ptr2<int> p1)"
msgstr ""

msgid "3320        {"
msgstr ""

msgid "3321            auto p2 = p1;   // error: double deletion"
msgstr ""

msgid "3322        }"
msgstr ""

msgid ""
"3323    The default copy operation will just copy the `p1.p` into `p2.p` "
"leading to a double destruction of `p1.p`. Be explicit about ownership:"
msgstr ""

msgid "3324        template<typename T>"
msgstr ""

msgid "3325        class Smart_ptr3 {"
msgstr ""

msgid "3326            owner<T*> p;   // OK: explicit about ownership of *p"
msgstr ""

msgid "3327            // ..."
msgstr ""

msgid "3328        public:"
msgstr ""

msgid "3329            // ..."
msgstr ""

msgid "3330            // ... copy and move operations ..."
msgstr ""

msgid "3331            ~Smart_ptr3() { delete p; }"
msgstr ""

msgid "3332        };"
msgstr ""

msgid "3333        void use(Smart_ptr3<int> p1)"
msgstr ""

msgid "3334        {"
msgstr ""

msgid "3335            auto p2 = p1;   // error: double deletion"
msgstr ""

msgid "3336        }"
msgstr ""

msgid "3337    ##### Note"
msgstr ""

msgid ""
"3338    Often the simplest way to get a destructor is to replace the pointer "
"with a smart pointer (e.g., `std::unique_ptr`) and let the compiler arrange "
"for proper destruction to be done implicitly."
msgstr ""

msgid "3339    ##### Note"
msgstr ""

msgid ""
"3340    Why not just require all owning pointers to be \"smart pointers\"?"
msgstr ""

msgid ""
"3341    That would sometimes require non-trivial code changes and may affect "
"ABIs."
msgstr ""

msgid "3342    ##### Enforcement"
msgstr ""

msgid "3343    * A class with a pointer data member is suspect."
msgstr ""

msgid ""
"3344    * A class with an `owner<T>` should define its default operations."
msgstr ""

msgid ""
"3345    ### <a name=\"Rc-dtor-virtual\"></a>C.35: A base class destructor "
"should be either public and virtual, or protected and nonvirtual"
msgstr ""

msgid "3346    ##### Reason"
msgstr ""

msgid "3347    To prevent undefined behavior."
msgstr ""

msgid ""
"3348    If the destructor is public, then calling code can attempt to "
"destroy a derived class object through a base class pointer, and the result "
"is undefined if the base class's destructor is non-virtual."
msgstr ""

msgid ""
"3349    If the destructor is protected, then calling code cannot destroy "
"through a base class pointer and the destructor does not need to be virtual; "
"it does need to be protected, not private, so that derived destructors can "
"invoke it."
msgstr ""

msgid ""
"3350    In general, the writer of a base class does not know the appropriate "
"action to be done upon destruction."
msgstr ""

msgid "3351    ##### Discussion"
msgstr ""

msgid "3352    See [this in the Discussion section](#Sd-dtor)."
msgstr ""

msgid "3353    ##### Example, bad"
msgstr ""

msgid "3354        struct Base {  // BAD: no virtual destructor"
msgstr ""

msgid "3355            virtual void f();"
msgstr ""

msgid "3356        };"
msgstr ""

msgid "3357        struct D : Base {"
msgstr ""

msgid "3358            string s {\"a resource needing cleanup\"};"
msgstr ""

msgid "3359            ~D() { /* ... do some cleanup ... */ }"
msgstr ""

msgid "3360            // ..."
msgstr ""

msgid "3361        };"
msgstr ""

msgid "3362        void use()"
msgstr ""

msgid "3363        {"
msgstr ""

msgid "3364            unique_ptr<Base> p = make_unique<D>();"
msgstr ""

msgid "3365            // ..."
msgstr ""

msgid ""
"3366        } // p's destruction calls ~Base(), not ~D(), which leaks D::s "
"and possibly more"
msgstr ""

msgid "3367    ##### Note"
msgstr ""

msgid ""
"3368    A virtual function defines an interface to derived classes that can "
"be used without looking at the derived classes."
msgstr ""

msgid ""
"3369    If the interface allows destroying, it should be safe to do so."
msgstr ""

msgid "3370    ##### Note"
msgstr ""

msgid ""
"3371    A destructor must be nonprivate or it will prevent using the type :"
msgstr ""

msgid "3372        class X {"
msgstr ""

msgid "3373            ~X();   // private destructor"
msgstr ""

msgid "3374            // ..."
msgstr ""

msgid "3375        };"
msgstr ""

msgid "3376        void use()"
msgstr ""

msgid "3377        {"
msgstr ""

msgid "3378            X a;                        // error: cannot destroy"
msgstr ""

msgid "3379            auto p = make_unique<X>();  // error: cannot destroy"
msgstr ""

msgid "3380        }"
msgstr ""

msgid "3381    ##### Exception"
msgstr ""

msgid ""
"3382    We can imagine one case where you could want a protected virtual "
"destructor: When an object of a derived type (and only of such a type) "
"should be allowed to destroy *another* object (not itself) through a pointer "
"to base. We haven't seen such a case in practice, though."
msgstr ""

msgid "3383    ##### Enforcement"
msgstr ""

msgid ""
"3384    * A class with any virtual functions should have a destructor that "
"is either public and virtual or else protected and nonvirtual."
msgstr ""

msgid "3385    ### <a name=\"Rc-dtor-fail\"></a>C.36: A destructor may not fail"
msgstr ""

msgid "3386    ##### Reason"
msgstr ""

msgid ""
"3387    In general we do not know how to write error-free code if a "
"destructor should fail."
msgstr ""

msgid ""
"3388    The standard library requires that all classes it deals with have "
"destructors that do not exit by throwing."
msgstr ""

msgid "3389    ##### Example"
msgstr ""

msgid "3390        class X {"
msgstr ""

msgid "3391        public:"
msgstr ""

msgid "3392            ~X() noexcept;"
msgstr ""

msgid "3393            // ..."
msgstr ""

msgid "3394        };"
msgstr ""

msgid "3395        X::~X() noexcept"
msgstr ""

msgid "3396        {"
msgstr ""

msgid "3397            // ..."
msgstr ""

msgid "3398            if (cannot_release_a_resource) terminate();"
msgstr ""

msgid "3399            // ..."
msgstr ""

msgid "3400        }"
msgstr ""

msgid "3401    ##### Note"
msgstr ""

msgid ""
"3402    Many have tried to devise a fool-proof scheme for dealing with "
"failure in destructors."
msgstr ""

msgid "3403    None have succeeded to come up with a general scheme."
msgstr ""

msgid ""
"3404    This can be a real practical problem: For example, what about a "
"socket that won't close?"
msgstr ""

msgid ""
"3405    The writer of a destructor does not know why the destructor is "
"called and cannot \"refuse to act\" by throwing an exception."
msgstr ""

msgid "3406    See [discussion](#Sd-dtor)."
msgstr ""

msgid ""
"3407    To make the problem worse, many \"close/release\" operations are not "
"retryable."
msgstr ""

msgid ""
"3408    If at all possible, consider failure to close/cleanup a fundamental "
"design error and terminate."
msgstr ""

msgid "3409    ##### Note"
msgstr ""

msgid ""
"3410    Declare a destructor `noexcept`. That will ensure that it either "
"completes normally or terminate the program."
msgstr ""

msgid "3411    ##### Note"
msgstr ""

msgid ""
"3412    If a resource cannot be released and the program may not fail, try "
"to signal the failure to the rest of the system somehow"
msgstr ""

msgid ""
"3413    (maybe even by modifying some global state and hope something will "
"notice and be able to take care of the problem)."
msgstr ""

msgid ""
"3414    Be fully aware that this technique is special-purpose and error-"
"prone."
msgstr ""

msgid "3415    Consider the \"my connection will not close\" example."
msgstr ""

msgid ""
"3416    Probably there is a problem at the other end of the connection and "
"only a piece of code responsible for both ends of the connection can "
"properly handle the problem."
msgstr ""

msgid ""
"3417    The destructor could send a message (somehow) to the responsible "
"part of the system, consider that to have closed the connection, and return "
"normally."
msgstr ""

msgid "3418    ##### Note"
msgstr ""

msgid ""
"3419    If a destructor uses operations that may fail, it can catch "
"exceptions and in some cases still complete successfully"
msgstr ""

msgid ""
"3420    (e.g., by using a different clean-up mechanism from the one that "
"threw an exception)."
msgstr ""

msgid "3421    ##### Enforcement"
msgstr ""

msgid ""
"3422    (Simple) A destructor should be declared `noexcept` if it could "
"throw."
msgstr ""

msgid ""
"3423    ### <a name=\"Rc-dtor-noexcept\"></a>C.37: Make destructors "
"`noexcept`"
msgstr ""

msgid "3424    ##### Reason"
msgstr ""

msgid ""
"3425     [A destructor may not fail](#Rc-dtor-fail). If a destructor tries "
"to exit with an exception, it's a bad design error and the program had "
"better terminate."
msgstr ""

msgid "3426    ##### Note"
msgstr ""

msgid ""
"3427    A destructor (either user-defined or compiler-generated) is "
"implicitly declared `noexcept` (independently of what code is in its body) "
"if all of the members of its class have `noexcept` destructors. By "
"explicitly marking destructors `noexcept`, an author guards against the "
"destructor becoming implicitly `noexcept(false)` through the addition or "
"modification of a class member."
msgstr ""

msgid "3428    ##### Enforcement"
msgstr ""

msgid ""
"3429    (Simple) A destructor should be declared `noexcept` if it could "
"throw."
msgstr ""

msgid "3430    ## <a name=\"SS-ctor\"></a>C.ctor: Constructors"
msgstr ""

msgid ""
"3431    A constructor defines how an object is initialized (constructed)."
msgstr ""

msgid ""
"3432    ### <a name=\"Rc-ctor\"></a>C.40: Define a constructor if a class "
"has an invariant"
msgstr ""

msgid "3433    ##### Reason"
msgstr ""

msgid "3434    That's what constructors are for."
msgstr ""

msgid "3435    ##### Example"
msgstr ""

msgid "3436        class Date {  // a Date represents a valid date"
msgstr ""

msgid ""
"3437                      // in the January 1, 1900 to December 31, 2100 "
"range"
msgstr ""

msgid "3438            Date(int dd, int mm, int yy)"
msgstr ""

msgid "3439                :d{dd}, m{mm}, y{yy}"
msgstr ""

msgid "3440            {"
msgstr ""

msgid ""
"3441                if (!is_valid(d, m, y)) throw Bad_date{};  // enforce "
"invariant"
msgstr ""

msgid "3442            }"
msgstr ""

msgid "3443            // ..."
msgstr ""

msgid "3444        private:"
msgstr ""

msgid "3445            int d, m, y;"
msgstr ""

msgid "3446        };"
msgstr ""

msgid ""
"3447    It is often a good idea to express the invariant as an `Ensures` on "
"the constructor."
msgstr ""

msgid "3448    ##### Note"
msgstr ""

msgid ""
"3449    A constructor can be used for convenience even if a class does not "
"have an invariant. For example:"
msgstr ""

msgid "3450        struct Rec {"
msgstr ""

msgid "3451            string s;"
msgstr ""

msgid "3452            int i {0};"
msgstr ""

msgid "3453            Rec(const string& ss) : s{ss} {}"
msgstr ""

msgid "3454            Rec(int ii) :i{ii} {}"
msgstr ""

msgid "3455        };"
msgstr ""

msgid "3456        Rec r1 {7};"
msgstr ""

msgid "3457        Rec r2 {\"Foo bar\"};"
msgstr ""

msgid "3458    ##### Note"
msgstr ""

msgid ""
"3459    The C++11 initializer list rule eliminates the need for many "
"constructors. For example:"
msgstr ""

msgid "3460        struct Rec2{"
msgstr ""

msgid "3461            string s;"
msgstr ""

msgid "3462            int i;"
msgstr ""

msgid ""
"3463            Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // "
"redundant"
msgstr ""

msgid "3464        };"
msgstr ""

msgid "3465        Rec2 r1 {\"Foo\", 7};"
msgstr ""

msgid "3466        Rec2 r2 {\"Bar\"};"
msgstr ""

msgid "3467    The `Rec2` constructor is redundant."
msgstr ""

msgid ""
"3468    Also, the default for `int` would be better done as a [member "
"initializer](#Rc-in-class-initializer)."
msgstr ""

msgid ""
"3469    **See also**: [construct valid object](#Rc-complete) and "
"[constructor throws](#Rc-throw)."
msgstr ""

msgid "3470    ##### Enforcement"
msgstr ""

msgid ""
"3471    * Flag classes with user-defined copy operations but no constructor "
"(a user-defined copy is a good indicator that the class has an invariant)"
msgstr ""

msgid ""
"3472    ### <a name=\"Rc-complete\"></a>C.41: A constructor should create a "
"fully initialized object"
msgstr ""

msgid "3473    ##### Reason"
msgstr ""

msgid ""
"3474    A constructor establishes the invariant for a class. A user of a "
"class should be able to assume that a constructed object is usable."
msgstr ""

msgid "3475    ##### Example, bad"
msgstr ""

msgid "3476        class X1 {"
msgstr ""

msgid "3477            FILE* f;   // call init() before any other function"
msgstr ""

msgid "3478            // ..."
msgstr ""

msgid "3479        public:"
msgstr ""

msgid "3480            X1() {}"
msgstr ""

msgid "3481            void init();   // initialize f"
msgstr ""

msgid "3482            void read();   // read from f"
msgstr ""

msgid "3483            // ..."
msgstr ""

msgid "3484        };"
msgstr ""

msgid "3485        void f()"
msgstr ""

msgid "3486        {"
msgstr ""

msgid "3487            X1 file;"
msgstr ""

msgid "3488            file.read();   // crash or bad read!"
msgstr ""

msgid "3489            // ..."
msgstr ""

msgid "3490            file.init();   // too late"
msgstr ""

msgid "3491            // ..."
msgstr ""

msgid "3492        }"
msgstr ""

msgid "3493    Compilers do not read comments."
msgstr ""

msgid "3494    ##### Exception"
msgstr ""

msgid ""
"3495    If a valid object cannot conveniently be constructed by a "
"constructor, [use a factory function](#Rc-factory)."
msgstr ""

msgid "3496    ##### Enforcement"
msgstr ""

msgid ""
"3497    * (Simple) Every constructor should initialize every member variable "
"(either explicitly, via a delegating ctor call or via default construction)."
msgstr ""

msgid ""
"3498    * (Unknown) If a constructor has an `Ensures` contract, try to see "
"if it holds as a postcondition."
msgstr ""

msgid "3499    ##### Note"
msgstr ""

msgid ""
"3500    If a constructor acquires a resource (to create a valid object), "
"that resource should be [released by the destructor](#Rc-dtor-release)."
msgstr ""

msgid ""
"3501    The idiom of having constructors acquire resources and destructors "
"release them is called [RAII](#Rr-raii) (\"Resource Acquisition Is "
"Initialization\")."
msgstr ""

msgid ""
"3502    ### <a name=\"Rc-throw\"></a>C.42: If a constructor cannot construct "
"a valid object, throw an exception"
msgstr ""

msgid "3503    ##### Reason"
msgstr ""

msgid "3504    Leaving behind an invalid object is asking for trouble."
msgstr ""

msgid "3505    ##### Example"
msgstr ""

msgid "3506        class X2 {"
msgstr ""

msgid "3507            FILE* f;"
msgstr ""

msgid "3508            // ..."
msgstr ""

msgid "3509        public:"
msgstr ""

msgid "3510            X2(const string& name)"
msgstr ""

msgid "3511                :f{fopen(name.c_str(), \"r\")}"
msgstr ""

msgid "3512            {"
msgstr ""

msgid ""
"3513                if (!f) throw runtime_error{\"could not open\" + name};"
msgstr ""

msgid "3514                // ..."
msgstr ""

msgid "3515            }"
msgstr ""

msgid "3516            void read();      // read from f"
msgstr ""

msgid "3517            // ..."
msgstr ""

msgid "3518        };"
msgstr ""

msgid "3519        void f()"
msgstr ""

msgid "3520        {"
msgstr ""

msgid "3521            X2 file {\"Zeno\"}; // throws if file isn't open"
msgstr ""

msgid "3522            file.read();      // fine"
msgstr ""

msgid "3523            // ..."
msgstr ""

msgid "3524        }"
msgstr ""

msgid "3525    ##### Example, bad"
msgstr ""

msgid ""
"3526        class X3 {     // bad: the constructor leaves a non-valid object "
"behind"
msgstr ""

msgid ""
"3527            FILE* f;   // call is_valid() before any other function"
msgstr ""

msgid "3528            bool valid;"
msgstr ""

msgid "3529            // ..."
msgstr ""

msgid "3530        public:"
msgstr ""

msgid "3531            X3(const string& name)"
msgstr ""

msgid "3532                :f{fopen(name.c_str(), \"r\")}, valid{false}"
msgstr ""

msgid "3533            {"
msgstr ""

msgid "3534                if (f) valid = true;"
msgstr ""

msgid "3535                // ..."
msgstr ""

msgid "3536            }"
msgstr ""

msgid "3537            bool is_valid() { return valid; }"
msgstr ""

msgid "3538            void read();   // read from f"
msgstr ""

msgid "3539            // ..."
msgstr ""

msgid "3540        };"
msgstr ""

msgid "3541        void f()"
msgstr ""

msgid "3542        {"
msgstr ""

msgid "3543            X3 file {\"Heraclides\"};"
msgstr ""

msgid "3544            file.read();   // crash or bad read!"
msgstr ""

msgid "3545            // ..."
msgstr ""

msgid "3546            if (file.is_valid()) {"
msgstr ""

msgid "3547                file.read();"
msgstr ""

msgid "3548                // ..."
msgstr ""

msgid "3549            }"
msgstr ""

msgid "3550            else {"
msgstr ""

msgid "3551                // ... handle error ..."
msgstr ""

msgid "3552            }"
msgstr ""

msgid "3553            // ..."
msgstr ""

msgid "3554        }"
msgstr ""

msgid "3555    ##### Note"
msgstr ""

msgid ""
"3556    For a variable definition (e.g., on the stack or as a member of "
"another object) there is no explicit function call from which an error code "
"could be returned."
msgstr ""

msgid ""
"3557    Leaving behind an invalid object and relying on users to "
"consistently check an `is_valid()` function before use is tedious, error-"
"prone, and inefficient."
msgstr ""

msgid "3558    ##### Exception"
msgstr ""

msgid ""
"3559    There are domains, such as some hard-real-time systems (think "
"airplane controls) where (without additional tool support) exception "
"handling is not sufficiently predictable from a timing perspective."
msgstr ""

msgid ""
"3560    There the `is_valid()` technique must be used. In such cases, check "
"`is_valid()` consistently and immediately to simulate [RAII](#Rr-raii)."
msgstr ""

msgid "3561    ##### Alternative"
msgstr ""

msgid ""
"3562    If you feel tempted to use some \"post-constructor initialization\" "
"or \"two-stage initialization\" idiom, try not to do that."
msgstr ""

msgid ""
"3563    If you really have to, look at [factory functions](#Rc-factory)."
msgstr ""

msgid "3564    ##### Note"
msgstr ""

msgid ""
"3565    One reason people have used `init()` functions rather than doing the "
"initialization work in a constructor has been to avoid code replication."
msgstr ""

msgid ""
"3566    [Delegating constructors](#Rc-delegating) and [default member "
"initialization](#Rc-in-class-initializer) do that better."
msgstr ""

msgid ""
"3567    Another reason has been to delay initialization until an object is "
"needed; the solution to that is often [not to declare a variable until it "
"can be properly initialized](#Res-init)"
msgstr ""

msgid "3568    ##### Enforcement"
msgstr ""

msgid "3569    ???"
msgstr ""

msgid ""
"3570    ### <a name=\"Rc-default0\"></a>C.43: Ensure that a copyable (value "
"type) class has a default constructor"
msgstr ""

msgid "3571    ##### Reason"
msgstr ""

msgid ""
"3572    Many language and library facilities rely on default constructors to "
"initialize their elements, e.g. `T a[10]` and `std::vector<T> v(10)`."
msgstr ""

msgid ""
"3573    A default constructor often simplifies the task of defining a "
"suitable [moved-from state](#???) for a type that is also copyable."
msgstr ""

msgid "3574    ##### Note"
msgstr ""

msgid ""
"3575    A [value type](#SS-concrete) is a class that is copyable (and "
"usually also comparable)."
msgstr ""

msgid ""
"3576    It is closely related to the notion of Regular type from [EoP](http:/"
"/elementsofprogramming.com/) and [the Palo Alto TR](http://www.open-std.org/"
"jtc1/sc22/wg21/docs/papers/2012/n3351.pdf)."
msgstr ""

msgid "3577    ##### Example"
msgstr ""

msgid "3578        class Date { // BAD: no default constructor"
msgstr ""

msgid "3579        public:"
msgstr ""

msgid "3580            Date(int dd, int mm, int yyyy);"
msgstr ""

msgid "3581            // ..."
msgstr ""

msgid "3582        };"
msgstr ""

msgid "3583        vector<Date> vd1(1000);   // default Date needed here"
msgstr ""

msgid ""
"3584        vector<Date> vd2(1000, Date{Month::October, 7, 1885});   // "
"alternative"
msgstr ""

msgid ""
"3585    The default constructor is only auto-generated if there is no user-"
"declared constructor, hence it's impossible to initialize the vector `vd1` "
"in the example above."
msgstr ""

msgid ""
"3586    The absence of a default value can cause surprises for users and "
"complicate its use, so if one can be reasonably defined, it should be."
msgstr ""

msgid "3587    `Date` is chosen to encourage thought:"
msgstr ""

msgid ""
"3588    There is no \"natural\" default date (the big bang is too far back "
"in time to be useful for most people), so this example is non-trivial."
msgstr ""

msgid ""
"3589    `{0, 0, 0}` is not a valid date in most calendar systems, so "
"choosing that would be introducing something like floating-point's `NaN`."
msgstr ""

msgid ""
"3590    However, most realistic `Date` classes have a \"first date\" (e.g. "
"January 1, 1970 is popular), so making that the default is usually trivial."
msgstr ""

msgid "3591        class Date {"
msgstr ""

msgid "3592        public:"
msgstr ""

msgid "3593            Date(int dd, int mm, int yyyy);"
msgstr ""

msgid "3594            Date() = default; // [See also](#Rc-default)"
msgstr ""

msgid "3595            // ..."
msgstr ""

msgid "3596        private:"
msgstr ""

msgid "3597            int dd = 1;"
msgstr ""

msgid "3598            int mm = 1;"
msgstr ""

msgid "3599            int yyyy = 1970;"
msgstr ""

msgid "3600            // ..."
msgstr ""

msgid "3601        };"
msgstr ""

msgid "3602        vector<Date> vd1(1000);"
msgstr ""

msgid "3603    ##### Note"
msgstr ""

msgid ""
"3604    A class with members that all have default constructors implicitly "
"gets a default constructor:"
msgstr ""

msgid "3605        struct X {"
msgstr ""

msgid "3606            string s;"
msgstr ""

msgid "3607            vector<int> v;"
msgstr ""

msgid "3608        };"
msgstr ""

msgid ""
"3609        X x; // means X{{}, {}}; that is the empty string and the empty "
"vector"
msgstr ""

msgid ""
"3610    Beware that built-in types are not properly default constructed:"
msgstr ""

msgid "3611        struct X {"
msgstr ""

msgid "3612            string s;"
msgstr ""

msgid "3613            int i;"
msgstr ""

msgid "3614        };"
msgstr ""

msgid "3615        void f()"
msgstr ""

msgid "3616        {"
msgstr ""

msgid ""
"3617            X x;    // x.s is initialized to the empty string; x.i is "
"uninitialized"
msgstr ""

msgid "3618            cout << x.s << ' ' << x.i << '\\n';"
msgstr ""

msgid "3619            ++x.i;"
msgstr ""

msgid "3620        }"
msgstr ""

msgid ""
"3621    Statically allocated objects of built-in types are by default "
"initialized to `0`, but local built-in variables are not."
msgstr ""

msgid ""
"3622    Beware that your compiler may default initialize local built-in "
"variables, whereas an optimized build will not."
msgstr ""

msgid ""
"3623    Thus, code like the example above may appear to work, but it relies "
"on undefined behavior."
msgstr ""

msgid ""
"3624    Assuming that you want initialization, an explicit default "
"initialization can help:"
msgstr ""

msgid "3625        struct X {"
msgstr ""

msgid "3626            string s;"
msgstr ""

msgid "3627            int i {};   // default initialize (to 0)"
msgstr ""

msgid "3628        };"
msgstr ""

msgid "3629    ##### Notes"
msgstr ""

msgid ""
"3630    Classes that don't have a reasonable default construction are "
"usually not copyable either, so they don't fall under this guideline."
msgstr ""

msgid ""
"3631    For example, a base class is not a value type (base classes should "
"not be copyable) and so does not necessarily need a default constructor:"
msgstr ""

msgid ""
"3632        // Shape is an abstract base class, not a copyable value type."
msgstr ""

msgid "3633        // It may or may not need a default constructor."
msgstr ""

msgid "3634        struct Shape {"
msgstr ""

msgid "3635            virtual void draw() = 0;"
msgstr ""

msgid "3636            virtual void rotate(int) = 0;"
msgstr ""

msgid "3637            // =delete copy/move functions"
msgstr ""

msgid "3638            // ..."
msgstr ""

msgid "3639        };"
msgstr ""

msgid ""
"3640    A class that must acquire a caller-provided resource during "
"construction often cannot have a default constructor, but it does not fall "
"under this guideline because such a class is usually not copyable anyway:"
msgstr ""

msgid "3641        // std::lock_guard is not a copyable value type."
msgstr ""

msgid "3642        // It does not have a default constructor."
msgstr ""

msgid "3643        lock_guard g {mx};  // guard the mutex mx"
msgstr ""

msgid "3644        lock_guard g2;      // error: guarding nothing"
msgstr ""

msgid ""
"3645    A class that has a \"special state\" that must be handled separately "
"from other states by member functions or users causes extra work"
msgstr ""

msgid ""
"3646    (and most likely more errors). Such a type can naturally use the "
"special state as a default constructed value, whether or not it is copyable:"
msgstr ""

msgid "3647        // std::ofstream is not a copyable value type."
msgstr ""

msgid "3648        // It does happen to have a default constructor"
msgstr ""

msgid "3649        // that goes along with a special \"not open\" state."
msgstr ""

msgid "3650        ofstream out {\"Foobar\"};"
msgstr ""

msgid "3651        // ..."
msgstr ""

msgid "3652        out << log(time, transaction);"
msgstr ""

msgid ""
"3653    Similar special-state types that are copyable, such as copyable "
"smart pointers that have the special state \"==nullptr\", should use the "
"special state as their default constructed value."
msgstr ""

msgid ""
"3654    However, it is preferable to have a default constructor default to a "
"meaningful state such as `std::string`s `\"\"` and `std::vector`s `{}`."
msgstr ""

msgid "3655    ##### Enforcement"
msgstr ""

msgid ""
"3656    * Flag classes that are copyable by `=` without a default "
"constructor"
msgstr ""

msgid "3657    * Flag classes that are comparable with `==` but not copyable"
msgstr ""

msgid ""
"3658    ### <a name=\"Rc-default00\"></a>C.44: Prefer default constructors "
"to be simple and non-throwing"
msgstr ""

msgid "3659    ##### Reason"
msgstr ""

msgid ""
"3660    Being able to set a value to \"the default\" without operations that "
"might fail simplifies error handling and reasoning about move operations."
msgstr ""

msgid "3661    ##### Example, problematic"
msgstr ""

msgid "3662        template<typename T>"
msgstr ""

msgid "3663        // elem points to space-elem element allocated using new"
msgstr ""

msgid "3664        class Vector0 {"
msgstr ""

msgid "3665        public:"
msgstr ""

msgid "3666            Vector0() :Vector0{0} {}"
msgstr ""

msgid ""
"3667            Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} "
"{}"
msgstr ""

msgid "3668            // ..."
msgstr ""

msgid "3669        private:"
msgstr ""

msgid "3670            own<T*> elem;"
msgstr ""

msgid "3671            T* space;"
msgstr ""

msgid "3672            T* last;"
msgstr ""

msgid "3673        };"
msgstr ""

msgid ""
"3674    This is nice and general, but setting a `Vector0` to empty after an "
"error involves an allocation, which may fail."
msgstr ""

msgid ""
"3675    Also, having a default `Vector` represented as `{new T[0], 0, 0}` "
"seems wasteful."
msgstr ""

msgid "3676    For example, `Vector0<int> v[100]` costs 100 allocations."
msgstr ""

msgid "3677    ##### Example"
msgstr ""

msgid "3678        template<typename T>"
msgstr ""

msgid ""
"3679        // elem is nullptr or elem points to space-elem element "
"allocated using new"
msgstr ""

msgid "3680        class Vector1 {"
msgstr ""

msgid "3681        public:"
msgstr ""

msgid ""
"3682            // sets the representation to {nullptr, nullptr, nullptr}; "
"doesn't throw"
msgstr ""

msgid "3683            Vector1() noexcept {}"
msgstr ""

msgid ""
"3684            Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} "
"{}"
msgstr ""

msgid "3685            // ..."
msgstr ""

msgid "3686        private:"
msgstr ""

msgid "3687            own<T*> elem = nullptr;"
msgstr ""

msgid "3688            T* space = nullptr;"
msgstr ""

msgid "3689            T* last = nullptr;"
msgstr ""

msgid "3690        };"
msgstr ""

msgid ""
"3691    Using `{nullptr, nullptr, nullptr}` makes `Vector1{}` cheap, but a "
"special case and implies run-time checks."
msgstr ""

msgid ""
"3692    Setting a `Vector1` to empty after detecting an error is trivial."
msgstr ""

msgid "3693    ##### Enforcement"
msgstr ""

msgid "3694    * Flag throwing default constructors"
msgstr ""

msgid ""
"3695    ### <a name=\"Rc-default\"></a>C.45: Don't define a default "
"constructor that only initializes data members; use in-class member "
"initializers instead"
msgstr ""

msgid "3696    ##### Reason"
msgstr ""

msgid ""
"3697    Using in-class member initializers lets the compiler generate the "
"function for you. The compiler-generated function can be more efficient."
msgstr ""

msgid "3698    ##### Example, bad"
msgstr ""

msgid "3699        class X1 { // BAD: doesn't use member initializers"
msgstr ""

msgid "3700            string s;"
msgstr ""

msgid "3701            int i;"
msgstr ""

msgid "3702        public:"
msgstr ""

msgid "3703            X1() :s{\"default\"}, i{1} { }"
msgstr ""

msgid "3704            // ..."
msgstr ""

msgid "3705        };"
msgstr ""

msgid "3706    ##### Example"
msgstr ""

msgid "3707        class X2 {"
msgstr ""

msgid "3708            string s = \"default\";"
msgstr ""

msgid "3709            int i = 1;"
msgstr ""

msgid "3710        public:"
msgstr ""

msgid "3711            // use compiler-generated default constructor"
msgstr ""

msgid "3712            // ..."
msgstr ""

msgid "3713        };"
msgstr ""

msgid "3714    ##### Enforcement"
msgstr ""

msgid ""
"3715    (Simple) A default constructor should do more than just initialize "
"member variables with constants."
msgstr ""

msgid ""
"3716    ### <a name=\"Rc-explicit\"></a>C.46: By default, declare single-"
"argument constructors explicit"
msgstr ""

msgid "3717    ##### Reason"
msgstr ""

msgid "3718    To avoid unintended conversions."
msgstr ""

msgid "3719    ##### Example, bad"
msgstr ""

msgid "3720        class String {"
msgstr ""

msgid "3721            // ..."
msgstr ""

msgid "3722        public:"
msgstr ""

msgid "3723            String(int);   // BAD"
msgstr ""

msgid "3724            // ..."
msgstr ""

msgid "3725        };"
msgstr ""

msgid "3726        String s = 10;   // surprise: string of size 10"
msgstr ""

msgid "3727    ##### Exception"
msgstr ""

msgid ""
"3728    If you really want an implicit conversion from the constructor "
"argument type to the class type, don't use `explicit`:"
msgstr ""

msgid "3729        class Complex {"
msgstr ""

msgid "3730            // ..."
msgstr ""

msgid "3731        public:"
msgstr ""

msgid ""
"3732            Complex(double d);   // OK: we want a conversion from d to "
"{d, 0}"
msgstr ""

msgid "3733            // ..."
msgstr ""

msgid "3734        };"
msgstr ""

msgid "3735        Complex z = 10.7;   // unsurprising conversion"
msgstr ""

msgid ""
"3736    **See also**: [Discussion of implicit conversions](#Ro-conversion)"
msgstr ""

msgid "3737    ##### Note"
msgstr ""

msgid ""
"3738    Copy and move constructors should not be made `explicit` because "
"they do not perform conversions. Explicit copy/move constructors make "
"passing and returning by value difficult."
msgstr ""

msgid "3739    ##### Enforcement"
msgstr ""

msgid ""
"3740    (Simple) Single-argument constructors should be declared `explicit`. "
"Good single argument non-`explicit` constructors are rare in most code based."
" Warn for all that are not on a \"positive list\"."
msgstr ""

msgid ""
"3741    ### <a name=\"Rc-order\"></a>C.47: Define and initialize member "
"variables in the order of member declaration"
msgstr ""

msgid "3742    ##### Reason"
msgstr ""

msgid ""
"3743    To minimize confusion and errors. That is the order in which the "
"initialization happens (independent of the order of member initializers)."
msgstr ""

msgid "3744    ##### Example, bad"
msgstr ""

msgid "3745        class Foo {"
msgstr ""

msgid "3746            int m1;"
msgstr ""

msgid "3747            int m2;"
msgstr ""

msgid "3748        public:"
msgstr ""

msgid ""
"3749            Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading "
"initializer order"
msgstr ""

msgid "3750            // ..."
msgstr ""

msgid "3751        };"
msgstr ""

msgid "3752        Foo x(1); // surprise: x.m1 == x.m2 == 2"
msgstr ""

msgid "3753    ##### Enforcement"
msgstr ""

msgid ""
"3754    (Simple) A member initializer list should mention the members in the "
"same order they are declared."
msgstr ""

msgid "3755    **See also**: [Discussion](#Sd-order)"
msgstr ""

msgid ""
"3756    ### <a name=\"Rc-in-class-initializer\"></a>C.48: Prefer in-class "
"initializers to member initializers in constructors for constant "
"initializers"
msgstr ""

msgid "3757    ##### Reason"
msgstr ""

msgid ""
"3758    Makes it explicit that the same value is expected to be used in all "
"constructors. Avoids repetition. Avoids maintenance problems. It leads to "
"the shortest and most efficient code."
msgstr ""

msgid "3759    ##### Example, bad"
msgstr ""

msgid "3760        class X {   // BAD"
msgstr ""

msgid "3761            int i;"
msgstr ""

msgid "3762            string s;"
msgstr ""

msgid "3763            int j;"
msgstr ""

msgid "3764        public:"
msgstr ""

msgid "3765            X() :i{666}, s{\"qqq\"} { }   // j is uninitialized"
msgstr ""

msgid ""
"3766            X(int ii) :i{ii} {}         // s is \"\" and j is "
"uninitialized"
msgstr ""

msgid "3767            // ..."
msgstr ""

msgid "3768        };"
msgstr ""

msgid ""
"3769    How would a maintainer know whether `j` was deliberately "
"uninitialized (probably a poor idea anyway) and whether it was intentional "
"to give `s` the default value `\"\"` in one case and `qqq` in another "
"(almost certainly a bug)? The problem with `j` (forgetting to initialize a "
"member) often happens when a new member is added to an existing class."
msgstr ""

msgid "3770    ##### Example"
msgstr ""

msgid "3771        class X2 {"
msgstr ""

msgid "3772            int i {666};"
msgstr ""

msgid "3773            string s {\"qqq\"};"
msgstr ""

msgid "3774            int j {0};"
msgstr ""

msgid "3775        public:"
msgstr ""

msgid ""
"3776            X2() = default;        // all members are initialized to "
"their defaults"
msgstr ""

msgid ""
"3777            X2(int ii) :i{ii} {}   // s and j initialized to their "
"defaults"
msgstr ""

msgid "3778            // ..."
msgstr ""

msgid "3779        };"
msgstr ""

msgid ""
"3780    **Alternative**: We can get part of the benefits from default "
"arguments to constructors, and that is not uncommon in older code. However, "
"that is less explicit, causes more arguments to be passed, and is repetitive "
"when there is more than one constructor:"
msgstr ""

msgid "3781        class X3 {   // BAD: inexplicit, argument passing overhead"
msgstr ""

msgid "3782            int i;"
msgstr ""

msgid "3783            string s;"
msgstr ""

msgid "3784            int j;"
msgstr ""

msgid "3785        public:"
msgstr ""

msgid "3786            X3(int ii = 666, const string& ss = \"qqq\", int jj = 0)"
msgstr ""

msgid ""
"3787                :i{ii}, s{ss}, j{jj} { }   // all members are "
"initialized to their defaults"
msgstr ""

msgid "3788            // ..."
msgstr ""

msgid "3789        };"
msgstr ""

msgid "3790    ##### Enforcement"
msgstr ""

msgid ""
"3791    * (Simple) Every constructor should initialize every member variable "
"(either explicitly, via a delegating ctor call or via default construction)."
msgstr ""

msgid ""
"3792    * (Simple) Default arguments to constructors suggest an in-class "
"initializer may be more appropriate."
msgstr ""

msgid ""
"3793    ### <a name=\"Rc-initialize\"></a>C.49: Prefer initialization to "
"assignment in constructors"
msgstr ""

msgid "3794    ##### Reason"
msgstr ""

msgid ""
"3795    An initialization explicitly states that initialization, rather than "
"assignment, is done and can be more elegant and efficient. Prevents \"use "
"before set\" errors."
msgstr ""

msgid "3796    ##### Example, good"
msgstr ""

msgid "3797        class A {   // Good"
msgstr ""

msgid "3798            string s1;"
msgstr ""

msgid "3799        public:"
msgstr ""

msgid "3800            A() : s1{\"Hello, \"} { }    // GOOD: directly construct"
msgstr ""

msgid "3801            // ..."
msgstr ""

msgid "3802        };"
msgstr ""

msgid "3803    ##### Example, bad"
msgstr ""

msgid "3804        class B {   // BAD"
msgstr ""

msgid "3805            string s1;"
msgstr ""

msgid "3806        public:"
msgstr ""

msgid ""
"3807            B() { s1 = \"Hello, \"; }   // BAD: default constructor "
"followed by assignment"
msgstr ""

msgid "3808            // ..."
msgstr ""

msgid "3809        };"
msgstr ""

msgid "3810        class C {   // UGLY, aka very bad"
msgstr ""

msgid "3811            int* p;"
msgstr ""

msgid "3812        public:"
msgstr ""

msgid ""
"3813            C() { cout << *p; p = new int{10}; }   // accidental use "
"before initialized"
msgstr ""

msgid "3814            // ..."
msgstr ""

msgid "3815        };"
msgstr ""

msgid ""
"3816    ### <a name=\"Rc-factory\"></a>C.50: Use a factory function if you "
"need \"virtual behavior\" during initialization"
msgstr ""

msgid "3817    ##### Reason"
msgstr ""

msgid ""
"3818    If the state of a base class object must depend on the state of a "
"derived part of the object, we need to use a virtual function (or "
"equivalent) while minimizing the window of opportunity to misuse an "
"imperfectly constructed object."
msgstr ""

msgid "3819    ##### Note"
msgstr ""

msgid ""
"3820    The return type of the factory should normally be `unique_ptr` by "
"default; if some uses are shared, the caller can `move` the `unique_ptr` "
"into a `shared_ptr`. However, if the factory author knows that all uses of "
"the returned object will be shared uses, return `shared_ptr` and use "
"`make_shared` in the body to save an allocation."
msgstr ""

msgid "3821    ##### Example, bad"
msgstr ""

msgid "3822        class B {"
msgstr ""

msgid "3823        public:"
msgstr ""

msgid "3824            B()"
msgstr ""

msgid "3825            {"
msgstr ""

msgid "3826                // ..."
msgstr ""

msgid "3827                f();   // BAD: virtual call in constructor"
msgstr ""

msgid "3828                // ..."
msgstr ""

msgid "3829            }"
msgstr ""

msgid "3830            virtual void f() = 0;"
msgstr ""

msgid "3831            // ..."
msgstr ""

msgid "3832        };"
msgstr ""

msgid "3833    ##### Example"
msgstr ""

msgid "3834        class B {"
msgstr ""

msgid "3835        protected:"
msgstr ""

msgid ""
"3836            B() { /* ... */ }              // create an imperfectly "
"initialized object"
msgstr ""

msgid ""
"3837            virtual void PostInitialize()  // to be called right after "
"construction"
msgstr ""

msgid "3838            {"
msgstr ""

msgid "3839                // ..."
msgstr ""

msgid "3840                f();    // GOOD: virtual dispatch is safe"
msgstr ""

msgid "3841                // ..."
msgstr ""

msgid "3842            }"
msgstr ""

msgid "3843        public:"
msgstr ""

msgid "3844            virtual void f() = 0;"
msgstr ""

msgid "3845            template<class T>"
msgstr ""

msgid ""
"3846            static shared_ptr<T> Create()  // interface for creating "
"shared objects"
msgstr ""

msgid "3847            {"
msgstr ""

msgid "3848                auto p = make_shared<T>();"
msgstr ""

msgid "3849                p->PostInitialize();"
msgstr ""

msgid "3850                return p;"
msgstr ""

msgid "3851            }"
msgstr ""

msgid "3852        };"
msgstr ""

msgid "3853        class D : public B { /* ... */ };  // some derived class"
msgstr ""

msgid "3854        shared_ptr<D> p = D::Create<D>();  // creating a D object"
msgstr ""

msgid ""
"3855    By making the constructor `protected` we avoid an incompletely "
"constructed object escaping into the wild."
msgstr ""

msgid ""
"3856    By providing the factory function `Create()`, we make construction "
"(on the free store) convenient."
msgstr ""

msgid "3857    ##### Note"
msgstr ""

msgid ""
"3858    Conventional factory functions allocate on the free store, rather "
"than on the stack or in an enclosing object."
msgstr ""

msgid "3859    **See also**: [Discussion](#Sd-factory)"
msgstr ""

msgid ""
"3860    ### <a name=\"Rc-delegating\"></a>C.51: Use delegating constructors "
"to represent common actions for all constructors of a class"
msgstr ""

msgid "3861    ##### Reason"
msgstr ""

msgid "3862    To avoid repetition and accidental differences."
msgstr ""

msgid "3863    ##### Example, bad"
msgstr ""

msgid "3864        class Date {   // BAD: repetitive"
msgstr ""

msgid "3865            int d;"
msgstr ""

msgid "3866            Month m;"
msgstr ""

msgid "3867            int y;"
msgstr ""

msgid "3868        public:"
msgstr ""

msgid "3869            Date(int ii, Month mm, year yy)"
msgstr ""

msgid "3870                :i{ii}, m{mm}, y{yy}"
msgstr ""

msgid "3871                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr ""

msgid "3872            Date(int ii, Month mm)"
msgstr ""

msgid "3873                :i{ii}, m{mm} y{current_year()}"
msgstr ""

msgid "3874                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr ""

msgid "3875            // ..."
msgstr ""

msgid "3876        };"
msgstr ""

msgid ""
"3877    The common action gets tedious to write and may accidentally not be "
"common."
msgstr ""

msgid "3878    ##### Example"
msgstr ""

msgid "3879        class Date2 {"
msgstr ""

msgid "3880            int d;"
msgstr ""

msgid "3881            Month m;"
msgstr ""

msgid "3882            int y;"
msgstr ""

msgid "3883        public:"
msgstr ""

msgid "3884            Date2(int ii, Month mm, year yy)"
msgstr ""

msgid "3885                :i{ii}, m{mm}, y{yy}"
msgstr ""

msgid "3886                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr ""

msgid "3887            Date2(int ii, Month mm)"
msgstr ""

msgid "3888                :Date2{ii, mm, current_year()} {}"
msgstr ""

msgid "3889            // ..."
msgstr ""

msgid "3890        };"
msgstr ""

msgid ""
"3891    **See also**: If the \"repeated action\" is a simple initialization, "
"consider [an in-class member initializer](#Rc-in-class-initializer)."
msgstr ""

msgid "3892    ##### Enforcement"
msgstr ""

msgid "3893    (Moderate) Look for similar constructor bodies."
msgstr ""

msgid ""
"3894    ### <a name=\"Rc-inheriting\"></a>C.52: Use inheriting constructors "
"to import constructors into a derived class that does not need further "
"explicit initialization"
msgstr ""

msgid "3895    ##### Reason"
msgstr ""

msgid ""
"3896    If you need those constructors for a derived class, re-implementing "
"them is tedious and error-prone."
msgstr ""

msgid "3897    ##### Example"
msgstr ""

msgid ""
"3898    `std::vector` has a lot of tricky constructors, so if I want my own "
"`vector`, I don't want to reimplement them:"
msgstr ""

msgid "3899        class Rec {"
msgstr ""

msgid "3900            // ... data and lots of nice constructors ..."
msgstr ""

msgid "3901        };"
msgstr ""

msgid "3902        class Oper : public Rec {"
msgstr ""

msgid "3903            using Rec::Rec;"
msgstr ""

msgid "3904            // ... no data members ..."
msgstr ""

msgid "3905            // ... lots of nice utility functions ..."
msgstr ""

msgid "3906        };"
msgstr ""

msgid "3907    ##### Example, bad"
msgstr ""

msgid "3908        struct Rec2 : public Rec {"
msgstr ""

msgid "3909            int x;"
msgstr ""

msgid "3910            using Rec::Rec;"
msgstr ""

msgid "3911        };"
msgstr ""

msgid "3912        Rec2 r {\"foo\", 7};"
msgstr ""

msgid "3913        int val = r.x;   // uninitialized"
msgstr ""

msgid "3914    ##### Enforcement"
msgstr ""

msgid ""
"3915    Make sure that every member of the derived class is initialized."
msgstr ""

msgid "3916    ## <a name=\"SS-copy\"></a>C.copy: Copy and move"
msgstr ""

msgid ""
"3917    Value types should generally be copyable, but interfaces in a class "
"hierarchy should not."
msgstr ""

msgid "3918    Resource handles may or may not be copyable."
msgstr ""

msgid ""
"3919    Types can be defined to move for logical as well as performance "
"reasons."
msgstr ""

msgid ""
"3920    ### <a name=\"Rc-copy-assignment\"></a>C.60: Make copy assignment "
"non-`virtual`, take the parameter by `const&`, and return by non-`const&`"
msgstr ""

msgid "3921    ##### Reason"
msgstr ""

msgid ""
"3922    It is simple and efficient. If you want to optimize for rvalues, "
"provide an overload that takes a `&&` (see [F.18](#Rf-consume))."
msgstr ""

msgid "3923    ##### Example"
msgstr ""

msgid "3924        class Foo {"
msgstr ""

msgid "3925        public:"
msgstr ""

msgid "3926            Foo& operator=(const Foo& x)"
msgstr ""

msgid "3927            {"
msgstr ""

msgid ""
"3928                // GOOD: no need to check for self-assignment (other "
"than performance)"
msgstr ""

msgid "3929                auto tmp = x;"
msgstr ""

msgid "3930                std::swap(*this, tmp);"
msgstr ""

msgid "3931                return *this;"
msgstr ""

msgid "3932            }"
msgstr ""

msgid "3933            // ..."
msgstr ""

msgid "3934        };"
msgstr ""

msgid "3935        Foo a;"
msgstr ""

msgid "3936        Foo b;"
msgstr ""

msgid "3937        Foo f();"
msgstr ""

msgid "3938        a = b;    // assign lvalue: copy"
msgstr ""

msgid "3939        a = f();  // assign rvalue: potentially move"
msgstr ""

msgid "3940    ##### Note"
msgstr ""

msgid ""
"3941    The `swap` implementation technique offers the [strong "
"guarantee](#Abrahams01)."
msgstr ""

msgid "3942    ##### Example"
msgstr ""

msgid ""
"3943    But what if you can get significantly better performance by not "
"making a temporary copy? Consider a simple `Vector` intended for a domain "
"where assignment of large, equal-sized `Vector`s is common. In this case, "
"the copy of elements implied by the `swap` implementation technique could "
"cause an order of magnitude increase in cost:"
msgstr ""

msgid "3944        template<typename T>"
msgstr ""

msgid "3945        class Vector {"
msgstr ""

msgid "3946        public:"
msgstr ""

msgid "3947            Vector& operator=(const Vector&);"
msgstr ""

msgid "3948            // ..."
msgstr ""

msgid "3949        private:"
msgstr ""

msgid "3950            T* elem;"
msgstr ""

msgid "3951            int sz;"
msgstr ""

msgid "3952        };"
msgstr ""

msgid "3953        Vector& Vector::operator=(const Vector& a)"
msgstr ""

msgid "3954        {"
msgstr ""

msgid "3955            if (a.sz > sz) {"
msgstr ""

msgid ""
"3956                // ... use the swap technique, it can't be bettered ..."
msgstr ""

msgid "3957                return *this"
msgstr ""

msgid "3958            }"
msgstr ""

msgid "3959            // ... copy sz elements from *a.elem to elem ..."
msgstr ""

msgid "3960            if (a.sz < sz) {"
msgstr ""

msgid ""
"3961                // ... destroy the surplus elements in *this* and adjust "
"size ..."
msgstr ""

msgid "3962            }"
msgstr ""

msgid "3963            return *this;"
msgstr ""

msgid "3964        }"
msgstr ""

msgid ""
"3965    By writing directly to the target elements, we will get only [the "
"basic guarantee](#Abrahams01) rather than the strong guarantee offered by "
"the `swap` technique. Beware of [self-assignment](#Rc-copy-self)."
msgstr ""

msgid ""
"3966    **Alternatives**: If you think you need a `virtual` assignment "
"operator, and understand why that's deeply problematic, don't call it "
"`operator=`. Make it a named function like `virtual void assign(const Foo&)`."
""
msgstr ""

msgid "3967    See [copy constructor vs. `clone()`](#Rc-copy-virtual)."
msgstr ""

msgid "3968    ##### Enforcement"
msgstr ""

msgid ""
"3969    * (Simple) An assignment operator should not be virtual. Here be "
"dragons!"
msgstr ""

msgid ""
"3970    * (Simple) An assignment operator should return `T&` to enable "
"chaining, not alternatives like `const T&` which interfere with "
"composability and putting objects in containers."
msgstr ""

msgid ""
"3971    * (Moderate) An assignment operator should (implicitly or "
"explicitly) invoke all base and member assignment operators."
msgstr ""

msgid ""
"3972      Look at the destructor to determine if the type has pointer "
"semantics or value semantics."
msgstr ""

msgid ""
"3973    ### <a name=\"Rc-copy-semantic\"></a>C.61: A copy operation should "
"copy"
msgstr ""

msgid "3974    ##### Reason"
msgstr ""

msgid ""
"3975    That is the generally assumed semantics. After `x = y`, we should "
"have `x == y`."
msgstr ""

msgid ""
"3976    After a copy `x` and `y` can be independent objects (value "
"semantics, the way non-pointer built-in types and the standard-library types "
"work) or refer to a shared object (pointer semantics, the way pointers work)."
""
msgstr ""

msgid "3977    ##### Example"
msgstr ""

msgid "3978        class X {   // OK: value semantics"
msgstr ""

msgid "3979        public:"
msgstr ""

msgid "3980            X();"
msgstr ""

msgid "3981            X(const X&);     // copy X"
msgstr ""

msgid "3982            void modify();   // change the value of X"
msgstr ""

msgid "3983            // ..."
msgstr ""

msgid "3984            ~X() { delete[] p; }"
msgstr ""

msgid "3985        private:"
msgstr ""

msgid "3986            T* p;"
msgstr ""

msgid "3987            int sz;"
msgstr ""

msgid "3988        };"
msgstr ""

msgid "3989        bool operator==(const X& a, const X& b)"
msgstr ""

msgid "3990        {"
msgstr ""

msgid ""
"3991            return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b."
"sz);"
msgstr ""

msgid "3992        }"
msgstr ""

msgid "3993        X::X(const X& a)"
msgstr ""

msgid "3994            :p{new T[a.sz]}, sz{a.sz}"
msgstr ""

msgid "3995        {"
msgstr ""

msgid "3996            copy(a.p, a.p + sz, p);"
msgstr ""

msgid "3997        }"
msgstr ""

msgid "3998        X x;"
msgstr ""

msgid "3999        X y = x;"
msgstr ""

msgid "4000        if (x != y) throw Bad{};"
msgstr ""

msgid "4001        x.modify();"
msgstr ""

msgid "4002        if (x == y) throw Bad{};   // assume value semantics"
msgstr ""

msgid "4003    ##### Example"
msgstr ""

msgid "4004        class X2 {  // OK: pointer semantics"
msgstr ""

msgid "4005        public:"
msgstr ""

msgid "4006            X2();"
msgstr ""

msgid "4007            X2(const X2&) = default; // shallow copy"
msgstr ""

msgid "4008            ~X2() = default;"
msgstr ""

msgid "4009            void modify();          // change the pointed-to value"
msgstr ""

msgid "4010            // ..."
msgstr ""

msgid "4011        private:"
msgstr ""

msgid "4012            T* p;"
msgstr ""

msgid "4013            int sz;"
msgstr ""

msgid "4014        };"
msgstr ""

msgid "4015        bool operator==(const X2& a, const X2& b)"
msgstr ""

msgid "4016        {"
msgstr ""

msgid "4017            return a.sz == b.sz && a.p == b.p;"
msgstr ""

msgid "4018        }"
msgstr ""

msgid "4019        X2 x;"
msgstr ""

msgid "4020        X2 y = x;"
msgstr ""

msgid "4021        if (x != y) throw Bad{};"
msgstr ""

msgid "4022        x.modify();"
msgstr ""

msgid "4023        if (x != y) throw Bad{};  // assume pointer semantics"
msgstr ""

msgid "4024    ##### Note"
msgstr ""

msgid ""
"4025    Prefer copy semantics unless you are building a \"smart pointer\". "
"Value semantics is the simplest to reason about and what the standard-"
"library facilities expect."
msgstr ""

msgid "4026    ##### Enforcement"
msgstr ""

msgid "4027    (Not enforceable)"
msgstr ""

msgid ""
"4028    ### <a name=\"Rc-copy-self\"></a>C.62: Make copy assignment safe for "
"self-assignment"
msgstr ""

msgid "4029    ##### Reason"
msgstr ""

msgid ""
"4030    If `x = x` changes the value of `x`, people will be surprised and "
"bad errors will occur (often including leaks)."
msgstr ""

msgid "4031    ##### Example"
msgstr ""

msgid ""
"4032    The standard-library containers handle self-assignment elegantly and "
"efficiently:"
msgstr ""

msgid "4033        std::vector<int> v = {3, 1, 4, 1, 5, 9};"
msgstr ""

msgid "4034        v = v;"
msgstr ""

msgid "4035        // the value of v is still {3, 1, 4, 1, 5, 9}"
msgstr ""

msgid "4036    ##### Note"
msgstr ""

msgid ""
"4037    The default assignment generated from members that handle self-"
"assignment correctly handles self-assignment."
msgstr ""

msgid "4038        struct Bar {"
msgstr ""

msgid "4039            vector<pair<int, int>> v;"
msgstr ""

msgid "4040            map<string, int> m;"
msgstr ""

msgid "4041            string s;"
msgstr ""

msgid "4042        };"
msgstr ""

msgid "4043        Bar b;"
msgstr ""

msgid "4044        // ..."
msgstr ""

msgid "4045        b = b;   // correct and efficient"
msgstr ""

msgid "4046    ##### Note"
msgstr ""

msgid ""
"4047    You can handle self-assignment by explicitly testing for self-"
"assignment, but often it is faster and more elegant to cope without such a "
"test (e.g., [using `swap`](#Rc-swap))."
msgstr ""

msgid "4048        class Foo {"
msgstr ""

msgid "4049            string s;"
msgstr ""

msgid "4050            int i;"
msgstr ""

msgid "4051        public:"
msgstr ""

msgid "4052            Foo& operator=(const Foo& a);"
msgstr ""

msgid "4053            // ..."
msgstr ""

msgid "4054        };"
msgstr ""

msgid ""
"4055        Foo& Foo::operator=(const Foo& a)   // OK, but there is a cost"
msgstr ""

msgid "4056        {"
msgstr ""

msgid "4057            if (this == &a) return *this;"
msgstr ""

msgid "4058            s = a.s;"
msgstr ""

msgid "4059            i = a.i;"
msgstr ""

msgid "4060            return *this;"
msgstr ""

msgid "4061        }"
msgstr ""

msgid "4062    This is obviously safe and apparently efficient."
msgstr ""

msgid ""
"4063    However, what if we do one self-assignment per million assignments?"
msgstr ""

msgid ""
"4064    That's about a million redundant tests (but since the answer is "
"essentially always the same, the computer's branch predictor will guess "
"right essentially every time)."
msgstr ""

msgid "4065    Consider:"
msgstr ""

msgid ""
"4066        Foo& Foo::operator=(const Foo& a)   // simpler, and probably "
"much better"
msgstr ""

msgid "4067        {"
msgstr ""

msgid "4068            s = a.s;"
msgstr ""

msgid "4069            i = a.i;"
msgstr ""

msgid "4070            return *this;"
msgstr ""

msgid "4071        }"
msgstr ""

msgid ""
"4072    `std::string` is safe for self-assignment and so are `int`. All the "
"cost is carried by the (rare) case of self-assignment."
msgstr ""

msgid "4073    ##### Enforcement"
msgstr ""

msgid ""
"4074    (Simple) Assignment operators should not contain the pattern `if "
"(this == &a) return *this;` ???"
msgstr ""

msgid ""
"4075    ### <a name=\"Rc-move-assignment\"></a>C.63: Make move assignment "
"non-`virtual`, take the parameter by `&&`, and return by non-`const &`"
msgstr ""

msgid "4076    ##### Reason"
msgstr ""

msgid "4077    It is simple and efficient."
msgstr ""

msgid "4078    **See**: [The rule for copy-assignment](#Rc-copy-assignment)."
msgstr ""

msgid "4079    ##### Enforcement"
msgstr ""

msgid ""
"4080    Equivalent to what is done for [copy-assignment](#Rc-copy-"
"assignment)."
msgstr ""

msgid ""
"4081    * (Simple) An assignment operator should not be virtual. Here be "
"dragons!"
msgstr ""

msgid ""
"4082    * (Simple) An assignment operator should return `T&` to enable "
"chaining, not alternatives like `const T&` which interfere with "
"composability and putting objects in containers."
msgstr ""

msgid ""
"4083    * (Moderate) A move assignment operator should (implicitly or "
"explicitly) invoke all base and member move assignment operators."
msgstr ""

msgid ""
"4084    ### <a name=\"Rc-move-semantic\"></a>C.64: A move operation should "
"move and leave its source in a valid state"
msgstr ""

msgid "4085    ##### Reason"
msgstr ""

msgid "4086    That is the generally assumed semantics."
msgstr ""

msgid ""
"4087    After `y = std::move(x)` the value of `y` should be the value `x` "
"had and `x` should be in a valid state."
msgstr ""

msgid "4088    ##### Example"
msgstr ""

msgid "4089        template<typename T>"
msgstr ""

msgid "4090        class X {   // OK: value semantics"
msgstr ""

msgid "4091        public:"
msgstr ""

msgid "4092            X();"
msgstr ""

msgid "4093            X(X&& a) noexcept;  // move X"
msgstr ""

msgid "4094            void modify();     // change the value of X"
msgstr ""

msgid "4095            // ..."
msgstr ""

msgid "4096            ~X() { delete[] p; }"
msgstr ""

msgid "4097        private:"
msgstr ""

msgid "4098            T* p;"
msgstr ""

msgid "4099            int sz;"
msgstr ""

msgid "4100        };"
msgstr ""

msgid "4101        X::X(X&& a)"
msgstr ""

msgid "4102            :p{a.p}, sz{a.sz}  // steal representation"
msgstr ""

msgid "4103        {"
msgstr ""

msgid "4104            a.p = nullptr;     // set to \"empty\""
msgstr ""

msgid "4105            a.sz = 0;"
msgstr ""

msgid "4106        }"
msgstr ""

msgid "4107        void use()"
msgstr ""

msgid "4108        {"
msgstr ""

msgid "4109            X x{};"
msgstr ""

msgid "4110            // ..."
msgstr ""

msgid "4111            X y = std::move(x);"
msgstr ""

msgid "4112            x = X{};   // OK"
msgstr ""

msgid "4113        } // OK: x can be destroyed"
msgstr ""

msgid "4114    ##### Note"
msgstr ""

msgid ""
"4115    Ideally, that moved-from should be the default value of the type."
msgstr ""

msgid ""
"4116    Ensure that unless there is an exceptionally good reason not to."
msgstr ""

msgid ""
"4117    However, not all types have a default value and for some types "
"establishing the default value can be expensive."
msgstr ""

msgid ""
"4118    The standard requires only that the moved-from object can be "
"destroyed."
msgstr ""

msgid ""
"4119    Often, we can easily and cheaply do better: The standard library "
"assumes that it is possible to assign to a moved-from object."
msgstr ""

msgid ""
"4120    Always leave the moved-from object in some (necessarily specified) "
"valid state."
msgstr ""

msgid "4121    ##### Note"
msgstr ""

msgid ""
"4122    Unless there is an exceptionally strong reason not to, make `x = std:"
":move(y); y = z;` work with the conventional semantics."
msgstr ""

msgid "4123    ##### Enforcement"
msgstr ""

msgid ""
"4124    (Not enforceable) Look for assignments to members in the move "
"operation. If there is a default constructor, compare those assignments to "
"the initializations in the default constructor."
msgstr ""

msgid ""
"4125    ### <a name=\"Rc-move-self\"></a>C.65: Make move assignment safe for "
"self-assignment"
msgstr ""

msgid "4126    ##### Reason"
msgstr ""

msgid ""
"4127    If `x = x` changes the value of `x`, people will be surprised and "
"bad errors may occur. However, people don't usually directly write a self-"
"assignment that turn into a move, but it can occur. However, `std::swap` is "
"implemented using move operations so if you accidentally do `swap(a, b)` "
"where `a` and `b` refer to the same object, failing to handle self-move "
"could be a serious and subtle error."
msgstr ""

msgid "4128    ##### Example"
msgstr ""

msgid "4129        class Foo {"
msgstr ""

msgid "4130            string s;"
msgstr ""

msgid "4131            int i;"
msgstr ""

msgid "4132        public:"
msgstr ""

msgid "4133            Foo& operator=(Foo&& a);"
msgstr ""

msgid "4134            // ..."
msgstr ""

msgid "4135        };"
msgstr ""

msgid ""
"4136        Foo& Foo::operator=(Foo&& a) noexcept  // OK, but there is a "
"cost"
msgstr ""

msgid "4137        {"
msgstr ""

msgid ""
"4138            if (this == &a) return *this;  // this line is redundant"
msgstr ""

msgid "4139            s = std::move(a.s);"
msgstr ""

msgid "4140            i = a.i;"
msgstr ""

msgid "4141            return *this;"
msgstr ""

msgid "4142        }"
msgstr ""

msgid ""
"4143    The one-in-a-million argument against `if (this == &a) return "
"*this;` tests from the discussion of [self-assignment](#Rc-copy-self) is "
"even more relevant for self-move."
msgstr ""

msgid "4144    ##### Note"
msgstr ""

msgid ""
"4145    There is no known general way of avoiding a `if (this == &a) return "
"*this;` test for a move assignment and still get a correct answer (i.e., "
"after `x = x` the value of `x` is unchanged)."
msgstr ""

msgid "4146    ##### Note"
msgstr ""

msgid ""
"4147    The ISO standard guarantees only a \"valid but unspecified\" state "
"for the standard-library containers. Apparently this has not been a problem "
"in about 10 years of experimental and production use. Please contact the "
"editors if you find a counter example. The rule here is more caution and "
"insists on complete safety."
msgstr ""

msgid "4148    ##### Example"
msgstr ""

msgid ""
"4149    Here is a way to move a pointer without a test (imagine it as code "
"in the implementation a move assignment):"
msgstr ""

msgid "4150        // move from other.ptr to this->ptr"
msgstr ""

msgid "4151        T* temp = other.ptr;"
msgstr ""

msgid "4152        other.ptr = nullptr;"
msgstr ""

msgid "4153        delete ptr;"
msgstr ""

msgid "4154        ptr = temp;"
msgstr ""

msgid "4155    ##### Enforcement"
msgstr ""

msgid ""
"4156    * (Moderate) In the case of self-assignment, a move assignment "
"operator should not leave the object holding pointer members that have been "
"`delete`d or set to `nullptr`."
msgstr ""

msgid ""
"4157    * (Not enforceable) Look at the use of standard-library container "
"types (incl. `string`) and consider them safe for ordinary (not life-"
"critical) uses."
msgstr ""

msgid ""
"4158    ### <a name=\"Rc-move-noexcept\"></a>C.66: Make move operations "
"`noexcept`"
msgstr ""

msgid "4159    ##### Reason"
msgstr ""

msgid "4160    A throwing move violates most people's reasonably assumptions."
msgstr ""

msgid ""
"4161    A non-throwing move will be used more efficiently by standard-"
"library and language facilities."
msgstr ""

msgid "4162    ##### Example"
msgstr ""

msgid "4163        template<typename T>"
msgstr ""

msgid "4164        class Vector {"
msgstr ""

msgid "4165            // ..."
msgstr ""

msgid ""
"4166            Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = "
"0; a.elem = nullptr; }"
msgstr ""

msgid ""
"4167            Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = "
"a.sz; a.sz = 0; a.elem = nullptr; }"
msgstr ""

msgid "4168            // ..."
msgstr ""

msgid "4169        public:"
msgstr ""

msgid "4170            T* elem;"
msgstr ""

msgid "4171            int sz;"
msgstr ""

msgid "4172        };"
msgstr ""

msgid "4173    These operations do not throw."
msgstr ""

msgid "4174    ##### Example, bad"
msgstr ""

msgid "4175        template<typename T>"
msgstr ""

msgid "4176        class Vector2 {"
msgstr ""

msgid "4177            // ..."
msgstr ""

msgid ""
"4178            Vector2(Vector2&& a) { *this = a; }             // just use "
"the copy"
msgstr ""

msgid ""
"4179            Vector2& operator=(Vector2&& a) { *this = a; }  // just use "
"the copy"
msgstr ""

msgid "4180            // ..."
msgstr ""

msgid "4181        public:"
msgstr ""

msgid "4182            T* elem;"
msgstr ""

msgid "4183            int sz;"
msgstr ""

msgid "4184        };"
msgstr ""

msgid ""
"4185    This `Vector2` is not just inefficient, but since a vector copy "
"requires allocation, it can throw."
msgstr ""

msgid "4186    ##### Enforcement"
msgstr ""

msgid "4187    (Simple) A move operation should be marked `noexcept`."
msgstr ""

msgid ""
"4188    ### <a name=\"Rc-copy-virtual\"></a>C.67: A polymorphic class should "
"suppress copying"
msgstr ""

msgid "4189    ##### Reason"
msgstr ""

msgid ""
"4190    A *polymorphic class* is a class that defines or inherits at least "
"one virtual function. It is likely that it will be used as a base class for "
"other derived classes with polymorphic behavior. If it is accidentally "
"passed by value, with the implicitly generated copy constructor and "
"assignment, we risk slicing: only the base portion of a derived object will "
"be copied, and the polymorphic behavior will be corrupted."
msgstr ""

msgid "4191    ##### Example, bad"
msgstr ""

msgid ""
"4192        class B { // BAD: polymorphic base class doesn't suppress "
"copying"
msgstr ""

msgid "4193        public:"
msgstr ""

msgid "4194            virtual char m() { return 'B'; }"
msgstr ""

msgid ""
"4195            // ... nothing about copy operations, so uses default ..."
msgstr ""

msgid "4196        };"
msgstr ""

msgid "4197        class D : public B {"
msgstr ""

msgid "4198        public:"
msgstr ""

msgid "4199            char m() override { return 'D'; }"
msgstr ""

msgid "4200            // ..."
msgstr ""

msgid "4201        };"
msgstr ""

msgid "4202        void f(B& b) {"
msgstr ""

msgid ""
"4203            auto b2 = b; // oops, slices the object; b2.m() will return "
"'B'"
msgstr ""

msgid "4204        }"
msgstr ""

msgid "4205        D d;"
msgstr ""

msgid "4206        f(d);"
msgstr ""

msgid "4207    ##### Example"
msgstr ""

msgid "4208        class B { // GOOD: polymorphic class suppresses copying"
msgstr ""

msgid "4209        public:"
msgstr ""

msgid "4210            B(const B&) = delete;"
msgstr ""

msgid "4211            B& operator=(const B&) = delete;"
msgstr ""

msgid "4212            virtual char m() { return 'B'; }"
msgstr ""

msgid "4213            // ..."
msgstr ""

msgid "4214        };"
msgstr ""

msgid "4215        class D : public B {"
msgstr ""

msgid "4216        public:"
msgstr ""

msgid "4217            char m() override { return 'D'; }"
msgstr ""

msgid "4218            // ..."
msgstr ""

msgid "4219        };"
msgstr ""

msgid "4220        void f(B& b) {"
msgstr ""

msgid ""
"4221            auto b2 = b; // ok, compiler will detect inadvertent "
"copying, and protest"
msgstr ""

msgid "4222        }"
msgstr ""

msgid "4223        D d;"
msgstr ""

msgid "4224        f(d);"
msgstr ""

msgid "4225    ##### Note"
msgstr ""

msgid ""
"4226    If you need to create deep copies of polymorphic objects, use "
"`clone()` functions: see [C.130](#Rh-copy)."
msgstr ""

msgid "4227    ##### Exception"
msgstr ""

msgid ""
"4228    Classes that represent exception objects need both to be polymorphic "
"and copy-constructible."
msgstr ""

msgid "4229    ##### Enforcement"
msgstr ""

msgid "4230    * Flag a polymorphic class with a non-deleted copy operation."
msgstr ""

msgid "4231    * Flag an assignment of polymorphic class objects."
msgstr ""

msgid "4232    ## C.other: Other default operation rules"
msgstr ""

msgid ""
"4233    In addition to the operations for which the language offer default "
"implementations,"
msgstr ""

msgid ""
"4234    there are a few operations that are so foundational that it rules "
"for their definition are needed:"
msgstr ""

msgid "4235    comparisons, `swap`, and `hash`."
msgstr ""

msgid ""
"4236    ### <a name=\"Rc-eqdefault\"></a>C.80: Use `=default` if you have to "
"be explicit about using the default semantics"
msgstr ""

msgid "4237    ##### Reason"
msgstr ""

msgid ""
"4238    The compiler is more likely to get the default semantics right and "
"you cannot implement these functions better than the compiler."
msgstr ""

msgid "4239    ##### Example"
msgstr ""

msgid "4240        class Tracer {"
msgstr ""

msgid "4241            string message;"
msgstr ""

msgid "4242        public:"
msgstr ""

msgid ""
"4243            Tracer(const string& m) : message{m} { cerr << \"entering \" "
"<< message << '\\n'; }"
msgstr ""

msgid "4244            ~Tracer() { cerr << \"exiting \" << message << '\\n'; }"
msgstr ""

msgid "4245            Tracer(const Tracer&) = default;"
msgstr ""

msgid "4246            Tracer& operator=(const Tracer&) = default;"
msgstr ""

msgid "4247            Tracer(Tracer&&) = default;"
msgstr ""

msgid "4248            Tracer& operator=(Tracer&&) = default;"
msgstr ""

msgid "4249        };"
msgstr ""

msgid ""
"4250    Because we defined the destructor, we must define the copy and move "
"operations. The `= default` is the best and simplest way of doing that."
msgstr ""

msgid "4251    ##### Example, bad"
msgstr ""

msgid "4252        class Tracer2 {"
msgstr ""

msgid "4253            string message;"
msgstr ""

msgid "4254        public:"
msgstr ""

msgid ""
"4255            Tracer2(const string& m) : message{m} { cerr << \"entering "
"\" << message << '\\n'; }"
msgstr ""

msgid "4256            ~Tracer2() { cerr << \"exiting \" << message << '\\n'; }"
msgstr ""

msgid "4257            Tracer2(const Tracer2& a) : message{a.message} {}"
msgstr ""

msgid ""
"4258            Tracer2& operator=(const Tracer2& a) { message = a.message; "
"return *this; }"
msgstr ""

msgid "4259            Tracer2(Tracer2&& a) :message{a.message} {}"
msgstr ""

msgid ""
"4260            Tracer2& operator=(Tracer2&& a) { message = a.message; "
"return *this; }"
msgstr ""

msgid "4261        };"
msgstr ""

msgid ""
"4262    Writing out the bodies of the copy and move operations is verbose, "
"tedious, and error-prone. A compiler does it better."
msgstr ""

msgid "4263    ##### Enforcement"
msgstr ""

msgid ""
"4264    (Moderate) The body of a special operation should not have the same "
"accessibility and semantics as the compiler-generated version, because that "
"would be redundant"
msgstr ""

msgid ""
"4265    ### <a name=\"Rc-delete\"></a>C.81: Use `=delete` when you want to "
"disable default behavior (without wanting an alternative)"
msgstr ""

msgid "4266    ##### Reason"
msgstr ""

msgid "4267    In a few cases, a default operation is not desirable."
msgstr ""

msgid "4268    ##### Example"
msgstr ""

msgid "4269        class Immortal {"
msgstr ""

msgid "4270        public:"
msgstr ""

msgid "4271            ~Immortal() = delete;   // do not allow destruction"
msgstr ""

msgid "4272            // ..."
msgstr ""

msgid "4273        };"
msgstr ""

msgid "4274        void use()"
msgstr ""

msgid "4275        {"
msgstr ""

msgid "4276            Immortal ugh;   // error: ugh cannot be destroyed"
msgstr ""

msgid "4277            Immortal* p = new Immortal{};"
msgstr ""

msgid "4278            delete p;       // error: cannot destroy *p"
msgstr ""

msgid "4279        }"
msgstr ""

msgid "4280    ##### Example"
msgstr ""

msgid ""
"4281    A `unique_ptr` can be moved, but not copied. To achieve that its "
"copy operations are deleted. To avoid copying it is necessary to `=delete` "
"its copy operations from lvalues:"
msgstr ""

msgid ""
"4282        template <class T, class D = default_delete<T>> class unique_ptr "
"{"
msgstr ""

msgid "4283        public:"
msgstr ""

msgid "4284            // ..."
msgstr ""

msgid "4285            constexpr unique_ptr() noexcept;"
msgstr ""

msgid "4286            explicit unique_ptr(pointer p) noexcept;"
msgstr ""

msgid "4287            // ..."
msgstr ""

msgid ""
"4288            unique_ptr(unique_ptr&& u) noexcept;   // move constructor"
msgstr ""

msgid "4289            // ..."
msgstr ""

msgid ""
"4290            unique_ptr(const unique_ptr&) = delete; // disable copy from "
"lvalue"
msgstr ""

msgid "4291            // ..."
msgstr ""

msgid "4292        };"
msgstr ""

msgid ""
"4293        unique_ptr<int> make();   // make \"something\" and return it by "
"moving"
msgstr ""

msgid "4294        void f()"
msgstr ""

msgid "4295        {"
msgstr ""

msgid "4296            unique_ptr<int> pi {};"
msgstr ""

msgid ""
"4297            auto pi2 {pi};      // error: no move constructor from "
"lvalue"
msgstr ""

msgid ""
"4298            auto pi3 {make()};  // OK, move: the result of make() is an "
"rvalue"
msgstr ""

msgid "4299        }"
msgstr ""

msgid "4300    Note that deleted functions should be public."
msgstr ""

msgid "4301    ##### Enforcement"
msgstr ""

msgid ""
"4302    The elimination of a default operation is (should be) based on the "
"desired semantics of the class. Consider such classes suspect, but maintain "
"a \"positive list\" of classes where a human has asserted that the semantics "
"is correct."
msgstr ""

msgid ""
"4303    ### <a name=\"Rc-ctor-virtual\"></a>C.82: Don't call virtual "
"functions in constructors and destructors"
msgstr ""

msgid "4304    ##### Reason"
msgstr ""

msgid ""
"4305    The function called will be that of the object constructed so far, "
"rather than a possibly overriding function in a derived class."
msgstr ""

msgid "4306    This can be most confusing."
msgstr ""

msgid ""
"4307    Worse, a direct or indirect call to an unimplemented pure virtual "
"function from a constructor or destructor results in undefined behavior."
msgstr ""

msgid "4308    ##### Example, bad"
msgstr ""

msgid "4309        class Base {"
msgstr ""

msgid "4310        public:"
msgstr ""

msgid "4311            virtual void f() = 0;   // not implemented"
msgstr ""

msgid ""
"4312            virtual void g();       // implemented with Base version"
msgstr ""

msgid ""
"4313            virtual void h();       // implemented with Base version"
msgstr ""

msgid "4314        };"
msgstr ""

msgid "4315        class Derived : public Base {"
msgstr ""

msgid "4316        public:"
msgstr ""

msgid "4317            void g() override;   // provide Derived implementation"
msgstr ""

msgid "4318            void h() final;      // provide Derived implementation"
msgstr ""

msgid "4319            Derived()"
msgstr ""

msgid "4320            {"
msgstr ""

msgid ""
"4321                // BAD: attempt to call an unimplemented virtual "
"function"
msgstr ""

msgid "4322                f();"
msgstr ""

msgid ""
"4323                // BAD: will call Derived::g, not dispatch further "
"virtually"
msgstr ""

msgid "4324                g();"
msgstr ""

msgid ""
"4325                // GOOD: explicitly state intent to call only the "
"visible version"
msgstr ""

msgid "4326                Derived::g();"
msgstr ""

msgid "4327                // ok, no qualification needed, h is final"
msgstr ""

msgid "4328                h();"
msgstr ""

msgid "4329            }"
msgstr ""

msgid "4330        };"
msgstr ""

msgid ""
"4331    Note that calling a specific explicitly qualified function is not a "
"virtual call even if the function is `virtual`."
msgstr ""

msgid ""
"4332    **See also** [factory functions](#Rc-factory) for how to achieve the "
"effect of a call to a derived class function without risking undefined "
"behavior."
msgstr ""

msgid "4333    ##### Note"
msgstr ""

msgid ""
"4334    There is nothing inherently wrong with calling virtual functions "
"from constructors and destructors."
msgstr ""

msgid "4335    The semantics of such calls is type safe."
msgstr ""

msgid ""
"4336    However, experience shows that such calls are rarely needed, easily "
"confuse maintainers, and become a source of errors when used by novices."
msgstr ""

msgid "4337    ##### Enforcement"
msgstr ""

msgid ""
"4338    * Flag calls of virtual functions from constructors and destructors."
msgstr ""

msgid ""
"4339    ### <a name=\"Rc-swap\"></a>C.83: For value-like types, consider "
"providing a `noexcept` swap function"
msgstr ""

msgid "4340    ##### Reason"
msgstr ""

msgid ""
"4341    A `swap` can be handy for implementing a number of idioms, from "
"smoothly moving objects around to implementing assignment easily to "
"providing a guaranteed commit function that enables strongly error-safe "
"calling code. Consider using swap to implement copy assignment in terms of "
"copy construction. See also [destructors, deallocation, and swap must never "
"fail](#Re-never-fail)."
msgstr ""

msgid "4342    ##### Example, good"
msgstr ""

msgid "4343        class Foo {"
msgstr ""

msgid "4344            // ..."
msgstr ""

msgid "4345        public:"
msgstr ""

msgid "4346            void swap(Foo& rhs) noexcept"
msgstr ""

msgid "4347            {"
msgstr ""

msgid "4348                m1.swap(rhs.m1);"
msgstr ""

msgid "4349                std::swap(m2, rhs.m2);"
msgstr ""

msgid "4350            }"
msgstr ""

msgid "4351        private:"
msgstr ""

msgid "4352            Bar m1;"
msgstr ""

msgid "4353            int m2;"
msgstr ""

msgid "4354        };"
msgstr ""

msgid ""
"4355    Providing a nonmember `swap` function in the same namespace as your "
"type for callers' convenience."
msgstr ""

msgid "4356        void swap(Foo& a, Foo& b)"
msgstr ""

msgid "4357        {"
msgstr ""

msgid "4358            a.swap(b);"
msgstr ""

msgid "4359        }"
msgstr ""

msgid "4360    ##### Enforcement"
msgstr ""

msgid ""
"4361    * (Simple) A class without virtual functions should have a `swap` "
"member function declared."
msgstr ""

msgid ""
"4362    * (Simple) When a class has a `swap` member function, it should be "
"declared `noexcept`."
msgstr ""

msgid ""
"4363    ### <a name=\"Rc-swap-fail\"></a>C.84: A `swap` function may not "
"fail"
msgstr ""

msgid "4364    ##### Reason"
msgstr ""

msgid ""
"4365     `swap` is widely used in ways that are assumed never to fail and "
"programs cannot easily be written to work correctly in the presence of a "
"failing `swap`. The standard-library containers and algorithms will not work "
"correctly if a swap of an element type fails."
msgstr ""

msgid "4366    ##### Example, bad"
msgstr ""

msgid "4367        void swap(My_vector& x, My_vector& y)"
msgstr ""

msgid "4368        {"
msgstr ""

msgid "4369            auto tmp = x;   // copy elements"
msgstr ""

msgid "4370            x = y;"
msgstr ""

msgid "4371            y = tmp;"
msgstr ""

msgid "4372        }"
msgstr ""

msgid ""
"4373    This is not just slow, but if a memory allocation occurs for the "
"elements in `tmp`, this `swap` may throw and would make STL algorithms fail "
"if used with them."
msgstr ""

msgid "4374    ##### Enforcement"
msgstr ""

msgid ""
"4375    (Simple) When a class has a `swap` member function, it should be "
"declared `noexcept`."
msgstr ""

msgid ""
"4376    ### <a name=\"Rc-swap-noexcept\"></a>C.85: Make `swap` `noexcept`"
msgstr ""

msgid "4377    ##### Reason"
msgstr ""

msgid "4378     [A `swap` may not fail](#Rc-swap-fail)."
msgstr ""

msgid ""
"4379    If a `swap` tries to exit with an exception, it's a bad design error "
"and the program had better terminate."
msgstr ""

msgid "4380    ##### Enforcement"
msgstr ""

msgid ""
"4381    (Simple) When a class has a `swap` member function, it should be "
"declared `noexcept`."
msgstr ""

msgid ""
"4382    ### <a name=\"Rc-eq\"></a>C.86: Make `==` symmetric with respect to "
"operand types and `noexcept`"
msgstr ""

msgid "4383    ##### Reason"
msgstr ""

msgid ""
"4384    Asymmetric treatment of operands is surprising and a source of "
"errors where conversions are possible."
msgstr ""

msgid ""
"4385    `==` is a fundamental operations and programmers should be able to "
"use it without fear of failure."
msgstr ""

msgid "4386    ##### Example"
msgstr ""

msgid "4387        struct X {"
msgstr ""

msgid "4388            string name;"
msgstr ""

msgid "4389            int number;"
msgstr ""

msgid "4390        };"
msgstr ""

msgid "4391        bool operator==(const X& a, const X& b) noexcept {"
msgstr ""

msgid "4392            return a.name == b.name && a.number == b.number;"
msgstr ""

msgid "4393        }"
msgstr ""

msgid "4394    ##### Example, bad"
msgstr ""

msgid "4395        class B {"
msgstr ""

msgid "4396            string name;"
msgstr ""

msgid "4397            int number;"
msgstr ""

msgid "4398            bool operator==(const B& a) const {"
msgstr ""

msgid "4399                return name == a.name && number == a.number;"
msgstr ""

msgid "4400            }"
msgstr ""

msgid "4401            // ..."
msgstr ""

msgid "4402        };"
msgstr ""

msgid ""
"4403    `B`'s comparison accepts conversions for its second operand, but not "
"its first."
msgstr ""

msgid "4404    ##### Note"
msgstr ""

msgid ""
"4405    If a class has a failure state, like `double`'s `NaN`, there is a "
"temptation to make a comparison against the failure state throw."
msgstr ""

msgid ""
"4406    The alternative is to make two failure states compare equal and any "
"valid state compare false against the failure state."
msgstr ""

msgid "4407    #### Note"
msgstr ""

msgid ""
"4408    This rule applies to all the usual comparison operators: `!=`, `<`, "
"`<=`, `>`, and `>=`."
msgstr ""

msgid "4409    ##### Enforcement"
msgstr ""

msgid ""
"4410    * Flag an `operator==()` for which the argument types differ; same "
"for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr ""

msgid ""
"4411    * Flag member `operator==()`s; same for other comparison operators: "
"`!=`, `<`, `<=`, `>`, and `>=`."
msgstr ""

msgid ""
"4412    ### <a name=\"Rc-eq-base\"></a>C.87: Beware of `==` on base classes"
msgstr ""

msgid "4413    ##### Reason"
msgstr ""

msgid ""
"4414    It is really hard to write a foolproof and useful `==` for a "
"hierarchy."
msgstr ""

msgid "4415    ##### Example, bad"
msgstr ""

msgid "4416        class B {"
msgstr ""

msgid "4417            string name;"
msgstr ""

msgid "4418            int number;"
msgstr ""

msgid "4419            virtual bool operator==(const B& a) const"
msgstr ""

msgid "4420            {"
msgstr ""

msgid "4421                 return name == a.name && number == a.number;"
msgstr ""

msgid "4422            }"
msgstr ""

msgid "4423            // ..."
msgstr ""

msgid "4424        };"
msgstr ""

msgid ""
"4425    `B`'s comparison accepts conversions for its second operand, but not "
"its first."
msgstr ""

msgid "4426        class D :B {"
msgstr ""

msgid "4427            char character;"
msgstr ""

msgid "4428            virtual bool operator==(const D& a) const"
msgstr ""

msgid "4429            {"
msgstr ""

msgid ""
"4430                return name == a.name && number == a.number && character "
"== a.character;"
msgstr ""

msgid "4431            }"
msgstr ""

msgid "4432            // ..."
msgstr ""

msgid "4433        };"
msgstr ""

msgid "4434        B b = ..."
msgstr ""

msgid "4435        D d = ..."
msgstr ""

msgid ""
"4436        b == d;    // compares name and number, ignores d's character"
msgstr ""

msgid "4437        d == b;    // error: no == defined"
msgstr ""

msgid "4438        D d2;"
msgstr ""

msgid "4439        d == d2;   // compares name, number, and character"
msgstr ""

msgid "4440        B& b2 = d2;"
msgstr ""

msgid ""
"4441        b2 == d;   // compares name and number, ignores d2's and d's "
"character"
msgstr ""

msgid ""
"4442    Of course there are ways of making `==` work in a hierarchy, but the "
"naive approaches do not scale"
msgstr ""

msgid "4443    #### Note"
msgstr ""

msgid ""
"4444    This rule applies to all the usual comparison operators: `!=`, `<`, "
"`<=`, `>`, and `>=`."
msgstr ""

msgid "4445    ##### Enforcement"
msgstr ""

msgid ""
"4446    * Flag a virtual `operator==()`; same for other comparison operators:"
" `!=`, `<`, `<=`, `>`, and `>=`."
msgstr ""

msgid "4447    ### <a name=\"Rc-hash\"></a>C.89: Make a `hash` `noexcept`"
msgstr ""

msgid "4448    ##### Reason"
msgstr ""

msgid ""
"4449    Users of hashed containers use hash indirectly and don't expect "
"simple access to throw."
msgstr ""

msgid "4450    It's a standard-library requirement."
msgstr ""

msgid "4451    ##### Example, bad"
msgstr ""

msgid "4452        template<>"
msgstr ""

msgid ""
"4453        struct hash<My_type> {  // thoroughly bad hash specialization"
msgstr ""

msgid "4454            using result_type = size_t;"
msgstr ""

msgid "4455            using argument_type = My_type;"
msgstr ""

msgid "4456            size_t operator() (const My_type & x) const"
msgstr ""

msgid "4457            {"
msgstr ""

msgid "4458                size_t xs = x.s.size();"
msgstr ""

msgid ""
"4459                if (xs < 4) throw Bad_My_type{};    // \"Nobody expects "
"the Spanish inquisition!\""
msgstr ""

msgid "4460                return hash<size_t>()(x.s.size()) ^ trim(x.s);"
msgstr ""

msgid "4461            }"
msgstr ""

msgid "4462        };"
msgstr ""

msgid "4463        int main()"
msgstr ""

msgid "4464        {"
msgstr ""

msgid "4465            unordered_map<My_type, int> m;"
msgstr ""

msgid "4466            My_type mt{ \"asdfg\" };"
msgstr ""

msgid "4467            m[mt] = 7;"
msgstr ""

msgid "4468            cout << m[My_type{ \"asdfg\" }] << '\\n';"
msgstr ""

msgid "4469        }"
msgstr ""

msgid ""
"4470    If you have to define a `hash` specialization, try simply to let it "
"combine standard-library `hash` specializations with `^` (xor)."
msgstr ""

msgid ""
"4471    That tends to work better than \"cleverness\" for non-specialists."
msgstr ""

msgid "4472    ##### Enforcement"
msgstr ""

msgid "4473    * Flag throwing `hash`es."
msgstr ""

msgid ""
"4474    ## <a name=\"SS-containers\"></a>C.con: Containers and other "
"resource handles"
msgstr ""

msgid ""
"4475    A container is an object holding a sequence of objects of some type; "
"`std::vector` is the archetypical container."
msgstr ""

msgid ""
"4476    A resource handle is a class that owns a resource; `std::vector` is "
"the typical resource handle; its resource is its sequence of elements."
msgstr ""

msgid "4477    Summary of container rules:"
msgstr ""

msgid "4478    * [C.100: Follow the STL when defining a container](#Rcon-stl)"
msgstr ""

msgid "4479    * [C.101: Give a container value semantics](#Rcon-val)"
msgstr ""

msgid "4480    * [C.102: Give a container move operations](#Rcon-move)"
msgstr ""

msgid ""
"4481    * [C.103: Give a container an initializer list constructor](#Rcon-"
"init)"
msgstr ""

msgid ""
"4482    * [C.104: Give a container a default constructor that sets it to "
"empty](#Rcon-empty)"
msgstr ""

msgid ""
"4483    * [C.105: Give a constructor and `Extent` constructor](#Rcon-val)"
msgstr ""

msgid "4484    * ???"
msgstr ""

msgid ""
"4485    * [C.109: If a resource handle has pointer semantics, provide `*` "
"and `->`](#rcon-ptr)"
msgstr ""

msgid "4486    **See also**: [Resources](#S-resource)"
msgstr ""

msgid ""
"4487    ## <a name=\"SS-lambdas\"></a>C.lambdas: Function objects and "
"lambdas"
msgstr ""

msgid ""
"4488    A function object is an object supplying an overloaded `()` so that "
"you can call it."
msgstr ""

msgid ""
"4489    A lambda expression (colloquially often shortened to \"a lambda\") "
"is a notation for generating a function object."
msgstr ""

msgid ""
"4490    Function objects should be cheap to copy (and therefore [passed by "
"value](#Rf-in))."
msgstr ""

msgid "4491    Summary:"
msgstr ""

msgid ""
"4492    * [F.50: Use a lambda when a function won't do (to capture local "
"variables, or to write a local function)](#Rf-capture-vs-overload)"
msgstr ""

msgid ""
"4493    * [F.52: Prefer capturing by reference in lambdas that will be used "
"locally, including passed to algorithms](#Rf-reference-capture)"
msgstr ""

msgid ""
"4494    * [F.53: Avoid capturing by reference in lambdas that will be used "
"nonlocally, including returned, stored on the heap, or passed to another "
"thread](#Rf-value-capture)"
msgstr ""

msgid ""
"4495    * [ES.28: Use lambdas for complex initialization, especially of "
"`const` variables](#Res-lambda-init)"
msgstr ""

msgid "4496    ## <a name=\"SS-hier\"></a>C.hier: Class hierarchies (OOP)"
msgstr ""

msgid ""
"4497    A class hierarchy is constructed to represent a set of "
"hierarchically organized concepts (only)."
msgstr ""

msgid "4498    Typically base classes act as interfaces."
msgstr ""

msgid ""
"4499    There are two major uses for hierarchies, often named implementation "
"inheritance and interface inheritance."
msgstr ""

msgid "4500    Class hierarchy rule summary:"
msgstr ""

msgid ""
"4501    * [C.120: Use class hierarchies to represent concepts with inherent "
"hierarchical structure (only)](#Rh-domain)"
msgstr ""

msgid ""
"4502    * [C.121: If a base class is used as an interface, make it a pure "
"abstract class](#Rh-abstract)"
msgstr ""

msgid ""
"4503    * [C.122: Use abstract classes as interfaces when complete "
"separation of interface and implementation is needed](#Rh-separation)"
msgstr ""

msgid "4504    Designing rules for classes in a hierarchy summary:"
msgstr ""

msgid ""
"4505    * [C.126: An abstract class typically doesn't need a "
"constructor](#Rh-abstract-ctor)"
msgstr ""

msgid ""
"4506    * [C.127: A class with a virtual function should have a virtual or "
"protected destructor](#Rh-dtor)"
msgstr ""

msgid ""
"4507    * [C.128: Virtual functions should specify exactly one of `virtual`, "
"`override`, or `final`](#Rh-override)"
msgstr ""

msgid ""
"4508    * [C.129: When designing a class hierarchy, distinguish between "
"implementation inheritance and interface inheritance](#Rh-kind)"
msgstr ""

msgid ""
"4509    * [C.130: For making deep copies of polymorphic classes prefer a "
"virtual `clone` function instead of copy construction/assignment](#Rh-copy)"
msgstr ""

msgid "4510    * [C.131: Avoid trivial getters and setters](#Rh-get)"
msgstr ""

msgid ""
"4511    * [C.132: Don't make a function `virtual` without reason](#Rh-"
"virtual)"
msgstr ""

msgid "4512    * [C.133: Avoid `protected` data](#Rh-protected)"
msgstr ""

msgid ""
"4513    * [C.134: Ensure all non-`const` data members have the same access "
"level](#Rh-public)"
msgstr ""

msgid ""
"4514    * [C.135: Use multiple inheritance to represent multiple distinct "
"interfaces](#Rh-mi-interface)"
msgstr ""

msgid ""
"4515    * [C.136: Use multiple inheritance to represent the union of "
"implementation attributes](#Rh-mi-implementation)"
msgstr ""

msgid ""
"4516    * [C.137: Use `virtual` bases to avoid overly general base "
"classes](#Rh-vbase)"
msgstr ""

msgid ""
"4517    * [C.138: Create an overload set for a derived class and its bases "
"with `using`](#Rh-using)"
msgstr ""

msgid "4518    * [C.139: Use `final` sparingly](#Rh-final)"
msgstr ""

msgid ""
"4519    * [C.140: Do not provide different default arguments for a virtual "
"function and an overrider](#Rh-virtual-default-arg)"
msgstr ""

msgid "4520    Accessing objects in a hierarchy rule summary:"
msgstr ""

msgid ""
"4521    * [C.145: Access polymorphic objects through pointers and "
"references](#Rh-poly)"
msgstr ""

msgid ""
"4522    * [C.146: Use `dynamic_cast` where class hierarchy navigation is "
"unavoidable](#Rh-dynamic_cast)"
msgstr ""

msgid ""
"4523    * [C.147: Use `dynamic_cast` to a reference type when failure to "
"find the required class is considered an error](#Rh-ref-cast)"
msgstr ""

msgid ""
"4524    * [C.148: Use `dynamic_cast` to a pointer type when failure to find "
"the required class is considered a valid alternative](#Rh-ptr-cast)"
msgstr ""

msgid ""
"4525    * [C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to "
"`delete` objects created using `new`](#Rh-smart)"
msgstr ""

msgid ""
"4526    * [C.150: Use `make_unique()` to construct objects owned by "
"`unique_ptr`s](#Rh-make_unique)"
msgstr ""

msgid ""
"4527    * [C.151: Use `make_shared()` to construct objects owned by "
"`shared_ptr`s](#Rh-make_shared)"
msgstr ""

msgid ""
"4528    * [C.152: Never assign a pointer to an array of derived class "
"objects to a pointer to its base](#Rh-array)"
msgstr ""

msgid "4529    * [C.153: Prefer virtual function to casting](#Rh-use-virtual)"
msgstr ""

msgid ""
"4530    ### <a name=\"Rh-domain\"></a>C.120: Use class hierarchies to "
"represent concepts with inherent hierarchical structure (only)"
msgstr ""

msgid "4531    ##### Reason"
msgstr ""

msgid ""
"4532    Direct representation of ideas in code eases comprehension and "
"maintenance. Make sure the idea represented in the base class exactly "
"matches all derived types and there is not a better way to express it than "
"using the tight coupling of inheritance."
msgstr ""

msgid ""
"4533    Do *not* use inheritance when simply having a data member will do. "
"Usually this means that the derived type needs to override a base virtual "
"function or needs access to a protected member."
msgstr ""

msgid "4534    ##### Example"
msgstr ""

msgid "4535        class DrawableUIElement {"
msgstr ""

msgid "4536        public:"
msgstr ""

msgid "4537            virtual void render() const = 0;"
msgstr ""

msgid "4538            // ..."
msgstr ""

msgid "4539        };"
msgstr ""

msgid "4540        class AbstractButton : public DrawableUIElement {"
msgstr ""

msgid "4541        public:"
msgstr ""

msgid "4542            virtual void onClick() = 0;"
msgstr ""

msgid "4543            // ..."
msgstr ""

msgid "4544        };"
msgstr ""

msgid "4545        class PushButton : public AbstractButton {"
msgstr ""

msgid "4546            virtual void render() const override;"
msgstr ""

msgid "4547            virtual void onClick() override;"
msgstr ""

msgid "4548            // ..."
msgstr ""

msgid "4549        };"
msgstr ""

msgid "4550        class Checkbox : public AbstractButton {"
msgstr ""

msgid "4551        // ..."
msgstr ""

msgid "4552        };"
msgstr ""

msgid "4553    ##### Example, bad"
msgstr ""

msgid ""
"4554    Do *not* represent non-hierarchical domain concepts as class "
"hierarchies."
msgstr ""

msgid "4555        template<typename T>"
msgstr ""

msgid "4556        class Container {"
msgstr ""

msgid "4557        public:"
msgstr ""

msgid "4558            // list operations:"
msgstr ""

msgid "4559            virtual T& get() = 0;"
msgstr ""

msgid "4560            virtual void put(T&) = 0;"
msgstr ""

msgid "4561            virtual void insert(Position) = 0;"
msgstr ""

msgid "4562            // ..."
msgstr ""

msgid "4563            // vector operations:"
msgstr ""

msgid "4564            virtual T& operator[](int) = 0;"
msgstr ""

msgid "4565            virtual void sort() = 0;"
msgstr ""

msgid "4566            // ..."
msgstr ""

msgid "4567            // tree operations:"
msgstr ""

msgid "4568            virtual void balance() = 0;"
msgstr ""

msgid "4569            // ..."
msgstr ""

msgid "4570        };"
msgstr ""

msgid ""
"4571    Here most overriding classes cannot implement most of the functions "
"required in the interface well."
msgstr ""

msgid "4572    Thus the base class becomes an implementation burden."
msgstr ""

msgid ""
"4573    Furthermore, the user of `Container` cannot rely on the member "
"functions actually performing a meaningful operations reasonably "
"efficiently;"
msgstr ""

msgid "4574    it may throw an exception instead."
msgstr ""

msgid "4575    Thus users have to resort to run-time checking and/or"
msgstr ""

msgid ""
"4576    not using this (over)general interface in favor of a particular "
"interface found by a run-time type inquiry (e.g., a `dynamic_cast`)."
msgstr ""

msgid "4577    ##### Enforcement"
msgstr ""

msgid ""
"4578    * Look for classes with lots of members that do nothing but throw."
msgstr ""

msgid ""
"4579    * Flag every use of a nonpublic base class `B` where the derived "
"class `D` does not override a virtual function or access a protected member "
"in `B`, and `B` is not one of the following: empty, a template parameter or "
"parameter pack of `D`, a class template specialized with `D`."
msgstr ""

msgid ""
"4580    ### <a name=\"Rh-abstract\"></a>C.121: If a base class is used as an "
"interface, make it a pure abstract class"
msgstr ""

msgid "4581    ##### Reason"
msgstr ""

msgid ""
"4582    A class is more stable (less brittle) if it does not contain data."
msgstr ""

msgid ""
"4583    Interfaces should normally be composed entirely of public pure "
"virtual functions and a default/empty virtual destructor."
msgstr ""

msgid "4584    ##### Example"
msgstr ""

msgid "4585        class My_interface {"
msgstr ""

msgid "4586        public:"
msgstr ""

msgid "4587            // ...only pure virtual functions here ..."
msgstr ""

msgid "4588            virtual ~My_interface() {}   // or =default"
msgstr ""

msgid "4589        };"
msgstr ""

msgid "4590    ##### Example, bad"
msgstr ""

msgid "4591        class Goof {"
msgstr ""

msgid "4592        public:"
msgstr ""

msgid "4593            // ...only pure virtual functions here ..."
msgstr ""

msgid "4594            // no virtual destructor"
msgstr ""

msgid "4595        };"
msgstr ""

msgid "4596        class Derived : public Goof {"
msgstr ""

msgid "4597            string s;"
msgstr ""

msgid "4598            // ..."
msgstr ""

msgid "4599        };"
msgstr ""

msgid "4600        void use()"
msgstr ""

msgid "4601        {"
msgstr ""

msgid "4602            unique_ptr<Goof> p {new Derived{\"here we go\"}};"
msgstr ""

msgid "4603            f(p.get()); // use Derived through the Goof interface"
msgstr ""

msgid "4604            g(p.get()); // use Derived through the Goof interface"
msgstr ""

msgid "4605        } // leak"
msgstr ""

msgid ""
"4606    The `Derived` is `delete`d through its `Goof` interface, so its "
"`string` is leaked."
msgstr ""

msgid "4607    Give `Goof` a virtual destructor and all is well."
msgstr ""

msgid "4608    ##### Enforcement"
msgstr ""

msgid ""
"4609    * Warn on any class that contains data members and also has an "
"overridable (non-`final`) virtual function."
msgstr ""

msgid ""
"4610    ### <a name=\"Rh-separation\"></a>C.122: Use abstract classes as "
"interfaces when complete separation of interface and implementation is "
"needed"
msgstr ""

msgid "4611    ##### Reason"
msgstr ""

msgid "4612    Such as on an ABI (link) boundary."
msgstr ""

msgid "4613    ##### Example"
msgstr ""

msgid "4614        struct Device {"
msgstr ""

msgid "4615            virtual ~Device() = default;"
msgstr ""

msgid "4616            virtual void write(span<const char> outbuf) = 0;"
msgstr ""

msgid "4617            virtual void read(span<char> inbuf) = 0;"
msgstr ""

msgid "4618        };"
msgstr ""

msgid "4619        class D1 : public Device {"
msgstr ""

msgid "4620            // ... data ..."
msgstr ""

msgid "4621            void write(span<const char> outbuf) override;"
msgstr ""

msgid "4622            void read(span<char> inbuf) override;"
msgstr ""

msgid "4623        };"
msgstr ""

msgid "4624        class D2 : public Device {"
msgstr ""

msgid "4625            // ... different data ..."
msgstr ""

msgid "4626            void write(span<const char> outbuf) override;"
msgstr ""

msgid "4627            void read(span<char> inbuf) override;"
msgstr ""

msgid "4628        };"
msgstr ""

msgid ""
"4629    A user can now use `D1`s and `D2`s interchangeably through the "
"interface provided by `Device`."
msgstr ""

msgid ""
"4630    Furthermore, we can update `D1` and `D2` in a ways that are not "
"binary compatible with older versions as long as all access goes through "
"`Device`."
msgstr ""

msgid "4631    ##### Enforcement"
msgstr ""

msgid "4632        ???"
msgstr ""

msgid "4633    ## C.hierclass: Designing classes in a hierarchy:"
msgstr ""

msgid ""
"4634    ### <a name=\"Rh-abstract-ctor\"></a>C.126: An abstract class "
"typically doesn't need a constructor"
msgstr ""

msgid "4635    ##### Reason"
msgstr ""

msgid ""
"4636    An abstract class typically does not have any data for a constructor "
"to initialize."
msgstr ""

msgid "4637    ##### Example"
msgstr ""

msgid "4638        ???"
msgstr ""

msgid "4639    ##### Exception"
msgstr ""

msgid ""
"4640    * A base class constructor that does work, such as registering an "
"object somewhere, may need a constructor."
msgstr ""

msgid ""
"4641    * In extremely rare cases, you might find it reasonable for an "
"abstract class to have a bit of data shared by all derived classes"
msgstr ""

msgid ""
"4642      (e.g., use statistics data, debug information, etc.); such classes "
"tend to have constructors. But be warned: Such classes also tend to be prone "
"to requiring virtual inheritance."
msgstr ""

msgid "4643    ##### Enforcement"
msgstr ""

msgid "4644    Flag abstract classes with constructors."
msgstr ""

msgid ""
"4645    ### <a name=\"Rh-dtor\"></a>C.127: A class with a virtual function "
"should have a virtual or protected destructor"
msgstr ""

msgid "4646    ##### Reason"
msgstr ""

msgid ""
"4647    A class with a virtual function is usually (and in general) used via "
"a pointer to base. Usually, the last user has to call delete on a pointer to "
"base, often via a smart pointer to base, so the destructor should be public "
"and virtual. Less commonly, if deletion through a pointer to base is not "
"intended to be supported, the destructor should be protected and nonvirtual; "
"see [C.35](#Rc-dtor-virtual)."
msgstr ""

msgid "4648    ##### Example, bad"
msgstr ""

msgid "4649        struct B {"
msgstr ""

msgid "4650            virtual int f() = 0;"
msgstr ""

msgid ""
"4651            // ... no user-written destructor, defaults to public "
"nonvirtual ..."
msgstr ""

msgid "4652        };"
msgstr ""

msgid "4653        // bad: derived from a class without a virtual destructor"
msgstr ""

msgid "4654        struct D : B {"
msgstr ""

msgid "4655            string s {\"default\"};"
msgstr ""

msgid "4656        };"
msgstr ""

msgid "4657        void use()"
msgstr ""

msgid "4658        {"
msgstr ""

msgid "4659            unique_ptr<B> p = make_unique<D>();"
msgstr ""

msgid "4660            // ..."
msgstr ""

msgid ""
"4661        } // undefined behavior. May call B::~B only and leak the string"
msgstr ""

msgid "4662    ##### Note"
msgstr ""

msgid ""
"4663    There are people who don't follow this rule because they plan to use "
"a class only through a `shared_ptr`: `std::shared_ptr<B> p = std::"
"make_shared<D>(args);` Here, the shared pointer will take care of deletion, "
"so no leak will occur from an inappropriate `delete` of the base. People who "
"do this consistently can get a false positive, but the rule is important -- "
"what if one was allocated using `make_unique`? It's not safe unless the "
"author of `B` ensures that it can never be misused, such as by making all "
"constructors private and providing a factory function to enforce the "
"allocation with `make_shared`."
msgstr ""

msgid "4664    ##### Enforcement"
msgstr ""

msgid ""
"4665    * A class with any virtual functions should have a destructor that "
"is either public and virtual or else protected and nonvirtual."
msgstr ""

msgid ""
"4666    * Flag `delete` of a class with a virtual function but no virtual "
"destructor."
msgstr ""

msgid ""
"4667    ### <a name=\"Rh-override\"></a>C.128: Virtual functions should "
"specify exactly one of `virtual`, `override`, or `final`"
msgstr ""

msgid "4668    ##### Reason"
msgstr ""

msgid "4669    Readability."
msgstr ""

msgid "4670    Detection of mistakes."
msgstr ""

msgid ""
"4671    Writing explicit `virtual`, `override`, or `final` is self-"
"documenting and enables the compiler to catch mismatch of types and/or names "
"between base and derived classes. However, writing more than one of these "
"three is both redundant and a potential source of errors."
msgstr ""

msgid ""
"4672    Use `virtual` only when declaring a new virtual function. Use "
"`override` only when declaring an overrider. Use `final` only when declaring "
"a final overrider. If a base class destructor is declared `virtual`, one "
"should avoid declaring derived class destructors  `virtual` or `override`. "
"Some code base and tools might insist on `override` for destructors, but "
"that is not the recommendation of these guidelines."
msgstr ""

msgid "4673    ##### Example, bad"
msgstr ""

msgid "4674        struct B {"
msgstr ""

msgid "4675            void f1(int);"
msgstr ""

msgid "4676            virtual void f2(int) const;"
msgstr ""

msgid "4677            virtual void f3(int);"
msgstr ""

msgid "4678            // ..."
msgstr ""

msgid "4679        };"
msgstr ""

msgid "4680        struct D : B {"
msgstr ""

msgid ""
"4681            void f1(int);        // bad (hope for a warning): D::f1() "
"hides B::f1()"
msgstr ""

msgid ""
"4682            void f2(int) const;  // bad (but conventional and valid): no "
"explicit override"
msgstr ""

msgid ""
"4683            void f3(double);     // bad (hope for a warning): D::f3() "
"hides B::f3()"
msgstr ""

msgid "4684            // ..."
msgstr ""

msgid "4685        };"
msgstr ""

msgid "4686    ##### Example, good"
msgstr ""

msgid "4687        struct Better : B {"
msgstr ""

msgid ""
"4688            void f1(int) override;        // error (caught): D::f1() "
"hides B::f1()"
msgstr ""

msgid "4689            void f2(int) const override;"
msgstr ""

msgid ""
"4690            void f3(double) override;     // error (caught): D::f3() "
"hides B::f3()"
msgstr ""

msgid "4691            // ..."
msgstr ""

msgid "4692        };"
msgstr ""

msgid "4693    ##### Enforcement"
msgstr ""

msgid ""
"4694    * Compare names in base and derived classes and flag uses of the "
"same name that does not override."
msgstr ""

msgid "4695    * Flag overrides with neither `override` nor `final`."
msgstr ""

msgid ""
"4696    * Flag function declarations that use more than one of `virtual`, "
"`override`, and `final`."
msgstr ""

msgid ""
"4697    ### <a name=\"Rh-kind\"></a>C.129: When designing a class hierarchy, "
"distinguish between implementation inheritance and interface inheritance"
msgstr ""

msgid "4698    ##### Reason"
msgstr ""

msgid ""
"4699    Implementation details in an interface makes the interface brittle;"
msgstr ""

msgid ""
"4700    that is, makes its users vulnerable to having to recompile after "
"changes in the implementation."
msgstr ""

msgid ""
"4701    Data in a base class increases the complexity of implementing the "
"base and can lead to replication of code."
msgstr ""

msgid "4702    ##### Note"
msgstr ""

msgid "4703    Definition:"
msgstr ""

msgid ""
"4704    * interface inheritance is the use of inheritance to separate users "
"from implementations,"
msgstr ""

msgid ""
"4705    in particular to allow derived classes to be added and changed "
"without affecting the users of base classes."
msgstr ""

msgid ""
"4706    * implementation inheritance is the use of inheritance to simplify "
"implementation of new facilities"
msgstr ""

msgid ""
"4707    by making useful operations available for implementers of related "
"new operations (sometimes called \"programming by difference\")."
msgstr ""

msgid ""
"4708    A pure interface class is simply a set of pure virtual functions; "
"see [I.25](#Ri-abstract)."
msgstr ""

msgid ""
"4709    In early OOP (e.g., in the 1980s and 1990s), implementation "
"inheritance and interface inheritance were often mixed"
msgstr ""

msgid "4710    and bad habits die hard."
msgstr ""

msgid ""
"4711    Even now, mixtures are not uncommon in old code bases and in old-"
"style teaching material."
msgstr ""

msgid ""
"4712    The importance of keeping the two kinds of inheritance increases"
msgstr ""

msgid ""
"4713    * with the size of a hierarchy (e.g., dozens of derived classes),"
msgstr ""

msgid ""
"4714    * with the length of time the hierarchy is used (e.g., decades), and"
msgstr ""

msgid ""
"4715    * with the number of distinct organizations in which a hierarchy is "
"used"
msgstr ""

msgid ""
"4716    (e.g., it can be difficult to distribute an update to a base class)"
msgstr ""

msgid "4717    ##### Example, bad"
msgstr ""

msgid "4718        class Shape {   // BAD, mixed interface and implementation"
msgstr ""

msgid "4719        public:"
msgstr ""

msgid "4720            Shape();"
msgstr ""

msgid ""
"4721            Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col "
"{co} { /* ... */}"
msgstr ""

msgid "4722            Point center() const { return cent; }"
msgstr ""

msgid "4723            Color color() const { return col; }"
msgstr ""

msgid "4724            virtual void rotate(int) = 0;"
msgstr ""

msgid "4725            virtual void move(Point p) { cent = p; redraw(); }"
msgstr ""

msgid "4726            virtual void redraw();"
msgstr ""

msgid "4727            // ..."
msgstr ""

msgid "4728        private:"
msgstr ""

msgid "4729            Point cent;"
msgstr ""

msgid "4730            Color col;"
msgstr ""

msgid "4731        };"
msgstr ""

msgid "4732        class Circle : public Shape {"
msgstr ""

msgid "4733        public:"
msgstr ""

msgid "4734            Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }"
msgstr ""

msgid "4735            // ..."
msgstr ""

msgid "4736        private:"
msgstr ""

msgid "4737            int rad;"
msgstr ""

msgid "4738        };"
msgstr ""

msgid "4739        class Triangle : public Shape {"
msgstr ""

msgid "4740        public:"
msgstr ""

msgid ""
"4741            Triangle(Point p1, Point p2, Point p3); // calculate center"
msgstr ""

msgid "4742            // ..."
msgstr ""

msgid "4743        };"
msgstr ""

msgid "4744    Problems:"
msgstr ""

msgid ""
"4745    * As the hierarchy grows and more data is added to `Shape`, the "
"constructors gets harder to write and maintain."
msgstr ""

msgid ""
"4746    * Why calculate the center for the `Triangle`? we may never us it."
msgstr ""

msgid "4747    * Add a data member to `Shape` (e.g., drawing style or canvas)"
msgstr ""

msgid ""
"4748    and all derived classes and all users needs to be reviewed, possibly "
"changes, and probably recompiled."
msgstr ""

msgid ""
"4749    The implementation of `Shape::move()` is an example of "
"implementation inheritance:"
msgstr ""

msgid ""
"4750    we have defined `move()` once and for all for all derived classes."
msgstr ""

msgid ""
"4751    The more code there is in such base class member function "
"implementations and the more data is shared by placing it in the base,"
msgstr ""

msgid ""
"4752    the more benefits we gain - and the less stable the hierarchy is."
msgstr ""

msgid "4753    ##### Example"
msgstr ""

msgid ""
"4754    This Shape hierarchy can be rewritten using interface inheritance:"
msgstr ""

msgid "4755        class Shape {  // pure interface"
msgstr ""

msgid "4756        public:"
msgstr ""

msgid "4757            virtual Point center() const = 0;"
msgstr ""

msgid "4758            virtual Color color() const = 0;"
msgstr ""

msgid "4759            virtual void rotate(int) = 0;"
msgstr ""

msgid "4760            virtual void move(Point p) = 0;"
msgstr ""

msgid "4761            virtual void redraw() = 0;"
msgstr ""

msgid "4762            // ..."
msgstr ""

msgid "4763        };"
msgstr ""

msgid ""
"4764    Note that a pure interface rarely have constructors: there is "
"nothing to construct."
msgstr ""

msgid "4765        class Circle : public Shape {"
msgstr ""

msgid "4766        public:"
msgstr ""

msgid ""
"4767            Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /"
"* ... */ }"
msgstr ""

msgid "4768            Point center() const override { return cent; }"
msgstr ""

msgid "4769            Color color() const override { return col; }"
msgstr ""

msgid "4770            // ..."
msgstr ""

msgid "4771        private:"
msgstr ""

msgid "4772            Point cent;"
msgstr ""

msgid "4773            int rad;"
msgstr ""

msgid "4774            Color col;"
msgstr ""

msgid "4775        };"
msgstr ""

msgid ""
"4776    The interface is now less brittle, but there is more work in "
"implementing the member functions."
msgstr ""

msgid ""
"4777    For example, `center` has to be implemented by every class derived "
"from `Shape`."
msgstr ""

msgid "4778    ##### Example, dual hierarchy"
msgstr ""

msgid ""
"4779    How can we gain the benefit of the stable hierarchies from "
"implementation hierarchies and the benefit of implementation reuse from "
"implementation inheritance."
msgstr ""

msgid "4780    One popular technique is dual hierarchies."
msgstr ""

msgid ""
"4781    There are many ways of implementing the idea of dual hierarchies; "
"here, we use a multiple-inheritance variant."
msgstr ""

msgid "4782    First we devise a hierarchy of interface classes:"
msgstr ""

msgid "4783        class Shape {   // pure interface"
msgstr ""

msgid "4784        public:"
msgstr ""

msgid "4785            virtual Point center() const = 0;"
msgstr ""

msgid "4786            virtual Color color() const = 0;"
msgstr ""

msgid "4787            virtual void rotate(int) = 0;"
msgstr ""

msgid "4788            virtual void move(Point p) = 0;"
msgstr ""

msgid "4789            virtual void redraw() = 0;"
msgstr ""

msgid "4790            // ..."
msgstr ""

msgid "4791        };"
msgstr ""

msgid "4792        class Circle : public Shape {   // pure interface"
msgstr ""

msgid "4793        public:"
msgstr ""

msgid "4794            virtual int radius() = 0;"
msgstr ""

msgid "4795            // ..."
msgstr ""

msgid "4796        };"
msgstr ""

msgid ""
"4797    To make this interface useful, we must provide its implementation "
"classes (here, named equivalently, but in the `Impl` namespace):"
msgstr ""

msgid "4798        class Impl::Shape : public Shape { // implementation"
msgstr ""

msgid "4799        public:"
msgstr ""

msgid "4800            // constructors, destructor"
msgstr ""

msgid "4801            // ..."
msgstr ""

msgid "4802            Point center() const override { /* ... */ }"
msgstr ""

msgid "4803            Color color() const override { /* ... */ }"
msgstr ""

msgid "4804            void rotate(int) override { /* ... */ }"
msgstr ""

msgid "4805            void move(Point p) override { /* ... */ }"
msgstr ""

msgid "4806            void redraw() override { /* ... */ }"
msgstr ""

msgid "4807            // ..."
msgstr ""

msgid "4808        };"
msgstr ""

msgid ""
"4809    Now `Shape` is a poor example of a class with an implementation,"
msgstr ""

msgid ""
"4810    but bear with us because this is just a simple example of a "
"technique aimed at more complex hierarchies."
msgstr ""

msgid ""
"4811        class Impl::Circle : public Circle, public Impl::Shape {   // "
"implementation"
msgstr ""

msgid "4812        public:"
msgstr ""

msgid "4813            // constructors, destructor"
msgstr ""

msgid "4814            int radius() override { /* ... */ }"
msgstr ""

msgid "4815            // ..."
msgstr ""

msgid "4816        };"
msgstr ""

msgid ""
"4817    And we could extend the hierarchies by adding a Smiley class (:-)):"
msgstr ""

msgid "4818        class Smiley : public Circle { // pure interface"
msgstr ""

msgid "4819        public:"
msgstr ""

msgid "4820            // ..."
msgstr ""

msgid "4821        };"
msgstr ""

msgid ""
"4822        class Impl::Smiley : public Smiley, public Impl::Circle {   // "
"implementation"
msgstr ""

msgid "4823        public:"
msgstr ""

msgid "4824            // constructors, destructor"
msgstr ""

msgid "4825            // ..."
msgstr ""

msgid "4826        }"
msgstr ""

msgid "4827    There are now two hierarchies:"
msgstr ""

msgid "4828    * interface: Smiley -> Circle -> Shape"
msgstr ""

msgid "4829    * implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape"
msgstr ""

msgid ""
"4830    Since each implementation derived from its interface as well as its "
"implementation base class we get a lattice (DAG):"
msgstr ""

msgid "4831        Smiley     ->         Circle     ->  Shape"
msgstr ""

msgid "4832          ^                     ^               ^"
msgstr ""

msgid "4833          |                     |               |"
msgstr ""

msgid "4834        Impl::Smiley -> Impl::Circle -> Impl::Shape"
msgstr ""

msgid ""
"4835    As mentioned, this is just one way to construct a dual hierarchy."
msgstr ""

msgid ""
"4836    The implementation hierarchy can be used directly, rather than "
"through the abstract interface."
msgstr ""

msgid "4837        void work_with_shape(Shape&);"
msgstr ""

msgid "4838        int user()"
msgstr ""

msgid "4839        {"
msgstr ""

msgid ""
"4840            Impl::Smiley my_smiley{ /* args */ };   // create concrete "
"shape"
msgstr ""

msgid "4841            // ..."
msgstr ""

msgid ""
"4842            my_smiley.some_member();        // use implementation class "
"directly"
msgstr ""

msgid "4843            // ..."
msgstr ""

msgid ""
"4844            work_with_shape(my_smiley);     // use implementation "
"through abstract interface"
msgstr ""

msgid "4845            // ..."
msgstr ""

msgid "4846        }"
msgstr ""

msgid ""
"4847    This can be useful when the implementation class has members that "
"are not offered in the abstract interface"
msgstr ""

msgid ""
"4848    or if direct use of a member offers optimization opportunities (e.g."
", if an implementation member function is `final`)"
msgstr ""

msgid "4849    ##### Note"
msgstr ""

msgid ""
"4850    Another (related) technique for separating interface and "
"implementation is [Pimpl](#Ri-pimpl)."
msgstr ""

msgid "4851    ##### Note"
msgstr ""

msgid ""
"4852    There is often a choice between offering common functionality as "
"(implemented) base class functions and free-standing functions"
msgstr ""

msgid "4853    (in an implementation namespace)."
msgstr ""

msgid ""
"4854    Base classes gives a shorter notation and easier access to shared "
"data (in the base)"
msgstr ""

msgid ""
"4855    at the cost of the functionality being available only to users of "
"the hierarchy."
msgstr ""

msgid "4856    ##### Enforcement"
msgstr ""

msgid ""
"4857    * Flag a derived to base conversion to a base with both data and "
"virtual functions"
msgstr ""

msgid ""
"4858    (except for calls from a derived class member to a base class "
"member)"
msgstr ""

msgid "4859    * ???"
msgstr ""

msgid ""
"4860    ### <a name=\"Rh-copy\"></a>C.130: For making deep copies of "
"polymorphic classes prefer a virtual `clone` function instead of copy "
"construction/assignment"
msgstr ""

msgid "4861    ##### Reason"
msgstr ""

msgid ""
"4862    Copying a polymorphic class is discouraged due to the slicing "
"problem, see [C.67](#Rc-copy-virtual). If you really need copy semantics, "
"copy deeply: Provide a virtual `clone` function that will copy the actual "
"most-derived type and return an owning pointer to the new object, and then "
"in derived classes return the derived type (use a covariant return type)."
msgstr ""

msgid "4863    ##### Example"
msgstr ""

msgid "4864        class B {"
msgstr ""

msgid "4865        public:"
msgstr ""

msgid "4866            virtual owner<B*> clone() = 0;"
msgstr ""

msgid "4867            virtual ~B() = 0;"
msgstr ""

msgid "4868            B(const B&) = delete;"
msgstr ""

msgid "4869            B& operator=(const B&) = delete;"
msgstr ""

msgid "4870        };"
msgstr ""

msgid "4871        class D : public B {"
msgstr ""

msgid "4872        public:"
msgstr ""

msgid "4873            owner<D*> clone() override;"
msgstr ""

msgid "4874            virtual ~D() override;"
msgstr ""

msgid "4875        };"
msgstr ""

msgid ""
"4876    Generally, it is recommended to use smart pointers to represent "
"ownership (see [R.20](#Rr-owner)). However, because of language rules, the "
"covariant return type cannot be a smart pointer: `D::clone` can't return a "
"`unique_ptr<D>` while `B::clone` returns `unique_ptr<B>`. Therefore, you "
"either need to consistently return `unique_ptr<B>` in all overrides, or use "
"`owner<>` utility from the [Guidelines Support Library](#SS-views)."
msgstr ""

msgid ""
"4877    ### <a name=\"Rh-get\"></a>C.131: Avoid trivial getters and setters"
msgstr ""

msgid "4878    ##### Reason"
msgstr ""

msgid ""
"4879    A trivial getter or setter adds no semantic value; the data item "
"could just as well be `public`."
msgstr ""

msgid "4880    ##### Example"
msgstr ""

msgid "4881        class Point {   // Bad: verbose"
msgstr ""

msgid "4882            int x;"
msgstr ""

msgid "4883            int y;"
msgstr ""

msgid "4884        public:"
msgstr ""

msgid "4885            Point(int xx, int yy) : x{xx}, y{yy} { }"
msgstr ""

msgid "4886            int get_x() const { return x; }"
msgstr ""

msgid "4887            void set_x(int xx) { x = xx; }"
msgstr ""

msgid "4888            int get_y() const { return y; }"
msgstr ""

msgid "4889            void set_y(int yy) { y = yy; }"
msgstr ""

msgid "4890            // no behavioral member functions"
msgstr ""

msgid "4891        };"
msgstr ""

msgid ""
"4892    Consider making such a class a `struct` -- that is, a behaviorless "
"bunch of variables, all public data and no member functions."
msgstr ""

msgid "4893        struct Point {"
msgstr ""

msgid "4894            int x {0};"
msgstr ""

msgid "4895            int y {0};"
msgstr ""

msgid "4896        };"
msgstr ""

msgid ""
"4897    Note that we can put default initializers on member variables: [C.49:"
" Prefer initialization to assignment in constructors](#Rc-initialize)."
msgstr ""

msgid "4898    ##### Note"
msgstr ""

msgid ""
"4899    The key to this rule is whether the semantics of the getter/setter "
"are trivial. While it is not a complete definition of \"trivial\", consider "
"whether there would be any difference beyond syntax if the getter/setter was "
"a public data member instead. Examples of non-trivial semantics would be: "
"maintaining a class invariant or converting between an internal type and an "
"interface type."
msgstr ""

msgid "4900    ##### Enforcement"
msgstr ""

msgid ""
"4901    Flag multiple `get` and `set` member functions that simply access a "
"member without additional semantics."
msgstr ""

msgid ""
"4902    ### <a name=\"Rh-virtual\"></a>C.132: Don't make a function "
"`virtual` without reason"
msgstr ""

msgid "4903    ##### Reason"
msgstr ""

msgid "4904    Redundant `virtual` increases run-time and object-code size."
msgstr ""

msgid ""
"4905    A virtual function can be overridden and is thus open to mistakes in "
"a derived class."
msgstr ""

msgid ""
"4906    A virtual function ensures code replication in a templated hierarchy."
""
msgstr ""

msgid "4907    ##### Example, bad"
msgstr ""

msgid "4908        template<class T>"
msgstr ""

msgid "4909        class Vector {"
msgstr ""

msgid "4910        public:"
msgstr ""

msgid "4911            // ..."
msgstr ""

msgid ""
"4912            virtual int size() const { return sz; }   // bad: what good "
"could a derived class do?"
msgstr ""

msgid "4913        private:"
msgstr ""

msgid "4914            T* elem;   // the elements"
msgstr ""

msgid "4915            int sz;    // number of elements"
msgstr ""

msgid "4916        };"
msgstr ""

msgid ""
"4917    This kind of \"vector\" isn't meant to be used as a base class at "
"all."
msgstr ""

msgid "4918    ##### Enforcement"
msgstr ""

msgid "4919    * Flag a class with virtual functions but no derived classes."
msgstr ""

msgid ""
"4920    * Flag a class where all member functions are virtual and have "
"implementations."
msgstr ""

msgid "4921    ### <a name=\"Rh-protected\"></a>C.133: Avoid `protected` data"
msgstr ""

msgid "4922    ##### Reason"
msgstr ""

msgid "4923    `protected` data is a source of complexity and errors."
msgstr ""

msgid "4924    `protected` data complicates the statement of invariants."
msgstr ""

msgid ""
"4925    `protected` data inherently violates the guidance against putting "
"data in base classes, which usually leads to having to deal with virtual "
"inheritance as well."
msgstr ""

msgid "4926    ##### Example, bad"
msgstr ""

msgid "4927        class Shape {"
msgstr ""

msgid "4928        public:"
msgstr ""

msgid "4929            // ... interface functions ..."
msgstr ""

msgid "4930        protected:"
msgstr ""

msgid "4931            // data for use in derived classes:"
msgstr ""

msgid "4932            Color fill_color;"
msgstr ""

msgid "4933            Color edge_color;"
msgstr ""

msgid "4934            Style st;"
msgstr ""

msgid "4935        };"
msgstr ""

msgid ""
"4936    Now it is up to every derived `Shape` to manipulate the protected "
"data correctly."
msgstr ""

msgid ""
"4937    This has been popular, but also a major source of maintenance "
"problems."
msgstr ""

msgid ""
"4938    In a large class hierarchy, the consistent use of protected data is "
"hard to maintain because there can be a lot of code,"
msgstr ""

msgid "4939    spread over a lot of classes."
msgstr ""

msgid ""
"4940    The set of classes that can touch that data is open: anyone can "
"derive a new class and start manipulating the protected data."
msgstr ""

msgid ""
"4941    Often, it is not possible to examine the complete set of classes, so "
"any change to the representation of the class becomes infeasible."
msgstr ""

msgid ""
"4942    There is no enforced invariant for the protected data; it is much "
"like a set of global variables."
msgstr ""

msgid ""
"4943    The protected data has de facto become global to a large body of "
"code."
msgstr ""

msgid "4944    ##### Note"
msgstr ""

msgid ""
"4945    Protected data often looks tempting to enable arbitrary improvements "
"through derivation."
msgstr ""

msgid "4946    Often, what you get is unprincipled changes and errors."
msgstr ""

msgid ""
"4947    [Prefer `private` data](#Rc-private) with a well-specified and "
"enforced invariant."
msgstr ""

msgid ""
"4948    Alternative, and often better, [keep data out of any class used as "
"an interface](#Rh-abstract)."
msgstr ""

msgid "4949    ##### Note"
msgstr ""

msgid "4950    Protected member function can be just fine."
msgstr ""

msgid "4951    ##### Enforcement"
msgstr ""

msgid "4952    Flag classes with `protected` data."
msgstr ""

msgid ""
"4953    ### <a name=\"Rh-public\"></a>C.134: Ensure all non-`const` data "
"members have the same access level"
msgstr ""

msgid "4954    ##### Reason"
msgstr ""

msgid "4955    Prevention of logical confusion leading to errors."
msgstr ""

msgid ""
"4956    If the non-`const` data members don't have the same access level, "
"the type is confused about what it's trying to do."
msgstr ""

msgid ""
"4957    Is it a type that maintains an invariant or simply a collection of "
"values?"
msgstr ""

msgid "4958    ##### Discussion"
msgstr ""

msgid ""
"4959    The core question is: What code is responsible for maintaining a "
"meaningful/correct value for that variable?"
msgstr ""

msgid "4960    There are exactly two kinds of data members:"
msgstr ""

msgid ""
"4961    * A: Ones that don't participate in the object's invariant. Any "
"combination of values for these members is valid."
msgstr ""

msgid ""
"4962    * B: Ones that do participate in the object's invariant. Not every "
"combination of values is meaningful (else there'd be no invariant). "
"Therefore all code that has write access to these variables must know about "
"the invariant, know the semantics, and know (and actively implement and "
"enforce) the rules for keeping the values correct."
msgstr ""

msgid ""
"4963    Data members in category A should just be `public` (or, more rarely, "
"`protected` if you only want derived classes to see them). They don't need "
"encapsulation. All code in the system might as well see and manipulate them."
msgstr ""

msgid ""
"4964    Data members in category B should be `private` or `const`. This is "
"because encapsulation is important. To make them non-`private` and non-"
"`const` would mean that the object can't control its own state: An unbounded "
"amount of code beyond the class would need to know about the invariant and "
"participate in maintaining it accurately -- if these data members were "
"`public`, that would be all calling code that uses the object; if they were "
"`protected`, it would be all the code in current and future derived classes. "
"This leads to brittle and tightly coupled code that quickly becomes a "
"nightmare to maintain. Any code that inadvertently sets the data members to "
"an invalid or unexpected combination of values would corrupt the object and "
"all subsequent uses of the object."
msgstr ""

msgid "4965    Most classes are either all A or all B:"
msgstr ""

msgid ""
"4966    * *All public*: If you're writing an aggregate bundle-of-variables "
"without an invariant across those variables, then all the variables should "
"be `public`."
msgstr ""

msgid ""
"4967      [By convention, declare such classes `struct` rather than "
"`class`](#Rc-struct)"
msgstr ""

msgid ""
"4968    * *All private*: If you're writing a type that maintains an "
"invariant, then all the non-`const` variables should be private -- it should "
"be encapsulated."
msgstr ""

msgid "4969    ##### Exception"
msgstr ""

msgid ""
"4970    Occasionally classes will mix A and B, usually for debug reasons. An "
"encapsulated object may contain something like non-`const` debug "
"instrumentation that isn't part of the invariant and so falls into category "
"A -- it isn't really part of the object's value or meaningful observable "
"state either. In that case, the A parts should be treated as A's (made "
"`public`, or in rarer cases `protected` if they should be visible only to "
"derived classes) and the B parts should still be treated like B's (`private` "
"or `const`)."
msgstr ""

msgid "4971    ##### Enforcement"
msgstr ""

msgid ""
"4972    Flag any class that has non-`const` data members with different "
"access levels."
msgstr ""

msgid ""
"4973    ### <a name=\"Rh-mi-interface\"></a>C.135: Use multiple inheritance "
"to represent multiple distinct interfaces"
msgstr ""

msgid "4974    ##### Reason"
msgstr ""

msgid ""
"4975    Not all classes will necessarily support all interfaces, and not all "
"callers will necessarily want to deal with all operations."
msgstr ""

msgid ""
"4976    Especially to break apart monolithic interfaces into \"aspects\" of "
"behavior supported by a given derived class."
msgstr ""

msgid "4977    ##### Example"
msgstr ""

msgid ""
"4978        class iostream : public istream, public ostream {   // very "
"simplified"
msgstr ""

msgid "4979            // ..."
msgstr ""

msgid "4980        };"
msgstr ""

msgid ""
"4981    `istream` provides the interface to input operations; `ostream` "
"provides the interface to output operations."
msgstr ""

msgid ""
"4982    `iostream` provides the union of the `istream` and `ostream` "
"interfaces and the synchronization needed to allow both on a single stream."
msgstr ""

msgid "4983    ##### Note"
msgstr ""

msgid ""
"4984    This is a very common use of inheritance because the need for "
"multiple different interfaces to an implementation is common"
msgstr ""

msgid ""
"4985    and such interfaces are often not easily or naturally organized into "
"a single-rooted hierarchy."
msgstr ""

msgid "4986    ##### Note"
msgstr ""

msgid "4987    Such interfaces are typically abstract classes."
msgstr ""

msgid "4988    ##### Enforcement"
msgstr ""

msgid "4989    ???"
msgstr ""

msgid ""
"4990    ### <a name=\"Rh-mi-implementation\"></a>C.136: Use multiple "
"inheritance to represent the union of implementation attributes"
msgstr ""

msgid "4991    ##### Reason"
msgstr ""

msgid ""
"4992    Some forms of mixins have state and often operations on that state."
msgstr ""

msgid ""
"4993    If the operations are virtual the use of inheritance is necessary, "
"if not using inheritance can avoid boilerplate and forwarding."
msgstr ""

msgid "4994    ##### Example"
msgstr ""

msgid ""
"4995        class iostream : public istream, public ostream {   // very "
"simplified"
msgstr ""

msgid "4996            // ..."
msgstr ""

msgid "4997        };"
msgstr ""

msgid ""
"4998    `istream` provides the interface to input operations (and some "
"data); `ostream` provides the interface to output operations (and some data)."
""
msgstr ""

msgid ""
"4999    `iostream` provides the union of the `istream` and `ostream` "
"interfaces and the synchronization needed to allow both on a single stream."
msgstr ""

msgid "5000    ##### Note"
msgstr ""

msgid ""
"5001    This a relatively rare use because implementation can often be "
"organized into a single-rooted hierarchy."
msgstr ""

msgid "5002    ##### Example"
msgstr ""

msgid ""
"5003    Sometimes, an \"implementation attribute\" is more like a \"mixin\" "
"that determine the behavior of an implementation and inject"
msgstr ""

msgid ""
"5004    members to enable the implementation of the policies it requires."
msgstr ""

msgid "5005    For example, see `std::enable_shared_from_this`"
msgstr ""

msgid ""
"5006    or various bases from boost.intrusive (e.g. `list_base_hook` or "
"`intrusive_ref_counter`)."
msgstr ""

msgid "5007    ##### Enforcement"
msgstr ""

msgid "5008    ???"
msgstr ""

msgid ""
"5009    ### <a name=\"Rh-vbase\"></a>C.137: Use `virtual` bases to avoid "
"overly general base classes"
msgstr ""

msgid "5010    ##### Reason"
msgstr ""

msgid "5011     Allow separation of shared data and interface."
msgstr ""

msgid ""
"5012     To avoid all shared data to being put into an ultimate base class."
msgstr ""

msgid "5013    ##### Example"
msgstr ""

msgid "5014        struct Interface {"
msgstr ""

msgid "5015            virtual void f();"
msgstr ""

msgid "5016            virtual int g();"
msgstr ""

msgid "5017            // ... no data here ..."
msgstr ""

msgid "5018        };"
msgstr ""

msgid "5019        class Utility {  // with data"
msgstr ""

msgid "5020            void utility1();"
msgstr ""

msgid "5021            virtual void utility2();    // customization point"
msgstr ""

msgid "5022        public:"
msgstr ""

msgid "5023            int x;"
msgstr ""

msgid "5024            int y;"
msgstr ""

msgid "5025        };"
msgstr ""

msgid ""
"5026        class Derive1 : public Interface, virtual protected Utility {"
msgstr ""

msgid "5027            // override Interface functions"
msgstr ""

msgid "5028            // Maybe override Utility virtual functions"
msgstr ""

msgid "5029            // ..."
msgstr ""

msgid "5030        };"
msgstr ""

msgid ""
"5031        class Derive2 : public Interface, virtual protected Utility {"
msgstr ""

msgid "5032            // override Interface functions"
msgstr ""

msgid "5033            // Maybe override Utility virtual functions"
msgstr ""

msgid "5034            // ..."
msgstr ""

msgid "5035        };"
msgstr ""

msgid ""
"5036    Factoring out `Utility` makes sense if many derived classes share "
"significant \"implementation details.\""
msgstr ""

msgid "5037    ##### Note"
msgstr ""

msgid ""
"5038    Obviously, the example is too \"theoretical\", but it is hard to "
"find a *small* realistic example."
msgstr ""

msgid ""
"5039    `Interface` is the root of an [interface hierarchy](#Rh-abstract)"
msgstr ""

msgid ""
"5040    and `Utility` is the root of an [implementation hierarchy](#Rh-kind)."
""
msgstr ""

msgid ""
"5041    Here is [a slightly more realistic example](https://www.quora.com/"
"What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/"
"Lance-Diduck) with an explanation."
msgstr ""

msgid "5042    ##### Note"
msgstr ""

msgid "5043    Often, linearization of a hierarchy is a better solution."
msgstr ""

msgid "5044    ##### Enforcement"
msgstr ""

msgid "5045    Flag mixed interface and implementation hierarchies."
msgstr ""

msgid ""
"5046    ### <a name=\"Rh-using\"></a>C.138: Create an overload set for a "
"derived class and its bases with `using`"
msgstr ""

msgid "5047    ##### Reason"
msgstr ""

msgid ""
"5048    Without a using declaration, member functions in the derived class "
"hide the entire inherited overload sets."
msgstr ""

msgid "5049    ##### Example, bad"
msgstr ""

msgid "5050        #include <iostream>"
msgstr ""

msgid "5051        class B {"
msgstr ""

msgid "5052        public:"
msgstr ""

msgid ""
"5053            virtual int f(int i) { std::cout << \"f(int): \"; return i; "
"}"
msgstr ""

msgid ""
"5054            virtual double f(double d) { std::cout << \"f(double): \"; "
"return d; }"
msgstr ""

msgid "5055        };"
msgstr ""

msgid "5056        class D: public B {"
msgstr ""

msgid "5057        public:"
msgstr ""

msgid ""
"5058            int f(int i) override { std::cout << \"f(int): \"; return i "
"+ 1; }"
msgstr ""

msgid "5059        };"
msgstr ""

msgid "5060        int main()"
msgstr ""

msgid "5061        {"
msgstr ""

msgid "5062            D d;"
msgstr ""

msgid "5063            std::cout << d.f(2) << '\\n';   // prints \"f(int): 3\""
msgstr ""

msgid "5064            std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\""
msgstr ""

msgid "5065        }"
msgstr ""

msgid "5066    ##### Example, good"
msgstr ""

msgid "5067        class D: public B {"
msgstr ""

msgid "5068        public:"
msgstr ""

msgid ""
"5069            int f(int i) override { std::cout << \"f(int): \"; return i "
"+ 1; }"
msgstr ""

msgid "5070            using B::f; // exposes f(double)"
msgstr ""

msgid "5071        };"
msgstr ""

msgid "5072    ##### Note"
msgstr ""

msgid ""
"5073    This issue affects both virtual and nonvirtual member functions"
msgstr ""

msgid ""
"5074    For variadic bases, C++17 introduced a variadic form of the using-"
"declaration,"
msgstr ""

msgid "5075        template <class... Ts>"
msgstr ""

msgid "5076        struct Overloader : Ts... {"
msgstr ""

msgid ""
"5077            using Ts::operator()...; // exposes operator() from every "
"base"
msgstr ""

msgid "5078        };"
msgstr ""

msgid "5079    ##### Enforcement"
msgstr ""

msgid "5080    Diagnose name hiding"
msgstr ""

msgid "5081    ### <a name=\"Rh-final\"></a>C.139: Use `final` sparingly"
msgstr ""

msgid "5082    ##### Reason"
msgstr ""

msgid ""
"5083    Capping a hierarchy with `final` is rarely needed for logical "
"reasons and can be damaging to the extensibility of a hierarchy."
msgstr ""

msgid "5084    ##### Example, bad"
msgstr ""

msgid "5085        class Widget { /* ... */ };"
msgstr ""

msgid ""
"5086        // nobody will ever want to improve My_widget (or so you "
"thought)"
msgstr ""

msgid "5087        class My_widget final : public Widget { /* ... */ };"
msgstr ""

msgid ""
"5088        class My_improved_widget : public My_widget { /* ... */ };  // "
"error: can't do that"
msgstr ""

msgid "5089    ##### Note"
msgstr ""

msgid "5090    Not every class is meant to be a base class."
msgstr ""

msgid ""
"5091    Most standard-library classes are examples of that (e.g., `std::"
"vector` and `std::string` are not designed to be derived from)."
msgstr ""

msgid ""
"5092    This rule is about using `final` on classes with virtual functions "
"meant to be interfaces for a class hierarchy."
msgstr ""

msgid "5093    ##### Note"
msgstr ""

msgid ""
"5094    Capping an individual virtual function with `final` is error-prone "
"as `final` can easily be overlooked when defining/overriding a set of "
"functions."
msgstr ""

msgid ""
"5095    Fortunately, the compiler catches such mistakes: You cannot re-"
"declare/re-open a `final` member in a derived class."
msgstr ""

msgid "5096    ##### Note"
msgstr ""

msgid ""
"5097    Claims of performance improvements from `final` should be "
"substantiated."
msgstr ""

msgid ""
"5098    Too often, such claims are based on conjecture or experience with "
"other languages."
msgstr ""

msgid ""
"5099    There are examples where `final` can be important for both logical "
"and performance reasons."
msgstr ""

msgid ""
"5100    One example is a performance-critical AST hierarchy in a compiler or "
"language analysis tool."
msgstr ""

msgid ""
"5101    New derived classes are not added every year and only by library "
"implementers."
msgstr ""

msgid "5102    However, misuses are (or at least have been) far more common."
msgstr ""

msgid "5103    ##### Enforcement"
msgstr ""

msgid "5104    Flag uses of `final`."
msgstr ""

msgid ""
"5105    ### <a name=\"Rh-virtual-default-arg\"></a>C.140: Do not provide "
"different default arguments for a virtual function and an overrider"
msgstr ""

msgid "5106    ##### Reason"
msgstr ""

msgid ""
"5107    That can cause confusion: An overrider does not inherit default "
"arguments."
msgstr ""

msgid "5108    ##### Example, bad"
msgstr ""

msgid "5109        class Base {"
msgstr ""

msgid "5110        public:"
msgstr ""

msgid "5111            virtual int multiply(int value, int factor = 2) = 0;"
msgstr ""

msgid "5112        };"
msgstr ""

msgid "5113        class Derived : public Base {"
msgstr ""

msgid "5114        public:"
msgstr ""

msgid "5115            int multiply(int value, int factor = 10) override;"
msgstr ""

msgid "5116        };"
msgstr ""

msgid "5117        Derived d;"
msgstr ""

msgid "5118        Base& b = d;"
msgstr ""

msgid ""
"5119        b.multiply(10);  // these two calls will call the same function "
"but"
msgstr ""

msgid ""
"5120        d.multiply(10);  // with different arguments and so different "
"results"
msgstr ""

msgid "5121    ##### Enforcement"
msgstr ""

msgid ""
"5122    Flag default arguments on virtual functions if they differ between "
"base and derived declarations."
msgstr ""

msgid "5123    ## C.hier-access: Accessing objects in a hierarchy"
msgstr ""

msgid ""
"5124    ### <a name=\"Rh-poly\"></a>C.145: Access polymorphic objects "
"through pointers and references"
msgstr ""

msgid "5125    ##### Reason"
msgstr ""

msgid ""
"5126    If you have a class with a virtual function, you don't (in general) "
"know which class provided the function to be used."
msgstr ""

msgid "5127    ##### Example"
msgstr ""

msgid "5128        struct B { int a; virtual int f(); };"
msgstr ""

msgid "5129        struct D : B { int b; int f() override; };"
msgstr ""

msgid "5130        void use(B b)"
msgstr ""

msgid "5131        {"
msgstr ""

msgid "5132            D d;"
msgstr ""

msgid "5133            B b2 = d;   // slice"
msgstr ""

msgid "5134            B b3 = b;"
msgstr ""

msgid "5135        }"
msgstr ""

msgid "5136        void use2()"
msgstr ""

msgid "5137        {"
msgstr ""

msgid "5138            D d;"
msgstr ""

msgid "5139            use(d);   // slice"
msgstr ""

msgid "5140        }"
msgstr ""

msgid "5141    Both `d`s are sliced."
msgstr ""

msgid "5142    ##### Exception"
msgstr ""

msgid ""
"5143    You can safely access a named polymorphic object in the scope of its "
"definition, just don't slice it."
msgstr ""

msgid "5144        void use3()"
msgstr ""

msgid "5145        {"
msgstr ""

msgid "5146            D d;"
msgstr ""

msgid "5147            d.f();   // OK"
msgstr ""

msgid "5148        }"
msgstr ""

msgid "5149    ##### Enforcement"
msgstr ""

msgid "5150    Flag all slicing."
msgstr ""

msgid ""
"5151    ### <a name=\"Rh-dynamic_cast\"></a>C.146: Use `dynamic_cast` where "
"class hierarchy navigation is unavoidable"
msgstr ""

msgid "5152    ##### Reason"
msgstr ""

msgid "5153    `dynamic_cast` is checked at run time."
msgstr ""

msgid "5154    ##### Example"
msgstr ""

msgid "5155        struct B {   // an interface"
msgstr ""

msgid "5156            virtual void f();"
msgstr ""

msgid "5157            virtual void g();"
msgstr ""

msgid "5158        };"
msgstr ""

msgid "5159        struct D : B {   // a wider interface"
msgstr ""

msgid "5160            void f() override;"
msgstr ""

msgid "5161            virtual void h();"
msgstr ""

msgid "5162        };"
msgstr ""

msgid "5163        void user(B* pb)"
msgstr ""

msgid "5164        {"
msgstr ""

msgid "5165            if (D* pd = dynamic_cast<D*>(pb)) {"
msgstr ""

msgid "5166                // ... use D's interface ..."
msgstr ""

msgid "5167            }"
msgstr ""

msgid "5168            else {"
msgstr ""

msgid "5169                // ... make do with B's interface ..."
msgstr ""

msgid "5170            }"
msgstr ""

msgid "5171        }"
msgstr ""

msgid ""
"5172    Use of the other casts can violate type safety and cause the program "
"to access a variable that is actually of type `X` to be accessed as if it "
"were of an unrelated type `Z`:"
msgstr ""

msgid "5173        void user2(B* pb)   // bad"
msgstr ""

msgid "5174        {"
msgstr ""

msgid ""
"5175            D* pd = static_cast<D*>(pb);    // I know that pb really "
"points to a D; trust me"
msgstr ""

msgid "5176            // ... use D's interface ..."
msgstr ""

msgid "5177        }"
msgstr ""

msgid "5178        void user3(B* pb)    // unsafe"
msgstr ""

msgid "5179        {"
msgstr ""

msgid "5180            if (some_condition) {"
msgstr ""

msgid ""
"5181                D* pd = static_cast<D*>(pb);   // I know that pb really "
"points to a D; trust me"
msgstr ""

msgid "5182                // ... use D's interface ..."
msgstr ""

msgid "5183            }"
msgstr ""

msgid "5184            else {"
msgstr ""

msgid "5185                // ... make do with B's interface ..."
msgstr ""

msgid "5186            }"
msgstr ""

msgid "5187        }"
msgstr ""

msgid "5188        void f()"
msgstr ""

msgid "5189        {"
msgstr ""

msgid "5190            B b;"
msgstr ""

msgid "5191            user(&b);   // OK"
msgstr ""

msgid "5192            user2(&b);  // bad error"
msgstr ""

msgid ""
"5193            user3(&b);  // OK *if* the programmer got the some_condition "
"check right"
msgstr ""

msgid "5194        }"
msgstr ""

msgid "5195    ##### Note"
msgstr ""

msgid "5196    Like other casts, `dynamic_cast` is overused."
msgstr ""

msgid "5197    [Prefer virtual functions to casting](#Rh-use-virtual)."
msgstr ""

msgid ""
"5198    Prefer [static polymorphism](#???) to hierarchy navigation where it "
"is possible (no run-time resolution necessary)"
msgstr ""

msgid "5199    and reasonably convenient."
msgstr ""

msgid "5200    ##### Note"
msgstr ""

msgid ""
"5201    Some people use `dynamic_cast` where a `typeid` would have been more "
"appropriate;"
msgstr ""

msgid ""
"5202    `dynamic_cast` is a general \"is kind of\" operation for discovering "
"the best interface to an object,"
msgstr ""

msgid ""
"5203    whereas `typeid` is a \"give me the exact type of this object\" "
"operation to discover the actual type of an object."
msgstr ""

msgid ""
"5204    The latter is an inherently simpler operation that ought to be "
"faster."
msgstr ""

msgid ""
"5205    The latter (`typeid`) is easily hand-crafted if necessary (e.g., if "
"working on a system where RTTI is -- for some reason -- prohibited),"
msgstr ""

msgid ""
"5206    the former (`dynamic_cast`) is far harder to implement correctly in "
"general."
msgstr ""

msgid "5207    Consider:"
msgstr ""

msgid "5208        struct B {"
msgstr ""

msgid "5209            const char* name {\"B\"};"
msgstr ""

msgid ""
"5210            // if pb1->id() == pb2->id() *pb1 is the same type as *pb2"
msgstr ""

msgid "5211            virtual const char* id() const { return name; }"
msgstr ""

msgid "5212            // ..."
msgstr ""

msgid "5213        };"
msgstr ""

msgid "5214        struct D : B {"
msgstr ""

msgid "5215            const char* name {\"D\"};"
msgstr ""

msgid "5216            const char* id() const override { return name; }"
msgstr ""

msgid "5217            // ..."
msgstr ""

msgid "5218        };"
msgstr ""

msgid "5219        void use()"
msgstr ""

msgid "5220        {"
msgstr ""

msgid "5221            B* pb1 = new B;"
msgstr ""

msgid "5222            B* pb2 = new D;"
msgstr ""

msgid "5223            cout << pb1->id(); // \"B\""
msgstr ""

msgid "5224            cout << pb2->id(); // \"D\""
msgstr ""

msgid "5225            if (pb1->id() == \"D\") {         // looks innocent"
msgstr ""

msgid "5226                D* pd = static_cast<D*>(pb1);"
msgstr ""

msgid "5227                // ..."
msgstr ""

msgid "5228            }"
msgstr ""

msgid "5229            // ..."
msgstr ""

msgid "5230        }"
msgstr ""

msgid ""
"5231    The result of `pb2->id() == \"D\"` is actually implementation "
"defined."
msgstr ""

msgid "5232    We added it to warn of the dangers of home-brew RTTI."
msgstr ""

msgid ""
"5233    This code may work as expected for years, just to fail on a new "
"machine, new compiler, or a new linker that does not unify character "
"literals."
msgstr ""

msgid "5234    If you implement your own RTTI, be careful."
msgstr ""

msgid "5235    ##### Exception"
msgstr ""

msgid ""
"5236    If your implementation provided a really slow `dynamic_cast`, you "
"may have to use a workaround."
msgstr ""

msgid ""
"5237    However, all workarounds that cannot be statically resolved involve "
"explicit casting (typically `static_cast`) and are error-prone."
msgstr ""

msgid ""
"5238    You will basically be crafting your own special-purpose "
"`dynamic_cast`."
msgstr ""

msgid ""
"5239    So, first make sure that your `dynamic_cast` really is as slow as "
"you think it is (there are a fair number of unsupported rumors about)"
msgstr ""

msgid ""
"5240    and that your use of `dynamic_cast` is really performance critical."
msgstr ""

msgid ""
"5241    We are of the opinion that current implementations of `dynamic_cast` "
"are unnecessarily slow."
msgstr ""

msgid ""
"5242    For example, under suitable conditions, it is possible to perform a "
"`dynamic_cast` in [fast constant time](http://www.stroustrup.com/"
"fast_dynamic_casting.pdf)."
msgstr ""

msgid ""
"5243    However, compatibility makes changes difficult even if all agree "
"that an effort to optimize is worthwhile."
msgstr ""

msgid ""
"5244    In very rare cases, if you have measured that the `dynamic_cast` "
"overhead is material, you have other means to statically guarantee that a "
"downcast will succeed (e.g., you are using CRTP carefully), and there is no "
"virtual inheritance involved, consider tactically resorting `static_cast` "
"with a prominent comment and disclaimer summarizing this paragraph and that "
"human attention is needed under maintenance because the type system can't "
"verify correctness. Even so, in our experience such \"I know what I'm "
"doing\" situations are still a known bug source."
msgstr ""

msgid "5245    ##### Exception"
msgstr ""

msgid "5246    Consider:"
msgstr ""

msgid "5247        template<typename B>"
msgstr ""

msgid "5248        class Dx : B {"
msgstr ""

msgid "5249            // ..."
msgstr ""

msgid "5250        };"
msgstr ""

msgid "5251    ##### Enforcement"
msgstr ""

msgid ""
"5252    * Flag all uses of `static_cast` for downcasts, including C-style "
"casts that perform a `static_cast`."
msgstr ""

msgid ""
"5253    * This rule is part of the [type-safety profile](#Pro-type-downcast)."
""
msgstr ""

msgid ""
"5254    ### <a name=\"Rh-ref-cast\"></a>C.147: Use `dynamic_cast` to a "
"reference type when failure to find the required class is considered an "
"error"
msgstr ""

msgid "5255    ##### Reason"
msgstr ""

msgid ""
"5256    Casting to a reference expresses that you intend to end up with a "
"valid object, so the cast must succeed. `dynamic_cast` will then throw if it "
"does not succeed."
msgstr ""

msgid "5257    ##### Example"
msgstr ""

msgid "5258        ???"
msgstr ""

msgid "5259    ##### Enforcement"
msgstr ""

msgid "5260    ???"
msgstr ""

msgid ""
"5261    ### <a name=\"Rh-ptr-cast\"></a>C.148: Use `dynamic_cast` to a "
"pointer type when failure to find the required class is considered a valid "
"alternative"
msgstr ""

msgid "5262    ##### Reason"
msgstr ""

msgid ""
"5263    The `dynamic_cast` conversion allows to test whether a pointer is "
"pointing at a polymorphic object that has a given class in its hierarchy. "
"Since failure to find the class merely returns a null value, it can be "
"tested during run time. This allows writing code that can choose alternative "
"paths depending on the results."
msgstr ""

msgid ""
"5264    Contrast with [C.147](#Rh-ptr-cast), where failure is an error, and "
"should not be used for conditional execution."
msgstr ""

msgid "5265    ##### Example"
msgstr ""

msgid ""
"5266    The example below describes the `add` function of a `Shape_owner` "
"that takes ownership of constructed `Shape` objects. The objects are also "
"sorted into views, according to their geometric attributes."
msgstr ""

msgid ""
"5267    In this example, `Shape` does not inherit from "
"`Geometric_attributes`. Only its subclasses do."
msgstr ""

msgid "5268        void add(Shape* const item)"
msgstr ""

msgid "5269        {"
msgstr ""

msgid "5270          // Ownership is always taken"
msgstr ""

msgid "5271          owned_shapes.emplace_back(item);"
msgstr ""

msgid ""
"5272          // Check the Geometric_attributes and add the shape to none/"
"one/some/all of the views"
msgstr ""

msgid "5273          if (auto even = dynamic_cast<Even_sided*>(item))"
msgstr ""

msgid "5274          {"
msgstr ""

msgid "5275            view_of_evens.emplace_back(even);"
msgstr ""

msgid "5276          }"
msgstr ""

msgid ""
"5277          if (auto trisym = "
"dynamic_cast<Trilaterally_symmetrical*>(item))"
msgstr ""

msgid "5278          {"
msgstr ""

msgid "5279            view_of_trisyms.emplace_back(trisym);"
msgstr ""

msgid "5280          }"
msgstr ""

msgid "5281        }"
msgstr ""

msgid "5282    ##### Notes"
msgstr ""

msgid ""
"5283    A failure to find the required class will cause `dynamic_cast` to "
"return a null value, and de-referencing a null-valued pointer will lead to "
"undefined behavior."
msgstr ""

msgid ""
"5284    Therefore the result of the `dynamic_cast` should always be treated "
"as if it may contain a null value, and tested."
msgstr ""

msgid "5285    ##### Enforcement"
msgstr ""

msgid ""
"5286    * (Complex) Unless there is a null test on the result of a "
"`dynamic_cast` of a pointer type, warn upon dereference of the pointer."
msgstr ""

msgid ""
"5287    ### <a name=\"Rh-smart\"></a>C.149: Use `unique_ptr` or `shared_ptr` "
"to avoid forgetting to `delete` objects created using `new`"
msgstr ""

msgid "5288    ##### Reason"
msgstr ""

msgid "5289    Avoid resource leaks."
msgstr ""

msgid "5290    ##### Example"
msgstr ""

msgid "5291        void use(int i)"
msgstr ""

msgid "5292        {"
msgstr ""

msgid ""
"5293            auto p = new int {7};           // bad: initialize local "
"pointers with new"
msgstr ""

msgid ""
"5294            auto q = make_unique<int>(9);   // ok: guarantee the release "
"of the memory-allocated for 9"
msgstr ""

msgid ""
"5295            if (0 < i) return;              // maybe return and leak"
msgstr ""

msgid "5296            delete p;                       // too late"
msgstr ""

msgid "5297        }"
msgstr ""

msgid "5298    ##### Enforcement"
msgstr ""

msgid ""
"5299    * Flag initialization of a naked pointer with the result of a `new`"
msgstr ""

msgid "5300    * Flag `delete` of local variable"
msgstr ""

msgid ""
"5301    ### <a name=\"Rh-make_unique\"></a>C.150: Use `make_unique()` to "
"construct objects owned by `unique_ptr`s"
msgstr ""

msgid "5302    ##### Reason"
msgstr ""

msgid ""
"5303     `make_unique` gives a more concise statement of the construction."
msgstr ""

msgid "5304    It also ensures exception safety in complex expressions."
msgstr ""

msgid "5305    ##### Example"
msgstr ""

msgid "5306        unique_ptr<Foo> p {new<Foo>{7}};   // OK: but repetitive"
msgstr ""

msgid ""
"5307        auto q = make_unique<Foo>(7);      // Better: no repetition of "
"Foo"
msgstr ""

msgid ""
"5308        // Not exception-safe: the compiler may interleave the "
"computations of arguments as follows:"
msgstr ""

msgid "5309        //"
msgstr ""

msgid "5310        // 1. allocate memory for Foo,"
msgstr ""

msgid "5311        // 2. construct Foo,"
msgstr ""

msgid "5312        // 3. call bar,"
msgstr ""

msgid "5313        // 4. construct unique_ptr<Foo>."
msgstr ""

msgid "5314        //"
msgstr ""

msgid ""
"5315        // If bar throws, Foo will not be destroyed, and the memory-"
"allocated for it will leak."
msgstr ""

msgid "5316        f(unique_ptr<Foo>(new Foo()), bar());"
msgstr ""

msgid ""
"5317        // Exception-safe: calls to functions are never interleaved."
msgstr ""

msgid "5318        f(make_unique<Foo>(), bar());"
msgstr ""

msgid "5319    ##### Enforcement"
msgstr ""

msgid ""
"5320    * Flag the repetitive usage of template specialization list `<Foo>`"
msgstr ""

msgid "5321    * Flag variables declared to be `unique_ptr<Foo>`"
msgstr ""

msgid ""
"5322    ### <a name=\"Rh-make_shared\"></a>C.151: Use `make_shared()` to "
"construct objects owned by `shared_ptr`s"
msgstr ""

msgid "5323    ##### Reason"
msgstr ""

msgid ""
"5324     `make_shared` gives a more concise statement of the construction."
msgstr ""

msgid ""
"5325    It also gives an opportunity to eliminate a separate allocation for "
"the reference counts, by placing the `shared_ptr`'s use counts next to its "
"object."
msgstr ""

msgid "5326    ##### Example"
msgstr ""

msgid "5327        void test() {"
msgstr ""

msgid ""
"5328            // OK: but repetitive; and separate allocations for the Bar "
"and shared_ptr's use count"
msgstr ""

msgid "5329            shared_ptr<Bar> p {new<Bar>{7}};"
msgstr ""

msgid ""
"5330            auto q = make_shared<Bar>(7);   // Better: no repetition of "
"Bar; one object"
msgstr ""

msgid "5331        }"
msgstr ""

msgid "5332    ##### Enforcement"
msgstr ""

msgid ""
"5333    * Flag the repetitive usage of template specialization list`<Bar>`"
msgstr ""

msgid "5334    * Flag variables declared to be `shared_ptr<Bar>`"
msgstr ""

msgid ""
"5335    ### <a name=\"Rh-array\"></a>C.152: Never assign a pointer to an "
"array of derived class objects to a pointer to its base"
msgstr ""

msgid "5336    ##### Reason"
msgstr ""

msgid ""
"5337    Subscripting the resulting base pointer will lead to invalid object "
"access and probably to memory corruption."
msgstr ""

msgid "5338    ##### Example"
msgstr ""

msgid "5339        struct B { int x; };"
msgstr ""

msgid "5340        struct D : B { int y; };"
msgstr ""

msgid "5341        void use(B*);"
msgstr ""

msgid "5342        D a[] = {{1, 2}, {3, 4}, {5, 6}};"
msgstr ""

msgid ""
"5343        B* p = a;     // bad: a decays to &a[0] which is converted to a "
"B*"
msgstr ""

msgid "5344        p[1].x = 7;   // overwrite D[0].y"
msgstr ""

msgid ""
"5345        use(a);       // bad: a decays to &a[0] which is converted to a "
"B*"
msgstr ""

msgid "5346    ##### Enforcement"
msgstr ""

msgid ""
"5347    * Flag all combinations of array decay and base to derived "
"conversions."
msgstr ""

msgid ""
"5348    * Pass an array as a `span` rather than as a pointer, and don't let "
"the array name suffer a derived-to-base conversion before getting into the "
"`span`"
msgstr ""

msgid ""
"5349    ### <a name=\"Rh-use-virtual\"></a>C.153: Prefer virtual function to "
"casting"
msgstr ""

msgid "5350    ##### Reason"
msgstr ""

msgid ""
"5351    A virtual function call is safe, whereas casting is error-prone."
msgstr ""

msgid ""
"5352    A virtual function call reaches the most derived function, whereas a "
"cast may reach an intermediate class and therefore"
msgstr ""

msgid ""
"5353    give a wrong result (especially as a hierarchy is modified during "
"maintenance)."
msgstr ""

msgid "5354    ##### Example"
msgstr ""

msgid "5355        ???"
msgstr ""

msgid "5356    ##### Enforcement"
msgstr ""

msgid "5357    See [C.146](#Rh-dynamic_cast) and ???"
msgstr ""

msgid ""
"5358    ## <a name=\"SS-overload\"></a>C.over: Overloading and overloaded "
"operators"
msgstr ""

msgid ""
"5359    You can overload ordinary functions, template functions, and "
"operators."
msgstr ""

msgid "5360    You cannot overload function objects."
msgstr ""

msgid "5361    Overload rule summary:"
msgstr ""

msgid ""
"5362    * [C.160: Define operators primarily to mimic conventional "
"usage](#Ro-conventional)"
msgstr ""

msgid ""
"5363    * [C.161: Use nonmember functions for symmetric operators](#Ro-"
"symmetric)"
msgstr ""

msgid ""
"5364    * [C.162: Overload operations that are roughly equivalent](#Ro-"
"equivalent)"
msgstr ""

msgid ""
"5365    * [C.163: Overload only for operations that are roughly "
"equivalent](#Ro-equivalent-2)"
msgstr ""

msgid "5366    * [C.164: Avoid conversion operators](#Ro-conversion)"
msgstr ""

msgid "5367    * [C.165: Use `using` for customization points](#Ro-custom)"
msgstr ""

msgid ""
"5368    * [C.166: Overload unary `&` only as part of a system of smart "
"pointers and references](#Ro-address-of)"
msgstr ""

msgid ""
"5369    * [C.167: Use an operator for an operation with its conventional "
"meaning](#Ro-overload)"
msgstr ""

msgid ""
"5370    * [C.168: Define overloaded operators in the namespace of their "
"operands](#Ro-namespace)"
msgstr ""

msgid ""
"5371    * [C.170: If you feel like overloading a lambda, use a generic "
"lambda](#Ro-lambda)"
msgstr ""

msgid ""
"5372    ### <a name=\"Ro-conventional\"></a>C.160: Define operators "
"primarily to mimic conventional usage"
msgstr ""

msgid "5373    ##### Reason"
msgstr ""

msgid "5374    Minimize surprises."
msgstr ""

msgid "5375    ##### Example"
msgstr ""

msgid "5376        class X {"
msgstr ""

msgid "5377        public:"
msgstr ""

msgid "5378            // ..."
msgstr ""

msgid ""
"5379            X& operator=(const X&); // member function defining "
"assignment"
msgstr ""

msgid ""
"5380            friend bool operator==(const X&, const X&); // == needs "
"access to representation"
msgstr ""

msgid ""
"5381                                                        // after a = b "
"we have a == b"
msgstr ""

msgid "5382            // ..."
msgstr ""

msgid "5383        };"
msgstr ""

msgid ""
"5384    Here, the conventional semantics is maintained: [Copies compare "
"equal](#SS-copy)."
msgstr ""

msgid "5385    ##### Example, bad"
msgstr ""

msgid ""
"5386        X operator+(X a, X b) { return a.v - b.v; }   // bad: makes + "
"subtract"
msgstr ""

msgid "5387    ##### Note"
msgstr ""

msgid ""
"5388    Nonmember operators should be either friends or defined in [the same "
"namespace as their operands](#Ro-namespace)."
msgstr ""

msgid ""
"5389    [Binary operators should treat their operands equivalently](#Ro-"
"symmetric)."
msgstr ""

msgid "5390    ##### Enforcement"
msgstr ""

msgid "5391    Possibly impossible."
msgstr ""

msgid ""
"5392    ### <a name=\"Ro-symmetric\"></a>C.161: Use nonmember functions for "
"symmetric operators"
msgstr ""

msgid "5393    ##### Reason"
msgstr ""

msgid "5394    If you use member functions, you need two."
msgstr ""

msgid ""
"5395    Unless you use a nonmember function for (say) `==`, `a == b` and `b ="
"= a` will be subtly different."
msgstr ""

msgid "5396    ##### Example"
msgstr ""

msgid ""
"5397        bool operator==(Point a, Point b) { return a.x == b.x && a.y == "
"b.y; }"
msgstr ""

msgid "5398    ##### Enforcement"
msgstr ""

msgid "5399    Flag member operator functions."
msgstr ""

msgid ""
"5400    ### <a name=\"Ro-equivalent\"></a>C.162: Overload operations that "
"are roughly equivalent"
msgstr ""

msgid "5401    ##### Reason"
msgstr ""

msgid ""
"5402    Having different names for logically equivalent operations on "
"different argument types is confusing, leads to encoding type information in "
"function names, and inhibits generic programming."
msgstr ""

msgid "5403    ##### Example"
msgstr ""

msgid "5404    Consider:"
msgstr ""

msgid "5405        void print(int a);"
msgstr ""

msgid "5406        void print(int a, int base);"
msgstr ""

msgid "5407        void print(const string&);"
msgstr ""

msgid ""
"5408    These three functions all print their arguments (appropriately). "
"Conversely:"
msgstr ""

msgid "5409        void print_int(int a);"
msgstr ""

msgid "5410        void print_based(int a, int base);"
msgstr ""

msgid "5411        void print_string(const string&);"
msgstr ""

msgid ""
"5412    These three functions all print their arguments (appropriately). "
"Adding to the name just introduced verbosity and inhibits generic code."
msgstr ""

msgid "5413    ##### Enforcement"
msgstr ""

msgid "5414    ???"
msgstr ""

msgid ""
"5415    ### <a name=\"Ro-equivalent-2\"></a>C.163: Overload only for "
"operations that are roughly equivalent"
msgstr ""

msgid "5416    ##### Reason"
msgstr ""

msgid ""
"5417    Having the same name for logically different functions is confusing "
"and leads to errors when using generic programming."
msgstr ""

msgid "5418    ##### Example"
msgstr ""

msgid "5419    Consider:"
msgstr ""

msgid ""
"5420        void open_gate(Gate& g);   // remove obstacle from garage exit "
"lane"
msgstr ""

msgid ""
"5421        void fopen(const char* name, const char* mode);   // open file"
msgstr ""

msgid ""
"5422    The two operations are fundamentally different (and unrelated) so it "
"is good that their names differ. Conversely:"
msgstr ""

msgid ""
"5423        void open(Gate& g);   // remove obstacle from garage exit lane"
msgstr ""

msgid ""
"5424        void open(const char* name, const char* mode =\"r\");   // open "
"file"
msgstr ""

msgid ""
"5425    The two operations are still fundamentally different (and unrelated) "
"but the names have been reduced to their (common) minimum, opening "
"opportunities for confusion."
msgstr ""

msgid "5426    Fortunately, the type system will catch many such mistakes."
msgstr ""

msgid "5427    ##### Note"
msgstr ""

msgid ""
"5428    Be particularly careful about common and popular names, such as "
"`open`, `move`, `+`, and `==`."
msgstr ""

msgid "5429    ##### Enforcement"
msgstr ""

msgid "5430    ???"
msgstr ""

msgid ""
"5431    ### <a name=\"Ro-conversion\"></a>C.164: Avoid conversion operators"
msgstr ""

msgid "5432    ##### Reason"
msgstr ""

msgid ""
"5433    Implicit conversions can be essential (e.g., `double` to `int`) but "
"often cause surprises (e.g., `String` to C-style string)."
msgstr ""

msgid "5434    ##### Note"
msgstr ""

msgid ""
"5435    Prefer explicitly named conversions until a serious need is "
"demonstrated."
msgstr ""

msgid ""
"5436    By \"serious need\" we mean a reason that is fundamental in the "
"application domain (such as an integer to complex number conversion)"
msgstr ""

msgid ""
"5437    and frequently needed. Do not introduce implicit conversions "
"(through conversion operators or non-`explicit` constructors)"
msgstr ""

msgid "5438    just to gain a minor convenience."
msgstr ""

msgid "5439    ##### Example, bad"
msgstr ""

msgid ""
"5440        class String {   // handle ownership and access to a sequence of "
"characters"
msgstr ""

msgid "5441            // ..."
msgstr ""

msgid "5442            String(czstring p); // copy from *p to *(this->elem)"
msgstr ""

msgid "5443            // ..."
msgstr ""

msgid "5444            operator zstring() { return elem; }"
msgstr ""

msgid "5445            // ..."
msgstr ""

msgid "5446        };"
msgstr ""

msgid "5447        void user(zstring p)"
msgstr ""

msgid "5448        {"
msgstr ""

msgid "5449            if (*p == \"\") {"
msgstr ""

msgid "5450                String s {\"Trouble ahead!\"};"
msgstr ""

msgid "5451                // ..."
msgstr ""

msgid "5452                p = s;"
msgstr ""

msgid "5453            }"
msgstr ""

msgid "5454            // use p"
msgstr ""

msgid "5455        }"
msgstr ""

msgid ""
"5456    The string allocated for `s` and assigned to `p` is destroyed before "
"it can be used."
msgstr ""

msgid "5457    ##### Enforcement"
msgstr ""

msgid "5458    Flag all conversion operators."
msgstr ""

msgid ""
"5459    ### <a name=\"Ro-custom\"></a>C.165: Use `using` for customization "
"points"
msgstr ""

msgid "5460    ##### Reason"
msgstr ""

msgid ""
"5461    To find function objects and functions defined in a separate "
"namespace to \"customize\" a common function."
msgstr ""

msgid "5462    ##### Example"
msgstr ""

msgid ""
"5463    Consider `swap`. It is a general (standard-library) function with a "
"definition that will work for just about any type."
msgstr ""

msgid ""
"5464    However, it is desirable to define specific `swap()`s for specific "
"types."
msgstr ""

msgid ""
"5465    For example, the general `swap()` will copy the elements of two "
"`vector`s being swapped, whereas a good specific implementation will not "
"copy elements at all."
msgstr ""

msgid "5466        namespace N {"
msgstr ""

msgid "5467            My_type X { /* ... */ };"
msgstr ""

msgid "5468            void swap(X&, X&);   // optimized swap for N::X"
msgstr ""

msgid "5469            // ..."
msgstr ""

msgid "5470        }"
msgstr ""

msgid "5471        void f1(N::X& a, N::X& b)"
msgstr ""

msgid "5472        {"
msgstr ""

msgid ""
"5473            std::swap(a, b);   // probably not what we wanted: calls std:"
":swap()"
msgstr ""

msgid "5474        }"
msgstr ""

msgid ""
"5475    The `std::swap()` in `f1()` does exactly what we asked it to do: it "
"calls the `swap()` in namespace `std`."
msgstr ""

msgid "5476    Unfortunately, that's probably not what we wanted."
msgstr ""

msgid "5477    How do we get `N::X` considered?"
msgstr ""

msgid "5478        void f2(N::X& a, N::X& b)"
msgstr ""

msgid "5479        {"
msgstr ""

msgid "5480            swap(a, b);   // calls N::swap"
msgstr ""

msgid "5481        }"
msgstr ""

msgid "5482    But that may not be what we wanted for generic code."
msgstr ""

msgid ""
"5483    There, we typically want the specific function if it exists and the "
"general function if not."
msgstr ""

msgid ""
"5484    This is done by including the general function in the lookup for the "
"function:"
msgstr ""

msgid "5485        void f3(N::X& a, N::X& b)"
msgstr ""

msgid "5486        {"
msgstr ""

msgid "5487            using std::swap;  // make std::swap available"
msgstr ""

msgid ""
"5488            swap(a, b);        // calls N::swap if it exists, otherwise "
"std::swap"
msgstr ""

msgid "5489        }"
msgstr ""

msgid "5490    ##### Enforcement"
msgstr ""

msgid ""
"5491    Unlikely, except for known customization points, such as `swap`."
msgstr ""

msgid ""
"5492    The problem is that the unqualified and qualified lookups both have "
"uses."
msgstr ""

msgid ""
"5493    ### <a name=\"Ro-address-of\"></a>C.166: Overload unary `&` only as "
"part of a system of smart pointers and references"
msgstr ""

msgid "5494    ##### Reason"
msgstr ""

msgid "5495    The `&` operator is fundamental in C++."
msgstr ""

msgid "5496    Many parts of the C++ semantics assumes its default meaning."
msgstr ""

msgid "5497    ##### Example"
msgstr ""

msgid "5498        class Ptr { // a somewhat smart pointer"
msgstr ""

msgid "5499            Ptr(X* pp) :p(pp) { /* check */ }"
msgstr ""

msgid "5500            X* operator->() { /* check */ return p; }"
msgstr ""

msgid "5501            X operator[](int i);"
msgstr ""

msgid "5502            X operator*();"
msgstr ""

msgid "5503        private:"
msgstr ""

msgid "5504            T* p;"
msgstr ""

msgid "5505        };"
msgstr ""

msgid "5506        class X {"
msgstr ""

msgid "5507            Ptr operator&() { return Ptr{this}; }"
msgstr ""

msgid "5508            // ..."
msgstr ""

msgid "5509        };"
msgstr ""

msgid "5510    ##### Note"
msgstr ""

msgid ""
"5511    If you \"mess with\" operator `&` be sure that its definition has "
"matching meanings for `->`, `[]`, `*`, and `.` on the result type."
msgstr ""

msgid ""
"5512    Note that operator `.` currently cannot be overloaded so a perfect "
"system is impossible."
msgstr ""

msgid ""
"5513    We hope to remedy that: <http://www.open-std.org/jtc1/sc22/wg21/docs/"
"papers/2015/n4477.pdf>."
msgstr ""

msgid "5514    Note that `std::addressof()` always yields a built-in pointer."
msgstr ""

msgid "5515    ##### Enforcement"
msgstr ""

msgid ""
"5516    Tricky. Warn if `&` is user-defined without also defining `->` for "
"the result type."
msgstr ""

msgid ""
"5517    ### <a name=\"Ro-overload\"></a>C.167: Use an operator for an "
"operation with its conventional meaning"
msgstr ""

msgid "5518    ##### Reason"
msgstr ""

msgid "5519    Readability. Convention. Reusability. Support for generic code"
msgstr ""

msgid "5520    ##### Example"
msgstr ""

msgid ""
"5521        void cout_my_class(const My_class& c) // confusing, not "
"conventional,not generic"
msgstr ""

msgid "5522        {"
msgstr ""

msgid "5523            std::cout << /* class members here */;"
msgstr ""

msgid "5524        }"
msgstr ""

msgid ""
"5525        std::ostream& operator<<(std::ostream& os, const my_class& c) // "
"OK"
msgstr ""

msgid "5526        {"
msgstr ""

msgid "5527            return os << /* class members here */;"
msgstr ""

msgid "5528        }"
msgstr ""

msgid ""
"5529    By itself, `cout_my_class` would be OK, but it is not usable/"
"composable with code that rely on the `<<` convention for output:"
msgstr ""

msgid "5530        My_class var { /* ... */ };"
msgstr ""

msgid "5531        // ..."
msgstr ""

msgid "5532        cout << \"var = \" << var << '\\n';"
msgstr ""

msgid "5533    ##### Note"
msgstr ""

msgid ""
"5534    There are strong and vigorous conventions for the meaning most "
"operators, such as"
msgstr ""

msgid "5535    * comparisons (`==`, `!=`, `<`, `<=`, `>`, and `>=`),"
msgstr ""

msgid "5536    * arithmetic operations (`+`, `-`, `*`, `/`, and `%`)"
msgstr ""

msgid "5537    * access operations (`.`, `->`, unary `*`, and `[]`)"
msgstr ""

msgid "5538    * assignment (`=`)"
msgstr ""

msgid ""
"5539    Don't define those unconventionally and don't invent your own names "
"for them."
msgstr ""

msgid "5540    ##### Enforcement"
msgstr ""

msgid "5541    Tricky. Requires semantic insight."
msgstr ""

msgid ""
"5542    ### <a name=\"Ro-namespace\"></a>C.168: Define overloaded operators "
"in the namespace of their operands"
msgstr ""

msgid "5543    ##### Reason"
msgstr ""

msgid "5544    Readability."
msgstr ""

msgid "5545    Ability for find operators using ADL."
msgstr ""

msgid "5546    Avoiding inconsistent definition in different namespaces"
msgstr ""

msgid "5547    ##### Example"
msgstr ""

msgid "5548        struct S { };"
msgstr ""

msgid ""
"5549        bool operator==(S, S);   // OK: in the same namespace as S, and "
"even next to S"
msgstr ""

msgid "5550        S s;"
msgstr ""

msgid "5551        bool x = (s == s);"
msgstr ""

msgid "5552    This is what a default `==` would do, if we had such defaults."
msgstr ""

msgid "5553    ##### Example"
msgstr ""

msgid "5554        namespace N {"
msgstr ""

msgid "5555            struct S { };"
msgstr ""

msgid ""
"5556            bool operator==(S, S);   // OK: in the same namespace as S, "
"and even next to S"
msgstr ""

msgid "5557        }"
msgstr ""

msgid "5558        N::S s;"
msgstr ""

msgid "5559        bool x = (s == s);  // finds N::operator==() by ADL"
msgstr ""

msgid "5560    ##### Example, bad"
msgstr ""

msgid "5561        struct S { };"
msgstr ""

msgid "5562        S s;"
msgstr ""

msgid "5563        namespace N {"
msgstr ""

msgid "5564            S::operator!(S a) { return true; }"
msgstr ""

msgid "5565            S not_s = !s;"
msgstr ""

msgid "5566        }"
msgstr ""

msgid "5567        namespace M {"
msgstr ""

msgid "5568            S::operator!(S a) { return false; }"
msgstr ""

msgid "5569            S not_s = !s;"
msgstr ""

msgid "5570        }"
msgstr ""

msgid "5571    Here, the meaning of `!s` differs in `N` and `M`."
msgstr ""

msgid "5572    This can be most confusing."
msgstr ""

msgid ""
"5573    Remove the definition of `namespace M` and the confusion is replaced "
"by an opportunity to make the mistake."
msgstr ""

msgid "5574    ##### Note"
msgstr ""

msgid ""
"5575    If a binary operator is defined for two types that are defined in "
"different namespaces, you cannot follow this rule."
msgstr ""

msgid "5576    For example:"
msgstr ""

msgid ""
"5577        Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&);"
msgstr ""

msgid "5578    This may be something best avoided."
msgstr ""

msgid "5579    ##### See also"
msgstr ""

msgid ""
"5580    This is a special case of the rule that [helper functions should be "
"defined in the same namespace as their class](#Rc-helper)."
msgstr ""

msgid "5581    ##### Enforcement"
msgstr ""

msgid ""
"5582    * Flag operator definitions that are not it the namespace of their "
"operands"
msgstr ""

msgid ""
"5583    ### <a name=\"Ro-lambda\"></a>C.170: If you feel like overloading a "
"lambda, use a generic lambda"
msgstr ""

msgid "5584    ##### Reason"
msgstr ""

msgid ""
"5585    You cannot overload by defining two different lambdas with the same "
"name."
msgstr ""

msgid "5586    ##### Example"
msgstr ""

msgid "5587        void f(int);"
msgstr ""

msgid "5588        void f(double);"
msgstr ""

msgid ""
"5589        auto f = [](char);   // error: cannot overload variable and "
"function"
msgstr ""

msgid "5590        auto g = [](int) { /* ... */ };"
msgstr ""

msgid ""
"5591        auto g = [](double) { /* ... */ };   // error: cannot overload "
"variables"
msgstr ""

msgid "5592        auto h = [](auto) { /* ... */ };   // OK"
msgstr ""

msgid "5593    ##### Enforcement"
msgstr ""

msgid "5594    The compiler catches the attempt to overload a lambda."
msgstr ""

msgid "5595    ## <a name=\"SS-union\"></a>C.union: Unions"
msgstr ""

msgid ""
"5596    A `union` is a `struct` where all members start at the same address "
"so that it can hold only one member at a time."
msgstr ""

msgid ""
"5597    A `union` does not keep track of which member is stored so the "
"programmer has to get it right;"
msgstr ""

msgid ""
"5598    this is inherently error-prone, but there are ways to compensate."
msgstr ""

msgid ""
"5599    A type that is a `union` plus an indicator of which member is "
"currently held is called a *tagged union*, a *discriminated union*, or a "
"*variant*."
msgstr ""

msgid "5600    Union rule summary:"
msgstr ""

msgid "5601    * [C.180: Use `union`s to save Memory](#Ru-union)"
msgstr ""

msgid "5602    * [C.181: Avoid \"naked\" `union`s](#Ru-naked)"
msgstr ""

msgid ""
"5603    * [C.182: Use anonymous `union`s to implement tagged unions](#Ru-"
"anonymous)"
msgstr ""

msgid "5604    * [C.183: Don't use a `union` for type punning](#Ru-pun)"
msgstr ""

msgid "5605    * ???"
msgstr ""

msgid "5606    ### <a name=\"Ru-union\"></a>C.180: Use `union`s to save memory"
msgstr ""

msgid "5607    ##### Reason"
msgstr ""

msgid ""
"5608    A `union` allows a single piece of memory to be used for different "
"types of objects at different times."
msgstr ""

msgid ""
"5609    Consequently, it can be used to save memory when we have several "
"objects that are never used at the same time."
msgstr ""

msgid "5610    ##### Example"
msgstr ""

msgid "5611        union Value {"
msgstr ""

msgid "5612            int x;"
msgstr ""

msgid "5613            double d;"
msgstr ""

msgid "5614        };"
msgstr ""

msgid "5615        Value v = { 123 };  // now v holds an int"
msgstr ""

msgid "5616        cout << v.x << '\\n';    // write 123"
msgstr ""

msgid "5617        v.d = 987.654;  // now v holds a double"
msgstr ""

msgid "5618        cout << v.d << '\\n';    // write 987.654"
msgstr ""

msgid "5619    But heed the warning: [Avoid \"naked\" `union`s](#Ru-naked)"
msgstr ""

msgid "5620    ##### Example"
msgstr ""

msgid "5621        // Short-string optimization"
msgstr ""

msgid ""
"5622        constexpr size_t buffer_size = 16; // Slightly larger than the "
"size of a pointer"
msgstr ""

msgid "5623        class Immutable_string {"
msgstr ""

msgid "5624        public:"
msgstr ""

msgid "5625            Immutable_string(const char* str) :"
msgstr ""

msgid "5626                size(strlen(str))"
msgstr ""

msgid "5627            {"
msgstr ""

msgid "5628                if (size < buffer_size)"
msgstr ""

msgid "5629                    strcpy_s(string_buffer, buffer_size, str);"
msgstr ""

msgid "5630                else {"
msgstr ""

msgid "5631                    string_ptr = new char[size + 1];"
msgstr ""

msgid "5632                    strcpy_s(string_ptr, size + 1, str);"
msgstr ""

msgid "5633                }"
msgstr ""

msgid "5634            }"
msgstr ""

msgid "5635            ~Immutable_string()"
msgstr ""

msgid "5636            {"
msgstr ""

msgid "5637                if (size >= buffer_size)"
msgstr ""

msgid "5638                    delete string_ptr;"
msgstr ""

msgid "5639            }"
msgstr ""

msgid "5640            const char* get_str() const"
msgstr ""

msgid "5641            {"
msgstr ""

msgid ""
"5642                return (size < buffer_size) ? string_buffer : "
"string_ptr;"
msgstr ""

msgid "5643            }"
msgstr ""

msgid "5644        private:"
msgstr ""

msgid ""
"5645            // If the string is short enough, we store the string itself"
msgstr ""

msgid "5646            // instead of a pointer to the string."
msgstr ""

msgid "5647            union {"
msgstr ""

msgid "5648                char* string_ptr;"
msgstr ""

msgid "5649                char string_buffer[buffer_size];"
msgstr ""

msgid "5650            };"
msgstr ""

msgid "5651            const size_t size;"
msgstr ""

msgid "5652        };"
msgstr ""

msgid "5653    ##### Enforcement"
msgstr ""

msgid "5654    ???"
msgstr ""

msgid "5655    ### <a name=\"Ru-naked\"></a>C.181: Avoid \"naked\" `union`s"
msgstr ""

msgid "5656    ##### Reason"
msgstr ""

msgid ""
"5657    A *naked union* is a union without an associated indicator which "
"member (if any) it holds,"
msgstr ""

msgid "5658    so that the programmer has to keep track."
msgstr ""

msgid "5659    Naked unions are a source of type errors."
msgstr ""

msgid "5660    ##### Example, bad"
msgstr ""

msgid "5661        union Value {"
msgstr ""

msgid "5662            int x;"
msgstr ""

msgid "5663            double d;"
msgstr ""

msgid "5664        };"
msgstr ""

msgid "5665        Value v;"
msgstr ""

msgid "5666        v.d = 987.654;  // v holds a double"
msgstr ""

msgid "5667    So far, so good, but we can easily misuse the `union`:"
msgstr ""

msgid ""
"5668        cout << v.x << '\\n';    // BAD, undefined behavior: v holds a "
"double, but we read it as an int"
msgstr ""

msgid "5669    Note that the type error happened without any explicit cast."
msgstr ""

msgid ""
"5670    When we tested that program the last value printed was `1683627180` "
"which it the integer value for the bit pattern for `987.654`."
msgstr ""

msgid ""
"5671    What we have here is an \"invisible\" type error that happens to "
"give a result that could easily look innocent."
msgstr ""

msgid "5672    And, talking about \"invisible\", this code produced no output:"
msgstr ""

msgid "5673        v.x = 123;"
msgstr ""

msgid "5674        cout << v.d << '\\n';    // BAD: undefined behavior"
msgstr ""

msgid "5675    ##### Alternative"
msgstr ""

msgid "5676    Wrap a `union` in a class together with a type field."
msgstr ""

msgid ""
"5677    The soon-to-be-standard `variant` type (to be found in `<variant>`) "
"does that for you:"
msgstr ""

msgid "5678        variant<int, double> v;"
msgstr ""

msgid "5679        v = 123;        // v holds an int"
msgstr ""

msgid "5680        int x = get<int>(v);"
msgstr ""

msgid "5681        v = 123.456;    // v holds a double"
msgstr ""

msgid "5682        w = get<double>(v);"
msgstr ""

msgid "5683    ##### Enforcement"
msgstr ""

msgid "5684    ???"
msgstr ""

msgid ""
"5685    ### <a name=\"Ru-anonymous\"></a>C.182: Use anonymous `union`s to "
"implement tagged unions"
msgstr ""

msgid "5686    ##### Reason"
msgstr ""

msgid "5687    A well-designed tagged union is type safe."
msgstr ""

msgid ""
"5688    An *anonymous* union simplifies the definition of a class with a "
"(tag, union) pair."
msgstr ""

msgid "5689    ##### Example"
msgstr ""

msgid "5690    This example is mostly borrowed from TC++PL4 pp216-218."
msgstr ""

msgid "5691    You can look there for an explanation."
msgstr ""

msgid "5692    The code is somewhat elaborate."
msgstr ""

msgid ""
"5693    Handling a type with user-defined assignment and destructor is "
"tricky."
msgstr ""

msgid ""
"5694    Saving programmers from having to write such code is one reason for "
"including `variant` in the standard."
msgstr ""

msgid ""
"5695        class Value { // two alternative representations represented as "
"a union"
msgstr ""

msgid "5696        private:"
msgstr ""

msgid "5697            enum class Tag { number, text };"
msgstr ""

msgid "5698            Tag type; // discriminant"
msgstr ""

msgid "5699            union { // representation (note: anonymous union)"
msgstr ""

msgid "5700                int i;"
msgstr ""

msgid ""
"5701                string s; // string has default constructor, copy "
"operations, and destructor"
msgstr ""

msgid "5702            };"
msgstr ""

msgid "5703        public:"
msgstr ""

msgid "5704            struct Bad_entry { }; // used for exceptions"
msgstr ""

msgid "5705            ~Value();"
msgstr ""

msgid ""
"5706            Value& operator=(const Value&);   // necessary because of "
"the string variant"
msgstr ""

msgid "5707            Value(const Value&);"
msgstr ""

msgid "5708            // ..."
msgstr ""

msgid "5709            int number() const;"
msgstr ""

msgid "5710            string text() const;"
msgstr ""

msgid "5711            void set_number(int n);"
msgstr ""

msgid "5712            void set_text(const string&);"
msgstr ""

msgid "5713            // ..."
msgstr ""

msgid "5714        };"
msgstr ""

msgid "5715        int Value::number() const"
msgstr ""

msgid "5716        {"
msgstr ""

msgid "5717            if (type != Tag::number) throw Bad_entry{};"
msgstr ""

msgid "5718            return i;"
msgstr ""

msgid "5719        }"
msgstr ""

msgid "5720        string Value::text() const"
msgstr ""

msgid "5721        {"
msgstr ""

msgid "5722            if (type != Tag::text) throw Bad_entry{};"
msgstr ""

msgid "5723            return s;"
msgstr ""

msgid "5724        }"
msgstr ""

msgid "5725        void Value::set_number(int n)"
msgstr ""

msgid "5726        {"
msgstr ""

msgid "5727            if (type == Tag::text) {"
msgstr ""

msgid "5728                s.~string();      // explicitly destroy string"
msgstr ""

msgid "5729                type = Tag::number;"
msgstr ""

msgid "5730            }"
msgstr ""

msgid "5731            i = n;"
msgstr ""

msgid "5732        }"
msgstr ""

msgid "5733        void Value::set_text(const string& ss)"
msgstr ""

msgid "5734        {"
msgstr ""

msgid "5735            if (type == Tag::text)"
msgstr ""

msgid "5736                s = ss;"
msgstr ""

msgid "5737            else {"
msgstr ""

msgid ""
"5738                new(&s) string{ss};   // placement new: explicitly "
"construct string"
msgstr ""

msgid "5739                type = Tag::text;"
msgstr ""

msgid "5740            }"
msgstr ""

msgid "5741        }"
msgstr ""

msgid ""
"5742        Value& Value::operator=(const Value& e)   // necessary because "
"of the string variant"
msgstr ""

msgid "5743        {"
msgstr ""

msgid "5744            if (type == Tag::text && e.type == Tag::text) {"
msgstr ""

msgid "5745                s = e.s;    // usual string assignment"
msgstr ""

msgid "5746                return *this;"
msgstr ""

msgid "5747            }"
msgstr ""

msgid ""
"5748            if (type == Tag::text) s.~string(); // explicit destroy"
msgstr ""

msgid "5749            switch (e.type) {"
msgstr ""

msgid "5750            case Tag::number:"
msgstr ""

msgid "5751                i = e.i;"
msgstr ""

msgid "5752                break;"
msgstr ""

msgid "5753            case Tag::text:"
msgstr ""

msgid ""
"5754                new(&s)(e.s);   // placement new: explicit construct"
msgstr ""

msgid "5755                type = e.type;"
msgstr ""

msgid "5756            }"
msgstr ""

msgid "5757            return *this;"
msgstr ""

msgid "5758        }"
msgstr ""

msgid "5759        Value::~Value()"
msgstr ""

msgid "5760        {"
msgstr ""

msgid ""
"5761            if (type == Tag::text) s.~string(); // explicit destroy"
msgstr ""

msgid "5762        }"
msgstr ""

msgid "5763    ##### Enforcement"
msgstr ""

msgid "5764    ???"
msgstr ""

msgid ""
"5765    ### <a name=\"Ru-pun\"></a>C.183: Don't use a `union` for type "
"punning"
msgstr ""

msgid "5766    ##### Reason"
msgstr ""

msgid ""
"5767    It is undefined behavior to read a `union` member with a different "
"type from the one with which it was written."
msgstr ""

msgid ""
"5768    Such punning is invisible, or at least harder to spot than using a "
"named cast."
msgstr ""

msgid "5769    Type punning using a `union` is a source of errors."
msgstr ""

msgid "5770    ##### Example, bad"
msgstr ""

msgid "5771        union Pun {"
msgstr ""

msgid "5772            int x;"
msgstr ""

msgid "5773            unsigned char c[sizeof(int)];"
msgstr ""

msgid "5774        };"
msgstr ""

msgid ""
"5775    The idea of `Pun` is to be able to look at the character "
"representation of an `int`."
msgstr ""

msgid "5776        void bad(Pun& u)"
msgstr ""

msgid "5777        {"
msgstr ""

msgid "5778            u.x = 'x';"
msgstr ""

msgid "5779            cout << u.c[0] << '\\n';     // undefined behavior"
msgstr ""

msgid "5780        }"
msgstr ""

msgid ""
"5781    If you wanted to see the bytes of an `int`, use a (named) cast:"
msgstr ""

msgid "5782        void if_you_must_pun(int& x)"
msgstr ""

msgid "5783        {"
msgstr ""

msgid "5784            auto p = reinterpret_cast<unsigned char*>(&x);"
msgstr ""

msgid "5785            cout << p[0] << '\\n';     // OK; better"
msgstr ""

msgid "5786            // ..."
msgstr ""

msgid "5787        }"
msgstr ""

msgid ""
"5788    Accessing the result of an `reinterpret_cast` to a different type "
"from the objects declared type is defined behavior (even though "
"`reinterpret_cast` is discouraged),"
msgstr ""

msgid "5789    but at least we can see that something tricky is going on."
msgstr ""

msgid "5790    ##### Note"
msgstr ""

msgid "5791    Unfortunately, `union`s are commonly used for type punning."
msgstr ""

msgid ""
"5792    We don't consider \"sometimes, it works as expected\" a strong "
"argument."
msgstr ""

msgid ""
"5793    C++17 introduced a distinct type `std::byte` to facilitate "
"operations on raw object representation.  Use that type instead of `unsigned "
"char` or `char` for these operations."
msgstr ""

msgid "5794    ##### Enforcement"
msgstr ""

msgid "5795    ???"
msgstr ""

msgid "5796    # <a name=\"S-enum\"></a>Enum: Enumerations"
msgstr ""

msgid ""
"5797    Enumerations are used to define sets of integer values and for "
"defining types for such sets of values."
msgstr ""

msgid ""
"5798    There are two kind of enumerations, \"plain\" `enum`s and `class "
"enum`s."
msgstr ""

msgid "5799    Enumeration rule summary:"
msgstr ""

msgid "5800    * [Enum.1: Prefer enumerations over macros](#Renum-macro)"
msgstr ""

msgid ""
"5801    * [Enum.2: Use enumerations to represent sets of related named "
"constants](#Renum-set)"
msgstr ""

msgid ""
"5802    * [Enum.3: Prefer `enum class`es over \"plain\" `enum`s](#Renum-"
"class)"
msgstr ""

msgid ""
"5803    * [Enum.4: Define operations on enumerations for safe and simple "
"use](#Renum-oper)"
msgstr ""

msgid "5804    * [Enum.5: Don't use `ALL_CAPS` for enumerators](#Renum-caps)"
msgstr ""

msgid "5805    * [Enum.6: Avoid unnamed enumerations](#Renum-unnamed)"
msgstr ""

msgid ""
"5806    * [Enum.7: Specify the underlying type of an enumeration only when "
"necessary](#Renum-underlying)"
msgstr ""

msgid ""
"5807    * [Enum.8: Specify enumerator values only when necessary](#Renum-"
"value)"
msgstr ""

msgid ""
"5808    ### <a name=\"Renum-macro\"></a>Enum.1: Prefer enumerations over "
"macros"
msgstr ""

msgid "5809    ##### Reason"
msgstr ""

msgid ""
"5810    Macros do not obey scope and type rules. Also, macro names are "
"removed during preprocessing and so usually don't appear in tools like "
"debuggers."
msgstr ""

msgid "5811    ##### Example"
msgstr ""

msgid "5812    First some bad old code:"
msgstr ""

msgid "5813        // webcolors.h (third party header)"
msgstr ""

msgid "5814        #define RED   0xFF0000"
msgstr ""

msgid "5815        #define GREEN 0x00FF00"
msgstr ""

msgid "5816        #define BLUE  0x0000FF"
msgstr ""

msgid "5817        // productinfo.h"
msgstr ""

msgid "5818        // The following define product subtypes based on color"
msgstr ""

msgid "5819        #define RED    0"
msgstr ""

msgid "5820        #define PURPLE 1"
msgstr ""

msgid "5821        #define BLUE   2"
msgstr ""

msgid ""
"5822        int webby = BLUE;   // webby == 2; probably not what was desired"
msgstr ""

msgid "5823    Instead use an `enum`:"
msgstr ""

msgid ""
"5824        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = "
"0x0000FF };"
msgstr ""

msgid "5825        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr ""

msgid "5826        int webby = blue;   // error: be specific"
msgstr ""

msgid "5827        Web_color webby = Web_color::blue;"
msgstr ""

msgid "5828    We used an `enum class` to avoid name clashes."
msgstr ""

msgid "5829    ##### Enforcement"
msgstr ""

msgid "5830    Flag macros that define integer values."
msgstr ""

msgid ""
"5831    ### <a name=\"Renum-set\"></a>Enum.2: Use enumerations to represent "
"sets of related named constants"
msgstr ""

msgid "5832    ##### Reason"
msgstr ""

msgid ""
"5833    An enumeration shows the enumerators to be related and can be a "
"named type."
msgstr ""

msgid "5834    ##### Example"
msgstr ""

msgid ""
"5835        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = "
"0x0000FF };"
msgstr ""

msgid "5836    ##### Note"
msgstr ""

msgid ""
"5837    Switching on an enumeration is common and the compiler can warn "
"against unusual patterns of case labels. For example:"
msgstr ""

msgid "5838        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr ""

msgid "5839        void print(Product_info inf)"
msgstr ""

msgid "5840        {"
msgstr ""

msgid "5841            switch (inf) {"
msgstr ""

msgid "5842            case Product_info::red: cout << \"red\"; break;"
msgstr ""

msgid "5843            case Product_info::purple: cout << \"purple\"; break;"
msgstr ""

msgid "5844            }"
msgstr ""

msgid "5845        }"
msgstr ""

msgid ""
"5846    Such off-by-one switch`statements are often the results of an added "
"enumerator and insufficient testing."
msgstr ""

msgid "5847    ##### Enforcement"
msgstr ""

msgid ""
"5848    * Flag `switch`-statements where the `case`s cover most but not all "
"enumerators of an enumeration."
msgstr ""

msgid ""
"5849    * Flag `switch`-statements where the `case`s cover a few enumerators "
"of an enumeration, but has no `default`."
msgstr ""

msgid ""
"5850    ### <a name=\"Renum-class\"></a>Enum.3: Prefer class enums over "
"\"plain\" enums"
msgstr ""

msgid "5851    ##### Reason"
msgstr ""

msgid ""
"5852    To minimize surprises: traditional enums convert to int too readily."
msgstr ""

msgid "5853    ##### Example"
msgstr ""

msgid "5854        void Print_color(int color);"
msgstr ""

msgid ""
"5855        enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = "
"0x0000FF };"
msgstr ""

msgid "5856        enum Product_info { Red = 0, Purple = 1, Blue = 2 };"
msgstr ""

msgid "5857        Web_color webby = Web_color::blue;"
msgstr ""

msgid "5858        // Clearly at least one of these calls is buggy."
msgstr ""

msgid "5859        Print_color(webby);"
msgstr ""

msgid "5860        Print_color(Product_info::Blue);"
msgstr ""

msgid "5861    Instead use an `enum class`:"
msgstr ""

msgid "5862        void Print_color(int color);"
msgstr ""

msgid ""
"5863        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = "
"0x0000FF };"
msgstr ""

msgid "5864        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr ""

msgid "5865        Web_color webby = Web_color::blue;"
msgstr ""

msgid ""
"5866        Print_color(webby);  // Error: cannot convert Web_color to int."
msgstr ""

msgid ""
"5867        Print_color(Product_info::Red);  // Error: cannot convert "
"Product_info to int."
msgstr ""

msgid "5868    ##### Enforcement"
msgstr ""

msgid "5869    (Simple) Warn on any non-class `enum` definition."
msgstr ""

msgid ""
"5870    ### <a name=\"Renum-oper\"></a>Enum.4: Define operations on "
"enumerations for safe and simple use"
msgstr ""

msgid "5871    ##### Reason"
msgstr ""

msgid "5872    Convenience of use and avoidance of errors."
msgstr ""

msgid "5873    ##### Example"
msgstr ""

msgid "5874        enum Day { mon, tue, wed, thu, fri, sat, sun };"
msgstr ""

msgid "5875        Day& operator++(Day& d)"
msgstr ""

msgid "5876        {"
msgstr ""

msgid ""
"5877            return d = (d == Day::sun) ? Day::mon : "
"static_cast<Day>(static_cast<int>(d)+1);"
msgstr ""

msgid "5878        }"
msgstr ""

msgid "5879        Day today = Day::sat;"
msgstr ""

msgid "5880        Day tomorrow = ++today;"
msgstr ""

msgid "5881    The use of a `static_cast` is not pretty, but"
msgstr ""

msgid "5882        Day& operator++(Day& d)"
msgstr ""

msgid "5883        {"
msgstr ""

msgid ""
"5884            return d = (d == Day::sun) ? Day::mon : Day{++d};    // "
"error"
msgstr ""

msgid "5885        }"
msgstr ""

msgid ""
"5886    is an infinite recursion, and writing it without a cast, using a "
"`switch` on all cases is long-winded."
msgstr ""

msgid "5887    ##### Enforcement"
msgstr ""

msgid "5888    Flag repeated expressions cast back into an enumeration."
msgstr ""

msgid ""
"5889    ### <a name=\"Renum-caps\"></a>Enum.5: Don't use `ALL_CAPS` for "
"enumerators"
msgstr ""

msgid "5890    ##### Reason"
msgstr ""

msgid "5891    Avoid clashes with macros."
msgstr ""

msgid "5892    ##### Example, bad"
msgstr ""

msgid "5893         // webcolors.h (third party header)"
msgstr ""

msgid "5894        #define RED   0xFF0000"
msgstr ""

msgid "5895        #define GREEN 0x00FF00"
msgstr ""

msgid "5896        #define BLUE  0x0000FF"
msgstr ""

msgid "5897        // productinfo.h"
msgstr ""

msgid "5898        // The following define product subtypes based on color"
msgstr ""

msgid ""
"5899        enum class Product_info { RED, PURPLE, BLUE };   // syntax error"
msgstr ""

msgid "5900    ##### Enforcement"
msgstr ""

msgid "5901    Flag ALL_CAPS enumerators."
msgstr ""

msgid ""
"5902    ### <a name=\"Renum-unnamed\"></a>Enum.6: Avoid unnamed enumerations"
msgstr ""

msgid "5903    ##### Reason"
msgstr ""

msgid "5904    If you can't name an enumeration, the values are not related"
msgstr ""

msgid "5905    ##### Example, bad"
msgstr ""

msgid "5906        enum { red = 0xFF0000, scale = 4, is_signed = 1 };"
msgstr ""

msgid ""
"5907    Such code is not uncommon in code written before there were "
"convenient alternative ways of specifying integer constants."
msgstr ""

msgid "5908    ##### Alternative"
msgstr ""

msgid "5909    Use `constexpr` values instead. For example:"
msgstr ""

msgid "5910        constexpr int red = 0xFF0000;"
msgstr ""

msgid "5911        constexpr short scale = 4;"
msgstr ""

msgid "5912        constexpr bool is_signed = true;"
msgstr ""

msgid "5913    ##### Enforcement"
msgstr ""

msgid "5914    Flag unnamed enumerations."
msgstr ""

msgid ""
"5915    ### <a name=\"Renum-underlying\"></a>Enum.7: Specify the underlying "
"type of an enumeration only when necessary"
msgstr ""

msgid "5916    ##### Reason"
msgstr ""

msgid "5917    The default is the easiest to read and write."
msgstr ""

msgid "5918    `int` is the default integer type."
msgstr ""

msgid "5919    `int` is compatible with C `enum`s."
msgstr ""

msgid "5920    ##### Example"
msgstr ""

msgid "5921        enum class Direction : char { n, s, e, w,"
msgstr ""

msgid ""
"5922                                      ne, nw, se, sw };  // underlying "
"type saves space"
msgstr ""

msgid "5923        enum class Web_color : int32_t { red   = 0xFF0000,"
msgstr ""

msgid "5924                                         green = 0x00FF00,"
msgstr ""

msgid ""
"5925                                         blue  = 0x0000FF };  // "
"underlying type is redundant"
msgstr ""

msgid "5926    ##### Note"
msgstr ""

msgid ""
"5927    Specifying the underlying type is necessary in forward declarations "
"of enumerations:"
msgstr ""

msgid "5928        enum Flags : char;"
msgstr ""

msgid "5929        void f(Flags);"
msgstr ""

msgid "5930        // ...."
msgstr ""

msgid "5931        enum flags : char { /* ... */ };"
msgstr ""

msgid "5932    ##### Enforcement"
msgstr ""

msgid "5933    ????"
msgstr ""

msgid ""
"5934    ### <a name=\"Renum-value\"></a>Enum.8: Specify enumerator values "
"only when necessary"
msgstr ""

msgid "5935    ##### Reason"
msgstr ""

msgid "5936    It's the simplest."
msgstr ""

msgid "5937    It avoids duplicate enumerator values."
msgstr ""

msgid ""
"5938    The default gives a consecutive set of values that is good for "
"`switch`-statement implementations."
msgstr ""

msgid "5939    ##### Example"
msgstr ""

msgid "5940        enum class Col1 { red, yellow, blue };"
msgstr ""

msgid "5941        enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo"
msgstr ""

msgid "5942        enum class Month { jan = 1, feb, mar, apr, may, jun,"
msgstr ""

msgid ""
"5943                           jul, august, sep, oct, nov, dec }; // "
"starting with 1 is conventional"
msgstr ""

msgid ""
"5944        enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 "
"}; // set of bits"
msgstr ""

msgid ""
"5945    Specifying values is necessary to match conventional values (e.g., "
"`Month`)"
msgstr ""

msgid ""
"5946    and where consecutive values are undesirable (e.g., to get separate "
"bits as in `Base_flag`)."
msgstr ""

msgid "5947    ##### Enforcement"
msgstr ""

msgid "5948    * Flag duplicate enumerator values"
msgstr ""

msgid "5949    * Flag explicitly specified all-consecutive enumerator values"
msgstr ""

msgid "5950    # <a name=\"S-resource\"></a>R: Resource management"
msgstr ""

msgid "5951    This section contains rules related to resources."
msgstr ""

msgid ""
"5952    A resource is anything that must be acquired and (explicitly or "
"implicitly) released, such as memory, file handles, sockets, and locks."
msgstr ""

msgid ""
"5953    The reason it must be released is typically that it can be in short "
"supply, so even delayed release may do harm."
msgstr ""

msgid ""
"5954    The fundamental aim is to ensure that we don't leak any resources "
"and that we don't hold a resource longer than we need to."
msgstr ""

msgid ""
"5955    An entity that is responsible for releasing a resource is called an "
"owner."
msgstr ""

msgid ""
"5956    There are a few cases where leaks can be acceptable or even optimal:"
msgstr ""

msgid ""
"5957    If you are writing a program that simply produces an output based on "
"an input and the amount of memory needed is proportional to the size of the "
"input, the optimal strategy (for performance and ease of programming) is "
"sometimes simply never to delete anything."
msgstr ""

msgid ""
"5958    If you have enough memory to handle your largest input, leak away, "
"but be sure to give a good error message if you are wrong."
msgstr ""

msgid "5959    Here, we ignore such cases."
msgstr ""

msgid "5960    * Resource management rule summary:"
msgstr ""

msgid ""
"5961      * [R.1: Manage resources automatically using resource handles and "
"RAII (Resource Acquisition Is Initialization)](#Rr-raii)"
msgstr ""

msgid ""
"5962      * [R.2: In interfaces, use raw pointers to denote individual "
"objects (only)](#Rr-use-ptr)"
msgstr ""

msgid "5963      * [R.3: A raw pointer (a `T*`) is non-owning](#Rr-ptr)"
msgstr ""

msgid "5964      * [R.4: A raw reference (a `T&`) is non-owning](#Rr-ref)"
msgstr ""

msgid ""
"5965      * [R.5: Prefer scoped objects, don't heap-allocate "
"unnecessarily](#Rr-scoped)"
msgstr ""

msgid "5966      * [R.6: Avoid non-`const` global variables](#Rr-global)"
msgstr ""

msgid "5967    * Allocation and deallocation rule summary:"
msgstr ""

msgid "5968      * [R.10: Avoid `malloc()` and `free()`](#Rr-mallocfree)"
msgstr ""

msgid ""
"5969      * [R.11: Avoid calling `new` and `delete` explicitly](#Rr-"
"newdelete)"
msgstr ""

msgid ""
"5970      * [R.12: Immediately give the result of an explicit resource "
"allocation to a manager object](#Rr-immediate-alloc)"
msgstr ""

msgid ""
"5971      * [R.13: Perform at most one explicit resource allocation in a "
"single expression statement](#Rr-single-alloc)"
msgstr ""

msgid "5972      * [R.14: ??? array vs. pointer parameter](#Rr-ap)"
msgstr ""

msgid ""
"5973      * [R.15: Always overload matched allocation/deallocation "
"pairs](#Rr-pair)"
msgstr ""

msgid ""
"5974    * <a name=\"Rr-summary-smartptrs\"></a>Smart pointer rule summary:"
msgstr ""

msgid ""
"5975      * [R.20: Use `unique_ptr` or `shared_ptr` to represent "
"ownership](#Rr-owner)"
msgstr ""

msgid ""
"5976      * [R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to "
"share ownership](#Rr-unique)"
msgstr ""

msgid ""
"5977      * [R.22: Use `make_shared()` to make `shared_ptr`s](#Rr-"
"make_shared)"
msgstr ""

msgid ""
"5978      * [R.23: Use `make_unique()` to make `unique_ptr`s](#Rr-"
"make_unique)"
msgstr ""

msgid ""
"5979      * [R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s](#Rr-"
"weak_ptr)"
msgstr ""

msgid ""
"5980      * [R.30: Take smart pointers as parameters only to explicitly "
"express lifetime semantics](#Rr-smartptrparam)"
msgstr ""

msgid ""
"5981      * [R.31: If you have non-`std` smart pointers, follow the basic "
"pattern from `std`](#Rr-smart)"
msgstr ""

msgid ""
"5982      * [R.32: Take a `unique_ptr<widget>` parameter to express that a "
"function assumes ownership of a `widget`](#Rr-uniqueptrparam)"
msgstr ""

msgid ""
"5983      * [R.33: Take a `unique_ptr<widget>&` parameter to express that a "
"function reseats the `widget`](#Rr-reseat)"
msgstr ""

msgid ""
"5984      * [R.34: Take a `shared_ptr<widget>` parameter to express that a "
"function is part owner](#Rr-sharedptrparam-owner)"
msgstr ""

msgid ""
"5985      * [R.35: Take a `shared_ptr<widget>&` parameter to express that a "
"function might reseat the shared pointer](#Rr-sharedptrparam)"
msgstr ""

msgid ""
"5986      * [R.36: Take a `const shared_ptr<widget>&` parameter to express "
"that it might retain a reference count to the object ???](#Rr-sharedptrparam-"
"const)"
msgstr ""

msgid ""
"5987      * [R.37: Do not pass a pointer or reference obtained from an "
"aliased smart pointer](#Rr-smartptrget)"
msgstr ""

msgid ""
"5988    ### <a name=\"Rr-raii\"></a>R.1: Manage resources automatically "
"using resource handles and RAII (Resource Acquisition Is Initialization)"
msgstr ""

msgid "5989    ##### Reason"
msgstr ""

msgid ""
"5990    To avoid leaks and the complexity of manual resource management."
msgstr ""

msgid ""
"5991    C++'s language-enforced constructor/destructor symmetry mirrors the "
"symmetry inherent in resource acquire/release function pairs such as `fopen`/"
"`fclose`, `lock`/`unlock`, and `new`/`delete`."
msgstr ""

msgid ""
"5992    Whenever you deal with a resource that needs paired acquire/release "
"function calls, encapsulate that resource in an object that enforces pairing "
"for you -- acquire the resource in its constructor, and release it in its "
"destructor."
msgstr ""

msgid "5993    ##### Example, bad"
msgstr ""

msgid "5994    Consider:"
msgstr ""

msgid "5995        void send(X* x, cstring_span destination)"
msgstr ""

msgid "5996        {"
msgstr ""

msgid "5997            auto port = open_port(destination);"
msgstr ""

msgid "5998            my_mutex.lock();"
msgstr ""

msgid "5999            // ..."
msgstr ""

msgid "6000            send(port, x);"
msgstr ""

msgid "6001            // ..."
msgstr ""

msgid "6002            my_mutex.unlock();"
msgstr ""

msgid "6003            close_port(port);"
msgstr ""

msgid "6004            delete x;"
msgstr ""

msgid "6005        }"
msgstr ""

msgid ""
"6006    In this code, you have to remember to `unlock`, `close_port`, and "
"`delete` on all paths, and do each exactly once."
msgstr ""

msgid ""
"6007    Further, if any of the code marked `...` throws an exception, then "
"`x` is leaked and `my_mutex` remains locked."
msgstr ""

msgid "6008    ##### Example"
msgstr ""

msgid "6009    Consider:"
msgstr ""

msgid ""
"6010        void send(unique_ptr<X> x, cstring_span destination)  // x owns "
"the X"
msgstr ""

msgid "6011        {"
msgstr ""

msgid ""
"6012            Port port{destination};            // port owns the "
"PortHandle"
msgstr ""

msgid ""
"6013            lock_guard<mutex> guard{my_mutex}; // guard owns the lock"
msgstr ""

msgid "6014            // ..."
msgstr ""

msgid "6015            send(port, x);"
msgstr ""

msgid "6016            // ..."
msgstr ""

msgid ""
"6017        } // automatically unlocks my_mutex and deletes the pointer in x"
msgstr ""

msgid ""
"6018    Now all resource cleanup is automatic, performed once on all paths "
"whether or not there is an exception. As a bonus, the function now "
"advertises that it takes over ownership of the pointer."
msgstr ""

msgid ""
"6019    What is `Port`? A handy wrapper that encapsulates the resource:"
msgstr ""

msgid "6020        class Port {"
msgstr ""

msgid "6021            PortHandle port;"
msgstr ""

msgid "6022        public:"
msgstr ""

msgid ""
"6023            Port(cstring_span destination) : "
"port{open_port(destination)} { }"
msgstr ""

msgid "6024            ~Port() { close_port(port); }"
msgstr ""

msgid "6025            operator PortHandle() { return port; }"
msgstr ""

msgid ""
"6026            // port handles can't usually be cloned, so disable copying "
"and assignment if necessary"
msgstr ""

msgid "6027            Port(const Port&) = delete;"
msgstr ""

msgid "6028            Port& operator=(const Port&) = delete;"
msgstr ""

msgid "6029        };"
msgstr ""

msgid "6030    ##### Note"
msgstr ""

msgid ""
"6031    Where a resource is \"ill-behaved\" in that it isn't represented as "
"a class with a destructor, wrap it in a class or use [`finally`](#Re-"
"finally)"
msgstr ""

msgid "6032    **See also**: [RAII](#Rr-raii)"
msgstr ""

msgid ""
"6033    ### <a name=\"Rr-use-ptr\"></a>R.2: In interfaces, use raw pointers "
"to denote individual objects (only)"
msgstr ""

msgid "6034    ##### Reason"
msgstr ""

msgid ""
"6035    Arrays are best represented by a container type (e.g., `vector` "
"(owning)) or a `span` (non-owning)."
msgstr ""

msgid ""
"6036    Such containers and views hold sufficient information to do range "
"checking."
msgstr ""

msgid "6037    ##### Example, bad"
msgstr ""

msgid ""
"6038        void f(int* p, int n)   // n is the number of elements in p[]"
msgstr ""

msgid "6039        {"
msgstr ""

msgid "6040            // ..."
msgstr ""

msgid "6041            p[2] = 7;   // bad: subscript raw pointer"
msgstr ""

msgid "6042            // ..."
msgstr ""

msgid "6043        }"
msgstr ""

msgid ""
"6044    The compiler does not read comments, and without reading other code "
"you do not know whether `p` really points to `n` elements."
msgstr ""

msgid "6045    Use a `span` instead."
msgstr ""

msgid "6046    ##### Example"
msgstr ""

msgid "6047        void g(int* p, int fmt)   // print *p using format #fmt"
msgstr ""

msgid "6048        {"
msgstr ""

msgid "6049            // ... uses *p and p[0] only ..."
msgstr ""

msgid "6050        }"
msgstr ""

msgid "6051    ##### Exception"
msgstr ""

msgid ""
"6052    C-style strings are passed as single pointers to a zero-terminated "
"sequence of characters."
msgstr ""

msgid ""
"6053    Use `zstring` rather than `char*` to indicate that you rely on that "
"convention."
msgstr ""

msgid "6054    ##### Note"
msgstr ""

msgid ""
"6055    Many current uses of pointers to a single element could be "
"references."
msgstr ""

msgid ""
"6056    However, where `nullptr` is a possible value, a reference may not be "
"a reasonable alternative."
msgstr ""

msgid "6057    ##### Enforcement"
msgstr ""

msgid ""
"6058    * Flag pointer arithmetic (including `++`) on a pointer that is not "
"part of a container, view, or iterator."
msgstr ""

msgid ""
"6059      This rule would generate a huge number of false positives if "
"applied to an older code base."
msgstr ""

msgid "6060    * Flag array names passed as simple pointers"
msgstr ""

msgid ""
"6061    ### <a name=\"Rr-ptr\"></a>R.3: A raw pointer (a `T*`) is non-owning"
msgstr ""

msgid "6062    ##### Reason"
msgstr ""

msgid ""
"6063    There is nothing (in the C++ standard or in most code) to say "
"otherwise and most raw pointers are non-owning."
msgstr ""

msgid ""
"6064    We want owning pointers identified so that we can reliably and "
"efficiently delete the objects pointed to by owning pointers."
msgstr ""

msgid "6065    ##### Example"
msgstr ""

msgid "6066        void f()"
msgstr ""

msgid "6067        {"
msgstr ""

msgid ""
"6068            int* p1 = new int{7};           // bad: raw owning pointer"
msgstr ""

msgid ""
"6069            auto p2 = make_unique<int>(7);  // OK: the int is owned by a "
"unique pointer"
msgstr ""

msgid "6070            // ..."
msgstr ""

msgid "6071        }"
msgstr ""

msgid ""
"6072    The `unique_ptr` protects against leaks by guaranteeing the deletion "
"of its object (even in the presence of exceptions). The `T*` does not."
msgstr ""

msgid "6073    ##### Example"
msgstr ""

msgid "6074        template<typename T>"
msgstr ""

msgid "6075        class X {"
msgstr ""

msgid "6076            // ..."
msgstr ""

msgid "6077        public:"
msgstr ""

msgid ""
"6078            T* p;   // bad: it is unclear whether p is owning or not"
msgstr ""

msgid ""
"6079            T* q;   // bad: it is unclear whether q is owning or not"
msgstr ""

msgid "6080        };"
msgstr ""

msgid "6081    We can fix that problem by making ownership explicit:"
msgstr ""

msgid "6082        template<typename T>"
msgstr ""

msgid "6083        class X2 {"
msgstr ""

msgid "6084            // ..."
msgstr ""

msgid "6085        public:"
msgstr ""

msgid "6086            owner<T*> p;  // OK: p is owning"
msgstr ""

msgid "6087            T* q;         // OK: q is not owning"
msgstr ""

msgid "6088        };"
msgstr ""

msgid "6089    ##### Exception"
msgstr ""

msgid ""
"6090    A major class of exception is legacy code, especially code that must "
"remain compilable as C or interface with C and C-style C++ through ABIs."
msgstr ""

msgid ""
"6091    The fact that there are billions of lines of code that violate this "
"rule against owning `T*`s cannot be ignored."
msgstr ""

msgid ""
"6092    We'd love to see program transformation tools turning 20-year-old "
"\"legacy\" code into shiny modern code,"
msgstr ""

msgid ""
"6093    we encourage the development, deployment and use of such tools,"
msgstr ""

msgid ""
"6094    we hope the guidelines will help the development of such tools,"
msgstr ""

msgid ""
"6095    and we even contributed (and contribute) to the research and "
"development in this area."
msgstr ""

msgid ""
"6096    However, it will take time: \"legacy code\" is generated faster than "
"we can renovate old code, and so it will be for a few years."
msgstr ""

msgid ""
"6097    This code cannot all be rewritten (ever assuming good code "
"transformation software), especially not soon."
msgstr ""

msgid ""
"6098    This problem cannot be solved (at scale) by transforming all owning "
"pointers to `unique_ptr`s and `shared_ptr`s,"
msgstr ""

msgid ""
"6099    partly because we need/use owning \"raw pointers\" as well as simple "
"pointers in the implementation of our fundamental resource handles."
msgstr ""

msgid ""
"6100    For example, common `vector` implementations have one owning pointer "
"and two non-owning pointers."
msgstr ""

msgid ""
"6101    Many ABIs (and essentially all interfaces to C code) use `T*`s, some "
"of them owning."
msgstr ""

msgid ""
"6102    Some interfaces cannot be simply annotated with `owner` because they "
"need to remain compilable as C"
msgstr ""

msgid ""
"6103    (although this would be a rare good use for a macro, that expands to "
"`owner` in C++ mode only)."
msgstr ""

msgid "6104    ##### Note"
msgstr ""

msgid ""
"6105    `owner<T*>` has no default semantics beyond `T*`. It can be used "
"without changing any code using it and without affecting ABIs."
msgstr ""

msgid "6106    It is simply a indicator to programmers and analysis tools."
msgstr ""

msgid ""
"6107    For example, if an `owner<T*>` is a member of a class, that class "
"better have a destructor that `delete`s it."
msgstr ""

msgid "6108    ##### Example, bad"
msgstr ""

msgid ""
"6109    Returning a (raw) pointer imposes a lifetime management uncertainty "
"on the caller; that is, who deletes the pointed-to object?"
msgstr ""

msgid "6110        Gadget* make_gadget(int n)"
msgstr ""

msgid "6111        {"
msgstr ""

msgid "6112            auto p = new Gadget{n};"
msgstr ""

msgid "6113            // ..."
msgstr ""

msgid "6114            return p;"
msgstr ""

msgid "6115        }"
msgstr ""

msgid "6116        void caller(int n)"
msgstr ""

msgid "6117        {"
msgstr ""

msgid "6118            auto p = make_gadget(n);   // remember to delete p"
msgstr ""

msgid "6119            // ..."
msgstr ""

msgid "6120            delete p;"
msgstr ""

msgid "6121        }"
msgstr ""

msgid ""
"6122    In addition to suffering from the problem from [leak](#???), this "
"adds a spurious allocation and deallocation operation, and is needlessly "
"verbose. If Gadget is cheap to move out of a function (i.e., is small or has "
"an efficient move operation), just return it \"by value\" (see [\"out\" "
"return values](#Rf-out)):"
msgstr ""

msgid "6123        Gadget make_gadget(int n)"
msgstr ""

msgid "6124        {"
msgstr ""

msgid "6125            Gadget g{n};"
msgstr ""

msgid "6126            // ..."
msgstr ""

msgid "6127            return g;"
msgstr ""

msgid "6128        }"
msgstr ""

msgid "6129    ##### Note"
msgstr ""

msgid "6130    This rule applies to factory functions."
msgstr ""

msgid "6131    ##### Note"
msgstr ""

msgid ""
"6132    If pointer semantics are required (e.g., because the return type "
"needs to refer to a base class of a class hierarchy (an interface)), return "
"a \"smart pointer.\""
msgstr ""

msgid "6133    ##### Enforcement"
msgstr ""

msgid ""
"6134    * (Simple) Warn on `delete` of a raw pointer that is not an "
"`owner<T>`."
msgstr ""

msgid ""
"6135    * (Moderate) Warn on failure to either `reset` or explicitly "
"`delete` an `owner<T>` pointer on every code path."
msgstr ""

msgid ""
"6136    * (Simple) Warn if the return value of `new` is assigned to a raw "
"pointer."
msgstr ""

msgid ""
"6137    * (Simple) Warn if a function returns an object that was allocated "
"within the function but has a move constructor."
msgstr ""

msgid "6138      Suggest considering returning it by value instead."
msgstr ""

msgid ""
"6139    ### <a name=\"Rr-ref\"></a>R.4: A raw reference (a `T&`) is non-"
"owning"
msgstr ""

msgid "6140    ##### Reason"
msgstr ""

msgid ""
"6141    There is nothing (in the C++ standard or in most code) to say "
"otherwise and most raw references are non-owning."
msgstr ""

msgid ""
"6142    We want owners identified so that we can reliably and efficiently "
"delete the objects pointed to by owning pointers."
msgstr ""

msgid "6143    ##### Example"
msgstr ""

msgid "6144        void f()"
msgstr ""

msgid "6145        {"
msgstr ""

msgid "6146            int& r = *new int{7};  // bad: raw owning reference"
msgstr ""

msgid "6147            // ..."
msgstr ""

msgid ""
"6148            delete &r;             // bad: violated the rule against "
"deleting raw pointers"
msgstr ""

msgid "6149        }"
msgstr ""

msgid "6150    **See also**: [The raw pointer rule](#Rr-ptr)"
msgstr ""

msgid "6151    ##### Enforcement"
msgstr ""

msgid "6152    See [the raw pointer rule](#Rr-ptr)"
msgstr ""

msgid ""
"6153    ### <a name=\"Rr-scoped\"></a>R.5: Prefer scoped objects, don't heap-"
"allocate unnecessarily"
msgstr ""

msgid "6154    ##### Reason"
msgstr ""

msgid ""
"6155    A scoped object is a local object, a global object, or a member."
msgstr ""

msgid ""
"6156    This implies that there is no separate allocation and deallocation "
"cost in excess of that already used for the containing scope or object."
msgstr ""

msgid ""
"6157    The members of a scoped object are themselves scoped and the scoped "
"object's constructor and destructor manage the members' lifetimes."
msgstr ""

msgid "6158    ##### Example"
msgstr ""

msgid ""
"6159    The following example is inefficient (because it has unnecessary "
"allocation and deallocation), vulnerable to exception throws and returns in "
"the `...` part (leading to leaks), and verbose:"
msgstr ""

msgid "6160        void f(int n)"
msgstr ""

msgid "6161        {"
msgstr ""

msgid "6162            auto p = new Gadget{n};"
msgstr ""

msgid "6163            // ..."
msgstr ""

msgid "6164            delete p;"
msgstr ""

msgid "6165        }"
msgstr ""

msgid "6166    Instead, use a local variable:"
msgstr ""

msgid "6167        void f(int n)"
msgstr ""

msgid "6168        {"
msgstr ""

msgid "6169            Gadget g{n};"
msgstr ""

msgid "6170            // ..."
msgstr ""

msgid "6171        }"
msgstr ""

msgid "6172    ##### Enforcement"
msgstr ""

msgid ""
"6173    * (Moderate) Warn if an object is allocated and then deallocated on "
"all paths within a function. Suggest it should be a local `auto` stack "
"object instead."
msgstr ""

msgid ""
"6174    * (Simple) Warn if a local `Unique_ptr` or `Shared_ptr` is not "
"moved, copied, reassigned or `reset` before its lifetime ends."
msgstr ""

msgid ""
"6175    ### <a name=\"Rr-global\"></a>R.6: Avoid non-`const` global "
"variables"
msgstr ""

msgid "6176    ##### Reason"
msgstr ""

msgid ""
"6177    Global variables can be accessed from everywhere so they can "
"introduce surprising dependencies between apparently unrelated objects."
msgstr ""

msgid "6178    They are a notable source of errors."
msgstr ""

msgid ""
"6179    **Warning**: The initialization of global objects is not totally "
"ordered."
msgstr ""

msgid "6180    If you use a global object initialize it with a constant."
msgstr ""

msgid ""
"6181    Note that it is possible to get undefined initialization order even "
"for `const` objects."
msgstr ""

msgid "6182    ##### Exception"
msgstr ""

msgid "6183    A global object is often better than a singleton."
msgstr ""

msgid "6184    ##### Exception"
msgstr ""

msgid ""
"6185    An immutable (`const`) global does not introduce the problems we try "
"to avoid by banning global objects."
msgstr ""

msgid "6186    ##### Enforcement"
msgstr ""

msgid ""
"6187    (??? NM: Obviously we can warn about non-`const` statics ... do we "
"want to?)"
msgstr ""

msgid "6188    ## <a name=\"SS-alloc\"></a>R.alloc: Allocation and deallocation"
msgstr ""

msgid ""
"6189    ### <a name=\"Rr-mallocfree\"></a>R.10: Avoid `malloc()` and "
"`free()`"
msgstr ""

msgid "6190    ##### Reason"
msgstr ""

msgid ""
"6191     `malloc()` and `free()` do not support construction and "
"destruction, and do not mix well with `new` and `delete`."
msgstr ""

msgid "6192    ##### Example"
msgstr ""

msgid "6193        class Record {"
msgstr ""

msgid "6194            int id;"
msgstr ""

msgid "6195            string name;"
msgstr ""

msgid "6196            // ..."
msgstr ""

msgid "6197        };"
msgstr ""

msgid "6198        void use()"
msgstr ""

msgid "6199        {"
msgstr ""

msgid "6200            // p1 may be nullptr"
msgstr ""

msgid "6201            // *p1 is not initialized; in particular,"
msgstr ""

msgid ""
"6202            // that string isn't a string, but a string-sized bag of "
"bits"
msgstr ""

msgid ""
"6203            Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));"
msgstr ""

msgid "6204            auto p2 = new Record;"
msgstr ""

msgid ""
"6205            // unless an exception is thrown, *p2 is default initialized"
msgstr ""

msgid "6206            auto p3 = new(nothrow) Record;"
msgstr ""

msgid ""
"6207            // p3 may be nullptr; if not, *p3 is default initialized"
msgstr ""

msgid "6208            // ..."
msgstr ""

msgid ""
"6209            delete p1;    // error: cannot delete object allocated by "
"malloc()"
msgstr ""

msgid ""
"6210            free(p2);    // error: cannot free() object allocated by new"
msgstr ""

msgid "6211        }"
msgstr ""

msgid ""
"6212    In some implementations that `delete` and that `free()` might work, "
"or maybe they will cause run-time errors."
msgstr ""

msgid "6213    ##### Exception"
msgstr ""

msgid ""
"6214    There are applications and sections of code where exceptions are not "
"acceptable."
msgstr ""

msgid ""
"6215    Some of the best such examples are in life-critical hard-real-time "
"code."
msgstr ""

msgid ""
"6216    Beware that many bans on exception use are based on superstition "
"(bad)"
msgstr ""

msgid ""
"6217    or by concerns for older code bases with unsystematic resource "
"management (unfortunately, but sometimes necessary)."
msgstr ""

msgid "6218    In such cases, consider the `nothrow` versions of `new`."
msgstr ""

msgid "6219    ##### Enforcement"
msgstr ""

msgid "6220    Flag explicit use of `malloc` and `free`."
msgstr ""

msgid ""
"6221    ### <a name=\"Rr-newdelete\"></a>R.11: Avoid calling `new` and "
"`delete` explicitly"
msgstr ""

msgid "6222    ##### Reason"
msgstr ""

msgid ""
"6223    The pointer returned by `new` should belong to a resource handle "
"(that can call `delete`)."
msgstr ""

msgid ""
"6224    If the pointer returned by `new` is assigned to a plain/naked "
"pointer, the object can be leaked."
msgstr ""

msgid "6225    ##### Note"
msgstr ""

msgid ""
"6226    In a large program, a naked `delete` (that is a `delete` in "
"application code, rather than part of code devoted to resource management)"
msgstr ""

msgid ""
"6227    is a likely bug: if you have N `delete`s, how can you be certain "
"that you don't need N+1 or N-1?"
msgstr ""

msgid "6228    The bug may be latent: it may emerge only during maintenance."
msgstr ""

msgid ""
"6229    If you have a naked `new`, you probably need a naked `delete` "
"somewhere, so you probably have a bug."
msgstr ""

msgid "6230    ##### Enforcement"
msgstr ""

msgid ""
"6231    (Simple) Warn on any explicit use of `new` and `delete`. Suggest "
"using `make_unique` instead."
msgstr ""

msgid ""
"6232    ### <a name=\"Rr-immediate-alloc\"></a>R.12: Immediately give the "
"result of an explicit resource allocation to a manager object"
msgstr ""

msgid "6233    ##### Reason"
msgstr ""

msgid "6234    If you don't, an exception or a return may lead to a leak."
msgstr ""

msgid "6235    ##### Example, bad"
msgstr ""

msgid "6236        void f(const string& name)"
msgstr ""

msgid "6237        {"
msgstr ""

msgid ""
"6238            FILE* f = fopen(name, \"r\");            // open the file"
msgstr ""

msgid "6239            vector<char> buf(1024);"
msgstr ""

msgid ""
"6240            auto _ = finally([f] { fclose(f); });  // remember to close "
"the file"
msgstr ""

msgid "6241            // ..."
msgstr ""

msgid "6242        }"
msgstr ""

msgid "6243    The allocation of `buf` may fail and leak the file handle."
msgstr ""

msgid "6244    ##### Example"
msgstr ""

msgid "6245        void f(const string& name)"
msgstr ""

msgid "6246        {"
msgstr ""

msgid "6247            ifstream f{name};   // open the file"
msgstr ""

msgid "6248            vector<char> buf(1024);"
msgstr ""

msgid "6249            // ..."
msgstr ""

msgid "6250        }"
msgstr ""

msgid ""
"6251    The use of the file handle (in `ifstream`) is simple, efficient, and "
"safe."
msgstr ""

msgid "6252    ##### Enforcement"
msgstr ""

msgid ""
"6253    * Flag explicit allocations used to initialize pointers (problem: "
"how many direct resource allocations can we recognize?)"
msgstr ""

msgid ""
"6254    ### <a name=\"Rr-single-alloc\"></a>R.13: Perform at most one "
"explicit resource allocation in a single expression statement"
msgstr ""

msgid "6255    ##### Reason"
msgstr ""

msgid ""
"6256    If you perform two explicit resource allocations in one statement, "
"you could leak resources because the order of evaluation of many "
"subexpressions, including function arguments, is unspecified."
msgstr ""

msgid "6257    ##### Example"
msgstr ""

msgid "6258        void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);"
msgstr ""

msgid "6259    This `fun` can be called like this:"
msgstr ""

msgid "6260        // BAD: potential leak"
msgstr ""

msgid ""
"6261        fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new "
"Widget(c, d)));"
msgstr ""

msgid ""
"6262    This is exception-unsafe because the compiler may reorder the two "
"expressions building the function's two arguments."
msgstr ""

msgid ""
"6263    In particular, the compiler can interleave execution of the two "
"expressions:"
msgstr ""

msgid ""
"6264    Memory allocation (by calling `operator new`) could be done first "
"for both objects, followed by attempts to call the two `Widget` constructors."
""
msgstr ""

msgid ""
"6265    If one of the constructor calls throws an exception, then the other "
"object's memory will never be released!"
msgstr ""

msgid ""
"6266    This subtle problem has a simple solution: Never perform more than "
"one explicit resource allocation in a single expression statement."
msgstr ""

msgid "6267    For example:"
msgstr ""

msgid ""
"6268        shared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy"
msgstr ""

msgid "6269        fun(sp1, new Widget(c, d));"
msgstr ""

msgid ""
"6270    The best solution is to avoid explicit allocation entirely use "
"factory functions that return owning objects:"
msgstr ""

msgid ""
"6271        fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // "
"Best"
msgstr ""

msgid "6272    Write your own factory wrapper if there is not one already."
msgstr ""

msgid "6273    ##### Enforcement"
msgstr ""

msgid ""
"6274    * Flag expressions with multiple explicit resource allocations "
"(problem: how many direct resource allocations can we recognize?)"
msgstr ""

msgid "6275    ### <a name=\"Rr-ap\"></a>R.14: ??? array vs. pointer parameter"
msgstr ""

msgid "6276    ##### Reason"
msgstr ""

msgid ""
"6277    An array decays to a pointer, thereby losing its size, opening the "
"opportunity for range errors."
msgstr ""

msgid "6278    ##### Example"
msgstr ""

msgid "6279        ??? what do we recommend: f(int*[]) or f(int**) ???"
msgstr ""

msgid "6280    **Alternative**: Use `span` to preserve size information."
msgstr ""

msgid "6281    ##### Enforcement"
msgstr ""

msgid "6282    Flag `[]` parameters."
msgstr ""

msgid ""
"6283    ### <a name=\"Rr-pair\"></a>R.15: Always overload matched allocation/"
"deallocation pairs"
msgstr ""

msgid "6284    ##### Reason"
msgstr ""

msgid "6285    Otherwise you get mismatched operations and chaos."
msgstr ""

msgid "6286    ##### Example"
msgstr ""

msgid "6287        class X {"
msgstr ""

msgid "6288            // ..."
msgstr ""

msgid "6289            void* operator new(size_t s);"
msgstr ""

msgid "6290            void operator delete(void*);"
msgstr ""

msgid "6291            // ..."
msgstr ""

msgid "6292        };"
msgstr ""

msgid "6293    ##### Note"
msgstr ""

msgid ""
"6294    If you want memory that cannot be deallocated, `=delete` the "
"deallocation operation."
msgstr ""

msgid "6295    Don't leave it undeclared."
msgstr ""

msgid "6296    ##### Enforcement"
msgstr ""

msgid "6297    Flag incomplete pairs."
msgstr ""

msgid "6298    ## <a name=\"SS-smart\"></a>R.smart: Smart pointers"
msgstr ""

msgid ""
"6299    ### <a name=\"Rr-owner\"></a>R.20: Use `unique_ptr` or `shared_ptr` "
"to represent ownership"
msgstr ""

msgid "6300    ##### Reason"
msgstr ""

msgid "6301    They can prevent resource leaks."
msgstr ""

msgid "6302    ##### Example"
msgstr ""

msgid "6303    Consider:"
msgstr ""

msgid "6304        void f()"
msgstr ""

msgid "6305        {"
msgstr ""

msgid "6306            X x;"
msgstr ""

msgid "6307            X* p1 { new X };              // see also ???"
msgstr ""

msgid ""
"6308            unique_ptr<T> p2 { new X };   // unique ownership; see also "
"???"
msgstr ""

msgid ""
"6309            shared_ptr<T> p3 { new X };   // shared ownership; see also "
"???"
msgstr ""

msgid ""
"6310            auto p4 = make_unique<X>();   // unique_ownership, "
"preferable to the explicit use \"new\""
msgstr ""

msgid ""
"6311            auto p5 = make_shared<X>();   // shared ownership, "
"preferable to the explicit use \"new\""
msgstr ""

msgid "6312        }"
msgstr ""

msgid "6313    This will leak the object used to initialize `p1` (only)."
msgstr ""

msgid "6314    ##### Enforcement"
msgstr ""

msgid ""
"6315    (Simple) Warn if the return value of `new` or a function call with "
"return value of pointer type is assigned to a raw pointer."
msgstr ""

msgid ""
"6316    ### <a name=\"Rr-unique\"></a>R.21: Prefer `unique_ptr` over "
"`shared_ptr` unless you need to share ownership"
msgstr ""

msgid "6317    ##### Reason"
msgstr ""

msgid ""
"6318    A `unique_ptr` is conceptually simpler and more predictable (you "
"know when destruction happens) and faster (you don't implicitly maintain a "
"use count)."
msgstr ""

msgid "6319    ##### Example, bad"
msgstr ""

msgid "6320    This needlessly adds and maintains a reference count."
msgstr ""

msgid "6321        void f()"
msgstr ""

msgid "6322        {"
msgstr ""

msgid "6323            shared_ptr<Base> base = make_shared<Derived>();"
msgstr ""

msgid ""
"6324            // use base locally, without copying it -- refcount never "
"exceeds 1"
msgstr ""

msgid "6325        } // destroy base"
msgstr ""

msgid "6326    ##### Example"
msgstr ""

msgid "6327    This is more efficient:"
msgstr ""

msgid "6328        void f()"
msgstr ""

msgid "6329        {"
msgstr ""

msgid "6330            unique_ptr<Base> base = make_unique<Derived>();"
msgstr ""

msgid "6331            // use base locally"
msgstr ""

msgid "6332        } // destroy base"
msgstr ""

msgid "6333    ##### Enforcement"
msgstr ""

msgid ""
"6334    (Simple) Warn if a function uses a `Shared_ptr` with an object "
"allocated within the function, but never returns the `Shared_ptr` or passes "
"it to a function requiring a `Shared_ptr&`. Suggest using `unique_ptr` "
"instead."
msgstr ""

msgid ""
"6335    ### <a name=\"Rr-make_shared\"></a>R.22: Use `make_shared()` to make "
"`shared_ptr`s"
msgstr ""

msgid "6336    ##### Reason"
msgstr ""

msgid ""
"6337    If you first make an object and then give it to a `shared_ptr` "
"constructor, you (most likely) do one more allocation (and later "
"deallocation) than if you use `make_shared()` because the reference counts "
"must be allocated separately from the object."
msgstr ""

msgid "6338    ##### Example"
msgstr ""

msgid "6339    Consider:"
msgstr ""

msgid "6340        shared_ptr<X> p1 { new X{2} }; // bad"
msgstr ""

msgid "6341        auto p = make_shared<X>(2);    // good"
msgstr ""

msgid ""
"6342    The `make_shared()` version mentions `X` only once, so it is usually "
"shorter (as well as faster) than the version with the explicit `new`."
msgstr ""

msgid "6343    ##### Enforcement"
msgstr ""

msgid ""
"6344    (Simple) Warn if a `shared_ptr` is constructed from the result of "
"`new` rather than `make_shared`."
msgstr ""

msgid ""
"6345    ### <a name=\"Rr-make_unique\"></a>R.23: Use `make_unique()` to make "
"`unique_ptr`s"
msgstr ""

msgid "6346    ##### Reason"
msgstr ""

msgid "6347    For convenience and consistency with `shared_ptr`."
msgstr ""

msgid "6348    ##### Note"
msgstr ""

msgid ""
"6349    `make_unique()` is C++14, but widely available (as well as simple to "
"write)."
msgstr ""

msgid "6350    ##### Enforcement"
msgstr ""

msgid ""
"6351    (Simple) Warn if a `unique_ptr` is constructed from the result of "
"`new` rather than `make_unique`."
msgstr ""

msgid ""
"6352    ### <a name=\"Rr-weak_ptr\"></a>R.24: Use `std::weak_ptr` to break "
"cycles of `shared_ptr`s"
msgstr ""

msgid "6353    ##### Reason"
msgstr ""

msgid ""
"6354     `shared_ptr`'s rely on use counting and the use count for a cyclic "
"structure never goes to zero, so we need a mechanism to"
msgstr ""

msgid "6355    be able to destroy a cyclic structure."
msgstr ""

msgid "6356    ##### Example"
msgstr ""

msgid "6357        #include <memory>"
msgstr ""

msgid "6358        class bar;"
msgstr ""

msgid "6359        class foo"
msgstr ""

msgid "6360        {"
msgstr ""

msgid "6361        public:"
msgstr ""

msgid ""
"6362          explicit foo(const std::shared_ptr<bar>& forward_reference)"
msgstr ""

msgid "6363            : forward_reference_(forward_reference)"
msgstr ""

msgid "6364          { }"
msgstr ""

msgid "6365        private:"
msgstr ""

msgid "6366          std::shared_ptr<bar> forward_reference_;"
msgstr ""

msgid "6367        };"
msgstr ""

msgid "6368        class bar"
msgstr ""

msgid "6369        {"
msgstr ""

msgid "6370        public:"
msgstr ""

msgid "6371          explicit bar(const std::weak_ptr<foo>& back_reference)"
msgstr ""

msgid "6372            : back_reference_(back_reference)"
msgstr ""

msgid "6373          { }"
msgstr ""

msgid "6374          void do_something()"
msgstr ""

msgid "6375          {"
msgstr ""

msgid ""
"6376            if (auto shared_back_reference = back_reference_.lock()) {"
msgstr ""

msgid "6377              // Use *shared_back_reference"
msgstr ""

msgid "6378            }"
msgstr ""

msgid "6379          }"
msgstr ""

msgid "6380        private:"
msgstr ""

msgid "6381          std::weak_ptr<foo> back_reference_;"
msgstr ""

msgid "6382        };"
msgstr ""

msgid "6383    ##### Note"
msgstr ""

msgid ""
"6384     ??? (HS: A lot of people say \"to break cycles\", while I think "
"\"temporary shared ownership\" is more to the point.)"
msgstr ""

msgid ""
"6385    ???(BS: breaking cycles is what you must do; temporarily sharing "
"ownership is how you do it."
msgstr ""

msgid ""
"6386    You could \"temporarily share ownership\" simply by using another "
"`shared_ptr`.)"
msgstr ""

msgid "6387    ##### Enforcement"
msgstr ""

msgid ""
"6388    ??? probably impossible. If we could statically detect cycles, we "
"wouldn't need `weak_ptr`"
msgstr ""

msgid ""
"6389    ### <a name=\"Rr-smartptrparam\"></a>R.30: Take smart pointers as "
"parameters only to explicitly express lifetime semantics"
msgstr ""

msgid "6390    ##### Reason"
msgstr ""

msgid ""
"6391    Accepting a smart pointer to a `widget` is wrong if the function "
"just needs the `widget` itself."
msgstr ""

msgid ""
"6392    It should be able to accept any `widget` object, not just ones whose "
"lifetimes are managed by a particular kind of smart pointer."
msgstr ""

msgid ""
"6393    A function that does not manipulate lifetime should take raw "
"pointers or references instead."
msgstr ""

msgid "6394    ##### Example, bad"
msgstr ""

msgid "6395        // callee"
msgstr ""

msgid "6396        void f(shared_ptr<widget>& w)"
msgstr ""

msgid "6397        {"
msgstr ""

msgid "6398            // ..."
msgstr ""

msgid ""
"6399            use(*w); // only use of w -- the lifetime is not used at all"
msgstr ""

msgid "6400            // ..."
msgstr ""

msgid "6401        };"
msgstr ""

msgid "6402        // caller"
msgstr ""

msgid "6403        shared_ptr<widget> my_widget = /* ... */;"
msgstr ""

msgid "6404        f(my_widget);"
msgstr ""

msgid "6405        widget stack_widget;"
msgstr ""

msgid "6406        f(stack_widget); // error"
msgstr ""

msgid "6407    ##### Example, good"
msgstr ""

msgid "6408        // callee"
msgstr ""

msgid "6409        void f(widget& w)"
msgstr ""

msgid "6410        {"
msgstr ""

msgid "6411            // ..."
msgstr ""

msgid "6412            use(w);"
msgstr ""

msgid "6413            // ..."
msgstr ""

msgid "6414        };"
msgstr ""

msgid "6415        // caller"
msgstr ""

msgid "6416        shared_ptr<widget> my_widget = /* ... */;"
msgstr ""

msgid "6417        f(*my_widget);"
msgstr ""

msgid "6418        widget stack_widget;"
msgstr ""

msgid "6419        f(stack_widget); // ok -- now this works"
msgstr ""

msgid "6420    ##### Enforcement"
msgstr ""

msgid ""
"6421    * (Simple) Warn if a function takes a parameter of a smart pointer "
"type (that overloads `operator->` or `operator*`) that is copyable but the "
"function only calls any of: `operator*`, `operator->` or `get()`."
msgstr ""

msgid "6422      Suggest using a `T*` or `T&` instead."
msgstr ""

msgid ""
"6423    * Flag a parameter of a smart pointer type (a type that overloads "
"`operator->` or `operator*`) that is copyable/movable but never copied/moved "
"from in the function body, and that is never modified, and that is not "
"passed along to another function that could do so. That means the ownership "
"semantics are not used."
msgstr ""

msgid "6424      Suggest using a `T*` or `T&` instead."
msgstr ""

msgid ""
"6425    ### <a name=\"Rr-smart\"></a>R.31: If you have non-`std` smart "
"pointers, follow the basic pattern from `std`"
msgstr ""

msgid "6426    ##### Reason"
msgstr ""

msgid ""
"6427    The rules in the following section also work for other kinds of "
"third-party and custom smart pointers and are very useful for diagnosing "
"common smart pointer errors that cause performance and correctness problems."
msgstr ""

msgid "6428    You want the rules to work on all the smart pointers you use."
msgstr ""

msgid ""
"6429    Any type (including primary template or specialization) that "
"overloads unary `*` and `->` is considered a smart pointer:"
msgstr ""

msgid ""
"6430    * If it is copyable, it is recognized as a reference-counted "
"`shared_ptr`."
msgstr ""

msgid ""
"6431    * If it is not copyable, it is recognized as a unique `unique_ptr`."
msgstr ""

msgid "6432    ##### Example"
msgstr ""

msgid "6433        // use Boost's intrusive_ptr"
msgstr ""

msgid "6434        #include <boost/intrusive_ptr.hpp>"
msgstr ""

msgid ""
"6435        void f(boost::intrusive_ptr<widget> p)  // error under rule "
"'sharedptrparam'"
msgstr ""

msgid "6436        {"
msgstr ""

msgid "6437            p->foo();"
msgstr ""

msgid "6438        }"
msgstr ""

msgid "6439        // use Microsoft's CComPtr"
msgstr ""

msgid "6440        #include <atlbase.h>"
msgstr ""

msgid ""
"6441        void f(CComPtr<widget> p)               // error under rule "
"'sharedptrparam'"
msgstr ""

msgid "6442        {"
msgstr ""

msgid "6443            p->foo();"
msgstr ""

msgid "6444        }"
msgstr ""

msgid ""
"6445    Both cases are an error under the [`sharedptrparam` guideline](#Rr-"
"smartptrparam):"
msgstr ""

msgid ""
"6446    `p` is a `Shared_ptr`, but nothing about its sharedness is used here "
"and passing it by value is a silent pessimization;"
msgstr ""

msgid ""
"6447    these functions should accept a smart pointer only if they need to "
"participate in the widget's lifetime management. Otherwise they should "
"accept a `widget*`, if it can be `nullptr`. Otherwise, and ideally, the "
"function should accept a `widget&`."
msgstr ""

msgid ""
"6448    These smart pointers match the `Shared_ptr` concept, so these "
"guideline enforcement rules work on them out of the box and expose this "
"common pessimization."
msgstr ""

msgid ""
"6449    ### <a name=\"Rr-uniqueptrparam\"></a>R.32: Take a "
"`unique_ptr<widget>` parameter to express that a function assumes ownership "
"of a `widget`"
msgstr ""

msgid "6450    ##### Reason"
msgstr ""

msgid ""
"6451    Using `unique_ptr` in this way both documents and enforces the "
"function call's ownership transfer."
msgstr ""

msgid "6452    ##### Example"
msgstr ""

msgid ""
"6453        void sink(unique_ptr<widget>); // takes ownership of the widget"
msgstr ""

msgid "6454        void uses(widget*);            // just uses the widget"
msgstr ""

msgid "6455    ##### Example, bad"
msgstr ""

msgid ""
"6456        void thinko(const unique_ptr<widget>&); // usually not what you "
"want"
msgstr ""

msgid "6457    ##### Enforcement"
msgstr ""

msgid ""
"6458    * (Simple) Warn if a function takes a `Unique_ptr<T>` parameter by "
"lvalue reference and does not either assign to it or call `reset()` on it on "
"at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr ""

msgid ""
"6459    * (Simple) ((Foundation)) Warn if a function takes a `Unique_ptr<T>` "
"parameter by reference to `const`. Suggest taking a `const T*` or `const T&` "
"instead."
msgstr ""

msgid ""
"6460    ### <a name=\"Rr-reseat\"></a>R.33: Take a `unique_ptr<widget>&` "
"parameter to express that a function reseats the`widget`"
msgstr ""

msgid "6461    ##### Reason"
msgstr ""

msgid ""
"6462    Using `unique_ptr` in this way both documents and enforces the "
"function call's reseating semantics."
msgstr ""

msgid "6463    ##### Note"
msgstr ""

msgid ""
"6464    \"reseat\" means \"making a pointer or a smart pointer refer to a "
"different object.\""
msgstr ""

msgid "6465    ##### Example"
msgstr ""

msgid ""
"6466        void reseat(unique_ptr<widget>&); // \"will\" or \"might\" "
"reseat pointer"
msgstr ""

msgid "6467    ##### Example, bad"
msgstr ""

msgid ""
"6468        void thinko(const unique_ptr<widget>&); // usually not what you "
"want"
msgstr ""

msgid "6469    ##### Enforcement"
msgstr ""

msgid ""
"6470    * (Simple) Warn if a function takes a `Unique_ptr<T>` parameter by "
"lvalue reference and does not either assign to it or call `reset()` on it on "
"at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr ""

msgid ""
"6471    * (Simple) ((Foundation)) Warn if a function takes a `Unique_ptr<T>` "
"parameter by reference to `const`. Suggest taking a `const T*` or `const T&` "
"instead."
msgstr ""

msgid ""
"6472    ### <a name=\"Rr-sharedptrparam-owner\"></a>R.34: Take a "
"`shared_ptr<widget>` parameter to express that a function is part owner"
msgstr ""

msgid "6473    ##### Reason"
msgstr ""

msgid "6474    This makes the function's ownership sharing explicit."
msgstr ""

msgid "6475    ##### Example, good"
msgstr ""

msgid ""
"6476        void share(shared_ptr<widget>);            // share -- \"will\" "
"retain refcount"
msgstr ""

msgid ""
"6477        void may_share(const shared_ptr<widget>&); // \"might\" retain "
"refcount"
msgstr ""

msgid ""
"6478        void reseat(shared_ptr<widget>&);          // \"might\" reseat "
"ptr"
msgstr ""

msgid "6479    ##### Enforcement"
msgstr ""

msgid ""
"6480    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by "
"lvalue reference and does not either assign to it or call `reset()` on it on "
"at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr ""

msgid ""
"6481    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by value or by reference to `const` and does not copy or move it to another "
"`Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` "
"instead."
msgstr ""

msgid ""
"6482    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by rvalue reference. Suggesting taking it by value instead."
msgstr ""

msgid ""
"6483    ### <a name=\"Rr-sharedptrparam\"></a>R.35: Take a "
"`shared_ptr<widget>&` parameter to express that a function might reseat the "
"shared pointer"
msgstr ""

msgid "6484    ##### Reason"
msgstr ""

msgid "6485    This makes the function's reseating explicit."
msgstr ""

msgid "6486    ##### Note"
msgstr ""

msgid ""
"6487    \"reseat\" means \"making a reference or a smart pointer refer to a "
"different object.\""
msgstr ""

msgid "6488    ##### Example, good"
msgstr ""

msgid ""
"6489        void share(shared_ptr<widget>);            // share -- \"will\" "
"retain refcount"
msgstr ""

msgid ""
"6490        void reseat(shared_ptr<widget>&);          // \"might\" reseat "
"ptr"
msgstr ""

msgid ""
"6491        void may_share(const shared_ptr<widget>&); // \"might\" retain "
"refcount"
msgstr ""

msgid "6492    ##### Enforcement"
msgstr ""

msgid ""
"6493    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by "
"lvalue reference and does not either assign to it or call `reset()` on it on "
"at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr ""

msgid ""
"6494    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by value or by reference to `const` and does not copy or move it to another "
"`Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` "
"instead."
msgstr ""

msgid ""
"6495    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by rvalue reference. Suggesting taking it by value instead."
msgstr ""

msgid ""
"6496    ### <a name=\"Rr-sharedptrparam-const\"></a>R.36: Take a `const "
"shared_ptr<widget>&` parameter to express that it might retain a reference "
"count to the object ???"
msgstr ""

msgid "6497    ##### Reason"
msgstr ""

msgid "6498    This makes the function's ??? explicit."
msgstr ""

msgid "6499    ##### Example, good"
msgstr ""

msgid ""
"6500        void share(shared_ptr<widget>);            // share -- \"will\" "
"retain refcount"
msgstr ""

msgid ""
"6501        void reseat(shared_ptr<widget>&);          // \"might\" reseat "
"ptr"
msgstr ""

msgid ""
"6502        void may_share(const shared_ptr<widget>&); // \"might\" retain "
"refcount"
msgstr ""

msgid "6503    ##### Enforcement"
msgstr ""

msgid ""
"6504    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by "
"lvalue reference and does not either assign to it or call `reset()` on it on "
"at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr ""

msgid ""
"6505    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by value or by reference to `const` and does not copy or move it to another "
"`Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` "
"instead."
msgstr ""

msgid ""
"6506    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` "
"by rvalue reference. Suggesting taking it by value instead."
msgstr ""

msgid ""
"6507    ### <a name=\"Rr-smartptrget\"></a>R.37: Do not pass a pointer or "
"reference obtained from an aliased smart pointer"
msgstr ""

msgid "6508    ##### Reason"
msgstr ""

msgid ""
"6509    Violating this rule is the number one cause of losing reference "
"counts and finding yourself with a dangling pointer."
msgstr ""

msgid ""
"6510    Functions should prefer to pass raw pointers and references down "
"call chains."
msgstr ""

msgid ""
"6511    At the top of the call tree where you obtain the raw pointer or "
"reference from a smart pointer that keeps the object alive."
msgstr ""

msgid ""
"6512    You need to be sure that the smart pointer cannot inadvertently be "
"reset or reassigned from within the call tree below."
msgstr ""

msgid "6513    ##### Note"
msgstr ""

msgid ""
"6514    To do this, sometimes you need to take a local copy of a smart "
"pointer, which firmly keeps the object alive for the duration of the "
"function and the call tree."
msgstr ""

msgid "6515    ##### Example"
msgstr ""

msgid "6516    Consider this code:"
msgstr ""

msgid "6517        // global (static or heap), or aliased local ..."
msgstr ""

msgid "6518        shared_ptr<widget> g_p = ...;"
msgstr ""

msgid "6519        void f(widget& w)"
msgstr ""

msgid "6520        {"
msgstr ""

msgid "6521            g();"
msgstr ""

msgid "6522            use(w);  // A"
msgstr ""

msgid "6523        }"
msgstr ""

msgid "6524        void g()"
msgstr ""

msgid "6525        {"
msgstr ""

msgid ""
"6526            g_p = ...; // oops, if this was the last shared_ptr to that "
"widget, destroys the widget"
msgstr ""

msgid "6527        }"
msgstr ""

msgid "6528    The following should not pass code review:"
msgstr ""

msgid "6529        void my_code()"
msgstr ""

msgid "6530        {"
msgstr ""

msgid ""
"6531            // BAD: passing pointer or reference obtained from a "
"nonlocal smart pointer"
msgstr ""

msgid ""
"6532            //      that could be inadvertently reset somewhere inside f "
"or it callees"
msgstr ""

msgid "6533            f(*g_p);"
msgstr ""

msgid ""
"6534            // BAD: same reason, just passing it as a \"this\" pointer"
msgstr ""

msgid "6535             g_p->func();"
msgstr ""

msgid "6536        }"
msgstr ""

msgid ""
"6537    The fix is simple -- take a local copy of the pointer to \"keep a "
"ref count\" for your call tree:"
msgstr ""

msgid "6538        void my_code()"
msgstr ""

msgid "6539        {"
msgstr ""

msgid ""
"6540            // cheap: 1 increment covers this entire function and all "
"the call trees below us"
msgstr ""

msgid "6541            auto pin = g_p;"
msgstr ""

msgid ""
"6542            // GOOD: passing pointer or reference obtained from a local "
"unaliased smart pointer"
msgstr ""

msgid "6543            f(*pin);"
msgstr ""

msgid "6544            // GOOD: same reason"
msgstr ""

msgid "6545            pin->func();"
msgstr ""

msgid "6546        }"
msgstr ""

msgid "6547    ##### Enforcement"
msgstr ""

msgid ""
"6548    * (Simple) Warn if a pointer or reference obtained from a smart "
"pointer variable (`Unique_ptr` or `Shared_ptr`) that is nonlocal, or that is "
"local but potentially aliased, is used in a function call. If the smart "
"pointer is a `Shared_ptr` then suggest taking a local copy of the smart "
"pointer and obtain a pointer or reference from that instead."
msgstr ""

msgid "6549    # <a name=\"S-expr\"></a>ES: Expressions and statements"
msgstr ""

msgid ""
"6550    Expressions and statements are the lowest and most direct way of "
"expressing actions and computation. Declarations in local scopes are "
"statements."
msgstr ""

msgid ""
"6551    For naming, commenting, and indentation rules, see [NL: Naming and "
"layout](#S-naming)."
msgstr ""

msgid "6552    General rules:"
msgstr ""

msgid ""
"6553    * [ES.1: Prefer the standard library to other libraries and to "
"\"handcrafted code\"](#Res-lib)"
msgstr ""

msgid ""
"6554    * [ES.2: Prefer suitable abstractions to direct use of language "
"features](#Res-abstr)"
msgstr ""

msgid "6555    Declaration rules:"
msgstr ""

msgid "6556    * [ES.5: Keep scopes small](#Res-scope)"
msgstr ""

msgid ""
"6557    * [ES.6: Declare names in for-statement initializers and conditions "
"to limit scope](#Res-cond)"
msgstr ""

msgid ""
"6558    * [ES.7: Keep common and local names short, and keep uncommon and "
"nonlocal names longer](#Res-name-length)"
msgstr ""

msgid "6559    * [ES.8: Avoid similar-looking names](#Res-name-similar)"
msgstr ""

msgid "6560    * [ES.9: Avoid `ALL_CAPS` names](#Res-not-CAPS)"
msgstr ""

msgid ""
"6561    * [ES.10: Declare one name (only) per declaration](#Res-name-one)"
msgstr ""

msgid ""
"6562    * [ES.11: Use `auto` to avoid redundant repetition of type "
"names](#Res-auto)"
msgstr ""

msgid "6563    * [ES.12: Do not reuse names in nested scopes](#Res-reuse)"
msgstr ""

msgid "6564    * [ES.20: Always initialize an object](#Res-always)"
msgstr ""

msgid ""
"6565    * [ES.21: Don't introduce a variable (or constant) before you need "
"to use it](#Res-introduce)"
msgstr ""

msgid ""
"6566    * [ES.22: Don't declare a variable until you have a value to "
"initialize it with](#Res-init)"
msgstr ""

msgid "6567    * [ES.23: Prefer the `{}`-initializer syntax](#Res-list)"
msgstr ""

msgid "6568    * [ES.24: Use a `unique_ptr<T>` to hold pointers](#Res-unique)"
msgstr ""

msgid ""
"6569    * [ES.25: Declare an object `const` or `constexpr` unless you want "
"to modify its value later on](#Res-const)"
msgstr ""

msgid ""
"6570    * [ES.26: Don't use a variable for two unrelated purposes](#Res-"
"recycle)"
msgstr ""

msgid ""
"6571    * [ES.27: Use `std::array` or `stack_array` for arrays on the "
"stack](#Res-stack)"
msgstr ""

msgid ""
"6572    * [ES.28: Use lambdas for complex initialization, especially of "
"`const` variables](#Res-lambda-init)"
msgstr ""

msgid ""
"6573    * [ES.30: Don't use macros for program text manipulation](#Res-"
"macros)"
msgstr ""

msgid ""
"6574    * [ES.31: Don't use macros for constants or \"functions\"](#Res-"
"macros2)"
msgstr ""

msgid "6575    * [ES.32: Use `ALL_CAPS` for all macro names](#Res-ALL_CAPS)"
msgstr ""

msgid ""
"6576    * [ES.33: If you must use macros, give them unique names](#Res-"
"MACROS)"
msgstr ""

msgid ""
"6577    * [ES.34: Don't define a (C-style) variadic function](#Res-ellipses)"
msgstr ""

msgid "6578    Expression rules:"
msgstr ""

msgid "6579    * [ES.40: Avoid complicated expressions](#Res-complicated)"
msgstr ""

msgid ""
"6580    * [ES.41: If in doubt about operator precedence, parenthesize](#Res-"
"parens)"
msgstr ""

msgid ""
"6581    * [ES.42: Keep use of pointers simple and straightforward](#Res-ptr)"
msgstr ""

msgid ""
"6582    * [ES.43: Avoid expressions with undefined order of evaluation](#Res-"
"order)"
msgstr ""

msgid ""
"6583    * [ES.44: Don't depend on order of evaluation of function "
"arguments](#Res-order-fct)"
msgstr ""

msgid ""
"6584    * [ES.45: Avoid \"magic constants\"; use symbolic constants](#Res-"
"magic)"
msgstr ""

msgid "6585    * [ES.46: Avoid narrowing conversions](#Res-narrowing)"
msgstr ""

msgid ""
"6586    * [ES.47: Use `nullptr` rather than `0` or `NULL`](#Res-nullptr)"
msgstr ""

msgid "6587    * [ES.48: Avoid casts](#Res-casts)"
msgstr ""

msgid ""
"6588    * [ES.49: If you must use a cast, use a named cast](#Res-casts-"
"named)"
msgstr ""

msgid "6589    * [ES.50: Don't cast away `const`](#Res-casts-const)"
msgstr ""

msgid ""
"6590    * [ES.55: Avoid the need for range checking](#Res-range-checking)"
msgstr ""

msgid ""
"6591    * [ES.56: Write `std::move()` only when you need to explicitly move "
"an object to another scope](#Res-move)"
msgstr ""

msgid ""
"6592    * [ES.60: Avoid `new` and `delete` outside resource management "
"functions](#Res-new)"
msgstr ""

msgid ""
"6593    * [ES.61: Delete arrays using `delete[]` and non-arrays using "
"`delete`](#Res-del)"
msgstr ""

msgid ""
"6594    * [ES.62: Don't compare pointers into different arrays](#Res-arr2)"
msgstr ""

msgid "6595    * [ES.63: Don't slice](#Res-slice)"
msgstr ""

msgid ""
"6596    * [ES.64: Use the `T{e}`notation for construction](#Res-construct)"
msgstr ""

msgid "6597    * [ES.65: Don't dereference an invalid pointer](#Res-deref)"
msgstr ""

msgid "6598    Statement rules:"
msgstr ""

msgid ""
"6599    * [ES.70: Prefer a `switch`-statement to an `if`-statement when "
"there is a choice](#Res-switch-if)"
msgstr ""

msgid ""
"6600    * [ES.71: Prefer a range-`for`-statement to a `for`-statement when "
"there is a choice](#Res-for-range)"
msgstr ""

msgid ""
"6601    * [ES.72: Prefer a `for`-statement to a `while`-statement when there "
"is an obvious loop variable](#Res-for-while)"
msgstr ""

msgid ""
"6602    * [ES.73: Prefer a `while`-statement to a `for`-statement when there "
"is no obvious loop variable](#Res-while-for)"
msgstr ""

msgid ""
"6603    * [ES.74: Prefer to declare a loop variable in the initializer part "
"of a `for`-statement](#Res-for-init)"
msgstr ""

msgid "6604    * [ES.75: Avoid `do`-statements](#Res-do)"
msgstr ""

msgid "6605    * [ES.76: Avoid `goto`](#Res-goto)"
msgstr ""

msgid ""
"6606    * [ES.77: Minimize the use of `break` and `continue` in loops](#Res-"
"continue)"
msgstr ""

msgid ""
"6607    * [ES.78: Always end a non-empty `case` with a `break`](#Res-break)"
msgstr ""

msgid ""
"6608    * [ES.79: Use `default` to handle common cases (only)](#Res-default)"
msgstr ""

msgid ""
"6609    * [ES.84: Don't (try to) declare a local variable with no name](#Res-"
"noname)"
msgstr ""

msgid "6610    * [ES.85: Make empty statements visible](#Res-empty)"
msgstr ""

msgid ""
"6611    * [ES.86: Avoid modifying loop control variables inside the body of "
"raw for-loops](#Res-loop-counter)"
msgstr ""

msgid ""
"6612    * [ES.87: Don't add redundant `==` or `!=` to conditions](#Res-if)"
msgstr ""

msgid "6613    Arithmetic rules:"
msgstr ""

msgid "6614    * [ES.100: Don't mix signed and unsigned arithmetic](#Res-mix)"
msgstr ""

msgid ""
"6615    * [ES.101: Use unsigned types for bit manipulation](#Res-unsigned)"
msgstr ""

msgid "6616    * [ES.102: Use signed types for arithmetic](#Res-signed)"
msgstr ""

msgid "6617    * [ES.103: Don't overflow](#Res-overflow)"
msgstr ""

msgid "6618    * [ES.104: Don't underflow](#Res-underflow)"
msgstr ""

msgid "6619    * [ES.105: Don't divide by zero](#Res-zero)"
msgstr ""

msgid ""
"6620    * [ES.106: Don't try to avoid negative values by using "
"`unsigned`](#Res-nonnegative)"
msgstr ""

msgid ""
"6621    * [ES.107: Don't use `unsigned` for subscripts, prefer `gsl::"
"index`](#Res-subscripts)"
msgstr ""

msgid ""
"6622    ### <a name=\"Res-lib\"></a>ES.1: Prefer the standard library to "
"other libraries and to \"handcrafted code\""
msgstr ""

msgid "6623    ##### Reason"
msgstr ""

msgid ""
"6624    Code using a library can be much easier to write than code working "
"directly with language features, much shorter, tend to be of a higher level "
"of abstraction, and the library code is presumably already tested."
msgstr ""

msgid ""
"6625    The ISO C++ Standard Library is among the most widely known and best "
"tested libraries."
msgstr ""

msgid "6626    It is available as part of all C++ Implementations."
msgstr ""

msgid "6627    ##### Example"
msgstr ""

msgid "6628        auto sum = accumulate(begin(a), end(a), 0.0);   // good"
msgstr ""

msgid "6629    a range version of `accumulate` would be even better:"
msgstr ""

msgid "6630        auto sum = accumulate(v, 0.0); // better"
msgstr ""

msgid "6631    but don't hand-code a well-known algorithm:"
msgstr ""

msgid "6632        int max = v.size();   // bad: verbose, purpose unstated"
msgstr ""

msgid "6633        double sum = 0.0;"
msgstr ""

msgid "6634        for (int i = 0; i < max; ++i)"
msgstr ""

msgid "6635            sum = sum + v[i];"
msgstr ""

msgid "6636    ##### Exception"
msgstr ""

msgid ""
"6637    Large parts of the standard library rely on dynamic allocation (free "
"store). These parts, notably the containers but not the algorithms, are "
"unsuitable for some hard-real-time and embedded applications. In such cases, "
"consider providing/using similar facilities, e.g.,  a standard-library-style "
"container implemented using a pool allocator."
msgstr ""

msgid "6638    ##### Enforcement"
msgstr ""

msgid ""
"6639    Not easy. ??? Look for messy loops, nested loops, long functions, "
"absence of function calls, lack of use of non-built-in types. Cyclomatic "
"complexity?"
msgstr ""

msgid ""
"6640    ### <a name=\"Res-abstr\"></a>ES.2: Prefer suitable abstractions to "
"direct use of language features"
msgstr ""

msgid "6641    ##### Reason"
msgstr ""

msgid ""
"6642    A \"suitable abstraction\" (e.g., library or class) is closer to the "
"application concepts than the bare language, leads to shorter and clearer "
"code, and is likely to be better tested."
msgstr ""

msgid "6643    ##### Example"
msgstr ""

msgid "6644        vector<string> read1(istream& is)   // good"
msgstr ""

msgid "6645        {"
msgstr ""

msgid "6646            vector<string> res;"
msgstr ""

msgid "6647            for (string s; is >> s;)"
msgstr ""

msgid "6648                res.push_back(s);"
msgstr ""

msgid "6649            return res;"
msgstr ""

msgid "6650        }"
msgstr ""

msgid ""
"6651    The more traditional and lower-level near-equivalent is longer, "
"messier, harder to get right, and most likely slower:"
msgstr ""

msgid ""
"6652        char** read2(istream& is, int maxelem, int maxstring, int* "
"nread)   // bad: verbose and incomplete"
msgstr ""

msgid "6653        {"
msgstr ""

msgid "6654            auto res = new char*[maxelem];"
msgstr ""

msgid "6655            int elemcount = 0;"
msgstr ""

msgid "6656            while (is && elemcount < maxelem) {"
msgstr ""

msgid "6657                auto s = new char[maxstring];"
msgstr ""

msgid "6658                is.read(s, maxstring);"
msgstr ""

msgid "6659                res[elemcount++] = s;"
msgstr ""

msgid "6660            }"
msgstr ""

msgid "6661            nread = &elemcount;"
msgstr ""

msgid "6662            return res;"
msgstr ""

msgid "6663        }"
msgstr ""

msgid ""
"6664    Once the checking for overflow and error handling has been added "
"that code gets quite messy, and there is the problem remembering to `delete` "
"the returned pointer and the C-style strings that array contains."
msgstr ""

msgid "6665    ##### Enforcement"
msgstr ""

msgid ""
"6666    Not easy. ??? Look for messy loops, nested loops, long functions, "
"absence of function calls, lack of use of non-built-in types. Cyclomatic "
"complexity?"
msgstr ""

msgid "6667    ## ES.dcl: Declarations"
msgstr ""

msgid ""
"6668    A declaration is a statement. A declaration introduces a name into a "
"scope and may cause the construction of a named object."
msgstr ""

msgid "6669    ### <a name=\"Res-scope\"></a>ES.5: Keep scopes small"
msgstr ""

msgid "6670    ##### Reason"
msgstr ""

msgid ""
"6671    Readability. Minimize resource retention. Avoid accidental misuse of "
"value."
msgstr ""

msgid ""
"6672    **Alternative formulation**: Don't declare a name in an "
"unnecessarily large scope."
msgstr ""

msgid "6673    ##### Example"
msgstr ""

msgid "6674        void use()"
msgstr ""

msgid "6675        {"
msgstr ""

msgid ""
"6676            int i;    // bad: i is needlessly accessible after loop"
msgstr ""

msgid "6677            for (i = 0; i < 20; ++i) { /* ... */ }"
msgstr ""

msgid "6678            // no intended use of i here"
msgstr ""

msgid ""
"6679            for (int i = 0; i < 20; ++i) { /* ... */ }  // good: i is "
"local to for-loop"
msgstr ""

msgid ""
"6680            if (auto pc = dynamic_cast<Circle*>(ps)) {  // good: pc is "
"local to if-statement"
msgstr ""

msgid "6681                // ... deal with Circle ..."
msgstr ""

msgid "6682            }"
msgstr ""

msgid "6683            else {"
msgstr ""

msgid "6684                // ... handle error ..."
msgstr ""

msgid "6685            }"
msgstr ""

msgid "6686        }"
msgstr ""

msgid "6687    ##### Example, bad"
msgstr ""

msgid "6688        void use(const string& name)"
msgstr ""

msgid "6689        {"
msgstr ""

msgid "6690            string fn = name + \".txt\";"
msgstr ""

msgid "6691            ifstream is {fn};"
msgstr ""

msgid "6692            Record r;"
msgstr ""

msgid "6693            is >> r;"
msgstr ""

msgid ""
"6694            // ... 200 lines of code without intended use of fn or is ..."
""
msgstr ""

msgid "6695        }"
msgstr ""

msgid ""
"6696    This function is by most measure too long anyway, but the point is "
"that the resources used by `fn` and the file handle held by `is`"
msgstr ""

msgid ""
"6697    are retained for much longer than needed and that unanticipated use "
"of `is` and `fn` could happen later in the function."
msgstr ""

msgid "6698    In this case, it might be a good idea to factor out the read:"
msgstr ""

msgid "6699        Record load_record(const string& name)"
msgstr ""

msgid "6700        {"
msgstr ""

msgid "6701            string fn = name + \".txt\";"
msgstr ""

msgid "6702            ifstream is {fn};"
msgstr ""

msgid "6703            Record r;"
msgstr ""

msgid "6704            is >> r;"
msgstr ""

msgid "6705            return r;"
msgstr ""

msgid "6706        }"
msgstr ""

msgid "6707        void use(const string& name)"
msgstr ""

msgid "6708        {"
msgstr ""

msgid "6709            Record r = load_record(name);"
msgstr ""

msgid "6710            // ... 200 lines of code ..."
msgstr ""

msgid "6711        }"
msgstr ""

msgid "6712    ##### Enforcement"
msgstr ""

msgid ""
"6713    * Flag loop variable declared outside a loop and not used after the "
"loop"
msgstr ""

msgid ""
"6714    * Flag when expensive resources, such as file handles and locks are "
"not used for N-lines (for some suitable N)"
msgstr ""

msgid ""
"6715    ### <a name=\"Res-cond\"></a>ES.6: Declare names in for-statement "
"initializers and conditions to limit scope"
msgstr ""

msgid "6716    ##### Reason"
msgstr ""

msgid "6717    Readability. Minimize resource retention."
msgstr ""

msgid "6718    ##### Example"
msgstr ""

msgid "6719        void use()"
msgstr ""

msgid "6720        {"
msgstr ""

msgid "6721            for (string s; cin >> s;)"
msgstr ""

msgid "6722                v.push_back(s);"
msgstr ""

msgid ""
"6723            for (int i = 0; i < 20; ++i) {   // good: i is local to for-"
"loop"
msgstr ""

msgid "6724                // ..."
msgstr ""

msgid "6725            }"
msgstr ""

msgid ""
"6726            if (auto pc = dynamic_cast<Circle*>(ps)) {   // good: pc is "
"local to if-statement"
msgstr ""

msgid "6727                // ... deal with Circle ..."
msgstr ""

msgid "6728            }"
msgstr ""

msgid "6729            else {"
msgstr ""

msgid "6730                // ... handle error ..."
msgstr ""

msgid "6731            }"
msgstr ""

msgid "6732        }"
msgstr ""

msgid "6733    ##### Enforcement"
msgstr ""

msgid ""
"6734    * Flag loop variables declared before the loop and not used after "
"the loop"
msgstr ""

msgid ""
"6735    * (hard) Flag loop variables declared before the loop and used after "
"the loop for an unrelated purpose."
msgstr ""

msgid "6736    ##### C++17 example"
msgstr ""

msgid ""
"6737    Note: C++17 also adds `if` and `switch` initializer statements. "
"These require C++17 support."
msgstr ""

msgid "6738        map<int, string> mymap;"
msgstr ""

msgid "6739        if (auto result = mymap.insert(value); result.second) {"
msgstr ""

msgid ""
"6740            // insert succeeded, and result is valid for this block"
msgstr ""

msgid "6741            use(result.first);  // ok"
msgstr ""

msgid "6742            // ..."
msgstr ""

msgid "6743        } // result is destroyed here"
msgstr ""

msgid "6744    ##### C++17 enforcement (if using a C++17 compiler)"
msgstr ""

msgid ""
"6745    * Flag selection/loop variables declared before the body and not "
"used after the body"
msgstr ""

msgid ""
"6746    * (hard) Flag selection/loop variables declared before the body and "
"used after the body for an unrelated purpose."
msgstr ""

msgid ""
"6747    ### <a name=\"Res-name-length\"></a>ES.7: Keep common and local "
"names short, and keep uncommon and nonlocal names longer"
msgstr ""

msgid "6748    ##### Reason"
msgstr ""

msgid ""
"6749    Readability. Lowering the chance of clashes between unrelated non-"
"local names."
msgstr ""

msgid "6750    ##### Example"
msgstr ""

msgid "6751    Conventional short, local names increase readability:"
msgstr ""

msgid "6752        template<typename T>    // good"
msgstr ""

msgid "6753        void print(ostream& os, const vector<T>& v)"
msgstr ""

msgid "6754        {"
msgstr ""

msgid "6755            for (gsl::index i = 0; i < v.size(); ++i)"
msgstr ""

msgid "6756                os << v[i] << '\\n';"
msgstr ""

msgid "6757        }"
msgstr ""

msgid ""
"6758    An index is conventionally called `i` and there is no hint about the "
"meaning of the vector in this generic function, so `v` is as good name as "
"any. Compare"
msgstr ""

msgid ""
"6759        template<typename Element_type>   // bad: verbose, hard to read"
msgstr ""

msgid ""
"6760        void print(ostream& target_stream, const vector<Element_type>& "
"current_vector)"
msgstr ""

msgid "6761        {"
msgstr ""

msgid "6762            for (gsl::index current_element_index = 0;"
msgstr ""

msgid "6763                 current_element_index < current_vector.size();"
msgstr ""

msgid "6764                 ++current_element_index"
msgstr ""

msgid "6765            )"
msgstr ""

msgid ""
"6766            target_stream << current_vector[current_element_index] << "
"'\\n';"
msgstr ""

msgid "6767        }"
msgstr ""

msgid "6768    Yes, it is a caricature, but we have seen worse."
msgstr ""

msgid "6769    ##### Example"
msgstr ""

msgid "6770    Unconventional and short non-local names obscure code:"
msgstr ""

msgid "6771        void use1(const string& s)"
msgstr ""

msgid "6772        {"
msgstr ""

msgid "6773            // ..."
msgstr ""

msgid "6774            tt(s);   // bad: what is tt()?"
msgstr ""

msgid "6775            // ..."
msgstr ""

msgid "6776        }"
msgstr ""

msgid "6777    Better, give non-local entities readable names:"
msgstr ""

msgid "6778        void use1(const string& s)"
msgstr ""

msgid "6779        {"
msgstr ""

msgid "6780            // ..."
msgstr ""

msgid "6781            trim_tail(s);   // better"
msgstr ""

msgid "6782            // ..."
msgstr ""

msgid "6783        }"
msgstr ""

msgid ""
"6784    Here, there is a chance that the reader knows what `trim_tail` means "
"and that the reader can remember it after looking it up."
msgstr ""

msgid "6785    ##### Example, bad"
msgstr ""

msgid ""
"6786    Argument names of large functions are de facto non-local and should "
"be meaningful:"
msgstr ""

msgid ""
"6787        void complicated_algorithm(vector<Record>& vr, const "
"vector<int>& vi, map<string, int>& out)"
msgstr ""

msgid ""
"6788        // read from events in vr (marking used Records) for the indices "
"in"
msgstr ""

msgid "6789        // vi placing (name, index) pairs into out"
msgstr ""

msgid "6790        {"
msgstr ""

msgid "6791            // ... 500 lines of code using vr, vi, and out ..."
msgstr ""

msgid "6792        }"
msgstr ""

msgid ""
"6793    We recommend keeping functions short, but that rule isn't "
"universally adhered to and naming should reflect that."
msgstr ""

msgid "6794    ##### Enforcement"
msgstr ""

msgid ""
"6795    Check length of local and non-local names. Also take function length "
"into account."
msgstr ""

msgid ""
"6796    ### <a name=\"Res-name-similar\"></a>ES.8: Avoid similar-looking "
"names"
msgstr ""

msgid "6797    ##### Reason"
msgstr ""

msgid ""
"6798    Code clarity and readability. Too-similar names slow down "
"comprehension and increase the likelihood of error."
msgstr ""

msgid "6799    ##### Example; bad"
msgstr ""

msgid ""
"6800        if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) "
"surprise();"
msgstr ""

msgid "6801    ##### Example; bad"
msgstr ""

msgid ""
"6802    Do not declare a non-type with the same name as a type in the same "
"scope. This removes the need to disambiguate with a keyword such as `struct` "
"or `enum`. It also removes a source of errors, as `struct X` can implicitly "
"declare `X` if lookup fails."
msgstr ""

msgid "6803        struct foo { int n; };"
msgstr ""

msgid ""
"6804        struct foo foo();       // BAD, foo is a type already in scope"
msgstr ""

msgid "6805        struct foo x = foo();   // requires disambiguation"
msgstr ""

msgid "6806    ##### Exception"
msgstr ""

msgid ""
"6807    Antique header files might declare non-types and types with the same "
"name in the same scope."
msgstr ""

msgid "6808    ##### Enforcement"
msgstr ""

msgid ""
"6809    * Check names against a list of known confusing letter and digit "
"combinations."
msgstr ""

msgid ""
"6810    * Flag a declaration of a variable, function, or enumerator that "
"hides a class or enumeration declared in the same scope."
msgstr ""

msgid "6811    ### <a name=\"Res-not-CAPS\"></a>ES.9: Avoid `ALL_CAPS` names"
msgstr ""

msgid "6812    ##### Reason"
msgstr ""

msgid ""
"6813    Such names are commonly used for macros. Thus, `ALL_CAPS` name are "
"vulnerable to unintended macro substitution."
msgstr ""

msgid "6814    ##### Example"
msgstr ""

msgid "6815        // somewhere in some header:"
msgstr ""

msgid "6816        #define NE !="
msgstr ""

msgid "6817        // somewhere else in some other header:"
msgstr ""

msgid "6818        enum Coord { N, NE, NW, S, SE, SW, E, W };"
msgstr ""

msgid "6819        // somewhere third in some poor programmer's .cpp:"
msgstr ""

msgid "6820        switch (direction) {"
msgstr ""

msgid "6821        case N:"
msgstr ""

msgid "6822            // ..."
msgstr ""

msgid "6823        case NE:"
msgstr ""

msgid "6824            // ..."
msgstr ""

msgid "6825        // ..."
msgstr ""

msgid "6826        }"
msgstr ""

msgid "6827    ##### Note"
msgstr ""

msgid ""
"6828    Do not use `ALL_CAPS` for constants just because constants used to "
"be macros."
msgstr ""

msgid "6829    ##### Enforcement"
msgstr ""

msgid ""
"6830    Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro "
"names and flag all non-ALL-CAPS macro names."
msgstr ""

msgid ""
"6831    ### <a name=\"Res-name-one\"></a>ES.10: Declare one name (only) per "
"declaration"
msgstr ""

msgid "6832    ##### Reason"
msgstr ""

msgid ""
"6833    One-declaration-per line increases readability and avoids mistakes "
"related to"
msgstr ""

msgid ""
"6834    the C/C++ grammar. It also leaves room for a more descriptive end-of-"
"line"
msgstr ""

msgid "6835    comment."
msgstr ""

msgid "6836    ##### Example, bad"
msgstr ""

msgid "6837        char *p, c, a[7], *pp[7], **aa[10];   // yuck!"
msgstr ""

msgid "6838    ##### Exception"
msgstr ""

msgid ""
"6839    A function declaration can contain several function argument "
"declarations."
msgstr ""

msgid "6840    ##### Exception"
msgstr ""

msgid ""
"6841    A structured binding (C++17) is specifically designed to introduce "
"several variables:"
msgstr ""

msgid "6842        auto [iter, inserted] = m.insert_or_assign(k, val);"
msgstr ""

msgid "6843        if (inserted) { /* new entry was inserted */ }"
msgstr ""

msgid "6844    ##### Example"
msgstr ""

msgid "6845        template <class InputIterator, class Predicate>"
msgstr ""

msgid ""
"6846        bool any_of(InputIterator first, InputIterator last, Predicate "
"pred);"
msgstr ""

msgid "6847    or better using concepts:"
msgstr ""

msgid ""
"6848        bool any_of(InputIterator first, InputIterator last, Predicate "
"pred);"
msgstr ""

msgid "6849    ##### Example"
msgstr ""

msgid ""
"6850        double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); "
"FLT_RADIX is usually 2"
msgstr ""

msgid "6851    or:"
msgstr ""

msgid ""
"6852        double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is "
"usually 2"
msgstr ""

msgid "6853            double x,     // base value"
msgstr ""

msgid "6854            int n         // exponent"
msgstr ""

msgid "6855        );"
msgstr ""

msgid "6856    or:"
msgstr ""

msgid ""
"6857        // better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually "
"2"
msgstr ""

msgid "6858        double scalbn(double base, int exponent);"
msgstr ""

msgid "6859    ##### Example"
msgstr ""

msgid "6860        int a = 7, b = 9, c, d = 10, e = 3;"
msgstr ""

msgid ""
"6861    In a long list of declarators is is easy to overlook an "
"uninitialized variable."
msgstr ""

msgid "6862    ##### Enforcement"
msgstr ""

msgid ""
"6863    Flag variable and constant declarations with multiple declarators (e."
"g., `int* p, q;`)"
msgstr ""

msgid ""
"6864    ### <a name=\"Res-auto\"></a>ES.11: Use `auto` to avoid redundant "
"repetition of type names"
msgstr ""

msgid "6865    ##### Reason"
msgstr ""

msgid "6866    * Simple repetition is tedious and error-prone."
msgstr ""

msgid ""
"6867    * When you use `auto`, the name of the declared entity is in a fixed "
"position in the declaration, increasing readability."
msgstr ""

msgid ""
"6868    * In a template function declaration the return type can be a member "
"type."
msgstr ""

msgid "6869    ##### Example"
msgstr ""

msgid "6870    Consider:"
msgstr ""

msgid "6871        auto p = v.begin();   // vector<int>::iterator"
msgstr ""

msgid "6872        auto h = t.future();"
msgstr ""

msgid "6873        auto q = make_unique<int[]>(s);"
msgstr ""

msgid "6874        auto f = [](int x){ return x + 10; };"
msgstr ""

msgid ""
"6875    In each case, we save writing a longish, hard-to-remember type that "
"the compiler already knows but a programmer could get wrong."
msgstr ""

msgid "6876    ##### Example"
msgstr ""

msgid "6877        template<class T>"
msgstr ""

msgid ""
"6878        auto Container<T>::first() -> Iterator;   // Container<T>::"
"Iterator"
msgstr ""

msgid "6879    ##### Exception"
msgstr ""

msgid ""
"6880    Avoid `auto` for initializer lists and in cases where you know "
"exactly which type you want and where an initializer might require "
"conversion."
msgstr ""

msgid "6881    ##### Example"
msgstr ""

msgid "6882        auto lst = { 1, 2, 3 };   // lst is an initializer list"
msgstr ""

msgid ""
"6883        auto x{1};   // x is an int (after correction of the C++14 "
"standard; initializer_list in C++11)"
msgstr ""

msgid "6884    ##### Note"
msgstr ""

msgid ""
"6885    When concepts become available, we can (and should) be more specific "
"about the type we are deducing:"
msgstr ""

msgid "6886        // ..."
msgstr ""

msgid "6887        ForwardIterator p = algo(x, y, z);"
msgstr ""

msgid "6888    ##### Example (C++17)"
msgstr ""

msgid ""
"6889        auto [ quotient, remainder ] = div(123456, 73);   // break out "
"the members of the div_t result"
msgstr ""

msgid "6890    ##### Enforcement"
msgstr ""

msgid "6891    Flag redundant repetition of type names in a declaration."
msgstr ""

msgid ""
"6892    ### <a name=\"Res-reuse\"></a>ES.12: Do not reuse names in nested "
"scopes"
msgstr ""

msgid "6893    ##### Reason"
msgstr ""

msgid "6894    It is easy to get confused about which variable is used."
msgstr ""

msgid "6895    Can cause maintenance problems."
msgstr ""

msgid "6896    ##### Example, bad"
msgstr ""

msgid "6897        int d = 0;"
msgstr ""

msgid "6898        // ..."
msgstr ""

msgid "6899        if (cond) {"
msgstr ""

msgid "6900            // ..."
msgstr ""

msgid "6901            d = 9;"
msgstr ""

msgid "6902            // ..."
msgstr ""

msgid "6903        }"
msgstr ""

msgid "6904        else {"
msgstr ""

msgid "6905            // ..."
msgstr ""

msgid "6906            int d = 7;"
msgstr ""

msgid "6907            // ..."
msgstr ""

msgid "6908            d = value_to_be_returned;"
msgstr ""

msgid "6909            // ..."
msgstr ""

msgid "6910        }"
msgstr ""

msgid "6911        return d;"
msgstr ""

msgid ""
"6912    If this is a large `if`-statement, it is easy to overlook that a new "
"`d` has been introduced in the inner scope."
msgstr ""

msgid "6913    This is a known source of bugs."
msgstr ""

msgid ""
"6914    Sometimes such reuse of a name in an inner scope is called "
"\"shadowing\"."
msgstr ""

msgid "6915    ##### Note"
msgstr ""

msgid ""
"6916    Shadowing is primarily a problem when functions are too large and "
"too complex."
msgstr ""

msgid "6917    ##### Example"
msgstr ""

msgid ""
"6918    Shadowing of function arguments in the outermost block is disallowed "
"by the language:"
msgstr ""

msgid "6919        void f(int x)"
msgstr ""

msgid "6920        {"
msgstr ""

msgid "6921            int x = 4;  // error: reuse of function argument name"
msgstr ""

msgid "6922            if (x) {"
msgstr ""

msgid "6923                int x = 7;  // allowed, but bad"
msgstr ""

msgid "6924                // ..."
msgstr ""

msgid "6925            }"
msgstr ""

msgid "6926        }"
msgstr ""

msgid "6927    ##### Example, bad"
msgstr ""

msgid ""
"6928    Reuse of a member name as a local variable can also be a problem:"
msgstr ""

msgid "6929        struct S {"
msgstr ""

msgid "6930            int m;"
msgstr ""

msgid "6931            void f(int x);"
msgstr ""

msgid "6932        };"
msgstr ""

msgid "6933        void S::f(int x)"
msgstr ""

msgid "6934        {"
msgstr ""

msgid "6935            m = 7;    // assign to member"
msgstr ""

msgid "6936            if (x) {"
msgstr ""

msgid "6937                int m = 9;"
msgstr ""

msgid "6938                // ..."
msgstr ""

msgid "6939                m = 99; // assign to member"
msgstr ""

msgid "6940                // ..."
msgstr ""

msgid "6941            }"
msgstr ""

msgid "6942        }"
msgstr ""

msgid "6943    ##### Exception"
msgstr ""

msgid ""
"6944    We often reuse function names from a base class in a derived class:"
msgstr ""

msgid "6945        struct B {"
msgstr ""

msgid "6946            void f(int);"
msgstr ""

msgid "6947        };"
msgstr ""

msgid "6948        struct D : B {"
msgstr ""

msgid "6949            void f(double);"
msgstr ""

msgid "6950            using B::f;"
msgstr ""

msgid "6951        };"
msgstr ""

msgid "6952    This is error-prone."
msgstr ""

msgid ""
"6953    For example, had we forgotten the using declaration, a call `d.f(1)` "
"would not have found the `int` version of `f`."
msgstr ""

msgid ""
"6954    ??? Do we need a specific rule about shadowing/hiding in class "
"hierarchies?"
msgstr ""

msgid "6955    ##### Enforcement"
msgstr ""

msgid "6956    * Flag reuse of a name in nested local scopes"
msgstr ""

msgid ""
"6957    * Flag reuse of a member name as a local variable in a member "
"function"
msgstr ""

msgid ""
"6958    * Flag reuse of a global name as a local variable or a member name"
msgstr ""

msgid ""
"6959    * Flag reuse of a base class member name in a derived class (except "
"for function names)"
msgstr ""

msgid ""
"6960    ### <a name=\"Res-always\"></a>ES.20: Always initialize an object"
msgstr ""

msgid "6961    ##### Reason"
msgstr ""

msgid ""
"6962    Avoid used-before-set errors and their associated undefined behavior."
""
msgstr ""

msgid "6963    Avoid problems with comprehension of complex initialization."
msgstr ""

msgid "6964    Simplify refactoring."
msgstr ""

msgid "6965    ##### Example"
msgstr ""

msgid "6966        void use(int arg)"
msgstr ""

msgid "6967        {"
msgstr ""

msgid "6968            int i;   // bad: uninitialized variable"
msgstr ""

msgid "6969            // ..."
msgstr ""

msgid "6970            i = 7;   // initialize i"
msgstr ""

msgid "6971        }"
msgstr ""

msgid ""
"6972    No, `i = 7` does not initialize `i`; it assigns to it. Also, `i` can "
"be read in the `...` part. Better:"
msgstr ""

msgid "6973        void use(int arg)   // OK"
msgstr ""

msgid "6974        {"
msgstr ""

msgid "6975            int i = 7;   // OK: initialized"
msgstr ""

msgid "6976            string s;    // OK: default initialized"
msgstr ""

msgid "6977            // ..."
msgstr ""

msgid "6978        }"
msgstr ""

msgid "6979    ##### Note"
msgstr ""

msgid ""
"6980    The *always initialize* rule is deliberately stronger than the *an "
"object must be set before used* language rule."
msgstr ""

msgid ""
"6981    The latter, more relaxed rule, catches the technical bugs, but:"
msgstr ""

msgid "6982    * It leads to less readable code"
msgstr ""

msgid ""
"6983    * It encourages people to declare names in greater than necessary "
"scopes"
msgstr ""

msgid "6984    * It leads to harder to read code"
msgstr ""

msgid "6985    * It leads to logic bugs by encouraging complex code"
msgstr ""

msgid "6986    * It hampers refactoring"
msgstr ""

msgid ""
"6987    The *always initialize* rule is a style rule aimed to improve "
"maintainability as well as a rule protecting against used-before-set errors."
msgstr ""

msgid "6988    ##### Example"
msgstr ""

msgid ""
"6989    Here is an example that is often considered to demonstrate the need "
"for a more relaxed rule for initialization"
msgstr ""

msgid ""
"6990        widget i;    // \"widget\" a type that's expensive to "
"initialize, possibly a large POD"
msgstr ""

msgid "6991        widget j;"
msgstr ""

msgid "6992        if (cond) {  // bad: i and j are initialized \"late\""
msgstr ""

msgid "6993            i = f1();"
msgstr ""

msgid "6994            j = f2();"
msgstr ""

msgid "6995        }"
msgstr ""

msgid "6996        else {"
msgstr ""

msgid "6997            i = f3();"
msgstr ""

msgid "6998            j = f4();"
msgstr ""

msgid "6999        }"
msgstr ""

msgid ""
"7000    This cannot trivially be rewritten to initialize `i` and `j` with "
"initializers."
msgstr ""

msgid ""
"7001    Note that for types with a default constructor, attempting to "
"postpone initialization simply leads to a default initialization followed by "
"an assignment."
msgstr ""

msgid ""
"7002    A popular reason for such examples is \"efficiency\", but a compiler "
"that can detect whether we made a used-before-set error can also eliminate "
"any redundant double initialization."
msgstr ""

msgid ""
"7003    Assuming that there is a logical connection between `i` and `j`, "
"that connection should probably be expressed in code:"
msgstr ""

msgid "7004        pair<widget, widget> make_related_widgets(bool x)"
msgstr ""

msgid "7005        {"
msgstr ""

msgid "7006            return (x) ? {f1(), f2()} : {f3(), f4() };"
msgstr ""

msgid "7007        }"
msgstr ""

msgid "7008        auto [i, j] = make_related_widgets(cond);    // C++17"
msgstr ""

msgid "7009    ##### Note"
msgstr ""

msgid ""
"7010    Complex initialization has been popular with clever programmers for "
"decades."
msgstr ""

msgid "7011    It has also been a major source of errors and complexity."
msgstr ""

msgid ""
"7012    Many such errors are introduced during maintenance years after the "
"initial implementation."
msgstr ""

msgid "7013    ##### Example"
msgstr ""

msgid "7014    This rule covers member variables."
msgstr ""

msgid "7015        class X {"
msgstr ""

msgid "7016        public:"
msgstr ""

msgid "7017            X(int i, int ci) : m2{i}, cm2{ci} {}"
msgstr ""

msgid "7018            // ..."
msgstr ""

msgid "7019        private:"
msgstr ""

msgid "7020            int m1 = 7;"
msgstr ""

msgid "7021            int m2;"
msgstr ""

msgid "7022            int m3;"
msgstr ""

msgid "7023            const int cm1 = 7;"
msgstr ""

msgid "7024            const int cm2;"
msgstr ""

msgid "7025            const int cm3;"
msgstr ""

msgid "7026        };"
msgstr ""

msgid ""
"7027    The compiler will flag the uninitialized `cm3` because it is a "
"`const`, but it will not catch the lack of initialization of `m3`."
msgstr ""

msgid ""
"7028    Usually, a rare spurious member initialization is worth the absence "
"of errors from lack of initialization and often an optimizer"
msgstr ""

msgid ""
"7029    can eliminate a redundant initialization (e.g., an initialization "
"that occurs immediately before an assignment)."
msgstr ""

msgid "7030    ##### Exception"
msgstr ""

msgid ""
"7031    If you are declaring an object that is just about to be initialized "
"from input, initializing it would cause a double initialization."
msgstr ""

msgid ""
"7032    However, beware that this may leave uninitialized data beyond the "
"input -- and that has been a fertile source of errors and security breaches:"
msgstr ""

msgid "7033        constexpr int max = 8 * 1024;"
msgstr ""

msgid "7034        int buf[max];         // OK, but suspicious: uninitialized"
msgstr ""

msgid "7035        f.read(buf, max);"
msgstr ""

msgid ""
"7036    The cost of initializing that array could be significant in some "
"situations."
msgstr ""

msgid ""
"7037    However, such examples do tend to leave uninitialized variables "
"accessible, so they should be treated with suspicion."
msgstr ""

msgid "7038        constexpr int max = 8 * 1024;"
msgstr ""

msgid ""
"7039        int buf[max] = {};   // zero all elements; better in some "
"situations"
msgstr ""

msgid "7040        f.read(buf, max);"
msgstr ""

msgid ""
"7041    When feasible use a library function that is known not to overflow. "
"For example:"
msgstr ""

msgid "7042        string s;   // s is default initialized to \"\""
msgstr ""

msgid "7043        cin >> s;   // s expands to hold the string"
msgstr ""

msgid ""
"7044    Don't consider simple variables that are targets for input "
"operations exceptions to this rule:"
msgstr ""

msgid "7045        int i;   // bad"
msgstr ""

msgid "7046        // ..."
msgstr ""

msgid "7047        cin >> i;"
msgstr ""

msgid ""
"7048    In the not uncommon case where the input target and the input "
"operation get separated (as they should not) the possibility of used-before-"
"set opens up."
msgstr ""

msgid "7049        int i2 = 0;   // better"
msgstr ""

msgid "7050        // ..."
msgstr ""

msgid "7051        cin >> i2;"
msgstr ""

msgid ""
"7052    A good optimizer should know about input operations and eliminate "
"the redundant operation."
msgstr ""

msgid "7053    ##### Example"
msgstr ""

msgid ""
"7054    Using an `uninitialized` or sentinel value is a symptom of a problem "
"and not a"
msgstr ""

msgid "7055    solution:"
msgstr ""

msgid "7056        widget i = uninit;  // bad"
msgstr ""

msgid "7057        widget j = uninit;"
msgstr ""

msgid "7058        // ..."
msgstr ""

msgid "7059        use(i);         // possibly used before set"
msgstr ""

msgid "7060        // ..."
msgstr ""

msgid "7061        if (cond) {     // bad: i and j are initialized \"late\""
msgstr ""

msgid "7062            i = f1();"
msgstr ""

msgid "7063            j = f2();"
msgstr ""

msgid "7064        }"
msgstr ""

msgid "7065        else {"
msgstr ""

msgid "7066            i = f3();"
msgstr ""

msgid "7067            j = f4();"
msgstr ""

msgid "7068        }"
msgstr ""

msgid ""
"7069    Now the compiler cannot even simply detect a used-before-set. "
"Further, we've introduced complexity in the state space for widget: which "
"operations are valid on an `uninit` widget and which are not?"
msgstr ""

msgid "7070    ##### Note"
msgstr ""

msgid ""
"7071    Sometimes, a lambda can be used as an initializer to avoid an "
"uninitialized variable:"
msgstr ""

msgid "7072        error_code ec;"
msgstr ""

msgid "7073        Value v = [&] {"
msgstr ""

msgid ""
"7074            auto p = get_value();   // get_value() returns a "
"pair<error_code, Value>"
msgstr ""

msgid "7075            ec = p.first;"
msgstr ""

msgid "7076            return p.second;"
msgstr ""

msgid "7077        }();"
msgstr ""

msgid "7078    or maybe:"
msgstr ""

msgid "7079        Value v = [] {"
msgstr ""

msgid ""
"7080            auto p = get_value();   // get_value() returns a "
"pair<error_code, Value>"
msgstr ""

msgid "7081            if (p.first) throw Bad_value{p.first};"
msgstr ""

msgid "7082            return p.second;"
msgstr ""

msgid "7083        }();"
msgstr ""

msgid "7084    **See also**: [ES.28](#Res-lambda-init)"
msgstr ""

msgid "7085    ##### Enforcement"
msgstr ""

msgid "7086    * Flag every uninitialized variable."
msgstr ""

msgid ""
"7087      Don't flag variables of user-defined types with default "
"constructors."
msgstr ""

msgid ""
"7088    * Check that an uninitialized buffer is written into *immediately* "
"after declaration."
msgstr ""

msgid ""
"7089      Passing an uninitialized variable as a reference to non-`const` "
"argument can be assumed to be a write into the variable."
msgstr ""

msgid ""
"7090    ### <a name=\"Res-introduce\"></a>ES.21: Don't introduce a variable "
"(or constant) before you need to use it"
msgstr ""

msgid "7091    ##### Reason"
msgstr ""

msgid ""
"7092    Readability. To limit the scope in which the variable can be used."
msgstr ""

msgid "7093    ##### Example"
msgstr ""

msgid "7094        int x = 7;"
msgstr ""

msgid "7095        // ... no use of x here ..."
msgstr ""

msgid "7096        ++x;"
msgstr ""

msgid "7097    ##### Enforcement"
msgstr ""

msgid "7098    Flag declarations that are distant from their first use."
msgstr ""

msgid ""
"7099    ### <a name=\"Res-init\"></a>ES.22: Don't declare a variable until "
"you have a value to initialize it with"
msgstr ""

msgid "7100    ##### Reason"
msgstr ""

msgid ""
"7101    Readability. Limit the scope in which a variable can be used. Don't "
"risk used-before-set. Initialization is often more efficient than assignment."
""
msgstr ""

msgid "7102    ##### Example, bad"
msgstr ""

msgid "7103        string s;"
msgstr ""

msgid "7104        // ... no use of s here ..."
msgstr ""

msgid "7105        s = \"what a waste\";"
msgstr ""

msgid "7106    ##### Example, bad"
msgstr ""

msgid "7107        SomeLargeType var;   // ugly CaMeLcAsEvArIaBlE"
msgstr ""

msgid "7108        if (cond)   // some non-trivial condition"
msgstr ""

msgid "7109            Set(&var);"
msgstr ""

msgid "7110        else if (cond2 || !cond3) {"
msgstr ""

msgid "7111            var = Set2(3.14);"
msgstr ""

msgid "7112        }"
msgstr ""

msgid "7113        else {"
msgstr ""

msgid "7114            var = 0;"
msgstr ""

msgid "7115            for (auto& e : something)"
msgstr ""

msgid "7116                var += e;"
msgstr ""

msgid "7117        }"
msgstr ""

msgid ""
"7118        // use var; that this isn't done too early can be enforced "
"statically with only control flow"
msgstr ""

msgid ""
"7119    This would be fine if there was a default initialization for "
"`SomeLargeType` that wasn't too expensive."
msgstr ""

msgid ""
"7120    Otherwise, a programmer might very well wonder if every possible "
"path through the maze of conditions has been covered."
msgstr ""

msgid ""
"7121    If not, we have a \"use before set\" bug. This is a maintenance trap."
""
msgstr ""

msgid ""
"7122    For initializers of moderate complexity, including for `const` "
"variables, consider using a lambda to express the initializer; see [ES."
"28](#Res-lambda-init)."
msgstr ""

msgid "7123    ##### Enforcement"
msgstr ""

msgid ""
"7124    * Flag declarations with default initialization that are assigned to "
"before they are first read."
msgstr ""

msgid ""
"7125    * Flag any complicated computation after an uninitialized variable "
"and before its use."
msgstr ""

msgid ""
"7126    ### <a name=\"Res-list\"></a>ES.23: Prefer the `{}` initializer "
"syntax"
msgstr ""

msgid "7127    ##### Reason"
msgstr ""

msgid ""
"7128    The rules for `{}` initialization are simpler, more general, less "
"ambiguous, and safer than for other forms of initialization."
msgstr ""

msgid "7129    ##### Example"
msgstr ""

msgid "7130        int x {f(99)};"
msgstr ""

msgid "7131        vector<int> v = {1, 2, 3, 4, 5, 6};"
msgstr ""

msgid "7132    ##### Exception"
msgstr ""

msgid ""
"7133    For containers, there is a tradition for using `{...}` for a list of "
"elements and `(...)` for sizes:"
msgstr ""

msgid ""
"7134        vector<int> v1(10);    // vector of 10 elements with the default "
"value 0"
msgstr ""

msgid ""
"7135        vector<int> v2 {10};   // vector of 1 element with the value 10"
msgstr ""

msgid "7136    ##### Note"
msgstr ""

msgid "7137    `{}`-initializers do not allow narrowing conversions."
msgstr ""

msgid "7138    ##### Example"
msgstr ""

msgid "7139        int x {7.9};   // error: narrowing"
msgstr ""

msgid ""
"7140        int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning"
msgstr ""

msgid "7141    ##### Note"
msgstr ""

msgid ""
"7142    `{}` initialization can be used for all initialization; other forms "
"of initialization can't:"
msgstr ""

msgid ""
"7143        auto p = new vector<int> {1, 2, 3, 4, 5};   // initialized "
"vector"
msgstr ""

msgid ""
"7144        D::D(int a, int b) :m{a, b} {   // member initializer (e.g., m "
"might be a pair)"
msgstr ""

msgid "7145            // ..."
msgstr ""

msgid "7146        };"
msgstr ""

msgid "7147        X var {};   // initialize var to be empty"
msgstr ""

msgid "7148        struct S {"
msgstr ""

msgid "7149            int m {7};   // default initializer for a member"
msgstr ""

msgid "7150            // ..."
msgstr ""

msgid "7151        };"
msgstr ""

msgid "7152    ##### Note"
msgstr ""

msgid ""
"7153    Initialization of a variable declared using `auto` with a single "
"value, e.g., `{v}`, had surprising results until C++17."
msgstr ""

msgid "7154    The C++17 rules are somewhat less surprising:"
msgstr ""

msgid "7155        auto x1 {7};        // x1 is an int with the value 7"
msgstr ""

msgid ""
"7156        auto x2 = {7};  // x2 is an initializer_list<int> with an "
"element 7"
msgstr ""

msgid "7157        auto x11 {7, 8};    // error: two initializers"
msgstr ""

msgid ""
"7158        auto x22 = {7, 8};  // x2 is an initializer_list<int> with "
"elements 7 and 8"
msgstr ""

msgid "7159    So use `={...}` if you really want an `initializer_list<T>`"
msgstr ""

msgid ""
"7160        auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a "
"list"
msgstr ""

msgid "7161    ##### Note"
msgstr ""

msgid ""
"7162    Old habits die hard, so this rule is hard to apply consistently, "
"especially as there are so many cases where `=` is innocent."
msgstr ""

msgid "7163    ##### Example"
msgstr ""

msgid "7164        template<typename T>"
msgstr ""

msgid "7165        void f()"
msgstr ""

msgid "7166        {"
msgstr ""

msgid "7167            T x1(1);    // T initialized with 1"
msgstr ""

msgid ""
"7168            T x0();     // bad: function declaration (often a mistake)"
msgstr ""

msgid "7169            T y1 {1};   // T initialized with 1"
msgstr ""

msgid "7170            T y0 {};    // default initialized T"
msgstr ""

msgid "7171            // ..."
msgstr ""

msgid "7172        }"
msgstr ""

msgid "7173    **See also**: [Discussion](#???)"
msgstr ""

msgid "7174    ##### Enforcement"
msgstr ""

msgid "7175    Tricky."
msgstr ""

msgid "7176    * Don't flag uses of `=` for simple initializers."
msgstr ""

msgid "7177    * Look for `=` after `auto` has been seen."
msgstr ""

msgid ""
"7178    ### <a name=\"Res-unique\"></a>ES.24: Use a `unique_ptr<T>` to hold "
"pointers"
msgstr ""

msgid "7179    ##### Reason"
msgstr ""

msgid ""
"7180    Using `std::unique_ptr` is the simplest way to avoid leaks. It is "
"reliable, it"
msgstr ""

msgid ""
"7181    makes the type system do much of the work to validate ownership "
"safety, it"
msgstr ""

msgid ""
"7182    increases readability, and it has zero or near zero run-time cost."
msgstr ""

msgid "7183    ##### Example"
msgstr ""

msgid "7184        void use(bool leak)"
msgstr ""

msgid "7185        {"
msgstr ""

msgid "7186            auto p1 = make_unique<int>(7);   // OK"
msgstr ""

msgid "7187            int* p2 = new int{7};            // bad: might leak"
msgstr ""

msgid "7188            // ... no assignment to p2 ..."
msgstr ""

msgid "7189            if (leak) return;"
msgstr ""

msgid "7190            // ... no assignment to p2 ..."
msgstr ""

msgid "7191            vector<int> v(7);"
msgstr ""

msgid "7192            v.at(7) = 0;                    // exception thrown"
msgstr ""

msgid "7193            // ..."
msgstr ""

msgid "7194        }"
msgstr ""

msgid ""
"7195    If `leak == true` the object pointed to by `p2` is leaked and the "
"object pointed to by `p1` is not."
msgstr ""

msgid "7196    The same is the case when `at()` throws."
msgstr ""

msgid "7197    ##### Enforcement"
msgstr ""

msgid ""
"7198    Look for raw pointers that are targets of `new`, `malloc()`, or "
"functions that may return such pointers."
msgstr ""

msgid ""
"7199    ### <a name=\"Res-const\"></a>ES.25: Declare an object `const` or "
"`constexpr` unless you want to modify its value later on"
msgstr ""

msgid "7200    ##### Reason"
msgstr ""

msgid ""
"7201    That way you can't change the value by mistake. That way may offer "
"the compiler optimization opportunities."
msgstr ""

msgid "7202    ##### Example"
msgstr ""

msgid "7203        void f(int n)"
msgstr ""

msgid "7204        {"
msgstr ""

msgid ""
"7205            const int bufmax = 2 * n + 2;  // good: we can't change "
"bufmax by accident"
msgstr ""

msgid ""
"7206            int xmax = n;                  // suspicious: is xmax "
"intended to change?"
msgstr ""

msgid "7207            // ..."
msgstr ""

msgid "7208        }"
msgstr ""

msgid "7209    ##### Enforcement"
msgstr ""

msgid "7210    Look to see if a variable is actually mutated, and flag it if"
msgstr ""

msgid ""
"7211    not. Unfortunately, it may be impossible to detect when a non-"
"`const` was not"
msgstr ""

msgid "7212    *intended* to vary (vs when it merely did not vary)."
msgstr ""

msgid ""
"7213    ### <a name=\"Res-recycle\"></a>ES.26: Don't use a variable for two "
"unrelated purposes"
msgstr ""

msgid "7214    ##### Reason"
msgstr ""

msgid "7215    Readability and safety."
msgstr ""

msgid "7216    ##### Example, bad"
msgstr ""

msgid "7217        void use()"
msgstr ""

msgid "7218        {"
msgstr ""

msgid "7219            int i;"
msgstr ""

msgid "7220            for (i = 0; i < 20; ++i) { /* ... */ }"
msgstr ""

msgid ""
"7221            for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled"
msgstr ""

msgid "7222        }"
msgstr ""

msgid "7223    ##### Note"
msgstr ""

msgid ""
"7224    As an optimization, you may want to reuse a buffer as a scratch pad, "
"but even then prefer to limit the variable's scope as much as possible and "
"be careful not to cause bugs from data left in a recycled buffer as this is "
"a common source of security bugs."
msgstr ""

msgid "7225        void write_to_file() {"
msgstr ""

msgid ""
"7226            std::string buffer;             // to avoid reallocations on "
"every loop iteration"
msgstr ""

msgid "7227            for (auto& o : objects)"
msgstr ""

msgid "7228            {"
msgstr ""

msgid "7229                // First part of the work."
msgstr ""

msgid "7230                generate_first_String(buffer, o);"
msgstr ""

msgid "7231                write_to_file(buffer);"
msgstr ""

msgid "7232                // Second part of the work."
msgstr ""

msgid "7233                generate_second_string(buffer, o);"
msgstr ""

msgid "7234                write_to_file(buffer);"
msgstr ""

msgid "7235                // etc..."
msgstr ""

msgid "7236            }"
msgstr ""

msgid "7237        }"
msgstr ""

msgid "7238    ##### Enforcement"
msgstr ""

msgid "7239    Flag recycled variables."
msgstr ""

msgid ""
"7240    ### <a name=\"Res-stack\"></a>ES.27: Use `std::array` or "
"`stack_array` for arrays on the stack"
msgstr ""

msgid "7241    ##### Reason"
msgstr ""

msgid "7242    They are readable and don't implicitly convert to pointers."
msgstr ""

msgid ""
"7243    They are not confused with non-standard extensions of built-in "
"arrays."
msgstr ""

msgid "7244    ##### Example, bad"
msgstr ""

msgid "7245        const int n = 7;"
msgstr ""

msgid "7246        int m = 9;"
msgstr ""

msgid "7247        void f()"
msgstr ""

msgid "7248        {"
msgstr ""

msgid "7249            int a1[n];"
msgstr ""

msgid "7250            int a2[m];   // error: not ISO C++"
msgstr ""

msgid "7251            // ..."
msgstr ""

msgid "7252        }"
msgstr ""

msgid "7253    ##### Note"
msgstr ""

msgid "7254    The definition of `a1` is legal C++ and has always been."
msgstr ""

msgid "7255    There is a lot of such code."
msgstr ""

msgid ""
"7256    It is error-prone, though, especially when the bound is non-local."
msgstr ""

msgid ""
"7257    Also, it is a \"popular\" source of errors (buffer overflow, "
"pointers from array decay, etc.)."
msgstr ""

msgid ""
"7258    The definition of `a2` is C but not C++ and is considered a security "
"risk"
msgstr ""

msgid "7259    ##### Example"
msgstr ""

msgid "7260        const int n = 7;"
msgstr ""

msgid "7261        int m = 9;"
msgstr ""

msgid "7262        void f()"
msgstr ""

msgid "7263        {"
msgstr ""

msgid "7264            array<int, n> a1;"
msgstr ""

msgid "7265            stack_array<int> a2(m);"
msgstr ""

msgid "7266            // ..."
msgstr ""

msgid "7267        }"
msgstr ""

msgid "7268    ##### Enforcement"
msgstr ""

msgid "7269    * Flag arrays with non-constant bounds (C-style VLAs)"
msgstr ""

msgid "7270    * Flag arrays with non-local constant bounds"
msgstr ""

msgid ""
"7271    ### <a name=\"Res-lambda-init\"></a>ES.28: Use lambdas for complex "
"initialization, especially of `const` variables"
msgstr ""

msgid "7272    ##### Reason"
msgstr ""

msgid ""
"7273    It nicely encapsulates local initialization, including cleaning up "
"scratch variables needed only for the initialization, without needing to "
"create a needless nonlocal yet nonreusable function. It also works for "
"variables that should be `const` but only after some initialization work."
msgstr ""

msgid "7274    ##### Example, bad"
msgstr ""

msgid "7275        widget x;   // should be const, but:"
msgstr ""

msgid ""
"7276        for (auto i = 2; i <= N; ++i) {          // this could be some"
msgstr ""

msgid ""
"7277            x += some_obj.do_something_with(i);  // arbitrarily long "
"code"
msgstr ""

msgid ""
"7278        }                                        // needed to initialize "
"x"
msgstr ""

msgid ""
"7279        // from here, x should be const, but we can't say so in code in "
"this style"
msgstr ""

msgid "7280    ##### Example, good"
msgstr ""

msgid "7281        const widget x = [&]{"
msgstr ""

msgid ""
"7282            widget val;                                // assume that "
"widget has a default constructor"
msgstr ""

msgid ""
"7283            for (auto i = 2; i <= N; ++i) {            // this could be "
"some"
msgstr ""

msgid ""
"7284                val += some_obj.do_something_with(i);  // arbitrarily "
"long code"
msgstr ""

msgid ""
"7285            }                                          // needed to "
"initialize x"
msgstr ""

msgid "7286            return val;"
msgstr ""

msgid "7287        }();"
msgstr ""

msgid "7288    ##### Example"
msgstr ""

msgid "7289        string var = [&]{"
msgstr ""

msgid "7290            if (!in) return \"\";   // default"
msgstr ""

msgid "7291            string s;"
msgstr ""

msgid "7292            for (char c : in >> c)"
msgstr ""

msgid "7293                s += toupper(c);"
msgstr ""

msgid "7294            return s;"
msgstr ""

msgid "7295        }(); // note ()"
msgstr ""

msgid ""
"7296    If at all possible, reduce the conditions to a simple set of "
"alternatives (e.g., an `enum`) and don't mix up selection and initialization."
""
msgstr ""

msgid "7297    ##### Enforcement"
msgstr ""

msgid ""
"7298    Hard. At best a heuristic. Look for an uninitialized variable "
"followed by a loop assigning to it."
msgstr ""

msgid ""
"7299    ### <a name=\"Res-macros\"></a>ES.30: Don't use macros for program "
"text manipulation"
msgstr ""

msgid "7300    ##### Reason"
msgstr ""

msgid "7301    Macros are a major source of bugs."
msgstr ""

msgid "7302    Macros don't obey the usual scope and type rules."
msgstr ""

msgid ""
"7303    Macros ensure that the human reader sees something different from "
"what the compiler sees."
msgstr ""

msgid "7304    Macros complicate tool building."
msgstr ""

msgid "7305    ##### Example, bad"
msgstr ""

msgid "7306        #define Case break; case   /* BAD */"
msgstr ""

msgid ""
"7307    This innocuous-looking macro makes a single lower case `c` instead "
"of a `C` into a bad flow-control bug."
msgstr ""

msgid "7308    ##### Note"
msgstr ""

msgid ""
"7309    This rule does not ban the use of macros for \"configuration "
"control\" use in `#ifdef`s, etc."
msgstr ""

msgid "7310    ##### Enforcement"
msgstr ""

msgid ""
"7311    Scream when you see a macro that isn't just used for source control "
"(e.g., `#ifdef`)"
msgstr ""

msgid ""
"7312    ### <a name=\"Res-macros2\"></a>ES.31: Don't use macros for "
"constants or \"functions\""
msgstr ""

msgid "7313    ##### Reason"
msgstr ""

msgid "7314    Macros are a major source of bugs."
msgstr ""

msgid "7315    Macros don't obey the usual scope and type rules."
msgstr ""

msgid "7316    Macros don't obey the usual rules for argument passing."
msgstr ""

msgid ""
"7317    Macros ensure that the human reader sees something different from "
"what the compiler sees."
msgstr ""

msgid "7318    Macros complicate tool building."
msgstr ""

msgid "7319    ##### Example, bad"
msgstr ""

msgid "7320        #define PI 3.14"
msgstr ""

msgid "7321        #define SQUARE(a, b) (a * b)"
msgstr ""

msgid ""
"7322    Even if we hadn't left a well-known bug in `SQUARE` there are much "
"better behaved alternatives; for example:"
msgstr ""

msgid "7323        constexpr double pi = 3.14;"
msgstr ""

msgid "7324        template<typename T> T square(T a, T b) { return a * b; }"
msgstr ""

msgid "7325    ##### Enforcement"
msgstr ""

msgid ""
"7326    Scream when you see a macro that isn't just used for source control "
"(e.g., `#ifdef`)"
msgstr ""

msgid ""
"7327    ### <a name=\"Res-ALL_CAPS\"></a>ES.32: Use `ALL_CAPS` for all macro "
"names"
msgstr ""

msgid "7328    ##### Reason"
msgstr ""

msgid "7329    Convention. Readability. Distinguishing macros."
msgstr ""

msgid "7330    ##### Example"
msgstr ""

msgid "7331        #define forever for (;;)   /* very BAD */"
msgstr ""

msgid ""
"7332        #define FOREVER for (;;)   /* Still evil, but at least visible "
"to humans */"
msgstr ""

msgid "7333    ##### Enforcement"
msgstr ""

msgid "7334    Scream when you see a lower case macro."
msgstr ""

msgid ""
"7335    ### <a name=\"Res-MACROS\"></a>ES.33: If you must use macros, give "
"them unique names"
msgstr ""

msgid "7336    ##### Reason"
msgstr ""

msgid "7337    Macros do not obey scope rules."
msgstr ""

msgid "7338    ##### Example"
msgstr ""

msgid ""
"7339        #define MYCHAR        /* BAD, will eventually clash with someone "
"else's MYCHAR*/"
msgstr ""

msgid ""
"7340        #define ZCORP_CHAR    /* Still evil, but less likely to clash */"
msgstr ""

msgid "7341    ##### Note"
msgstr ""

msgid ""
"7342    Avoid macros if you can: [ES.30](#Res-macros), [ES.31](#Res-"
"macros2), and [ES.32](#Res-ALL_CAPS)."
msgstr ""

msgid ""
"7343    However, there are billions of lines of code littered with macros "
"and a long tradition for using and overusing macros."
msgstr ""

msgid ""
"7344    If you are forced to use macros, use long names and supposedly "
"unique prefixes (e.g., your organization's name) to lower the likelihood of "
"a clash."
msgstr ""

msgid "7345    ##### Enforcement"
msgstr ""

msgid "7346    Warn against short macro names."
msgstr ""

msgid ""
"7347    ### <a name=\"Res-ellipses\"></a> ES.34: Don't define a (C-style) "
"variadic function"
msgstr ""

msgid "7348    ##### Reason"
msgstr ""

msgid "7349    Not type safe."
msgstr ""

msgid "7350    Requires messy cast-and-macro-laden code to get working right."
msgstr ""

msgid "7351    ##### Example"
msgstr ""

msgid "7352        #include <cstdarg>"
msgstr ""

msgid ""
"7353        // \"severity\" followed by a zero-terminated list of char*s; "
"write the C-style strings to cerr"
msgstr ""

msgid "7354        void error(int severity ...)"
msgstr ""

msgid "7355        {"
msgstr ""

msgid ""
"7356            va_list ap;             // a magic type for holding "
"arguments"
msgstr ""

msgid ""
"7357            va_start(ap, severity); // arg startup: \"severity\" is the "
"first argument of error()"
msgstr ""

msgid "7358            for (;;) {"
msgstr ""

msgid ""
"7359                // treat the next var as a char*; no checking: a cast in "
"disguise"
msgstr ""

msgid "7360                char* p = va_arg(ap, char*);"
msgstr ""

msgid "7361                if (!p) break;"
msgstr ""

msgid "7362                cerr << p << ' ';"
msgstr ""

msgid "7363            }"
msgstr ""

msgid ""
"7364            va_end(ap);             // arg cleanup (don't forget this)"
msgstr ""

msgid "7365            cerr << '\\n';"
msgstr ""

msgid "7366            if (severity) exit(severity);"
msgstr ""

msgid "7367        }"
msgstr ""

msgid "7368        void use()"
msgstr ""

msgid "7369        {"
msgstr ""

msgid "7370            error(7, \"this\", \"is\", \"an\", \"error\", nullptr);"
msgstr ""

msgid "7371            error(7); // crash"
msgstr ""

msgid "7372            error(7, \"this\", \"is\", \"an\", \"error\");  // crash"
msgstr ""

msgid "7373            const char* is = \"is\";"
msgstr ""

msgid "7374            string an = \"an\";"
msgstr ""

msgid "7375            error(7, \"this\", \"is\", an, \"error\"); // crash"
msgstr ""

msgid "7376        }"
msgstr ""

msgid "7377    **Alternative**: Overloading. Templates. Variadic templates."
msgstr ""

msgid "7378        #include <iostream>"
msgstr ""

msgid "7379        void error(int severity)"
msgstr ""

msgid "7380        {"
msgstr ""

msgid "7381            std::cerr << '\\n';"
msgstr ""

msgid "7382            std::exit(severity);"
msgstr ""

msgid "7383        }"
msgstr ""

msgid "7384        template <typename T, typename... Ts>"
msgstr ""

msgid "7385        constexpr void error(int severity, T head, Ts... tail)"
msgstr ""

msgid "7386        {"
msgstr ""

msgid "7387            std::cerr << head;"
msgstr ""

msgid "7388            error(severity, tail...);"
msgstr ""

msgid "7389        }"
msgstr ""

msgid "7390        void use()"
msgstr ""

msgid "7391        {"
msgstr ""

msgid "7392            error(7); // No crash!"
msgstr ""

msgid ""
"7393            error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // "
"No crash!"
msgstr ""

msgid "7394            std::string an = \"an\";"
msgstr ""

msgid ""
"7395            error(7, \"this\", \"is\", \"not\", an, \"error\"); // No "
"crash!"
msgstr ""

msgid ""
"7396            error(5, \"oh\", \"no\", nullptr); // Compile error! No need "
"for nullptr."
msgstr ""

msgid "7397        }"
msgstr ""

msgid "7398    ##### Note"
msgstr ""

msgid "7399    This is basically the way `printf` is implemented."
msgstr ""

msgid "7400    ##### Enforcement"
msgstr ""

msgid "7401    * Flag definitions of C-style variadic functions."
msgstr ""

msgid "7402    * Flag `#include <cstdarg>` and `#include <stdarg.h>`"
msgstr ""

msgid "7403    ## ES.expr: Expressions"
msgstr ""

msgid "7404    Expressions manipulate values."
msgstr ""

msgid ""
"7405    ### <a name=\"Res-complicated\"></a>ES.40: Avoid complicated "
"expressions"
msgstr ""

msgid "7406    ##### Reason"
msgstr ""

msgid "7407    Complicated expressions are error-prone."
msgstr ""

msgid "7408    ##### Example"
msgstr ""

msgid "7409        // bad: assignment hidden in subexpression"
msgstr ""

msgid "7410        while ((c = getc()) != -1)"
msgstr ""

msgid ""
"7411        // bad: two non-local variables assigned in a sub-expressions"
msgstr ""

msgid "7412        while ((cin >> c1, cin >> c2), c1 == c2)"
msgstr ""

msgid "7413        // better, but possibly still too complicated"
msgstr ""

msgid "7414        for (char c1, c2; cin >> c1 >> c2 && c1 == c2;)"
msgstr ""

msgid "7415        // OK: if i and j are not aliased"
msgstr ""

msgid "7416        int x = ++i + ++j;"
msgstr ""

msgid "7417        // OK: if i != j and i != k"
msgstr ""

msgid "7418        v[i] = v[j] + v[k];"
msgstr ""

msgid "7419        // bad: multiple assignments \"hidden\" in subexpressions"
msgstr ""

msgid "7420        x = a + (b = f()) + (c = g()) * 7;"
msgstr ""

msgid "7421        // bad: relies on commonly misunderstood precedence rules"
msgstr ""

msgid "7422        x = a & b + c * d && e ^ f == 7;"
msgstr ""

msgid "7423        // bad: undefined behavior"
msgstr ""

msgid "7424        x = x++ + x++ + ++x;"
msgstr ""

msgid ""
"7425    Some of these expressions are unconditionally bad (e.g., they rely "
"on undefined behavior). Others are simply so complicated and/or unusual that "
"even good programmers could misunderstand them or overlook a problem when in "
"a hurry."
msgstr ""

msgid "7426    ##### Note"
msgstr ""

msgid "7427    C++17 tightens up the rules for the order of evaluation"
msgstr ""

msgid ""
"7428    (left-to-right except right-to-left in assignments, and the order of "
"evaluation of function arguments is unspecified; [see ES.43](#Res-order)),"
msgstr ""

msgid ""
"7429    but that doesn't change the fact that complicated expressions are "
"potentially confusing."
msgstr ""

msgid "7430    ##### Note"
msgstr ""

msgid ""
"7431    A programmer should know and use the basic rules for expressions."
msgstr ""

msgid "7432    ##### Example"
msgstr ""

msgid "7433        x = k * y + z;             // OK"
msgstr ""

msgid "7434        auto t1 = k * y;           // bad: unnecessarily verbose"
msgstr ""

msgid "7435        x = t1 + z;"
msgstr ""

msgid "7436        if (0 <= x && x < max)   // OK"
msgstr ""

msgid "7437        auto t1 = 0 <= x;        // bad: unnecessarily verbose"
msgstr ""

msgid "7438        auto t2 = x < max;"
msgstr ""

msgid "7439        if (t1 && t2)            // ..."
msgstr ""

msgid "7440    ##### Enforcement"
msgstr ""

msgid ""
"7441    Tricky. How complicated must an expression be to be considered "
"complicated? Writing computations as statements with one operation each is "
"also confusing. Things to consider:"
msgstr ""

msgid ""
"7442    * side effects: side effects on multiple non-local variables (for "
"some definition of non-local) can be suspect, especially if the side effects "
"are in separate subexpressions"
msgstr ""

msgid "7443    * writes to aliased variables"
msgstr ""

msgid "7444    * more than N operators (and what should N be?)"
msgstr ""

msgid "7445    * reliance of subtle precedence rules"
msgstr ""

msgid ""
"7446    * uses undefined behavior (can we catch all undefined behavior?)"
msgstr ""

msgid "7447    * implementation defined behavior?"
msgstr ""

msgid "7448    * ???"
msgstr ""

msgid ""
"7449    ### <a name=\"Res-parens\"></a>ES.41: If in doubt about operator "
"precedence, parenthesize"
msgstr ""

msgid "7450    ##### Reason"
msgstr ""

msgid ""
"7451    Avoid errors. Readability. Not everyone has the operator table "
"memorized."
msgstr ""

msgid "7452    ##### Example"
msgstr ""

msgid "7453        const unsigned int flag = 2;"
msgstr ""

msgid "7454        unsigned int a = flag;"
msgstr ""

msgid "7455        if (a & flag != 0)  // bad: means a&(flag != 0)"
msgstr ""

msgid ""
"7456    Note: We recommend that programmers know their precedence table for "
"the arithmetic operations, the logical operations, but consider mixing "
"bitwise logical operations with other operators in need of parentheses."
msgstr ""

msgid "7457        if ((a & flag) != 0)  // OK: works as intended"
msgstr ""

msgid "7458    ##### Note"
msgstr ""

msgid "7459    You should know enough not to need parentheses for:"
msgstr ""

msgid "7460        if (a < 0 || a <= max) {"
msgstr ""

msgid "7461            // ..."
msgstr ""

msgid "7462        }"
msgstr ""

msgid "7463    ##### Enforcement"
msgstr ""

msgid ""
"7464    * Flag combinations of bitwise-logical operators and other operators."
""
msgstr ""

msgid "7465    * Flag assignment operators not as the leftmost operator."
msgstr ""

msgid "7466    * ???"
msgstr ""

msgid ""
"7467    ### <a name=\"Res-ptr\"></a>ES.42: Keep use of pointers simple and "
"straightforward"
msgstr ""

msgid "7468    ##### Reason"
msgstr ""

msgid "7469    Complicated pointer manipulation is a major source of errors."
msgstr ""

msgid "7470    ##### Note"
msgstr ""

msgid "7471    Use `gsl::span` instead."
msgstr ""

msgid "7472    Pointers should [only refer to single objects](#Ri-array)."
msgstr ""

msgid ""
"7473    Pointer arithmetic is fragile and easy to get wrong, the source of "
"many, many bad bugs and security violations."
msgstr ""

msgid ""
"7474    `span` is a bounds-checked, safe type for accessing arrays of data."
msgstr ""

msgid ""
"7475    Access into an array with known bounds using a constant as a "
"subscript can be validated by the compiler."
msgstr ""

msgid "7476    ##### Example, bad"
msgstr ""

msgid "7477        void f(int* p, int count)"
msgstr ""

msgid "7478        {"
msgstr ""

msgid "7479            if (count < 2) return;"
msgstr ""

msgid "7480            int* q = p + 1;    // BAD"
msgstr ""

msgid "7481            ptrdiff_t d;"
msgstr ""

msgid "7482            int n;"
msgstr ""

msgid "7483            d = (p - &n);      // OK"
msgstr ""

msgid "7484            d = (q - p);       // OK"
msgstr ""

msgid "7485            int n = *p++;      // BAD"
msgstr ""

msgid "7486            if (count < 6) return;"
msgstr ""

msgid "7487            p[4] = 1;          // BAD"
msgstr ""

msgid "7488            p[count - 1] = 2;  // BAD"
msgstr ""

msgid "7489            use(&p[0], 3);     // BAD"
msgstr ""

msgid "7490        }"
msgstr ""

msgid "7491    ##### Example, good"
msgstr ""

msgid ""
"7492        void f(span<int> a) // BETTER: use span in the function "
"declaration"
msgstr ""

msgid "7493        {"
msgstr ""

msgid "7494            if (a.size() < 2) return;"
msgstr ""

msgid "7495            int n = a[0];      // OK"
msgstr ""

msgid "7496            span<int> q = a.subspan(1); // OK"
msgstr ""

msgid "7497            if (a.size() < 6) return;"
msgstr ""

msgid "7498            a[4] = 1;          // OK"
msgstr ""

msgid "7499            a[a.size() - 1] = 2;  // OK"
msgstr ""

msgid "7500            use(a.data(), 3);  // OK"
msgstr ""

msgid "7501        }"
msgstr ""

msgid "7502    ##### Note"
msgstr ""

msgid ""
"7503    Subscripting with a variable is difficult for both tools and humans "
"to validate as safe."
msgstr ""

msgid ""
"7504    `span` is a run-time bounds-checked, safe type for accessing arrays "
"of data."
msgstr ""

msgid ""
"7505    `at()` is another alternative that ensures single accesses are "
"bounds-checked."
msgstr ""

msgid ""
"7506    If iterators are needed to access an array, use the iterators from a "
"`span` constructed over the array."
msgstr ""

msgid "7507    ##### Example, bad"
msgstr ""

msgid "7508        void f(array<int, 10> a, int pos)"
msgstr ""

msgid "7509        {"
msgstr ""

msgid "7510            a[pos / 2] = 1; // BAD"
msgstr ""

msgid "7511            a[pos - 1] = 2; // BAD"
msgstr ""

msgid ""
"7512            a[-1] = 3;    // BAD (but easily caught by tools) -- no "
"replacement, just don't do this"
msgstr ""

msgid ""
"7513            a[10] = 4;    // BAD (but easily caught by tools) -- no "
"replacement, just don't do this"
msgstr ""

msgid "7514        }"
msgstr ""

msgid "7515    ##### Example, good"
msgstr ""

msgid "7516    Use a `span`:"
msgstr ""

msgid ""
"7517        void f1(span<int, 10> a, int pos) // A1: Change parameter type "
"to use span"
msgstr ""

msgid "7518        {"
msgstr ""

msgid "7519            a[pos / 2] = 1; // OK"
msgstr ""

msgid "7520            a[pos - 1] = 2; // OK"
msgstr ""

msgid "7521        }"
msgstr ""

msgid ""
"7522        void f2(array<int, 10> arr, int pos) // A2: Add local span and "
"use that"
msgstr ""

msgid "7523        {"
msgstr ""

msgid "7524            span<int> a = {arr, pos};"
msgstr ""

msgid "7525            a[pos / 2] = 1; // OK"
msgstr ""

msgid "7526            a[pos - 1] = 2; // OK"
msgstr ""

msgid "7527        }"
msgstr ""

msgid "7528    Use a `at()`:"
msgstr ""

msgid ""
"7529        void f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() "
"for access"
msgstr ""

msgid "7530        {"
msgstr ""

msgid "7531            at(a, pos / 2) = 1; // OK"
msgstr ""

msgid "7532            at(a, pos - 1) = 2; // OK"
msgstr ""

msgid "7533        }"
msgstr ""

msgid "7534    ##### Example, bad"
msgstr ""

msgid "7535        void f()"
msgstr ""

msgid "7536        {"
msgstr ""

msgid "7537            int arr[COUNT];"
msgstr ""

msgid "7538            for (int i = 0; i < COUNT; ++i)"
msgstr ""

msgid ""
"7539                arr[i] = i; // BAD, cannot use non-constant indexer"
msgstr ""

msgid "7540        }"
msgstr ""

msgid "7541    ##### Example, good"
msgstr ""

msgid "7542    Use a `span`:"
msgstr ""

msgid "7543        void f1()"
msgstr ""

msgid "7544        {"
msgstr ""

msgid "7545            int arr[COUNT];"
msgstr ""

msgid "7546            span<int> av = arr;"
msgstr ""

msgid "7547            for (int i = 0; i < COUNT; ++i)"
msgstr ""

msgid "7548                av[i] = i;"
msgstr ""

msgid "7549        }"
msgstr ""

msgid "7550    Use a `span` and range-`for`:"
msgstr ""

msgid "7551        void f1a()"
msgstr ""

msgid "7552        {"
msgstr ""

msgid "7553             int arr[COUNT];"
msgstr ""

msgid "7554             span<int, COUNT> av = arr;"
msgstr ""

msgid "7555             int i = 0;"
msgstr ""

msgid "7556             for (auto& e : av)"
msgstr ""

msgid "7557                 e = i++;"
msgstr ""

msgid "7558        }"
msgstr ""

msgid "7559    Use `at()` for access:"
msgstr ""

msgid "7560        void f2()"
msgstr ""

msgid "7561        {"
msgstr ""

msgid "7562            int arr[COUNT];"
msgstr ""

msgid "7563            for (int i = 0; i < COUNT; ++i)"
msgstr ""

msgid "7564                at(arr, i) = i;"
msgstr ""

msgid "7565        }"
msgstr ""

msgid "7566    Use a range-`for`:"
msgstr ""

msgid "7567        void f3()"
msgstr ""

msgid "7568        {"
msgstr ""

msgid "7569            int arr[COUNT];"
msgstr ""

msgid "7570            for (auto& e : arr)"
msgstr ""

msgid "7571                 e = i++;"
msgstr ""

msgid "7572        }"
msgstr ""

msgid "7573    ##### Note"
msgstr ""

msgid ""
"7574    Tooling can offer rewrites of array accesses that involve dynamic "
"index expressions to use `at()` instead:"
msgstr ""

msgid "7575        static int a[10];"
msgstr ""

msgid "7576        void f(int i, int j)"
msgstr ""

msgid "7577        {"
msgstr ""

msgid "7578            a[i + j] = 12;      // BAD, could be rewritten as ..."
msgstr ""

msgid "7579            at(a, i + j) = 12;  // OK -- bounds-checked"
msgstr ""

msgid "7580        }"
msgstr ""

msgid "7581    ##### Example"
msgstr ""

msgid ""
"7582    Turning an array into a pointer (as the language does essentially "
"always) removes opportunities for checking, so avoid it"
msgstr ""

msgid "7583        void g(int* p);"
msgstr ""

msgid "7584        void f()"
msgstr ""

msgid "7585        {"
msgstr ""

msgid "7586            int a[5];"
msgstr ""

msgid "7587            g(a);        // BAD: are we trying to pass an array?"
msgstr ""

msgid "7588            g(&a[0]);    // OK: passing one object"
msgstr ""

msgid "7589        }"
msgstr ""

msgid "7590    If you want to pass an array, say so:"
msgstr ""

msgid "7591        void g(int* p, size_t length);  // old (dangerous) code"
msgstr ""

msgid "7592        void g1(span<int> av); // BETTER: get g() changed."
msgstr ""

msgid "7593        void f2()"
msgstr ""

msgid "7594        {"
msgstr ""

msgid "7595            int a[5];"
msgstr ""

msgid "7596            span<int> av = a;"
msgstr ""

msgid ""
"7597            g(av.data(), av.size());   // OK, if you have no choice"
msgstr ""

msgid ""
"7598            g1(a);                     // OK -- no decay here, instead "
"use implicit span ctor"
msgstr ""

msgid "7599        }"
msgstr ""

msgid "7600    ##### Enforcement"
msgstr ""

msgid ""
"7601    * Flag any arithmetic operation on an expression of pointer type "
"that results in a value of pointer type."
msgstr ""

msgid ""
"7602    * Flag any indexing expression on an expression or variable of array "
"type (either static array or `std::array`) where the indexer is not a "
"compile-time constant expression with a value between `0` or and the upper "
"bound of the array."
msgstr ""

msgid ""
"7603    * Flag any expression that would rely on implicit conversion of an "
"array type to a pointer type."
msgstr ""

msgid "7604    This rule is part of the [bounds-safety profile](#SS-bounds)."
msgstr ""

msgid ""
"7605    ### <a name=\"Res-order\"></a>ES.43: Avoid expressions with "
"undefined order of evaluation"
msgstr ""

msgid "7606    ##### Reason"
msgstr ""

msgid "7607    You have no idea what such code does. Portability."
msgstr ""

msgid ""
"7608    Even if it does something sensible for you, it may do something "
"different on another compiler (e.g., the next release of your compiler) or "
"with a different optimizer setting."
msgstr ""

msgid "7609    ##### Note"
msgstr ""

msgid "7610    C++17 tightens up the rules for the order of evaluation:"
msgstr ""

msgid ""
"7611    left-to-right except right-to-left in assignments, and the order of "
"evaluation of function arguments is unspecified."
msgstr ""

msgid ""
"7612    However, remember that your code may be compiled with a pre-C++17 "
"compiler (e.g., through cut-and-paste) so don't be too clever."
msgstr ""

msgid "7613    ##### Example"
msgstr ""

msgid "7614        v[i] = ++i;   //  the result is undefined"
msgstr ""

msgid ""
"7615    A good rule of thumb is that you should not read a value twice in an "
"expression where you write to it."
msgstr ""

msgid "7616    ##### Enforcement"
msgstr ""

msgid "7617    Can be detected by a good analyzer."
msgstr ""

msgid ""
"7618    ### <a name=\"Res-order-fct\"></a>ES.44: Don't depend on order of "
"evaluation of function arguments"
msgstr ""

msgid "7619    ##### Reason"
msgstr ""

msgid "7620    Because that order is unspecified."
msgstr ""

msgid "7621    ##### Note"
msgstr ""

msgid ""
"7622    C++17 tightens up the rules for the order of evaluation, but the "
"order of evaluation of function arguments is still unspecified."
msgstr ""

msgid "7623    ##### Example"
msgstr ""

msgid "7624        int i = 0;"
msgstr ""

msgid "7625        f(++i, ++i);"
msgstr ""

msgid ""
"7626    The call will most likely be `f(0, 1)` or `f(1, 0)`, but you don't "
"know which."
msgstr ""

msgid "7627    Technically, the behavior is undefined."
msgstr ""

msgid ""
"7628    In C++17, this code does not have undefined behavior, but it is "
"still not specified which argument is evaluated first."
msgstr ""

msgid "7629    ##### Example"
msgstr ""

msgid "7630    Overloaded operators can lead to order of evaluation problems:"
msgstr ""

msgid "7631        f1()->m(f2());          // m(f1(), f2())"
msgstr ""

msgid ""
"7632        cout << f1() << f2();   // operator<<(operator<<(cout, f1()), "
"f2())"
msgstr ""

msgid ""
"7633    In C++17, these examples work as expected (left to right) and "
"assignments are evaluated right to left (just as ='s binding is right-to-"
"left)"
msgstr ""

msgid ""
"7634        f1() = f2();    // undefined behavior in C++14; in C++17, f2() "
"is evaluated before f1()"
msgstr ""

msgid "7635    ##### Enforcement"
msgstr ""

msgid "7636    Can be detected by a good analyzer."
msgstr ""

msgid ""
"7637    ### <a name=\"Res-magic\"></a>ES.45: Avoid \"magic constants\"; use "
"symbolic constants"
msgstr ""

msgid "7638    ##### Reason"
msgstr ""

msgid ""
"7639    Unnamed constants embedded in expressions are easily overlooked and "
"often hard to understand:"
msgstr ""

msgid "7640    ##### Example"
msgstr ""

msgid ""
"7641        for (int m = 1; m <= 12; ++m)   // don't: magic constant 12"
msgstr ""

msgid "7642            cout << month[m] << '\\n';"
msgstr ""

msgid ""
"7643    No, we don't all know that there are 12 months, numbered 1..12, in a "
"year. Better:"
msgstr ""

msgid "7644        // months are indexed 1..12"
msgstr ""

msgid "7645        constexpr int first_month = 1;"
msgstr ""

msgid "7646        constexpr int last_month = 12;"
msgstr ""

msgid ""
"7647        for (int m = first_month; m <= last_month; ++m)   // better"
msgstr ""

msgid "7648            cout << month[m] << '\\n';"
msgstr ""

msgid "7649    Better still, don't expose constants:"
msgstr ""

msgid "7650        for (auto m : month)"
msgstr ""

msgid "7651            cout << m << '\\n';"
msgstr ""

msgid "7652    ##### Enforcement"
msgstr ""

msgid ""
"7653    Flag literals in code. Give a pass to `0`, `1`, `nullptr`, `\\n`, "
"`\"\"`, and others on a positive list."
msgstr ""

msgid ""
"7654    ### <a name=\"Res-narrowing\"></a>ES.46: Avoid lossy (narrowing, "
"truncating) arithmetic conversions"
msgstr ""

msgid "7655    ##### Reason"
msgstr ""

msgid ""
"7656    A narrowing conversion destroys information, often unexpectedly so."
msgstr ""

msgid "7657    ##### Example, bad"
msgstr ""

msgid "7658    A key example is basic narrowing:"
msgstr ""

msgid "7659        double d = 7.9;"
msgstr ""

msgid "7660        int i = d;    // bad: narrowing: i becomes 7"
msgstr ""

msgid ""
"7661        i = (int) d;  // bad: we're going to claim this is still not "
"explicit enough"
msgstr ""

msgid "7662        void f(int x, long y, double d)"
msgstr ""

msgid "7663        {"
msgstr ""

msgid "7664            char c1 = x;   // bad: narrowing"
msgstr ""

msgid "7665            char c2 = y;   // bad: narrowing"
msgstr ""

msgid "7666            char c3 = d;   // bad: narrowing"
msgstr ""

msgid "7667        }"
msgstr ""

msgid "7668    ##### Note"
msgstr ""

msgid ""
"7669    The guidelines support library offers a `narrow_cast` operation for "
"specifying that narrowing is acceptable and a `narrow` (\"narrow if\") that "
"throws an exception if a narrowing would throw away information:"
msgstr ""

msgid ""
"7670        i = narrow_cast<int>(d);   // OK (you asked for it): narrowing: "
"i becomes 7"
msgstr ""

msgid "7671        i = narrow<int>(d);        // OK: throws narrowing_error"
msgstr ""

msgid ""
"7672    We also include lossy arithmetic casts, such as from a negative "
"floating point type to an unsigned integral type:"
msgstr ""

msgid "7673        double d = -7.9;"
msgstr ""

msgid "7674        unsigned u = 0;"
msgstr ""

msgid "7675        u = d;                          // BAD"
msgstr ""

msgid ""
"7676        u = narrow_cast<unsigned>(d);   // OK (you asked for it): u "
"becomes 0"
msgstr ""

msgid ""
"7677        u = narrow<unsigned>(d);        // OK: throws narrowing_error"
msgstr ""

msgid "7678    ##### Enforcement"
msgstr ""

msgid ""
"7679    A good analyzer can detect all narrowing conversions. However, "
"flagging all narrowing conversions will lead to a lot of false positives. "
"Suggestions:"
msgstr ""

msgid ""
"7680    * flag all floating-point to integer conversions (maybe only `float`-"
">`char` and `double`->`int`. Here be dragons! we need data)"
msgstr ""

msgid ""
"7681    * flag all `long`->`char` (I suspect `int`->`char` is very common. "
"Here be dragons! we need data)"
msgstr ""

msgid ""
"7682    * consider narrowing conversions for function arguments especially "
"suspect"
msgstr ""

msgid ""
"7683    ### <a name=\"Res-nullptr\"></a>ES.47: Use `nullptr` rather than `0` "
"or `NULL`"
msgstr ""

msgid "7684    ##### Reason"
msgstr ""

msgid ""
"7685    Readability. Minimize surprises: `nullptr` cannot be confused with "
"an"
msgstr ""

msgid ""
"7686    `int`. `nullptr` also has a well-specified (very restrictive) type, "
"and thus"
msgstr ""

msgid ""
"7687    works in more scenarios where type deduction might do the wrong "
"thing on `NULL`"
msgstr ""

msgid "7688    or `0`."
msgstr ""

msgid "7689    ##### Example"
msgstr ""

msgid "7690    Consider:"
msgstr ""

msgid "7691        void f(int);"
msgstr ""

msgid "7692        void f(char*);"
msgstr ""

msgid "7693        f(0);         // call f(int)"
msgstr ""

msgid "7694        f(nullptr);   // call f(char*)"
msgstr ""

msgid "7695    ##### Enforcement"
msgstr ""

msgid ""
"7696    Flag uses of `0` and `NULL` for pointers. The transformation may be "
"helped by simple program transformation."
msgstr ""

msgid "7697    ### <a name=\"Res-casts\"></a>ES.48: Avoid casts"
msgstr ""

msgid "7698    ##### Reason"
msgstr ""

msgid ""
"7699    Casts are a well-known source of errors. Make some optimizations "
"unreliable."
msgstr ""

msgid "7700    ##### Example, bad"
msgstr ""

msgid "7701        double d = 2;"
msgstr ""

msgid "7702        auto p = (long*)&d;"
msgstr ""

msgid "7703        auto q = (long long*)&d;"
msgstr ""

msgid "7704        cout << d << ' ' << *p << ' ' << *q << '\\n';"
msgstr ""

msgid ""
"7705    What would you think this fragment prints? The result is at best "
"implementation defined. I got"
msgstr ""

msgid "7706        2 0 4611686018427387904"
msgstr ""

msgid "7707    Adding"
msgstr ""

msgid "7708        *q = 666;"
msgstr ""

msgid "7709        cout << d << ' ' << *p << ' ' << *q << '\\n';"
msgstr ""

msgid "7710    I got"
msgstr ""

msgid "7711        3.29048e-321 666 666"
msgstr ""

msgid "7712    Surprised? I'm just glad I didn't crash the program."
msgstr ""

msgid "7713    ##### Note"
msgstr ""

msgid ""
"7714    Programmers who write casts typically assume that they know what "
"they are doing,"
msgstr ""

msgid "7715    or that writing a cast makes the program \"easier to read\"."
msgstr ""

msgid ""
"7716    In fact, they often disable the general rules for using values."
msgstr ""

msgid ""
"7717    Overload resolution and template instantiation usually pick the "
"right function if there is a right function to pick."
msgstr ""

msgid ""
"7718    If there is not, maybe there ought to be, rather than applying a "
"local fix (cast)."
msgstr ""

msgid "7719    ##### Note"
msgstr ""

msgid ""
"7720    Casts are necessary in a systems programming language.  For example, "
"how else"
msgstr ""

msgid ""
"7721    would we get the address of a device register into a pointer?  "
"However, casts"
msgstr ""

msgid "7722    are seriously overused as well as a major source of errors."
msgstr ""

msgid "7723    ##### Note"
msgstr ""

msgid ""
"7724    If you feel the need for a lot of casts, there may be a fundamental "
"design problem."
msgstr ""

msgid "7725    ##### Exception"
msgstr ""

msgid ""
"7726    Casting to `(void)` is the Standard-sanctioned way to turn off "
"`[[nodiscard]]` warnings. If you are calling a function with a "
"`[[nodiscard]]` return and you deliberately want to discard the result, "
"first think hard about whether that is really a good idea (there is usually "
"a good reason the author of the function or of the return type used "
"`[[nodiscard]]` in the first place), but if you still think it's appropriate "
"and your code reviewer agrees, write `(void)` to turn off the warning."
msgstr ""

msgid "7727    ##### Alternatives"
msgstr ""

msgid ""
"7728    Casts are widely (mis) used. Modern C++ has rules and constructs "
"that eliminate the need for casts in many contexts, such as"
msgstr ""

msgid "7729    * Use templates"
msgstr ""

msgid "7730    * Use `std::variant`"
msgstr ""

msgid ""
"7731    * Rely on the well-defined, safe, implicit conversions between "
"pointer types"
msgstr ""

msgid "7732    ##### Enforcement"
msgstr ""

msgid ""
"7733    * Force the elimination of C-style casts, except on a function with "
"a `[[nodiscard]]` return"
msgstr ""

msgid ""
"7734    * Warn if there are many functional style casts (there is an obvious "
"problem in quantifying 'many')"
msgstr ""

msgid ""
"7735    * The [type profile](#Pro-type-reinterpretcast) bans "
"`reinterpret_cast`."
msgstr ""

msgid ""
"7736    * Warn against [identity casts](#Pro-type-identitycast) between "
"pointer types, where the source and target types are the same (#Pro-type-"
"identitycast)"
msgstr ""

msgid ""
"7737    * Warn if a pointer cast could be [implicit](#Pro-type-"
"implicitpointercast)"
msgstr ""

msgid ""
"7738    ### <a name=\"Res-casts-named\"></a>ES.49: If you must use a cast, "
"use a named cast"
msgstr ""

msgid "7739    ##### Reason"
msgstr ""

msgid "7740    Readability. Error avoidance."
msgstr ""

msgid ""
"7741    Named casts are more specific than a C-style or functional cast, "
"allowing the compiler to catch some errors."
msgstr ""

msgid "7742    The named casts are:"
msgstr ""

msgid "7743    * `static_cast`"
msgstr ""

msgid "7744    * `const_cast`"
msgstr ""

msgid "7745    * `reinterpret_cast`"
msgstr ""

msgid "7746    * `dynamic_cast`"
msgstr ""

msgid ""
"7747    * `std::move`         // `move(x)` is an rvalue reference to `x`"
msgstr ""

msgid ""
"7748    * `std::forward`      // `forward(x)` is an rvalue reference to `x`"
msgstr ""

msgid ""
"7749    * `gsl::narrow_cast`  // `narrow_cast<T>(x)` is `static_cast<T>(x)`"
msgstr ""

msgid ""
"7750    * `gsl::narrow`       // `narrow<T>(x)` is `static_cast<T>(x)` if "
"`static_cast<T>(x) == x` or it throws `narrowing_error`"
msgstr ""

msgid "7751    ##### Example"
msgstr ""

msgid "7752        class B { /* ... */ };"
msgstr ""

msgid "7753        class D { /* ... */ };"
msgstr ""

msgid "7754        template<typename D> D* upcast(B* pb)"
msgstr ""

msgid "7755        {"
msgstr ""

msgid ""
"7756            D* pd0 = pb;                        // error: no implicit "
"conversion from B* to D*"
msgstr ""

msgid ""
"7757            D* pd1 = (D*)pb;                    // legal, but what is "
"done?"
msgstr ""

msgid ""
"7758            D* pd2 = static_cast<D*>(pb);       // error: D is not "
"derived from B"
msgstr ""

msgid ""
"7759            D* pd3 = reinterpret_cast<D*>(pb);  // OK: on your head be "
"it!"
msgstr ""

msgid ""
"7760            D* pd4 = dynamic_cast<D*>(pb);      // OK: return nullptr"
msgstr ""

msgid "7761            // ..."
msgstr ""

msgid "7762        }"
msgstr ""

msgid ""
"7763    The example was synthesized from real-world bugs where `D` used to "
"be derived from `B`, but someone refactored the hierarchy."
msgstr ""

msgid ""
"7764    The C-style cast is dangerous because it can do any kind of "
"conversion, depriving us of any protection from mistakes (now or in the "
"future)."
msgstr ""

msgid "7765    ##### Note"
msgstr ""

msgid ""
"7766    When converting between types with no information loss (e.g. from "
"`float` to"
msgstr ""

msgid ""
"7767    `double` or `int64` from `int32`), brace initialization may be used "
"instead."
msgstr ""

msgid "7768        double d {some_float};"
msgstr ""

msgid "7769        int64_t i {some_int32};"
msgstr ""

msgid ""
"7770    This makes it clear that the type conversion was intended and also "
"prevents"
msgstr ""

msgid ""
"7771    conversions between types that might result in loss of precision. "
"(It is a"
msgstr ""

msgid ""
"7772    compilation error to try to initialize a `float` from a `double` in "
"this fashion,"
msgstr ""

msgid "7773    for example.)"
msgstr ""

msgid "7774    ##### Note"
msgstr ""

msgid ""
"7775    `reinterpret_cast` can be essential, but the essential uses (e.g., "
"turning a machine address into pointer) are not type safe:"
msgstr ""

msgid ""
"7776        auto p = reinterpret_cast<Device_register>(0x800);  // "
"inherently dangerous"
msgstr ""

msgid "7777    ##### Enforcement"
msgstr ""

msgid "7778    * Flag C-style and functional casts."
msgstr ""

msgid ""
"7779    * The [type profile](#Pro-type-reinterpretcast) bans "
"`reinterpret_cast`."
msgstr ""

msgid ""
"7780    * The [type profile](#Pro-type-arithmeticcast) warns when using "
"`static_cast` between arithmetic types."
msgstr ""

msgid ""
"7781    ### <a name=\"Res-casts-const\"></a>ES.50: Don't cast away `const`"
msgstr ""

msgid "7782    ##### Reason"
msgstr ""

msgid "7783    It makes a lie out of `const`."
msgstr ""

msgid ""
"7784    If the variable is actually declared `const`, the result of "
"\"casting away `const`\" is undefined behavior."
msgstr ""

msgid "7785    ##### Example, bad"
msgstr ""

msgid "7786        void f(const int& i)"
msgstr ""

msgid "7787        {"
msgstr ""

msgid "7788            const_cast<int&>(i) = 42;   // BAD"
msgstr ""

msgid "7789        }"
msgstr ""

msgid "7790        static int i = 0;"
msgstr ""

msgid "7791        static const int j = 0;"
msgstr ""

msgid "7792        f(i); // silent side effect"
msgstr ""

msgid "7793        f(j); // undefined behavior"
msgstr ""

msgid "7794    ##### Example"
msgstr ""

msgid ""
"7795    Sometimes, you may be tempted to resort to `const_cast` to avoid "
"code duplication, such as when two accessor functions that differ only in "
"`const`-ness have similar implementations. For example:"
msgstr ""

msgid "7796        class Bar;"
msgstr ""

msgid "7797        class Foo {"
msgstr ""

msgid "7798        public:"
msgstr ""

msgid "7799            // BAD, duplicates logic"
msgstr ""

msgid "7800            Bar& get_bar() {"
msgstr ""

msgid ""
"7801                /* complex logic around getting a non-const reference to "
"my_bar */"
msgstr ""

msgid "7802            }"
msgstr ""

msgid "7803            const Bar& get_bar() const {"
msgstr ""

msgid ""
"7804                /* same complex logic around getting a const reference "
"to my_bar */"
msgstr ""

msgid "7805            }"
msgstr ""

msgid "7806        private:"
msgstr ""

msgid "7807            Bar my_bar;"
msgstr ""

msgid "7808        };"
msgstr ""

msgid ""
"7809    Instead, prefer to share implementations. Normally, you can just "
"have the non-`const` function call the `const` function. However, when there "
"is complex logic this can lead to the following pattern that still resorts "
"to a `const_cast`:"
msgstr ""

msgid "7810        class Foo {"
msgstr ""

msgid "7811        public:"
msgstr ""

msgid ""
"7812            // not great, non-const calls const version but resorts to "
"const_cast"
msgstr ""

msgid "7813            Bar& get_bar() {"
msgstr ""

msgid ""
"7814                return const_cast<Bar&>(static_cast<const Foo&>(*this)."
"get_bar());"
msgstr ""

msgid "7815            }"
msgstr ""

msgid "7816            const Bar& get_bar() const {"
msgstr ""

msgid ""
"7817                /* the complex logic around getting a const reference to "
"my_bar */"
msgstr ""

msgid "7818            }"
msgstr ""

msgid "7819        private:"
msgstr ""

msgid "7820            Bar my_bar;"
msgstr ""

msgid "7821        };"
msgstr ""

msgid ""
"7822    Although this pattern is safe when applied correctly, because the "
"caller must have had a non-`const` object to begin with, it's not ideal "
"because the safety is hard to enforce automatically as a checker rule."
msgstr ""

msgid ""
"7823    Instead, prefer to put the common code in a common helper function --"
" and make it a template so that it deduces `const`. This doesn't use any "
"`const_cast` at all:"
msgstr ""

msgid "7824        class Foo {"
msgstr ""

msgid "7825        public:                         // good"
msgstr ""

msgid ""
"7826                  Bar& get_bar()       { return get_bar_impl(*this); }"
msgstr ""

msgid ""
"7827            const Bar& get_bar() const { return get_bar_impl(*this); }"
msgstr ""

msgid "7828        private:"
msgstr ""

msgid "7829            Bar my_bar;"
msgstr ""

msgid ""
"7830            template<class T>           // good, deduces whether T is "
"const or non-const"
msgstr ""

msgid ""
"7831            static auto get_bar_impl(T& t) -> decltype(t.get_bar())"
msgstr ""

msgid ""
"7832                { /* the complex logic around getting a possibly-const "
"reference to my_bar */ }"
msgstr ""

msgid "7833        };"
msgstr ""

msgid "7834    ##### Exception"
msgstr ""

msgid ""
"7835    You may need to cast away `const` when calling `const`-incorrect "
"functions."
msgstr ""

msgid ""
"7836    Prefer to wrap such functions in inline `const`-correct wrappers to "
"encapsulate the cast in one place."
msgstr ""

msgid "7837    ##### Example"
msgstr ""

msgid ""
"7838    Sometimes, \"cast away `const`\" is to allow the updating of some "
"transient information of an otherwise immutable object."
msgstr ""

msgid "7839    Examples are caching, memoization, and precomputation."
msgstr ""

msgid ""
"7840    Such examples are often handled as well or better using `mutable` or "
"an indirection than with a `const_cast`."
msgstr ""

msgid ""
"7841    Consider keeping previously computed results around for a costly "
"operation:"
msgstr ""

msgid ""
"7842        int compute(int x); // compute a value for x; assume this to be "
"costly"
msgstr ""

msgid ""
"7843        class Cache {   // some type implementing a cache for an int-"
">int operation"
msgstr ""

msgid "7844        public:"
msgstr ""

msgid ""
"7845            pair<bool, int> find(int x) const;   // is there a value for "
"x?"
msgstr ""

msgid ""
"7846            void set(int x, int v);             // make y the value for "
"x"
msgstr ""

msgid "7847            // ..."
msgstr ""

msgid "7848        private:"
msgstr ""

msgid "7849            // ..."
msgstr ""

msgid "7850        };"
msgstr ""

msgid "7851        class X {"
msgstr ""

msgid "7852        public:"
msgstr ""

msgid "7853            int get_val(int x)"
msgstr ""

msgid "7854            {"
msgstr ""

msgid "7855                auto p = cache.find(x);"
msgstr ""

msgid "7856                if (p.first) return p.second;"
msgstr ""

msgid "7857                int val = compute(x);"
msgstr ""

msgid "7858                cache.set(x, val); // insert value for x"
msgstr ""

msgid "7859                return val;"
msgstr ""

msgid "7860            }"
msgstr ""

msgid "7861            // ..."
msgstr ""

msgid "7862        private:"
msgstr ""

msgid "7863            Cache cache;"
msgstr ""

msgid "7864        };"
msgstr ""

msgid ""
"7865    Here, `get_val()` is logically constant, so we would like to make it "
"a `const` member."
msgstr ""

msgid ""
"7866    To do this we still need to mutate `cache`, so people sometimes "
"resort to a `const_cast`:"
msgstr ""

msgid "7867        class X {   // Suspicious solution based on casting"
msgstr ""

msgid "7868        public:"
msgstr ""

msgid "7869            int get_val(int x) const"
msgstr ""

msgid "7870            {"
msgstr ""

msgid "7871                auto p = cache.find(x);"
msgstr ""

msgid "7872                if (p.first) return p.second;"
msgstr ""

msgid "7873                int val = compute(x);"
msgstr ""

msgid "7874                const_cast<Cache&>(cache).set(x, val);   // ugly"
msgstr ""

msgid "7875                return val;"
msgstr ""

msgid "7876            }"
msgstr ""

msgid "7877            // ..."
msgstr ""

msgid "7878        private:"
msgstr ""

msgid "7879            Cache cache;"
msgstr ""

msgid "7880        };"
msgstr ""

msgid "7881    Fortunately, there is a better solution:"
msgstr ""

msgid "7882    State that `cache` is mutable even for a `const` object:"
msgstr ""

msgid "7883        class X {   // better solution"
msgstr ""

msgid "7884        public:"
msgstr ""

msgid "7885            int get_val(int x) const"
msgstr ""

msgid "7886            {"
msgstr ""

msgid "7887                auto p = cache.find(x);"
msgstr ""

msgid "7888                if (p.first) return p.second;"
msgstr ""

msgid "7889                int val = compute(x);"
msgstr ""

msgid "7890                cache.set(x, val);"
msgstr ""

msgid "7891                return val;"
msgstr ""

msgid "7892            }"
msgstr ""

msgid "7893            // ..."
msgstr ""

msgid "7894        private:"
msgstr ""

msgid "7895            mutable Cache cache;"
msgstr ""

msgid "7896        };"
msgstr ""

msgid ""
"7897    An alternative solution would to store a pointer to the `cache`:"
msgstr ""

msgid "7898        class X {   // OK, but slightly messier solution"
msgstr ""

msgid "7899        public:"
msgstr ""

msgid "7900            int get_val(int x) const"
msgstr ""

msgid "7901            {"
msgstr ""

msgid "7902                auto p = cache->find(x);"
msgstr ""

msgid "7903                if (p.first) return p.second;"
msgstr ""

msgid "7904                int val = compute(x);"
msgstr ""

msgid "7905                cache->set(x, val);"
msgstr ""

msgid "7906                return val;"
msgstr ""

msgid "7907            }"
msgstr ""

msgid "7908            // ..."
msgstr ""

msgid "7909        private:"
msgstr ""

msgid "7910            unique_ptr<Cache> cache;"
msgstr ""

msgid "7911        };"
msgstr ""

msgid ""
"7912    That solution is the most flexible, but requires explicit "
"construction and destruction of `*cache`"
msgstr ""

msgid "7913    (most likely in the constructor and destructor of `X`)."
msgstr ""

msgid ""
"7914    In any variant, we must guard against data races on the `cache` in "
"multi-threaded code, possibly using a `std::mutex`."
msgstr ""

msgid "7915    ##### Enforcement"
msgstr ""

msgid "7916    * Flag `const_cast`s."
msgstr ""

msgid ""
"7917    * This rule is part of the [type-safety profile](#Pro-type-"
"constcast) for the related Profile."
msgstr ""

msgid ""
"7918    ### <a name=\"Res-range-checking\"></a>ES.55: Avoid the need for "
"range checking"
msgstr ""

msgid "7919    ##### Reason"
msgstr ""

msgid ""
"7920    Constructs that cannot overflow do not overflow (and usually run "
"faster):"
msgstr ""

msgid "7921    ##### Example"
msgstr ""

msgid "7922        for (auto& x : v)      // print all elements of v"
msgstr ""

msgid "7923            cout << x << '\\n';"
msgstr ""

msgid "7924        auto p = find(v, x);   // find x in v"
msgstr ""

msgid "7925    ##### Enforcement"
msgstr ""

msgid ""
"7926    Look for explicit range checks and heuristically suggest "
"alternatives."
msgstr ""

msgid ""
"7927    ### <a name=\"Res-move\"></a>ES.56: Write `std::move()` only when "
"you need to explicitly move an object to another scope"
msgstr ""

msgid "7928    ##### Reason"
msgstr ""

msgid ""
"7929    We move, rather than copy, to avoid duplication and for improved "
"performance."
msgstr ""

msgid ""
"7930    A move typically leaves behind an empty object ([C.64](#Rc-move-"
"semantic)), which can be surprising or even dangerous, so we try to avoid "
"moving from lvalues (they might be accessed later)."
msgstr ""

msgid "7931    ##### Notes"
msgstr ""

msgid ""
"7932    Moving is done implicitly when the source is an rvalue (e.g., value "
"in a `return` treatment or a function result), so don't pointlessly "
"complicate code in those cases by writing `move` explicitly. Instead, write "
"short functions that return values, and both the function's return and the "
"caller's accepting of the return will be optimized naturally."
msgstr ""

msgid ""
"7933    In general, following the guidelines in this document (including not "
"making variables' scopes needlessly large, writing short functions that "
"return values, returning local variables) help eliminate most need for "
"explicit `std::move`."
msgstr ""

msgid ""
"7934    Explicit `move` is needed to explicitly move an object to another "
"scope, notably to pass it to a \"sink\" function and in the implementations "
"of the move operations themselves (move constructor, move assignment "
"operator) and swap operations."
msgstr ""

msgid "7935    ##### Example, bad"
msgstr ""

msgid "7936        void sink(X&& x);   // sink takes ownership of x"
msgstr ""

msgid "7937        void user()"
msgstr ""

msgid "7938        {"
msgstr ""

msgid "7939            X x;"
msgstr ""

msgid "7940            // error: cannot bind an lvalue to a rvalue reference"
msgstr ""

msgid "7941            sink(x);"
msgstr ""

msgid ""
"7942            // OK: sink takes the contents of x, x must now be assumed "
"to be empty"
msgstr ""

msgid "7943            sink(std::move(x));"
msgstr ""

msgid "7944            // ..."
msgstr ""

msgid "7945            // probably a mistake"
msgstr ""

msgid "7946            use(x);"
msgstr ""

msgid "7947        }"
msgstr ""

msgid ""
"7948    Usually, a `std::move()` is used as an argument to a `&&` parameter."
msgstr ""

msgid ""
"7949    And after you do that, assume the object has been moved from (see [C."
"64](#Rc-move-semantic)) and don't read its state again until you first set "
"it to a new value."
msgstr ""

msgid "7950        void f() {"
msgstr ""

msgid "7951            string s1 = \"supercalifragilisticexpialidocious\";"
msgstr ""

msgid "7952            string s2 = s1;             // ok, takes a copy"
msgstr ""

msgid ""
"7953            assert(s1 == \"supercalifragilisticexpialidocious\");  // ok"
msgstr ""

msgid "7954            // bad, if you want to keep using s1's value"
msgstr ""

msgid "7955            string s3 = move(s1);"
msgstr ""

msgid "7956            // bad, assert will likely fail, s1 likely changed"
msgstr ""

msgid "7957            assert(s1 == \"supercalifragilisticexpialidocious\");"
msgstr ""

msgid "7958        }"
msgstr ""

msgid "7959    ##### Example"
msgstr ""

msgid ""
"7960        void sink(unique_ptr<widget> p);  // pass ownership of p to "
"sink()"
msgstr ""

msgid "7961        void f() {"
msgstr ""

msgid "7962            auto w = make_unique<widget>();"
msgstr ""

msgid "7963            // ..."
msgstr ""

msgid ""
"7964            sink(std::move(w));               // ok, give to sink()"
msgstr ""

msgid "7965            // ..."
msgstr ""

msgid ""
"7966            sink(w);    // Error: unique_ptr is carefully designed so "
"that you cannot copy it"
msgstr ""

msgid "7967        }"
msgstr ""

msgid "7968    ##### Notes"
msgstr ""

msgid ""
"7969    `std::move()` is a cast to `&&` in disguise; it doesn't itself move "
"anything, but marks a named object as a candidate that can be moved from."
msgstr ""

msgid ""
"7970    The language already knows the common cases where objects can be "
"moved from, especially when returning values from functions, so don't "
"complicate code with redundant `std::move()`'s."
msgstr ""

msgid ""
"7971    Never write `std::move()` just because you've heard \"it's more "
"efficient.\""
msgstr ""

msgid ""
"7972    In general, don't believe claims of \"efficiency\" without data "
"(???)."
msgstr ""

msgid "7973    In general, don't complicate your code without reason (??)"
msgstr ""

msgid "7974    ##### Example, bad"
msgstr ""

msgid "7975        vector<int> make_vector() {"
msgstr ""

msgid "7976            vector<int> result;"
msgstr ""

msgid "7977            // ... load result with data"
msgstr ""

msgid ""
"7978            return std::move(result);       // bad; just write \"return "
"result;\""
msgstr ""

msgid "7979        }"
msgstr ""

msgid ""
"7980    Never write `return move(local_variable);`, because the language "
"already knows the variable is a move candidate."
msgstr ""

msgid ""
"7981    Writing `move` in this code won't help, and can actually be "
"detrimental because on some compilers it interferes with RVO (the return "
"value optimization) by creating an additional reference alias to the local "
"variable."
msgstr ""

msgid "7982    ##### Example, bad"
msgstr ""

msgid ""
"7983        vector<int> v = std::move(make_vector());   // bad; the std::"
"move is entirely redundant"
msgstr ""

msgid ""
"7984    Never write `move` on a returned value such as `x = move(f());` "
"where `f` returns by value."
msgstr ""

msgid ""
"7985    The language already knows that a returned value is a temporary "
"object that can be moved from."
msgstr ""

msgid "7986    ##### Example"
msgstr ""

msgid "7987        void mover(X&& x) {"
msgstr ""

msgid "7988            call_something(std::move(x));         // ok"
msgstr ""

msgid ""
"7989            call_something(std::forward<X>(x));   // bad, don't std::"
"forward an rvalue reference"
msgstr ""

msgid ""
"7990            call_something(x);                    // suspicious, why not "
"std::move?"
msgstr ""

msgid "7991        }"
msgstr ""

msgid "7992        template<class T>"
msgstr ""

msgid "7993        void forwarder(T&& t) {"
msgstr ""

msgid ""
"7994            call_something(std::move(t));         // bad, don't std::"
"move a forwarding reference"
msgstr ""

msgid "7995            call_something(std::forward<T>(t));   // ok"
msgstr ""

msgid ""
"7996            call_something(t);                    // suspicious, why not "
"std::forward?"
msgstr ""

msgid "7997        }"
msgstr ""

msgid "7998    ##### Enforcement"
msgstr ""

msgid ""
"7999    * Flag use of `std::move(x)` where `x` is an rvalue or the language "
"will already treat it as an rvalue, including `return std::"
"move(local_variable);` and `std::move(f())` on a function that returns by "
"value."
msgstr ""

msgid ""
"8000    * Flag functions taking an `S&&` parameter if there is no `const S&` "
"overload to take care of lvalues."
msgstr ""

msgid ""
"8001    * Flag a `std::move`s argument passed to a parameter, except when "
"the parameter type is one of the following: an `X&&` rvalue reference; a "
"`T&&` forwarding reference where `T` is a template parameter type; or by "
"value and the type is move-only."
msgstr ""

msgid ""
"8002    * Flag when `std::move` is applied to a forwarding reference (`T&&` "
"where `T` is a template parameter type). Use `std::forward` instead."
msgstr ""

msgid ""
"8003    * Flag when `std::move` is applied to other than an rvalue reference."
" (More general case of the previous rule to cover the non-forwarding cases.)"
msgstr ""

msgid ""
"8004    * Flag when `std::forward` is applied to an rvalue reference (`X&&` "
"where `X` is a concrete type). Use `std::move` instead."
msgstr ""

msgid ""
"8005    * Flag when `std::forward` is applied to other than a forwarding "
"reference. (More general case of the previous rule to cover the non-moving "
"cases.)"
msgstr ""

msgid ""
"8006    * Flag when an object is potentially moved from and the next "
"operation is a `const` operation; there should first be an intervening non-"
"`const` operation, ideally assignment, to first reset the object's value."
msgstr ""

msgid ""
"8007    ### <a name=\"Res-new\"></a>ES.60: Avoid `new` and `delete` outside "
"resource management functions"
msgstr ""

msgid "8008    ##### Reason"
msgstr ""

msgid ""
"8009    Direct resource management in application code is error-prone and "
"tedious."
msgstr ""

msgid "8010    ##### Note"
msgstr ""

msgid "8011    also known as \"No naked `new`!\""
msgstr ""

msgid "8012    ##### Example, bad"
msgstr ""

msgid "8013        void f(int n)"
msgstr ""

msgid "8014        {"
msgstr ""

msgid "8015            auto p = new X[n];   // n default constructed Xs"
msgstr ""

msgid "8016            // ..."
msgstr ""

msgid "8017            delete[] p;"
msgstr ""

msgid "8018        }"
msgstr ""

msgid ""
"8019    There can be code in the `...` part that causes the `delete` never "
"to happen."
msgstr ""

msgid "8020    **See also**: [R: Resource management](#S-resource)"
msgstr ""

msgid "8021    ##### Enforcement"
msgstr ""

msgid "8022    Flag naked `new`s and naked `delete`s."
msgstr ""

msgid ""
"8023    ### <a name=\"Res-del\"></a>ES.61: Delete arrays using `delete[]` "
"and non-arrays using `delete`"
msgstr ""

msgid "8024    ##### Reason"
msgstr ""

msgid ""
"8025    That's what the language requires and mistakes can lead to resource "
"release errors and/or memory corruption."
msgstr ""

msgid "8026    ##### Example, bad"
msgstr ""

msgid "8027        void f(int n)"
msgstr ""

msgid "8028        {"
msgstr ""

msgid "8029            auto p = new X[n];   // n default constructed Xs"
msgstr ""

msgid "8030            // ..."
msgstr ""

msgid ""
"8031            delete p;   // error: just delete the object p, rather than "
"delete the array p[]"
msgstr ""

msgid "8032        }"
msgstr ""

msgid "8033    ##### Note"
msgstr ""

msgid ""
"8034    This example not only violates the [no naked `new` rule](#Res-new) "
"as in the previous example, it has many more problems."
msgstr ""

msgid "8035    ##### Enforcement"
msgstr ""

msgid ""
"8036    * if the `new` and the `delete` is in the same scope, mistakes can "
"be flagged."
msgstr ""

msgid ""
"8037    * if the `new` and the `delete` are in a constructor/destructor "
"pair, mistakes can be flagged."
msgstr ""

msgid ""
"8038    ### <a name=\"Res-arr2\"></a>ES.62: Don't compare pointers into "
"different arrays"
msgstr ""

msgid "8039    ##### Reason"
msgstr ""

msgid "8040    The result of doing so is undefined."
msgstr ""

msgid "8041    ##### Example, bad"
msgstr ""

msgid "8042        void f(int n)"
msgstr ""

msgid "8043        {"
msgstr ""

msgid "8044            int a1[7];"
msgstr ""

msgid "8045            int a2[9];"
msgstr ""

msgid "8046            if (&a1[5] < &a2[7]) {}       // bad: undefined"
msgstr ""

msgid "8047            if (0 < &a1[5] - &a2[7]) {}   // bad: undefined"
msgstr ""

msgid "8048        }"
msgstr ""

msgid "8049    ##### Note"
msgstr ""

msgid "8050    This example has many more problems."
msgstr ""

msgid "8051    ##### Enforcement"
msgstr ""

msgid "8052    ???"
msgstr ""

msgid "8053    ### <a name=\"Res-slice\"></a>ES.63: Don't slice"
msgstr ""

msgid "8054    ##### Reason"
msgstr ""

msgid ""
"8055    Slicing -- that is, copying only part of an object using assignment "
"or initialization -- most often leads to errors because"
msgstr ""

msgid "8056    the object was meant to be considered as a whole."
msgstr ""

msgid ""
"8057    In the rare cases where the slicing was deliberate the code can be "
"surprising."
msgstr ""

msgid "8058    ##### Example"
msgstr ""

msgid "8059        class Shape { /* ... */ };"
msgstr ""

msgid "8060        class Circle : public Shape { /* ... */ Point c; int r; };"
msgstr ""

msgid "8061        Circle c {{0, 0}, 42};"
msgstr ""

msgid "8062        Shape s {c};    // copy Shape part of Circle"
msgstr ""

msgid ""
"8063    The result will be meaningless because the center and radius will "
"not be copied from `c` into `s`."
msgstr ""

msgid ""
"8064    The first defense against this is to [define the base class `Shape` "
"not to allow this](#Rc-copy-virtual)."
msgstr ""

msgid "8065    ##### Alternative"
msgstr ""

msgid "8066    If you mean to slice, define an explicit operation to do so."
msgstr ""

msgid "8067    This saves readers from confusion."
msgstr ""

msgid "8068    For example:"
msgstr ""

msgid "8069        class Smiley : public Circle {"
msgstr ""

msgid "8070            public:"
msgstr ""

msgid "8071            Circle copy_circle();"
msgstr ""

msgid "8072            // ..."
msgstr ""

msgid "8073        };"
msgstr ""

msgid "8074        Smiley sm { /* ... */ };"
msgstr ""

msgid ""
"8075        Circle c1 {sm};  // ideally prevented by the definition of "
"Circle"
msgstr ""

msgid "8076        Circle c2 {sm.copy_circle()};"
msgstr ""

msgid "8077    ##### Enforcement"
msgstr ""

msgid "8078    Warn against slicing."
msgstr ""

msgid ""
"8079    ### <a name=\"Res-construct\"></a>ES.64: Use the `T{e}`notation for "
"construction"
msgstr ""

msgid "8080    ##### Reason"
msgstr ""

msgid ""
"8081    The `T{e}` construction syntax makes it explicit that construction "
"is desired."
msgstr ""

msgid "8082    The `T{e}` construction syntax doesn't allow narrowing."
msgstr ""

msgid ""
"8083    `T{e}` is the only safe and general expression for constructing a "
"value of type `T` from an expression `e`."
msgstr ""

msgid ""
"8084    The casts notations `T(e)` and `(T)e` are neither safe nor general."
msgstr ""

msgid "8085    ##### Example"
msgstr ""

msgid ""
"8086    For built-in types, the construction notation protects against "
"narrowing and reinterpretation"
msgstr ""

msgid "8087        void use(char ch, int i, double d, char* p, long long lng)"
msgstr ""

msgid "8088        {"
msgstr ""

msgid "8089            int x1 = int{ch};     // OK, but redundant"
msgstr ""

msgid ""
"8090            int x2 = int{d};      // error: double->int narrowing; use a "
"cast if you need to"
msgstr ""

msgid ""
"8091            int x3 = int{p};      // error: pointer to->int; use a "
"reinterpret_cast if you really need to"
msgstr ""

msgid ""
"8092            int x4 = int{lng};    // error: long long->int narrowing; "
"use a cast if you need to"
msgstr ""

msgid "8093            int y1 = int(ch);     // OK, but redundant"
msgstr ""

msgid ""
"8094            int y2 = int(d);      // bad: double->int narrowing; use a "
"cast if you need to"
msgstr ""

msgid ""
"8095            int y3 = int(p);      // bad: pointer to->int; use a "
"reinterpret_cast if you really need to"
msgstr ""

msgid ""
"8096            int y4 = int(lng);    // bad: long long->int narrowing; use "
"a cast if you need to"
msgstr ""

msgid "8097            int z1 = (int)ch;     // OK, but redundant"
msgstr ""

msgid ""
"8098            int z2 = (int)d;      // bad: double->int narrowing; use a "
"cast if you need to"
msgstr ""

msgid ""
"8099            int z3 = (int)p;      // bad: pointer to->int; use a "
"reinterpret_cast if you really need to"
msgstr ""

msgid ""
"8100            int z4 = (int)lng;    // bad: long long->int narrowing; use "
"a cast if you need to"
msgstr ""

msgid "8101        }"
msgstr ""

msgid ""
"8102    The integer to/from pointer conversions are implementation defined "
"when using the `T(e)` or `(T)e` notations, and non-portable"
msgstr ""

msgid "8103    between platforms with different integer and pointer sizes."
msgstr ""

msgid "8104    ##### Note"
msgstr ""

msgid ""
"8105    [Avoid casts](#Res-casts) (explicit type conversion) and if you must "
"[prefer named casts](#Res-casts-named)."
msgstr ""

msgid "8106    ##### Note"
msgstr ""

msgid "8107    When unambiguous, the `T` can be left out of `T{e}`."
msgstr ""

msgid "8108        complex<double> f(complex<double>);"
msgstr ""

msgid "8109        auto z = f({2*pi, 1});"
msgstr ""

msgid "8110    ##### Note"
msgstr ""

msgid ""
"8111    The construction notation is the most general [initializer "
"notation](#Res-list)."
msgstr ""

msgid "8112    ##### Exception"
msgstr ""

msgid ""
"8113    `std::vector` and other containers were defined before we had `{}` "
"as a notation for construction."
msgstr ""

msgid "8114    Consider:"
msgstr ""

msgid ""
"8115        vector<string> vs {10};                           // ten empty "
"strings"
msgstr ""

msgid ""
"8116        vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten "
"elements 1..10"
msgstr ""

msgid ""
"8117        vector<int> vi2 {10};                             // one element "
"with the value 10"
msgstr ""

msgid "8118    How do we get a `vector` of 10 default initialized `int`s?"
msgstr ""

msgid "8119        vector<int> v3(10); // ten elements with value 0"
msgstr ""

msgid ""
"8120    The use of `()` rather than `{}` for number of elements is "
"conventional (going back to the early 1980s), hard to change, but still"
msgstr ""

msgid ""
"8121    a design error: for a container where the element type can be "
"confused with the number of elements, we have an ambiguity that"
msgstr ""

msgid "8122    must be resolved."
msgstr ""

msgid ""
"8123    The conventional resolution is to interpret `{10}` as a list of one "
"element and use `(10)` to distinguish a size."
msgstr ""

msgid "8124    This mistake need not be repeated in new code."
msgstr ""

msgid "8125    We can define a type to represent the number of elements:"
msgstr ""

msgid "8126        struct Count { int n; };"
msgstr ""

msgid "8127        template<typename T>"
msgstr ""

msgid "8128        class Vector {"
msgstr ""

msgid "8129        public:"
msgstr ""

msgid ""
"8130            Vector(Count n);                     // n default-"
"initialized elements"
msgstr ""

msgid ""
"8131            Vector(initializer_list<T> init);    // init.size() elements"
msgstr ""

msgid "8132            // ..."
msgstr ""

msgid "8133        };"
msgstr ""

msgid "8134        Vector<int> v1{10};"
msgstr ""

msgid "8135        Vector<int> v2{Count{10}};"
msgstr ""

msgid ""
"8136        Vector<Count> v3{Count{10}};    // yes, there is still a very "
"minor problem"
msgstr ""

msgid "8137    The main problem left is to find a suitable name for `Count`."
msgstr ""

msgid "8138    ##### Enforcement"
msgstr ""

msgid "8139    Flag the C-style `(T)e` and functional-style `T(e)` casts."
msgstr ""

msgid ""
"8140    ### <a name=\"Res-deref\"></a>ES.65: Don't dereference an invalid "
"pointer"
msgstr ""

msgid "8141    ##### Reason"
msgstr ""

msgid ""
"8142    Dereferencing an invalid pointer, such as `nullptr`, is undefined "
"behavior, typically leading to immediate crashes,"
msgstr ""

msgid "8143    wrong results, or memory corruption."
msgstr ""

msgid "8144    ##### Note"
msgstr ""

msgid ""
"8145    This rule is an obvious and well-known language rule, but can be "
"hard to follow."
msgstr ""

msgid ""
"8146    It takes good coding style, library support, and static analysis to "
"eliminate violations without major overhead."
msgstr ""

msgid ""
"8147    This is a major part of the discussion of [C++'s resource- and type-"
"safety model](#Stroustrup15)."
msgstr ""

msgid "8148    **See also**:"
msgstr ""

msgid "8149    * Use [RAII](#Rr-raii) to avoid lifetime problems."
msgstr ""

msgid "8150    * Use [unique_ptr](#Rf-unique_ptr) to avoid lifetime problems."
msgstr ""

msgid "8151    * Use [shared_ptr](#Rf-shared_ptr) to avoid lifetime problems."
msgstr ""

msgid ""
"8152    * Use [references](#Rf-ptr-ref) when `nullptr` isn't a possibility."
msgstr ""

msgid ""
"8153    * Use [not_null](#Rf-not_null) to catch unexpected `nullptr` early."
msgstr ""

msgid "8154    * Use the [bounds profile](#SS-bounds) to avoid range errors."
msgstr ""

msgid "8155    ##### Example"
msgstr ""

msgid "8156        void f()"
msgstr ""

msgid "8157        {"
msgstr ""

msgid "8158            int x = 0;"
msgstr ""

msgid "8159            int* p = &x;"
msgstr ""

msgid "8160            if (condition()) {"
msgstr ""

msgid "8161                int y = 0;"
msgstr ""

msgid "8162                p = &y;"
msgstr ""

msgid "8163            } // invalidates p"
msgstr ""

msgid ""
"8164            *p = 42;            // BAD, p might be invalid if the branch "
"was taken"
msgstr ""

msgid "8165        }"
msgstr ""

msgid ""
"8166    To resolve the problem, either extend the lifetime of the object the "
"pointer is intended to refer to, or shorten the lifetime of the pointer "
"(move the dereference to before the pointed-to object's lifetime ends)."
msgstr ""

msgid "8167        void f1()"
msgstr ""

msgid "8168        {"
msgstr ""

msgid "8169            int x = 0;"
msgstr ""

msgid "8170            int* p = &x;"
msgstr ""

msgid "8171            int y = 0;"
msgstr ""

msgid "8172            if (condition()) {"
msgstr ""

msgid "8173                p = &y;"
msgstr ""

msgid "8174            }"
msgstr ""

msgid ""
"8175            *p = 42;            // OK, p points to x or y and both are "
"still in scope"
msgstr ""

msgid "8176        }"
msgstr ""

msgid ""
"8177    Unfortunately, most invalid pointer problems are harder to spot and "
"harder to fix."
msgstr ""

msgid "8178    ##### Example"
msgstr ""

msgid "8179        void f(int* p)"
msgstr ""

msgid "8180        {"
msgstr ""

msgid "8181            int x = *p; // BAD: how do we know that p is valid?"
msgstr ""

msgid "8182        }"
msgstr ""

msgid "8183    There is a huge amount of such code."
msgstr ""

msgid ""
"8184    Most works -- after lots of testing -- but in isolation it is "
"impossible to tell whether `p` could be the `nullptr`."
msgstr ""

msgid "8185    Consequently, this is also a major source of errors."
msgstr ""

msgid ""
"8186    There are many approaches to dealing with this potential problem:"
msgstr ""

msgid "8187        void f1(int* p) // deal with nullptr"
msgstr ""

msgid "8188        {"
msgstr ""

msgid "8189            if (!p) {"
msgstr ""

msgid ""
"8190                // deal with nullptr (allocate, return, throw, make p "
"point to something, whatever"
msgstr ""

msgid "8191            }"
msgstr ""

msgid "8192            int x = *p;"
msgstr ""

msgid "8193        }"
msgstr ""

msgid "8194    There are two potential problems with testing for `nullptr`:"
msgstr ""

msgid ""
"8195    * it is not always obvious what to do what to do if we find "
"`nullptr`"
msgstr ""

msgid "8196    * the test can be redundant and/or relatively expensive"
msgstr ""

msgid ""
"8197    * it is not obvious if the test is to protect against a violation or "
"part of the required logic."
msgstr ""

msgid ""
"8198        void f2(int* p) // state that p is not supposed to be nullptr"
msgstr ""

msgid "8199        {"
msgstr ""

msgid "8200            assert(p);"
msgstr ""

msgid "8201            int x = *p;"
msgstr ""

msgid "8202        }"
msgstr ""

msgid ""
"8203    This would carry a cost only when the assertion checking was enabled "
"and would give a compiler/analyzer useful information."
msgstr ""

msgid ""
"8204    This would work even better if/when C++ gets direct support for "
"contracts:"
msgstr ""

msgid ""
"8205        void f3(int* p) // state that p is not supposed to be nullptr"
msgstr ""

msgid "8206            [[expects: p]]"
msgstr ""

msgid "8207        {"
msgstr ""

msgid "8208            int x = *p;"
msgstr ""

msgid "8209        }"
msgstr ""

msgid ""
"8210    Alternatively, we could use `gsl::not_null` to ensure that `p` is "
"not the `nullptr`."
msgstr ""

msgid "8211        void f(not_null<int*> p)"
msgstr ""

msgid "8212        {"
msgstr ""

msgid "8213            int x = *p;"
msgstr ""

msgid "8214        }"
msgstr ""

msgid "8215    These remedies take care of `nullptr` only."
msgstr ""

msgid ""
"8216    Remember that there are other ways of getting an invalid pointer."
msgstr ""

msgid "8217    ##### Example"
msgstr ""

msgid "8218        void f(int* p)  // old code, doesn't use owner"
msgstr ""

msgid "8219        {"
msgstr ""

msgid "8220            delete p;"
msgstr ""

msgid "8221        }"
msgstr ""

msgid "8222        void g()        // old code: uses naked new"
msgstr ""

msgid "8223        {"
msgstr ""

msgid "8224            auto q = new int{7};"
msgstr ""

msgid "8225            f(q);"
msgstr ""

msgid "8226            int x = *q; // BAD: dereferences invalid pointer"
msgstr ""

msgid "8227        }"
msgstr ""

msgid "8228    ##### Example"
msgstr ""

msgid "8229        void f()"
msgstr ""

msgid "8230        {"
msgstr ""

msgid "8231            vector<int> v(10);"
msgstr ""

msgid "8232            int* p = &v[5];"
msgstr ""

msgid "8233            v.push_back(99); // could reallocate v's elements"
msgstr ""

msgid ""
"8234            int x = *p; // BAD: dereferences potentially invalid pointer"
msgstr ""

msgid "8235        }"
msgstr ""

msgid "8236    ##### Enforcement"
msgstr ""

msgid ""
"8237    This rule is part of the [lifetime safety profile](#SS-lifetime)"
msgstr ""

msgid ""
"8238    * Flag a dereference of a pointer that points to an object that has "
"gone out of scope"
msgstr ""

msgid ""
"8239    * Flag a dereference of a pointer that may have been invalidated by "
"assigning a `nullptr`"
msgstr ""

msgid ""
"8240    * Flag a dereference of a pointer that may have been invalidated by "
"a `delete`"
msgstr ""

msgid ""
"8241    * Flag a dereference to a pointer to a container element that may "
"have been invalidated by dereference"
msgstr ""

msgid "8242    ## ES.stmt: Statements"
msgstr ""

msgid ""
"8243    Statements control the flow of control (except for function calls "
"and exception throws, which are expressions)."
msgstr ""

msgid ""
"8244    ### <a name=\"Res-switch-if\"></a>ES.70: Prefer a `switch`-statement "
"to an `if`-statement when there is a choice"
msgstr ""

msgid "8245    ##### Reason"
msgstr ""

msgid "8246    * Readability."
msgstr ""

msgid ""
"8247    * Efficiency: A `switch` compares against constants and is usually "
"better optimized than a series of tests in an `if`-`then`-`else` chain."
msgstr ""

msgid ""
"8248    * A `switch` enables some heuristic consistency checking. For "
"example, have all values of an `enum` been covered? If not, is there a "
"`default`?"
msgstr ""

msgid "8249    ##### Example"
msgstr ""

msgid "8250        void use(int n)"
msgstr ""

msgid "8251        {"
msgstr ""

msgid "8252            switch (n) {   // good"
msgstr ""

msgid "8253            case 0:"
msgstr ""

msgid "8254                // ..."
msgstr ""

msgid "8255                break;"
msgstr ""

msgid "8256            case 7:"
msgstr ""

msgid "8257                // ..."
msgstr ""

msgid "8258                break;"
msgstr ""

msgid "8259            default:"
msgstr ""

msgid "8260                // ..."
msgstr ""

msgid "8261                break;"
msgstr ""

msgid "8262            }"
msgstr ""

msgid "8263        }"
msgstr ""

msgid "8264    rather than:"
msgstr ""

msgid "8265        void use2(int n)"
msgstr ""

msgid "8266        {"
msgstr ""

msgid ""
"8267            if (n == 0)   // bad: if-then-else chain comparing against a "
"set of constants"
msgstr ""

msgid "8268                // ..."
msgstr ""

msgid "8269            else if (n == 7)"
msgstr ""

msgid "8270                // ..."
msgstr ""

msgid "8271        }"
msgstr ""

msgid "8272    ##### Enforcement"
msgstr ""

msgid ""
"8273    Flag `if`-`then`-`else` chains that check against constants (only)."
msgstr ""

msgid ""
"8274    ### <a name=\"Res-for-range\"></a>ES.71: Prefer a range-`for`-"
"statement to a `for`-statement when there is a choice"
msgstr ""

msgid "8275    ##### Reason"
msgstr ""

msgid "8276    Readability. Error prevention. Efficiency."
msgstr ""

msgid "8277    ##### Example"
msgstr ""

msgid "8278        for (gsl::index i = 0; i < v.size(); ++i)   // bad"
msgstr ""

msgid "8279                cout << v[i] << '\\n';"
msgstr ""

msgid "8280        for (auto p = v.begin(); p != v.end(); ++p)   // bad"
msgstr ""

msgid "8281            cout << *p << '\\n';"
msgstr ""

msgid "8282        for (auto& x : v)    // OK"
msgstr ""

msgid "8283            cout << x << '\\n';"
msgstr ""

msgid ""
"8284        for (gsl::index i = 1; i < v.size(); ++i) // touches two "
"elements: can't be a range-for"
msgstr ""

msgid "8285            cout << v[i] + v[i - 1] << '\\n';"
msgstr ""

msgid ""
"8286        for (gsl::index i = 0; i < v.size(); ++i) // possible side "
"effect: can't be a range-for"
msgstr ""

msgid "8287            cout << f(v, &v[i]) << '\\n';"
msgstr ""

msgid ""
"8288        for (gsl::index i = 0; i < v.size(); ++i) { // body messes with "
"loop variable: can't be a range-for"
msgstr ""

msgid "8289            if (i % 2 == 0)"
msgstr ""

msgid "8290                continue;   // skip even elements"
msgstr ""

msgid "8291            else"
msgstr ""

msgid "8292                cout << v[i] << '\\n';"
msgstr ""

msgid "8293        }"
msgstr ""

msgid ""
"8294    A human or a good static analyzer may determine that there really "
"isn't a side effect on `v` in `f(v, &v[i])` so that the loop can be "
"rewritten."
msgstr ""

msgid ""
"8295    \"Messing with the loop variable\" in the body of a loop is "
"typically best avoided."
msgstr ""

msgid "8296    ##### Note"
msgstr ""

msgid ""
"8297    Don't use expensive copies of the loop variable of a range-`for` "
"loop:"
msgstr ""

msgid "8298        for (string s : vs) // ..."
msgstr ""

msgid "8299    This will copy each elements of `vs` into `s`. Better:"
msgstr ""

msgid "8300        for (string& s : vs) // ..."
msgstr ""

msgid "8301    Better still, if the loop variable isn't modified or copied:"
msgstr ""

msgid "8302        for (const string& s : vs) // ..."
msgstr ""

msgid "8303    ##### Enforcement"
msgstr ""

msgid ""
"8304    Look at loops, if a traditional loop just looks at each element of a "
"sequence, and there are no side effects on what it does with the elements, "
"rewrite the loop to a ranged-`for` loop."
msgstr ""

msgid ""
"8305    ### <a name=\"Res-for-while\"></a>ES.72: Prefer a `for`-statement to "
"a `while`-statement when there is an obvious loop variable"
msgstr ""

msgid "8306    ##### Reason"
msgstr ""

msgid ""
"8307    Readability: the complete logic of the loop is visible \"up front\". "
"The scope of the loop variable can be limited."
msgstr ""

msgid "8308    ##### Example"
msgstr ""

msgid "8309        for (gsl::index i = 0; i < vec.size(); i++) {"
msgstr ""

msgid "8310            // do work"
msgstr ""

msgid "8311        }"
msgstr ""

msgid "8312    ##### Example, bad"
msgstr ""

msgid "8313        int i = 0;"
msgstr ""

msgid "8314        while (i < vec.size()) {"
msgstr ""

msgid "8315            // do work"
msgstr ""

msgid "8316            i++;"
msgstr ""

msgid "8317        }"
msgstr ""

msgid "8318    ##### Enforcement"
msgstr ""

msgid "8319    ???"
msgstr ""

msgid ""
"8320    ### <a name=\"Res-while-for\"></a>ES.73: Prefer a `while`-statement "
"to a `for`-statement when there is no obvious loop variable"
msgstr ""

msgid "8321    ##### Reason"
msgstr ""

msgid "8322    Readability."
msgstr ""

msgid "8323    ##### Example"
msgstr ""

msgid "8324        int events = 0;"
msgstr ""

msgid "8325        for (; wait_for_event(); ++events) {  // bad, confusing"
msgstr ""

msgid "8326            // ..."
msgstr ""

msgid "8327        }"
msgstr ""

msgid ""
"8328    The \"event loop\" is misleading because the `events` counter has "
"nothing to do with the loop condition (`wait_for_event()`)."
msgstr ""

msgid "8329    Better"
msgstr ""

msgid "8330        int events = 0;"
msgstr ""

msgid "8331        while (wait_for_event()) {      // better"
msgstr ""

msgid "8332            ++events;"
msgstr ""

msgid "8333            // ..."
msgstr ""

msgid "8334        }"
msgstr ""

msgid "8335    ##### Enforcement"
msgstr ""

msgid ""
"8336    Flag actions in `for`-initializers and `for`-increments that do not "
"relate to the `for`-condition."
msgstr ""

msgid ""
"8337    ### <a name=\"Res-for-init\"></a>ES.74: Prefer to declare a loop "
"variable in the initializer part of a `for`-statement"
msgstr ""

msgid "8338    ##### Reason"
msgstr ""

msgid "8339    Limit the loop variable visibility to the scope of the loop."
msgstr ""

msgid ""
"8340    Avoid using the loop variable for other purposes after the loop."
msgstr ""

msgid "8341    ##### Example"
msgstr ""

msgid ""
"8342        for (int i = 0; i < 100; ++i) {   // GOOD: i var is visible only "
"inside the loop"
msgstr ""

msgid "8343            // ..."
msgstr ""

msgid "8344        }"
msgstr ""

msgid "8345    ##### Example, don't"
msgstr ""

msgid ""
"8346        int j;                            // BAD: j is visible outside "
"the loop"
msgstr ""

msgid "8347        for (j = 0; j < 100; ++j) {"
msgstr ""

msgid "8348            // ..."
msgstr ""

msgid "8349        }"
msgstr ""

msgid "8350        // j is still visible here and isn't needed"
msgstr ""

msgid ""
"8351    **See also**: [Don't use a variable for two unrelated purposes](#Res-"
"recycle)"
msgstr ""

msgid "8352    ##### Example"
msgstr ""

msgid "8353        for (string s; cin >> s; ) {"
msgstr ""

msgid "8354            cout << s << '\\n';"
msgstr ""

msgid "8355        }"
msgstr ""

msgid "8356    ##### Enforcement"
msgstr ""

msgid ""
"8357    Warn when a variable modified inside the `for`-statement is declared "
"outside the loop and not being used outside the loop."
msgstr ""

msgid ""
"8358    **Discussion**: Scoping the loop variable to the loop body also "
"helps code optimizers greatly. Recognizing that the induction variable"
msgstr ""

msgid ""
"8359    is only accessible in the loop body unblocks optimizations such as "
"hoisting, strength reduction, loop-invariant code motion, etc."
msgstr ""

msgid "8360    ### <a name=\"Res-do\"></a>ES.75: Avoid `do`-statements"
msgstr ""

msgid "8361    ##### Reason"
msgstr ""

msgid "8362    Readability, avoidance of errors."
msgstr ""

msgid ""
"8363    The termination condition is at the end (where it can be overlooked) "
"and the condition is not checked the first time through."
msgstr ""

msgid "8364    ##### Example"
msgstr ""

msgid "8365        int x;"
msgstr ""

msgid "8366        do {"
msgstr ""

msgid "8367            cin >> x;"
msgstr ""

msgid "8368            // ..."
msgstr ""

msgid "8369        } while (x < 0);"
msgstr ""

msgid "8370    ##### Note"
msgstr ""

msgid ""
"8371    Yes, there are genuine examples where a `do`-statement is a clear "
"statement of a solution, but also many bugs."
msgstr ""

msgid "8372    ##### Enforcement"
msgstr ""

msgid "8373    Flag `do`-statements."
msgstr ""

msgid "8374    ### <a name=\"Res-goto\"></a>ES.76: Avoid `goto`"
msgstr ""

msgid "8375    ##### Reason"
msgstr ""

msgid ""
"8376    Readability, avoidance of errors. There are better control "
"structures for humans; `goto` is for machine generated code."
msgstr ""

msgid "8377    ##### Exception"
msgstr ""

msgid "8378    Breaking out of a nested loop."
msgstr ""

msgid "8379    In that case, always jump forwards."
msgstr ""

msgid "8380        for (int i = 0; i < imax; ++i)"
msgstr ""

msgid "8381            for (int j = 0; j < jmax; ++j) {"
msgstr ""

msgid "8382                if (a[i][j] > elem_max) goto finished;"
msgstr ""

msgid "8383                // ..."
msgstr ""

msgid "8384            }"
msgstr ""

msgid "8385        finished:"
msgstr ""

msgid "8386        // ..."
msgstr ""

msgid "8387    ##### Example, bad"
msgstr ""

msgid "8388    There is a fair amount of use of the C goto-exit idiom:"
msgstr ""

msgid "8389        void f()"
msgstr ""

msgid "8390        {"
msgstr ""

msgid "8391            // ..."
msgstr ""

msgid "8392                goto exit;"
msgstr ""

msgid "8393            // ..."
msgstr ""

msgid "8394                goto exit;"
msgstr ""

msgid "8395            // ..."
msgstr ""

msgid "8396        exit:"
msgstr ""

msgid "8397            // ... common cleanup code ..."
msgstr ""

msgid "8398        }"
msgstr ""

msgid "8399    This is an ad-hoc simulation of destructors."
msgstr ""

msgid ""
"8400    Declare your resources with handles with destructors that clean up."
msgstr ""

msgid ""
"8401    If for some reason you cannot handle all cleanup with destructors "
"for the variables used,"
msgstr ""

msgid ""
"8402    consider `gsl::finally()` as a cleaner and more reliable alternative "
"to `goto exit`"
msgstr ""

msgid "8403    ##### Enforcement"
msgstr ""

msgid ""
"8404    * Flag `goto`. Better still flag all `goto`s that do not jump from a "
"nested loop to the statement immediately after a nest of loops."
msgstr ""

msgid ""
"8405    ### <a name=\"Res-continue\"></a>ES.77: Minimize the use of `break` "
"and `continue` in loops"
msgstr ""

msgid "8406    ##### Reason"
msgstr ""

msgid ""
"8407     In a non-trivial loop body, it is easy to overlook a `break` or a "
"`continue`."
msgstr ""

msgid ""
"8408     A `break` in a loop has a dramatically different meaning than a "
"`break` in a `switch`-statement"
msgstr ""

msgid ""
"8409     (and you can have `switch`-statement in a loop and a loop in a "
"`switch`-case)."
msgstr ""

msgid "8410    ##### Example"
msgstr ""

msgid "8411        ???"
msgstr ""

msgid "8412    ##### Alternative"
msgstr ""

msgid ""
"8413    Often, a loop that requires a `break` is a good candidate for a "
"function (algorithm), in which case the `break` becomes a `return`."
msgstr ""

msgid "8414        ???"
msgstr ""

msgid ""
"8415    Often. a loop that uses `continue` can equivalently and as clearly "
"be expressed by an `if`-statement."
msgstr ""

msgid "8416        ???"
msgstr ""

msgid "8417    ##### Note"
msgstr ""

msgid ""
"8418    If you really need to break out a loop, a `break` is typically "
"better than alternatives such as [modifying the loop variable](#Res-loop-"
"counter) or a [`goto`](#Res-goto):"
msgstr ""

msgid "8419    ##### Enforcement"
msgstr ""

msgid "8420    ???"
msgstr ""

msgid ""
"8421    ### <a name=\"Res-break\"></a>ES.78: Always end a non-empty `case` "
"with a `break`"
msgstr ""

msgid "8422    ##### Reason"
msgstr ""

msgid "8423     Accidentally leaving out a `break` is a fairly common bug."
msgstr ""

msgid "8424     A deliberate fallthrough is a maintenance hazard."
msgstr ""

msgid "8425    ##### Example"
msgstr ""

msgid "8426        switch (eventType) {"
msgstr ""

msgid "8427        case Information:"
msgstr ""

msgid "8428            update_status_bar();"
msgstr ""

msgid "8429            break;"
msgstr ""

msgid "8430        case Warning:"
msgstr ""

msgid "8431            write_event_log();"
msgstr ""

msgid "8432            // Bad - implicit fallthrough"
msgstr ""

msgid "8433        case Error:"
msgstr ""

msgid "8434            display_error_window();"
msgstr ""

msgid "8435            break;"
msgstr ""

msgid "8436        }"
msgstr ""

msgid "8437    It is easy to overlook the fallthrough. Be explicit:"
msgstr ""

msgid "8438        switch (eventType) {"
msgstr ""

msgid "8439        case Information:"
msgstr ""

msgid "8440            update_status_bar();"
msgstr ""

msgid "8441            break;"
msgstr ""

msgid "8442        case Warning:"
msgstr ""

msgid "8443            write_event_log();"
msgstr ""

msgid "8444            // fallthrough"
msgstr ""

msgid "8445        case Error:"
msgstr ""

msgid "8446            display_error_window();"
msgstr ""

msgid "8447            break;"
msgstr ""

msgid "8448        }"
msgstr ""

msgid "8449    In C++17, use a `[[fallthrough]]` annotation:"
msgstr ""

msgid "8450        switch (eventType) {"
msgstr ""

msgid "8451        case Information:"
msgstr ""

msgid "8452            update_status_bar();"
msgstr ""

msgid "8453            break;"
msgstr ""

msgid "8454        case Warning:"
msgstr ""

msgid "8455            write_event_log();"
msgstr ""

msgid "8456            [[fallthrough]];        // C++17"
msgstr ""

msgid "8457        case Error:"
msgstr ""

msgid "8458            display_error_window();"
msgstr ""

msgid "8459            break;"
msgstr ""

msgid "8460        }"
msgstr ""

msgid "8461    ##### Note"
msgstr ""

msgid "8462    Multiple case labels of a single statement is OK:"
msgstr ""

msgid "8463        switch (x) {"
msgstr ""

msgid "8464        case 'a':"
msgstr ""

msgid "8465        case 'b':"
msgstr ""

msgid "8466        case 'f':"
msgstr ""

msgid "8467            do_something(x);"
msgstr ""

msgid "8468            break;"
msgstr ""

msgid "8469        }"
msgstr ""

msgid "8470    ##### Enforcement"
msgstr ""

msgid "8471    Flag all fallthroughs from non-empty `case`s."
msgstr ""

msgid ""
"8472    ### <a name=\"Res-default\"></a>ES.79: Use `default` to handle "
"common cases (only)"
msgstr ""

msgid "8473    ##### Reason"
msgstr ""

msgid "8474     Code clarity."
msgstr ""

msgid "8475     Improved opportunities for error detection."
msgstr ""

msgid "8476    ##### Example"
msgstr ""

msgid "8477        enum E { a, b, c , d };"
msgstr ""

msgid "8478        void f1(E x)"
msgstr ""

msgid "8479        {"
msgstr ""

msgid "8480            switch (x) {"
msgstr ""

msgid "8481            case a:"
msgstr ""

msgid "8482                do_something();"
msgstr ""

msgid "8483                break;"
msgstr ""

msgid "8484            case b:"
msgstr ""

msgid "8485                do_something_else();"
msgstr ""

msgid "8486                break;"
msgstr ""

msgid "8487            default:"
msgstr ""

msgid "8488                take_the_default_action();"
msgstr ""

msgid "8489                break;"
msgstr ""

msgid "8490            }"
msgstr ""

msgid "8491        }"
msgstr ""

msgid ""
"8492    Here it is clear that there is a default action and that cases `a` "
"and `b` are special."
msgstr ""

msgid "8493    ##### Example"
msgstr ""

msgid ""
"8494    But what if there is no default action and you mean to handle only "
"specific cases?"
msgstr ""

msgid ""
"8495    In that case, have an empty default or else it is impossible to know "
"if you meant to handle all cases:"
msgstr ""

msgid "8496        void f2(E x)"
msgstr ""

msgid "8497        {"
msgstr ""

msgid "8498            switch (x) {"
msgstr ""

msgid "8499            case a:"
msgstr ""

msgid "8500                do_something();"
msgstr ""

msgid "8501                break;"
msgstr ""

msgid "8502            case b:"
msgstr ""

msgid "8503                do_something_else();"
msgstr ""

msgid "8504                break;"
msgstr ""

msgid "8505            default:"
msgstr ""

msgid "8506                // do nothing for the rest of the cases"
msgstr ""

msgid "8507                break;"
msgstr ""

msgid "8508            }"
msgstr ""

msgid "8509        }"
msgstr ""

msgid ""
"8510    If you leave out the `default`, a maintainer and/or a compiler may "
"reasonably assume that you intended to handle all cases:"
msgstr ""

msgid "8511        void f2(E x)"
msgstr ""

msgid "8512        {"
msgstr ""

msgid "8513            switch (x) {"
msgstr ""

msgid "8514            case a:"
msgstr ""

msgid "8515                do_something();"
msgstr ""

msgid "8516                break;"
msgstr ""

msgid "8517            case b:"
msgstr ""

msgid "8518            case c:"
msgstr ""

msgid "8519                do_something_else();"
msgstr ""

msgid "8520                break;"
msgstr ""

msgid "8521            }"
msgstr ""

msgid "8522        }"
msgstr ""

msgid "8523    Did you forget case `d` or deliberately leave it out?"
msgstr ""

msgid ""
"8524    Forgetting a case typically happens when a case is added to an "
"enumeration and the person doing so fails to add it to every"
msgstr ""

msgid "8525    switch over the enumerators."
msgstr ""

msgid "8526    ##### Enforcement"
msgstr ""

msgid ""
"8527    Flag `switch`-statements over an enumeration that don't handle all "
"enumerators and do not have a `default`."
msgstr ""

msgid ""
"8528    This may yield too many false positives in some code bases; if so, "
"flag only `switch`es that handle most but not all cases"
msgstr ""

msgid "8529    (that was the strategy of the very first C++ compiler)."
msgstr ""

msgid ""
"8530    ### <a name=\"Res-noname\"></a>ES.84: Don't (try to) declare a local "
"variable with no name"
msgstr ""

msgid "8531    ##### Reason"
msgstr ""

msgid "8532    There is no such thing."
msgstr ""

msgid ""
"8533    What looks to a human like a variable without a name is to the "
"compiler a statement consisting of a temporary that immediately goes out of "
"scope."
msgstr ""

msgid "8534    To avoid unpleasant surprises."
msgstr ""

msgid "8535    ##### Example, bad"
msgstr ""

msgid "8536        void f()"
msgstr ""

msgid "8537        {"
msgstr ""

msgid "8538            lock<mutex>{mx};   // Bad"
msgstr ""

msgid "8539            // ..."
msgstr ""

msgid "8540        }"
msgstr ""

msgid ""
"8541    This declares an unnamed `lock` object that immediately goes out of "
"scope at the point of the semicolon."
msgstr ""

msgid "8542    This is not an uncommon mistake."
msgstr ""

msgid ""
"8543    In particular, this particular example can lead to hard-to find race "
"conditions."
msgstr ""

msgid ""
"8544    There are exceedingly clever uses of this \"idiom\", but they are "
"far rarer than the mistakes."
msgstr ""

msgid "8545    ##### Note"
msgstr ""

msgid "8546    Unnamed function arguments are fine."
msgstr ""

msgid "8547    ##### Enforcement"
msgstr ""

msgid "8548    Flag statements that are just a temporary"
msgstr ""

msgid ""
"8549    ### <a name=\"Res-empty\"></a>ES.85: Make empty statements visible"
msgstr ""

msgid "8550    ##### Reason"
msgstr ""

msgid "8551    Readability."
msgstr ""

msgid "8552    ##### Example"
msgstr ""

msgid ""
"8553        for (i = 0; i < max; ++i);   // BAD: the empty statement is "
"easily overlooked"
msgstr ""

msgid "8554        v[i] = f(v[i]);"
msgstr ""

msgid "8555        for (auto x : v) {           // better"
msgstr ""

msgid "8556            // nothing"
msgstr ""

msgid "8557        }"
msgstr ""

msgid "8558        v[i] = f(v[i]);"
msgstr ""

msgid "8559    ##### Enforcement"
msgstr ""

msgid ""
"8560    Flag empty statements that are not blocks and don't contain comments."
""
msgstr ""

msgid ""
"8561    ### <a name=\"Res-loop-counter\"></a>ES.86: Avoid modifying loop "
"control variables inside the body of raw for-loops"
msgstr ""

msgid "8562    ##### Reason"
msgstr ""

msgid ""
"8563    The loop control up front should enable correct reasoning about what "
"is happening inside the loop. Modifying loop counters in both the iteration-"
"expression and inside the body of the loop is a perennial source of "
"surprises and bugs."
msgstr ""

msgid "8564    ##### Example"
msgstr ""

msgid "8565        for (int i = 0; i < 10; ++i) {"
msgstr ""

msgid "8566            // no updates to i -- ok"
msgstr ""

msgid "8567        }"
msgstr ""

msgid "8568        for (int i = 0; i < 10; ++i) {"
msgstr ""

msgid "8569            //"
msgstr ""

msgid "8570            if (/* something */) ++i; // BAD"
msgstr ""

msgid "8571            //"
msgstr ""

msgid "8572        }"
msgstr ""

msgid "8573        bool skip = false;"
msgstr ""

msgid "8574        for (int i = 0; i < 10; ++i) {"
msgstr ""

msgid "8575            if (skip) { skip = false; continue; }"
msgstr ""

msgid "8576            //"
msgstr ""

msgid ""
"8577            if (/* something */) skip = true;  // Better: using two "
"variable for two concepts."
msgstr ""

msgid "8578            //"
msgstr ""

msgid "8579        }"
msgstr ""

msgid "8580    ##### Enforcement"
msgstr ""

msgid ""
"8581    Flag variables that are potentially updated (have a non-`const` use) "
"in both the loop control iteration-expression and the loop body."
msgstr ""

msgid ""
"8582    ### <a name=\"Res-if\"></a>ES.87: Don't add redundant `==` or `!=` "
"to conditions"
msgstr ""

msgid "8583    ##### Reason"
msgstr ""

msgid ""
"8584    Doing so avoids verbosity and eliminates some opportunities for "
"mistakes."
msgstr ""

msgid "8585    Helps make style consistent and conventional."
msgstr ""

msgid "8586    ##### Example"
msgstr ""

msgid ""
"8587    By definition, a condition in an `if`-statement, `while`-statement, "
"or a `for`-statement selects between `true` and `false`."
msgstr ""

msgid ""
"8588    A numeric value is compared to `0` and a pointer value to `nullptr`."
msgstr ""

msgid "8589        // These all mean \"if `p` is not `nullptr`\""
msgstr ""

msgid "8590        if (p) { ... }            // good"
msgstr ""

msgid ""
"8591        if (p != 0) { ... }       // redundant `!=0`; bad: don't use 0 "
"for pointers"
msgstr ""

msgid ""
"8592        if (p != nullptr) { ... } // redundant `!=nullptr`, not "
"recommended"
msgstr ""

msgid ""
"8593    Often, `if (p)` is read as \"if `p` is valid\" which is a direct "
"expression of the programmers intent,"
msgstr ""

msgid "8594    whereas `if (p != nullptr)` would be a long-winded workaround."
msgstr ""

msgid "8595    ##### Example"
msgstr ""

msgid ""
"8596    This rule is especially useful when a declaration is used as a "
"condition"
msgstr ""

msgid ""
"8597        if (auto pc = dynamic_cast<Circle>(ps)) { ... } // execute is ps "
"points to a kind of Circle, good"
msgstr ""

msgid ""
"8598        if (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } //"
" not recommended"
msgstr ""

msgid "8599    ##### Example"
msgstr ""

msgid ""
"8600    Note that implicit conversions to bool are applied in conditions."
msgstr ""

msgid "8601    For example:"
msgstr ""

msgid "8602        for (string s; cin >> s; ) v.push_back(s);"
msgstr ""

msgid "8603    This invokes `istream`'s `operator bool()`."
msgstr ""

msgid "8604    ##### Note"
msgstr ""

msgid ""
"8605    Explicit comparison of an integer to `0` is in general not redundant."
""
msgstr ""

msgid ""
"8606    The reason is that (as opposed to pointers and Booleans) an integer "
"often has more than two reasonable values."
msgstr ""

msgid "8607    Furthermore `0` (zero) is often used to indicate success."
msgstr ""

msgid "8608    Consequently, it is best to be specific about the comparison."
msgstr ""

msgid "8609        void f(int i)"
msgstr ""

msgid "8610        {"
msgstr ""

msgid "8611            if (i)            // suspect"
msgstr ""

msgid "8612            // ..."
msgstr ""

msgid "8613            if (i == success) // possibly better"
msgstr ""

msgid "8614            // ..."
msgstr ""

msgid "8615        }"
msgstr ""

msgid "8616    Always remember that an integer can have more than two values."
msgstr ""

msgid "8617    ##### Example, bad"
msgstr ""

msgid "8618    It has been noted that"
msgstr ""

msgid ""
"8619        if(strcmp(p1, p2)) { ... }   // are the two C-style strings "
"equal? (mistake!)"
msgstr ""

msgid "8620    is a common beginners error."
msgstr ""

msgid ""
"8621    If you use C-style strings, you must know the `<cstring>` functions "
"well."
msgstr ""

msgid "8622    Being verbose and writing"
msgstr ""

msgid ""
"8623        if(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings "
"equal? (mistake!)"
msgstr ""

msgid "8624    would not in itself save you."
msgstr ""

msgid "8625    ##### Note"
msgstr ""

msgid ""
"8626    The opposite condition is most easily expressed using a negation:"
msgstr ""

msgid "8627        // These all mean \"if `p` is `nullptr`\""
msgstr ""

msgid "8628        if (!p) { ... }           // good"
msgstr ""

msgid ""
"8629        if (p == 0) { ... }       // redundant `== 0`; bad: don't use "
"`0` for pointers"
msgstr ""

msgid ""
"8630        if (p == nullptr) { ... } // redundant `== nullptr`, not "
"recommended"
msgstr ""

msgid "8631    ##### Enforcement"
msgstr ""

msgid ""
"8632    Easy, just check for redundant use of `!=` and `==` in conditions."
msgstr ""

msgid "8633    ## <a name=\"SS-numbers\"></a>Arithmetic"
msgstr ""

msgid ""
"8634    ### <a name=\"Res-mix\"></a>ES.100: Don't mix signed and unsigned "
"arithmetic"
msgstr ""

msgid "8635    ##### Reason"
msgstr ""

msgid "8636    Avoid wrong results."
msgstr ""

msgid "8637    ##### Example"
msgstr ""

msgid "8638        int x = -3;"
msgstr ""

msgid "8639        unsigned int y = 7;"
msgstr ""

msgid ""
"8640        cout << x - y << '\\n';  // unsigned result, possibly 4294967286"
msgstr ""

msgid "8641        cout << x + y << '\\n';  // unsigned result: 4"
msgstr ""

msgid ""
"8642        cout << x * y << '\\n';  // unsigned result, possibly 4294967275"
msgstr ""

msgid "8643    It is harder to spot the problem in more realistic examples."
msgstr ""

msgid "8644    ##### Note"
msgstr ""

msgid ""
"8645    Unfortunately, C++ uses signed integers for array subscripts and the "
"standard library uses unsigned integers for container subscripts."
msgstr ""

msgid ""
"8646    This precludes consistency. Use `gsl::index` for subscripts; [see ES."
"107](#Res-subscripts)."
msgstr ""

msgid "8647    ##### Enforcement"
msgstr ""

msgid "8648    * Compilers already know and sometimes warn."
msgstr ""

msgid ""
"8649    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison "
"where one of the arguments is `sizeof` or a call to container `.size()` and "
"the other is `ptrdiff_t`."
msgstr ""

msgid ""
"8650    ### <a name=\"Res-unsigned\"></a>ES.101: Use unsigned types for bit "
"manipulation"
msgstr ""

msgid "8651    ##### Reason"
msgstr ""

msgid ""
"8652    Unsigned types support bit manipulation without surprises from sign "
"bits."
msgstr ""

msgid "8653    ##### Example"
msgstr ""

msgid "8654        unsigned char x = 0b1010'1010;"
msgstr ""

msgid "8655        unsigned char y = ~x;   // y == 0b0101'0101;"
msgstr ""

msgid "8656    ##### Note"
msgstr ""

msgid "8657    Unsigned types can also be useful for modulo arithmetic."
msgstr ""

msgid "8658    However, if you want modulo arithmetic add"
msgstr ""

msgid ""
"8659    comments as necessary noting the reliance on wraparound behavior, as "
"such code"
msgstr ""

msgid "8660    can be surprising for many programmers."
msgstr ""

msgid "8661    ##### Enforcement"
msgstr ""

msgid ""
"8662    * Just about impossible in general because of the use of unsigned "
"subscripts in the standard library"
msgstr ""

msgid "8663    * ???"
msgstr ""

msgid ""
"8664    ### <a name=\"Res-signed\"></a>ES.102: Use signed types for "
"arithmetic"
msgstr ""

msgid "8665    ##### Reason"
msgstr ""

msgid "8666    Because most arithmetic is assumed to be signed;"
msgstr ""

msgid ""
"8667    `x - y` yields a negative number when `y > x` except in the rare "
"cases where you really want modulo arithmetic."
msgstr ""

msgid "8668    ##### Example"
msgstr ""

msgid ""
"8669    Unsigned arithmetic can yield surprising results if you are not "
"expecting it."
msgstr ""

msgid ""
"8670    This is even more true for mixed signed and unsigned arithmetic."
msgstr ""

msgid "8671        template<typename T, typename T2>"
msgstr ""

msgid "8672        T subtract(T x, T2 y)"
msgstr ""

msgid "8673        {"
msgstr ""

msgid "8674            return x - y;"
msgstr ""

msgid "8675        }"
msgstr ""

msgid "8676        void test()"
msgstr ""

msgid "8677        {"
msgstr ""

msgid "8678            int s = 5;"
msgstr ""

msgid "8679            unsigned int us = 5;"
msgstr ""

msgid "8680            cout << subtract(s, 7) << '\\n';       // -2"
msgstr ""

msgid "8681            cout << subtract(us, 7u) << '\\n';     // 4294967294"
msgstr ""

msgid "8682            cout << subtract(s, 7u) << '\\n';      // -2"
msgstr ""

msgid "8683            cout << subtract(us, 7) << '\\n';      // 4294967294"
msgstr ""

msgid "8684            cout << subtract(s, us + 2) << '\\n';  // -2"
msgstr ""

msgid "8685            cout << subtract(us, s + 2) << '\\n';  // 4294967294"
msgstr ""

msgid "8686        }"
msgstr ""

msgid "8687    Here we have been very explicit about what's happening,"
msgstr ""

msgid ""
"8688    but if you had seen `us - (s + 2)` or `s += 2; ...; us - s`, would "
"you reliably have suspected that the result would print as `4294967294`?"
msgstr ""

msgid "8689    ##### Exception"
msgstr ""

msgid "8690    Use unsigned types if you really want modulo arithmetic - add"
msgstr ""

msgid ""
"8691    comments as necessary noting the reliance on overflow behavior, as "
"such code"
msgstr ""

msgid "8692    is going to be surprising for many programmers."
msgstr ""

msgid "8693    ##### Example"
msgstr ""

msgid "8694    The standard library uses unsigned types for subscripts."
msgstr ""

msgid "8695    The built-in array uses signed types for subscripts."
msgstr ""

msgid "8696    This makes surprises (and bugs) inevitable."
msgstr ""

msgid "8697        int a[10];"
msgstr ""

msgid "8698        for (int i = 0; i < 10; ++i) a[i] = i;"
msgstr ""

msgid "8699        vector<int> v(10);"
msgstr ""

msgid ""
"8700        // compares signed to unsigned; some compilers warn, but we "
"should not"
msgstr ""

msgid "8701        for (gsl::index i = 0; i < v.size(); ++i) v[i] = i;"
msgstr ""

msgid "8702        int a2[-2];         // error: negative size"
msgstr ""

msgid ""
"8703        // OK, but the number of ints (4294967294) is so large that we "
"should get an exception"
msgstr ""

msgid "8704        vector<int> v2(-2);"
msgstr ""

msgid ""
"8705     Use `gsl::index` for subscripts; [see ES.107](#Res-subscripts)."
msgstr ""

msgid "8706    ##### Enforcement"
msgstr ""

msgid "8707    * Flag mixed signed and unsigned arithmetic"
msgstr ""

msgid ""
"8708    * Flag results of unsigned arithmetic assigned to or printed as "
"signed."
msgstr ""

msgid ""
"8709    * Flag unsigned literals (e.g. `-2`) used as container subscripts."
msgstr ""

msgid ""
"8710    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison "
"where one of the arguments is `sizeof` or a call to container `.size()` and "
"the other is `ptrdiff_t`."
msgstr ""

msgid "8711    ### <a name=\"Res-overflow\"></a>ES.103: Don't overflow"
msgstr ""

msgid "8712    ##### Reason"
msgstr ""

msgid "8713    Overflow usually makes your numeric algorithm meaningless."
msgstr ""

msgid ""
"8714    Incrementing a value beyond a maximum value can lead to memory "
"corruption and undefined behavior."
msgstr ""

msgid "8715    ##### Example, bad"
msgstr ""

msgid "8716        int a[10];"
msgstr ""

msgid "8717        a[10] = 7;   // bad"
msgstr ""

msgid "8718        int n = 0;"
msgstr ""

msgid "8719        while (n++ < 10)"
msgstr ""

msgid "8720            a[n - 1] = 9; // bad (twice)"
msgstr ""

msgid "8721    ##### Example, bad"
msgstr ""

msgid "8722        int n = numeric_limits<int>::max();"
msgstr ""

msgid "8723        int m = n + 1;   // bad"
msgstr ""

msgid "8724    ##### Example, bad"
msgstr ""

msgid "8725        int area(int h, int w) { return h * w; }"
msgstr ""

msgid "8726        auto a = area(10'000'000, 100'000'000);   // bad"
msgstr ""

msgid "8727    ##### Exception"
msgstr ""

msgid "8728    Use unsigned types if you really want modulo arithmetic."
msgstr ""

msgid ""
"8729    **Alternative**: For critical applications that can afford some "
"overhead, use a range-checked integer and/or floating-point type."
msgstr ""

msgid "8730    ##### Enforcement"
msgstr ""

msgid "8731    ???"
msgstr ""

msgid "8732    ### <a name=\"Res-underflow\"></a>ES.104: Don't underflow"
msgstr ""

msgid "8733    ##### Reason"
msgstr ""

msgid ""
"8734    Decrementing a value beyond a minimum value can lead to memory "
"corruption and undefined behavior."
msgstr ""

msgid "8735    ##### Example, bad"
msgstr ""

msgid "8736        int a[10];"
msgstr ""

msgid "8737        a[-2] = 7;   // bad"
msgstr ""

msgid "8738        int n = 101;"
msgstr ""

msgid "8739        while (n--)"
msgstr ""

msgid "8740            a[n - 1] = 9;   // bad (twice)"
msgstr ""

msgid "8741    ##### Exception"
msgstr ""

msgid "8742    Use unsigned types if you really want modulo arithmetic."
msgstr ""

msgid "8743    ##### Enforcement"
msgstr ""

msgid "8744    ???"
msgstr ""

msgid "8745    ### <a name=\"Res-zero\"></a>ES.105: Don't divide by zero"
msgstr ""

msgid "8746    ##### Reason"
msgstr ""

msgid "8747    The result is undefined and probably a crash."
msgstr ""

msgid "8748    ##### Note"
msgstr ""

msgid "8749    This also applies to `%`."
msgstr ""

msgid "8750    ##### Example; bad"
msgstr ""

msgid "8751        double divide(int a, int b) {"
msgstr ""

msgid "8752            // BAD, should be checked (e.g., in a precondition)"
msgstr ""

msgid "8753            return a / b;"
msgstr ""

msgid "8754        }"
msgstr ""

msgid "8755    ##### Example; good"
msgstr ""

msgid "8756        double divide(int a, int b) {"
msgstr ""

msgid ""
"8757            // good, address via precondition (and replace with "
"contracts once C++ gets them)"
msgstr ""

msgid "8758            Expects(b != 0);"
msgstr ""

msgid "8759            return a / b;"
msgstr ""

msgid "8760        }"
msgstr ""

msgid "8761        double divide(int a, int b) {"
msgstr ""

msgid "8762            // good, address via check"
msgstr ""

msgid "8763            return b ? a / b : quiet_NaN<double>();"
msgstr ""

msgid "8764        }"
msgstr ""

msgid ""
"8765    **Alternative**: For critical applications that can afford some "
"overhead, use a range-checked integer and/or floating-point type."
msgstr ""

msgid "8766    ##### Enforcement"
msgstr ""

msgid "8767    * Flag division by an integral value that could be zero"
msgstr ""

msgid ""
"8768    ### <a name=\"Res-nonnegative\"></a>ES.106: Don't try to avoid "
"negative values by using `unsigned`"
msgstr ""

msgid "8769    ##### Reason"
msgstr ""

msgid ""
"8770    Choosing `unsigned` implies many changes to the usual behavior of "
"integers, including modulo arithmetic,"
msgstr ""

msgid "8771    can suppress warnings related to overflow,"
msgstr ""

msgid ""
"8772    and opens the door for errors related to signed/unsigned mixes."
msgstr ""

msgid ""
"8773    Using `unsigned` doesn't actually eliminate the possibility of "
"negative values."
msgstr ""

msgid "8774    ##### Example"
msgstr ""

msgid ""
"8775        unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294"
msgstr ""

msgid "8776        int i1 = -2;"
msgstr ""

msgid ""
"8777        unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294"
msgstr ""

msgid "8778        int i2 = u2;            // Valid: the value of i2 is -2"
msgstr ""

msgid ""
"8779    These problems with such (perfectly legal) constructs are hard to "
"spot in real code and are the source of many real-world errors."
msgstr ""

msgid "8780    Consider:"
msgstr ""

msgid ""
"8781        unsigned area(unsigned height, unsigned width) { return "
"height*width; } // [see also](#Ri-expects)"
msgstr ""

msgid "8782        // ..."
msgstr ""

msgid "8783        int height;"
msgstr ""

msgid "8784        cin >> height;"
msgstr ""

msgid ""
"8785        auto a = area(height, 2);   // if the input is -2 a becomes "
"4294967292"
msgstr ""

msgid ""
"8786    Remember that `-1` when assigned to an `unsigned int` becomes the "
"largest `unsigned int`."
msgstr ""

msgid ""
"8787    Also, since unsigned arithmetic is modulo arithmetic the "
"multiplication didn't overflow, it wrapped around."
msgstr ""

msgid "8788    ##### Example"
msgstr ""

msgid ""
"8789        unsigned max = 100000;    // \"accidental typo\", I mean to say "
"10'000"
msgstr ""

msgid "8790        unsigned short x = 100;"
msgstr ""

msgid "8791        while (x < max) x += 100; // infinite loop"
msgstr ""

msgid ""
"8792    Had `x` been a signed `short`, we could have warned about the "
"undefined behavior upon overflow."
msgstr ""

msgid "8793    ##### Alternatives"
msgstr ""

msgid "8794    * use signed integers and check for `x >= 0`"
msgstr ""

msgid "8795    * use a positive integer type"
msgstr ""

msgid "8796    * use an integer subrange type"
msgstr ""

msgid "8797    * `Assert(-1 < x)`"
msgstr ""

msgid "8798    For example"
msgstr ""

msgid "8799        struct Positive {"
msgstr ""

msgid "8800            int val;"
msgstr ""

msgid "8801            Positive(int x) :val{x} { Assert(0 < x); }"
msgstr ""

msgid "8802            operator int() { return val; }"
msgstr ""

msgid "8803        };"
msgstr ""

msgid "8804        int f(Positive arg) { return arg; }"
msgstr ""

msgid "8805        int r1 = f(2);"
msgstr ""

msgid "8806        int r2 = f(-2);  // throws"
msgstr ""

msgid "8807    ##### Note"
msgstr ""

msgid "8808    ???"
msgstr ""

msgid "8809    ##### Enforcement"
msgstr ""

msgid ""
"8810    Hard: there is a lot of code using `unsigned` and we don't offer a "
"practical positive number type."
msgstr ""

msgid ""
"8811    ### <a name=\"Res-subscripts\"></a>ES.107: Don't use `unsigned` for "
"subscripts, prefer `gsl::index`"
msgstr ""

msgid "8812    ##### Reason"
msgstr ""

msgid "8813    To avoid signed/unsigned confusion."
msgstr ""

msgid "8814    To enable better optimization."
msgstr ""

msgid "8815    To enable better error detection."
msgstr ""

msgid "8816    To avoid the pitfalls with `auto` and `int`."
msgstr ""

msgid "8817    ##### Example, bad"
msgstr ""

msgid "8818        vector<int> vec = /*...*/;"
msgstr ""

msgid ""
"8819        for (int i = 0; i < vec.size(); i += 2)                    // "
"may not be big enough"
msgstr ""

msgid "8820            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8821        for (unsigned i = 0; i < vec.size(); i += 2)               // "
"risk wraparound"
msgstr ""

msgid "8822            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8823        for (auto i = 0; i < vec.size(); i += 2)                   // "
"may not be big enough"
msgstr ""

msgid "8824            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8825        for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // "
"verbose"
msgstr ""

msgid "8826            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8827        for (auto i = vec.size()-1; i >= 0; i -= 2)                // "
"bug"
msgstr ""

msgid "8828            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8829        for (int i = vec.size()-1; i >= 0; i -= 2)                 // "
"may not be big enough"
msgstr ""

msgid "8830            cout << vec[i] << '\\n';"
msgstr ""

msgid "8831    ##### Example, good"
msgstr ""

msgid "8832        vector<int> vec = /*...*/;"
msgstr ""

msgid ""
"8833        for (gsl::index i = 0; i < vec.size(); i += 2)             // ok"
msgstr ""

msgid "8834            cout << vec[i] << '\\n';"
msgstr ""

msgid ""
"8835        for (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // ok"
msgstr ""

msgid "8836            cout << vec[i] << '\\n';"
msgstr ""

msgid "8837    ##### Note"
msgstr ""

msgid "8838    The built-in array uses signed subscripts."
msgstr ""

msgid "8839    The standard-library containers use unsigned subscripts."
msgstr ""

msgid ""
"8840    Thus, no perfect and fully compatible solution is possible (unless "
"and until the standard-library containers change to use signed subscripts "
"someday in the future)."
msgstr ""

msgid ""
"8841    Given the known problems with unsigned and signed/unsigned mixtures, "
"better stick to (signed) integers of a sufficient size, which is guaranteed "
"by `gsl::index`."
msgstr ""

msgid "8842    ##### Example"
msgstr ""

msgid "8843        template<typename T>"
msgstr ""

msgid "8844        struct My_container {"
msgstr ""

msgid "8845        public:"
msgstr ""

msgid "8846            // ..."
msgstr ""

msgid "8847            T& operator[](gsl::index i);    // not unsigned"
msgstr ""

msgid "8848            // ..."
msgstr ""

msgid "8849        };"
msgstr ""

msgid "8850    ##### Example"
msgstr ""

msgid ""
"8851        ??? demonstrate improved code generation and potential for error "
"detection ???"
msgstr ""

msgid "8852    ##### Alternatives"
msgstr ""

msgid "8853    Alternatives for users"
msgstr ""

msgid "8854    * use algorithms"
msgstr ""

msgid "8855    * use range-for"
msgstr ""

msgid "8856    * use iterators/pointers"
msgstr ""

msgid "8857    ##### Enforcement"
msgstr ""

msgid ""
"8858    * Very tricky as long as the standard-library containers get it "
"wrong."
msgstr ""

msgid ""
"8859    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison "
"where one of the arguments is `sizeof` or a call to container `.size()` and "
"the other is `ptrdiff_t`."
msgstr ""

msgid "8860    # <a name=\"S-performance\"></a>Per: Performance"
msgstr ""

msgid "8861    ??? should this section be in the main guide???"
msgstr ""

msgid ""
"8862    This section contains rules for people who need high performance or "
"low-latency."
msgstr ""

msgid ""
"8863    That is, these are rules that relate to how to use as little time "
"and as few resources as possible to achieve a task in a predictably short "
"time."
msgstr ""

msgid ""
"8864    The rules in this section are more restrictive and intrusive than "
"what is needed for many (most) applications."
msgstr ""

msgid ""
"8865    Do not blindly try to follow them in general code: achieving the "
"goals of low latency requires extra work."
msgstr ""

msgid "8866    Performance rule summary:"
msgstr ""

msgid "8867    * [Per.1: Don't optimize without reason](#Rper-reason)"
msgstr ""

msgid "8868    * [Per.2: Don't optimize prematurely](#Rper-Knuth)"
msgstr ""

msgid ""
"8869    * [Per.3: Don't optimize something that's not performance "
"critical](#Rper-critical)"
msgstr ""

msgid ""
"8870    * [Per.4: Don't assume that complicated code is necessarily faster "
"than simple code](#Rper-simple)"
msgstr ""

msgid ""
"8871    * [Per.5: Don't assume that low-level code is necessarily faster "
"than high-level code](#Rper-low)"
msgstr ""

msgid ""
"8872    * [Per.6: Don't make claims about performance without "
"measurements](#Rper-measure)"
msgstr ""

msgid "8873    * [Per.7: Design to enable optimization](#Rper-efficiency)"
msgstr ""

msgid "8874    * [Per.10: Rely on the static type system](#Rper-type)"
msgstr ""

msgid ""
"8875    * [Per.11: Move computation from run time to compile time](#Rper-"
"Comp)"
msgstr ""

msgid "8876    * [Per.12: Eliminate redundant aliases](#Rper-alias)"
msgstr ""

msgid "8877    * [Per.13: Eliminate redundant indirections](#Rper-indirect)"
msgstr ""

msgid ""
"8878    * [Per.14: Minimize the number of allocations and "
"deallocations](#Rper-alloc)"
msgstr ""

msgid "8879    * [Per.15: Do not allocate on a critical branch](#Rper-alloc0)"
msgstr ""

msgid "8880    * [Per.16: Use compact data structures](#Rper-compact)"
msgstr ""

msgid ""
"8881    * [Per.17: Declare the most used member of a time-critical struct "
"first](#Rper-struct)"
msgstr ""

msgid "8882    * [Per.18: Space is time](#Rper-space)"
msgstr ""

msgid "8883    * [Per.19: Access memory predictably](#Rper-access)"
msgstr ""

msgid ""
"8884    * [Per.30: Avoid context switches on the critical path](#Rper-"
"context)"
msgstr ""

msgid ""
"8885    ### <a name=\"Rper-reason\"></a>Per.1: Don't optimize without reason"
msgstr ""

msgid "8886    ##### Reason"
msgstr ""

msgid ""
"8887    If there is no need for optimization, the main result of the effort "
"will be more errors and higher maintenance costs."
msgstr ""

msgid "8888    ##### Note"
msgstr ""

msgid "8889    Some people optimize out of habit or because it's fun."
msgstr ""

msgid "8890    ???"
msgstr ""

msgid "8891    ### <a name=\"Rper-Knuth\"></a>Per.2: Don't optimize prematurely"
msgstr ""

msgid "8892    ##### Reason"
msgstr ""

msgid ""
"8893    Elaborately optimized code is usually larger and harder to change "
"than unoptimized code."
msgstr ""

msgid "8894    ???"
msgstr ""

msgid ""
"8895    ### <a name=\"Rper-critical\"></a>Per.3: Don't optimize something "
"that's not performance critical"
msgstr ""

msgid "8896    ##### Reason"
msgstr ""

msgid ""
"8897    Optimizing a non-performance-critical part of a program has no "
"effect on system performance."
msgstr ""

msgid "8898    ##### Note"
msgstr ""

msgid ""
"8899    If your program spends most of its time waiting for the web or for a "
"human, optimization of in-memory computation is probably useless."
msgstr ""

msgid ""
"8900    Put another way: If your program spends 4% of its processing time "
"doing"
msgstr ""

msgid ""
"8901    computation A and 40% of its time doing computation B, a 50% "
"improvement on A is"
msgstr ""

msgid ""
"8902    only as impactful as a 5% improvement on B. (If you don't even know "
"how much"
msgstr ""

msgid ""
"8903    time is spent on A or B, see <a href=\"#Rper-reason\">Per.1</a> and "
"<a"
msgstr ""

msgid "8904    href=\"#Rper-Knuth\">Per.2</a>.)"
msgstr ""

msgid ""
"8905    ### <a name=\"Rper-simple\"></a>Per.4: Don't assume that complicated "
"code is necessarily faster than simple code"
msgstr ""

msgid "8906    ##### Reason"
msgstr ""

msgid ""
"8907    Simple code can be very fast. Optimizers sometimes do marvels with "
"simple code"
msgstr ""

msgid "8908    ##### Example, good"
msgstr ""

msgid "8909        // clear expression of intent, fast execution"
msgstr ""

msgid "8910        vector<uint8_t> v(100000);"
msgstr ""

msgid "8911        for (auto& c : v)"
msgstr ""

msgid "8912            c = ~c;"
msgstr ""

msgid "8913    ##### Example, bad"
msgstr ""

msgid "8914        // intended to be faster, but is actually slower"
msgstr ""

msgid "8915        vector<uint8_t> v(100000);"
msgstr ""

msgid "8916        for (size_t i = 0; i < v.size(); i += sizeof(uint64_t))"
msgstr ""

msgid "8917        {"
msgstr ""

msgid ""
"8918            uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);"
msgstr ""

msgid "8919            quad_word = ~quad_word;"
msgstr ""

msgid "8920        }"
msgstr ""

msgid "8921    ##### Note"
msgstr ""

msgid "8922    ???"
msgstr ""

msgid "8923    ???"
msgstr ""

msgid ""
"8924    ### <a name=\"Rper-low\"></a>Per.5: Don't assume that low-level code "
"is necessarily faster than high-level code"
msgstr ""

msgid "8925    ##### Reason"
msgstr ""

msgid ""
"8926    Low-level code sometimes inhibits optimizations. Optimizers "
"sometimes do marvels with high-level code."
msgstr ""

msgid "8927    ##### Note"
msgstr ""

msgid "8928    ???"
msgstr ""

msgid "8929    ???"
msgstr ""

msgid ""
"8930    ### <a name=\"Rper-measure\"></a>Per.6: Don't make claims about "
"performance without measurements"
msgstr ""

msgid "8931    ##### Reason"
msgstr ""

msgid ""
"8932    The field of performance is littered with myth and bogus folklore."
msgstr ""

msgid ""
"8933    Modern hardware and optimizers defy naive assumptions; even experts "
"are regularly surprised."
msgstr ""

msgid "8934    ##### Note"
msgstr ""

msgid ""
"8935    Getting good performance measurements can be hard and require "
"specialized tools."
msgstr ""

msgid "8936    ##### Note"
msgstr ""

msgid ""
"8937    A few simple microbenchmarks using Unix `time` or the standard-"
"library `<chrono>` can help dispel the most obvious myths."
msgstr ""

msgid ""
"8938    If you can't measure your complete system accurately, at least try "
"to measure a few of your key operations and algorithms."
msgstr ""

msgid ""
"8939    A profiler can help tell you which parts of your system are "
"performance critical."
msgstr ""

msgid "8940    Often, you will be surprised."
msgstr ""

msgid "8941    ???"
msgstr ""

msgid ""
"8942    ### <a name=\"Rper-efficiency\"></a>Per.7: Design to enable "
"optimization"
msgstr ""

msgid "8943    ##### Reason"
msgstr ""

msgid "8944    Because we often need to optimize the initial design."
msgstr ""

msgid ""
"8945    Because a design that ignore the possibility of later improvement is "
"hard to change."
msgstr ""

msgid "8946    ##### Example"
msgstr ""

msgid "8947    From the C (and C++) standard:"
msgstr ""

msgid ""
"8948        void qsort (void* base, size_t num, size_t size, int "
"(*compar)(const void*, const void*));"
msgstr ""

msgid "8949    When did you even want to sort memory?"
msgstr ""

msgid ""
"8950    Really, we sort sequences of elements, typically stored in "
"containers."
msgstr ""

msgid ""
"8951    A call to `qsort` throws away much useful information (e.g., the "
"element type), forces the user to repeat information"
msgstr ""

msgid ""
"8952    already known (e.g., the element size), and forces the user to write "
"extra code (e.g., a function to compare `double`s)."
msgstr ""

msgid ""
"8953    This implies added work for the programmer, is error-prone, and "
"deprives the compiler of information needed for optimization."
msgstr ""

msgid "8954        double data[100];"
msgstr ""

msgid "8955        // ... fill a ..."
msgstr ""

msgid "8956        // 100 chunks of memory of sizeof(double) starting at"
msgstr ""

msgid "8957        // address data using the order defined by compare_doubles"
msgstr ""

msgid "8958        qsort(data, 100, sizeof(double), compare_doubles);"
msgstr ""

msgid ""
"8959    From the point of view of interface design is that `qsort` throws "
"away useful information."
msgstr ""

msgid "8960    We can do better (in C++98)"
msgstr ""

msgid "8961        template<typename Iter>"
msgstr ""

msgid "8962            void sort(Iter b, Iter e);  // sort [b:e)"
msgstr ""

msgid "8963        sort(data, data + 100);"
msgstr ""

msgid ""
"8964    Here, we use the compiler's knowledge about the size of the array, "
"the type of elements, and how to compare `double`s."
msgstr ""

msgid ""
"8965    With C++11 plus [concepts](#SS-concepts), we can do better still"
msgstr ""

msgid "8966        // Sortable specifies that c must be a"
msgstr ""

msgid "8967        // random-access sequence of elements comparable with <"
msgstr ""

msgid "8968        void sort(Sortable& c);"
msgstr ""

msgid "8969        sort(c);"
msgstr ""

msgid ""
"8970    The key is to pass sufficient information for a good implementation "
"to be chosen."
msgstr ""

msgid ""
"8971    In this, the `sort` interfaces shown here still have a weakness:"
msgstr ""

msgid ""
"8972    They implicitly rely on the element type having less-than (`<`) "
"defined."
msgstr ""

msgid ""
"8973    To complete the interface, we need a second version that accepts a "
"comparison criteria:"
msgstr ""

msgid "8974        // compare elements of c using p"
msgstr ""

msgid "8975        void sort(Sortable& c, Predicate<Value_type<Sortable>> p);"
msgstr ""

msgid ""
"8976    The standard-library specification of `sort` offers those two "
"versions,"
msgstr ""

msgid ""
"8977    but the semantics is expressed in English rather than code using "
"concepts."
msgstr ""

msgid "8978    ##### Note"
msgstr ""

msgid ""
"8979    Premature optimization is said to be [the root of all evil](#Rper-"
"Knuth), but that's not a reason to despise performance."
msgstr ""

msgid ""
"8980    It is never premature to consider what makes a design amenable to "
"improvement, and improved performance is a commonly desired improvement."
msgstr ""

msgid ""
"8981    Aim to build a set of habits that by default results in efficient, "
"maintainable, and optimizable code."
msgstr ""

msgid ""
"8982    In particular, when you write a function that is not a one-off "
"implementation detail, consider"
msgstr ""

msgid "8983    * Information passing:"
msgstr ""

msgid ""
"8984    Prefer clean [interfaces](#S-interfaces) carrying sufficient "
"information for later improvement of implementation."
msgstr ""

msgid ""
"8985    Note that information flows into and out of an implementation "
"through the interfaces we provide."
msgstr ""

msgid ""
"8986    * Compact data: By default, [use compact data](#Rper-compact), such "
"as `std::vector` and [access it in a systematic fashion](#Rper-access)."
msgstr ""

msgid ""
"8987    If you think you need a linked structure, try to craft the interface "
"so that this structure isn't seen by users."
msgstr ""

msgid "8988    * Function argument passing and return:"
msgstr ""

msgid "8989    Distinguish between mutable and non-mutable data."
msgstr ""

msgid "8990    Don't impose a resource management burden on your users."
msgstr ""

msgid "8991    Don't impose spurious run-time indirections on your users."
msgstr ""

msgid ""
"8992    Use [conventional ways](#Rf-conventional) of passing information "
"through an interface;"
msgstr ""

msgid ""
"8993    unconventional and/or \"optimized\" ways of passing data can "
"seriously complicate later reimplementation."
msgstr ""

msgid "8994    * Abstraction:"
msgstr ""

msgid ""
"8995    Don't overgeneralize; a design that tries to cater for every "
"possible use (and misuse) and defers every design decision for later"
msgstr ""

msgid ""
"8996    (using compile-time or run-time indirections) is usually a "
"complicated, bloated, hard-to-understand mess."
msgstr ""

msgid ""
"8997    Generalize from concrete examples, preserving performance as we "
"generalize."
msgstr ""

msgid ""
"8998    Do not generalize based on mere speculation about future needs."
msgstr ""

msgid "8999    The ideal is zero-overhead generalization."
msgstr ""

msgid "9000    * Libraries:"
msgstr ""

msgid "9001    Use libraries with good interfaces."
msgstr ""

msgid ""
"9002    If no library is available build one yourself and imitate the "
"interface style from a good library."
msgstr ""

msgid ""
"9003    The [standard library](#S-stdlib) is a good first place to look for "
"inspiration."
msgstr ""

msgid "9004    * Isolation:"
msgstr ""

msgid ""
"9005    Isolate your code from messy and/or old-style code by providing an "
"interface of your choosing to it."
msgstr ""

msgid ""
"9006    This is sometimes called \"providing a wrapper\" for the useful/"
"necessary but messy code."
msgstr ""

msgid "9007    Don't let bad designs \"bleed into\" your code."
msgstr ""

msgid "9008    ##### Example"
msgstr ""

msgid "9009    Consider:"
msgstr ""

msgid "9010        template <class ForwardIterator, class T>"
msgstr ""

msgid ""
"9011        bool binary_search(ForwardIterator first, ForwardIterator last, "
"const T& val);"
msgstr ""

msgid ""
"9012    `binary_search(begin(c), end(c), 7)` will tell you whether `7` is in "
"`c` or not."
msgstr ""

msgid ""
"9013    However, it will not tell you where that `7` is or whether there are "
"more than one `7`."
msgstr ""

msgid ""
"9014    Sometimes, just passing the minimal amount of information back "
"(here, `true` or `false`) is sufficient, but a good interface passes"
msgstr ""

msgid ""
"9015    needed information back to the caller. Therefore, the standard "
"library also offers"
msgstr ""

msgid "9016        template <class ForwardIterator, class T>"
msgstr ""

msgid ""
"9017        ForwardIterator lower_bound(ForwardIterator first, "
"ForwardIterator last, const T& val);"
msgstr ""

msgid ""
"9018    `lower_bound` returns an iterator to the first match if any, "
"otherwise to the first element greater than `val`, or `last` if no such "
"element is found."
msgstr ""

msgid ""
"9019    However, `lower_bound` still doesn't return enough information for "
"all uses, so the standard library also offers"
msgstr ""

msgid "9020        template <class ForwardIterator, class T>"
msgstr ""

msgid "9021        pair<ForwardIterator, ForwardIterator>"
msgstr ""

msgid ""
"9022        equal_range(ForwardIterator first, ForwardIterator last, const "
"T& val);"
msgstr ""

msgid ""
"9023    `equal_range` returns a `pair` of iterators specifying the first and "
"one beyond last match."
msgstr ""

msgid "9024        auto r = equal_range(begin(c), end(c), 7);"
msgstr ""

msgid "9025        for (auto p = r.first(); p != r.second(), ++p)"
msgstr ""

msgid "9026            cout << *p << '\\n';"
msgstr ""

msgid ""
"9027    Obviously, these three interfaces are implemented by the same basic "
"code."
msgstr ""

msgid ""
"9028    They are simply three ways of presenting the basic binary search "
"algorithm to users,"
msgstr ""

msgid "9029    ranging from the simplest (\"make simple things simple!\")"
msgstr ""

msgid ""
"9030    to returning complete, but not always needed, information (\"don't "
"hide useful information\")."
msgstr ""

msgid ""
"9031    Naturally, crafting such a set of interfaces requires experience and "
"domain knowledge."
msgstr ""

msgid "9032    ##### Note"
msgstr ""

msgid ""
"9033    Do not simply craft the interface to match the first implementation "
"and the first use case you think of."
msgstr ""

msgid ""
"9034    Once your first initial implementation is complete, review it; once "
"you deploy it, mistakes will be hard to remedy."
msgstr ""

msgid "9035    ##### Note"
msgstr ""

msgid ""
"9036    A need for efficiency does not imply a need for [low-level "
"code](#Rper-low)."
msgstr ""

msgid "9037    High-level code does not imply slow or bloated."
msgstr ""

msgid "9038    ##### Note"
msgstr ""

msgid "9039    Things have costs."
msgstr ""

msgid ""
"9040    Don't be paranoid about costs (modern computers really are very "
"fast),"
msgstr ""

msgid ""
"9041    but have a rough idea of the order of magnitude of cost of what you "
"use."
msgstr ""

msgid "9042    For example, have a rough idea of the cost of"
msgstr ""

msgid "9043    a memory access,"
msgstr ""

msgid "9044    a function call,"
msgstr ""

msgid "9045    a string comparison,"
msgstr ""

msgid "9046    a system call,"
msgstr ""

msgid "9047    a disk access,"
msgstr ""

msgid "9048    and a message through a network."
msgstr ""

msgid "9049    ##### Note"
msgstr ""

msgid ""
"9050    If you can only think of one implementation, you probably don't have "
"something for which you can devise a stable interface."
msgstr ""

msgid ""
"9051    Maybe, it is just an implementation detail - not every piece of code "
"needs a stable interface - but pause and consider."
msgstr ""

msgid "9052    One question that can be useful is"
msgstr ""

msgid ""
"9053    \"what interface would be needed if this operation should be "
"implemented using multiple threads? be vectorized?\""
msgstr ""

msgid "9054    ##### Note"
msgstr ""

msgid ""
"9055    This rule does not contradict the [Don't optimize prematurely](#Rper-"
"Knuth) rule."
msgstr ""

msgid ""
"9056    It complements it encouraging developers enable later - appropriate "
"and non-premature - optimization, if and where needed."
msgstr ""

msgid "9057    ##### Enforcement"
msgstr ""

msgid "9058    Tricky."
msgstr ""

msgid ""
"9059    Maybe looking for `void*` function arguments will find examples of "
"interfaces that hinder later optimization."
msgstr ""

msgid ""
"9060    ### <a name=\"Rper-type\"></a>Per.10: Rely on the static type system"
msgstr ""

msgid "9061    ##### Reason"
msgstr ""

msgid ""
"9062    Type violations, weak types (e.g. `void*`s), and low-level code (e.g."
", manipulation of sequences as individual bytes) make the job of the "
"optimizer much harder. Simple code often optimizes better than hand-crafted "
"complex code."
msgstr ""

msgid "9063    ???"
msgstr ""

msgid ""
"9064    ### <a name=\"Rper-Comp\"></a>Per.11: Move computation from run time "
"to compile time"
msgstr ""

msgid "9065    ##### Reason"
msgstr ""

msgid "9066    To decrease code size and run time."
msgstr ""

msgid "9067    To avoid data races by using constants."
msgstr ""

msgid ""
"9068    To catch errors at compile time (and thus eliminate the need for "
"error-handling code)."
msgstr ""

msgid "9069    ##### Example"
msgstr ""

msgid "9070        double square(double d) { return d*d; }"
msgstr ""

msgid ""
"9071        static double s2 = square(2);    // old-style: dynamic "
"initialization"
msgstr ""

msgid ""
"9072        constexpr double ntimes(double d, int n)   // assume 0 <= n"
msgstr ""

msgid "9073        {"
msgstr ""

msgid "9074                double m = 1;"
msgstr ""

msgid "9075                while (n--) m *= d;"
msgstr ""

msgid "9076                return m;"
msgstr ""

msgid "9077        }"
msgstr ""

msgid ""
"9078        constexpr double s3 {ntimes(2, 3)};  // modern-style: compile-"
"time initialization"
msgstr ""

msgid ""
"9079    Code like the initialization of `s2` isn't uncommon, especially for "
"initialization that's a bit more complicated than `square()`."
msgstr ""

msgid ""
"9080    However, compared to the initialization of `s3` there are two "
"problems:"
msgstr ""

msgid "9081    * we suffer the overhead of a function call at run time"
msgstr ""

msgid ""
"9082    * `s2` just might be accessed by another thread before the "
"initialization happens."
msgstr ""

msgid "9083    Note: you can't have a data race on a constant."
msgstr ""

msgid "9084    ##### Example"
msgstr ""

msgid ""
"9085    Consider a popular technique for providing a handle for storing "
"small objects in the handle itself and larger ones on the heap."
msgstr ""

msgid "9086        constexpr int on_stack_max = 20;"
msgstr ""

msgid "9087        template<typename T>"
msgstr ""

msgid "9088        struct Scoped {     // store a T in Scoped"
msgstr ""

msgid "9089                // ..."
msgstr ""

msgid "9090            T obj;"
msgstr ""

msgid "9091        };"
msgstr ""

msgid "9092        template<typename T>"
msgstr ""

msgid "9093        struct On_heap {    // store a T on the free store"
msgstr ""

msgid "9094                // ..."
msgstr ""

msgid "9095                T* objp;"
msgstr ""

msgid "9096        };"
msgstr ""

msgid "9097        template<typename T>"
msgstr ""

msgid ""
"9098        using Handle = typename std::conditional<(sizeof(T) <= "
"on_stack_max),"
msgstr ""

msgid "9099                            Scoped<T>,      // first alternative"
msgstr ""

msgid "9100                            On_heap<T>      // second alternative"
msgstr ""

msgid "9101                       >::type;"
msgstr ""

msgid "9102        void f()"
msgstr ""

msgid "9103        {"
msgstr ""

msgid ""
"9104            Handle<double> v1;                   // the double goes on "
"the stack"
msgstr ""

msgid ""
"9105            Handle<std::array<double, 200>> v2;  // the array goes on "
"the free store"
msgstr ""

msgid "9106            // ..."
msgstr ""

msgid "9107        }"
msgstr ""

msgid ""
"9108    Assume that `Scoped` and `On_heap` provide compatible user "
"interfaces."
msgstr ""

msgid "9109    Here we compute the optimal type to use at compile time."
msgstr ""

msgid ""
"9110    There are similar techniques for selecting the optimal function to "
"call."
msgstr ""

msgid "9111    ##### Note"
msgstr ""

msgid "9112    The ideal is {not} to try execute everything at compile time."
msgstr ""

msgid ""
"9113    Obviously, most computations depend on inputs so they can't be moved "
"to compile time,"
msgstr ""

msgid ""
"9114    but beyond that logical constraint is the fact that complex compile-"
"time computation can seriously increase compile times"
msgstr ""

msgid "9115    and complicate debugging."
msgstr ""

msgid ""
"9116    It is even possible to slow down code by compile-time computation."
msgstr ""

msgid ""
"9117    This is admittedly rare, but by factoring out a general computation "
"into separate optimal sub-calculations it is possible to render the "
"instruction cache less effective."
msgstr ""

msgid "9118    ##### Enforcement"
msgstr ""

msgid ""
"9119    * Look for simple functions that might be constexpr (but are not)."
msgstr ""

msgid ""
"9120    * Look for functions called with all constant-expression arguments."
msgstr ""

msgid "9121    * Look for macros that could be constexpr."
msgstr ""

msgid ""
"9122    ### <a name=\"Rper-alias\"></a>Per.12: Eliminate redundant aliases"
msgstr ""

msgid "9123    ???"
msgstr ""

msgid ""
"9124    ### <a name=\"Rper-indirect\"></a>Per.13: Eliminate redundant "
"indirections"
msgstr ""

msgid "9125    ???"
msgstr ""

msgid ""
"9126    ### <a name=\"Rper-alloc\"></a>Per.14: Minimize the number of "
"allocations and deallocations"
msgstr ""

msgid "9127    ???"
msgstr ""

msgid ""
"9128    ### <a name=\"Rper-alloc0\"></a>Per.15: Do not allocate on a "
"critical branch"
msgstr ""

msgid "9129    ???"
msgstr ""

msgid ""
"9130    ### <a name=\"Rper-compact\"></a>Per.16: Use compact data structures"
msgstr ""

msgid "9131    ##### Reason"
msgstr ""

msgid "9132    Performance is typically dominated by memory access times."
msgstr ""

msgid "9133    ???"
msgstr ""

msgid ""
"9134    ### <a name=\"Rper-struct\"></a>Per.17: Declare the most used member "
"of a time-critical struct first"
msgstr ""

msgid "9135    ???"
msgstr ""

msgid "9136    ### <a name=\"Rper-space\"></a>Per.18: Space is time"
msgstr ""

msgid "9137    ##### Reason"
msgstr ""

msgid "9138    Performance is typically dominated by memory access times."
msgstr ""

msgid "9139    ???"
msgstr ""

msgid ""
"9140    ### <a name=\"Rper-access\"></a>Per.19: Access memory predictably"
msgstr ""

msgid "9141    ##### Reason"
msgstr ""

msgid ""
"9142    Performance is very sensitive to cache performance and cache "
"algorithms favor simple (usually linear) access to adjacent data."
msgstr ""

msgid "9143    ##### Example"
msgstr ""

msgid "9144        int matrix[rows][cols];"
msgstr ""

msgid "9145        // bad"
msgstr ""

msgid "9146        for (int c = 0; c < cols; ++c)"
msgstr ""

msgid "9147            for (int r = 0; r < rows; ++r)"
msgstr ""

msgid "9148                sum += matrix[r][c];"
msgstr ""

msgid "9149        // good"
msgstr ""

msgid "9150        for (int r = 0; r < rows; ++r)"
msgstr ""

msgid "9151            for (int c = 0; c < cols; ++c)"
msgstr ""

msgid "9152                sum += matrix[r][c];"
msgstr ""

msgid ""
"9153    ### <a name=\"Rper-context\"></a>Per.30: Avoid context switches on "
"the critical path"
msgstr ""

msgid "9154    ???"
msgstr ""

msgid "9155    # <a name=\"S-concurrency\"></a>CP: Concurrency and parallelism"
msgstr ""

msgid ""
"9156    We often want our computers to do many tasks at the same time (or at "
"least make them appear to do them at the same time)."
msgstr ""

msgid ""
"9157    The reasons for doing so varies (e.g., wanting to wait for many "
"events using only a single processor, processing many data streams "
"simultaneously, or utilizing many hardware facilities)"
msgstr ""

msgid ""
"9158    and so does the basic facilities for expressing concurrency and "
"parallelism."
msgstr ""

msgid ""
"9159    Here, we articulate a few general principles and rules for using the "
"ISO standard C++ facilities for expressing basic concurrency and parallelism."
""
msgstr ""

msgid ""
"9160    The core machine support for concurrent and parallel programming is "
"the thread."
msgstr ""

msgid ""
"9161    Threads allow you to run multiple instances of your program "
"independently, while sharing"
msgstr ""

msgid ""
"9162    the same memory. Concurrent programming is tricky for many reasons, "
"most"
msgstr ""

msgid ""
"9163    importantly that it is undefined behavior to read data in one thread "
"after it"
msgstr ""

msgid ""
"9164    was written by another thread, if there is no proper synchronization "
"between"
msgstr ""

msgid ""
"9165    those threads. Making existing single-threaded code execute "
"concurrently can be"
msgstr ""

msgid ""
"9166    as trivial as adding `std::async` or `std::thread` strategically, or "
"it can"
msgstr ""

msgid ""
"9167    necessitate a full rewrite, depending on whether the original code "
"was written"
msgstr ""

msgid "9168    in a thread-friendly way."
msgstr ""

msgid ""
"9169    The concurrency/parallelism rules in this document are designed with "
"three goals"
msgstr ""

msgid "9170    in mind:"
msgstr ""

msgid ""
"9171    * To help you write code that is amenable to being used in a "
"threaded"
msgstr ""

msgid "9172      environment"
msgstr ""

msgid ""
"9173    * To show clean, safe ways to use the threading primitives offered "
"by the"
msgstr ""

msgid "9174      standard library"
msgstr ""

msgid ""
"9175    * To offer guidance on what to do when concurrency and parallelism "
"aren't giving"
msgstr ""

msgid "9176      you the performance gains you need"
msgstr ""

msgid ""
"9177    It is also important to note that concurrency in C++ is an "
"unfinished"
msgstr ""

msgid ""
"9178    story. C++11 introduced many core concurrency primitives, C++14 "
"improved on"
msgstr ""

msgid ""
"9179    them, and it seems that there is much interest in making the writing "
"of"
msgstr ""

msgid ""
"9180    concurrent programs in C++ even easier. We expect some of the "
"library-related"
msgstr ""

msgid "9181    guidance here to change significantly over time."
msgstr ""

msgid "9182    This section needs a lot of work (obviously)."
msgstr ""

msgid "9183    Please note that we start with rules for relative non-experts."
msgstr ""

msgid "9184    Real experts must wait a bit;"
msgstr ""

msgid "9185    contributions are welcome,"
msgstr ""

msgid ""
"9186    but please think about the majority of programmers who are "
"struggling to get their concurrent programs correct and performant."
msgstr ""

msgid "9187    Concurrency and parallelism rule summary:"
msgstr ""

msgid ""
"9188    * [CP.1: Assume that your code will run as part of a multi-threaded "
"program](#Rconc-multi)"
msgstr ""

msgid "9189    * [CP.2: Avoid data races](#Rconc-races)"
msgstr ""

msgid ""
"9190    * [CP.3: Minimize explicit sharing of writable data](#Rconc-data)"
msgstr ""

msgid ""
"9191    * [CP.4: Think in terms of tasks, rather than threads](#Rconc-task)"
msgstr ""

msgid ""
"9192    * [CP.8: Don't try to use `volatile` for synchronization](#Rconc-"
"volatile)"
msgstr ""

msgid ""
"9193    * [CP.9: Whenever feasible use tools to validate your concurrent "
"code](#Rconc-tools)"
msgstr ""

msgid "9194    **See also**:"
msgstr ""

msgid "9195    * [CP.con: Concurrency](#SScp-con)"
msgstr ""

msgid "9196    * [CP.par: Parallelism](#SScp-par)"
msgstr ""

msgid "9197    * [CP.mess: Message passing](#SScp-mess)"
msgstr ""

msgid "9198    * [CP.vec: Vectorization](#SScp-vec)"
msgstr ""

msgid "9199    * [CP.free: Lock-free programming](#SScp-free)"
msgstr ""

msgid "9200    * [CP.etc: Etc. concurrency rules](#SScp-etc)"
msgstr ""

msgid ""
"9201    ### <a name=\"Rconc-multi\"></a>CP.1: Assume that your code will run "
"as part of a multi-threaded program"
msgstr ""

msgid "9202    ##### Reason"
msgstr ""

msgid ""
"9203    It is hard to be certain that concurrency isn't used now or will be "
"sometime in the future."
msgstr ""

msgid "9204    Code gets reused."
msgstr ""

msgid ""
"9205    Libraries using threads may be used from some other part of the "
"program."
msgstr ""

msgid ""
"9206    Note that this applies most urgently to library code and least "
"urgently to stand-alone applications."
msgstr ""

msgid ""
"9207    However, thanks to the magic of cut-and-paste, code fragments can "
"turn up in unexpected places."
msgstr ""

msgid "9208    ##### Example"
msgstr ""

msgid "9209        double cached_computation(double x)"
msgstr ""

msgid "9210        {"
msgstr ""

msgid "9211            static double cached_x = 0.0;"
msgstr ""

msgid "9212            static double cached_result = COMPUTATION_OF_ZERO;"
msgstr ""

msgid "9213            double result;"
msgstr ""

msgid "9214            if (cached_x == x)"
msgstr ""

msgid "9215                return cached_result;"
msgstr ""

msgid "9216            result = computation(x);"
msgstr ""

msgid "9217            cached_x = x;"
msgstr ""

msgid "9218            cached_result = result;"
msgstr ""

msgid "9219            return result;"
msgstr ""

msgid "9220        }"
msgstr ""

msgid ""
"9221    Although `cached_computation` works perfectly in a single-threaded "
"environment, in a multi-threaded environment the two `static` variables "
"result in data races and thus undefined behavior."
msgstr ""

msgid ""
"9222    There are several ways that this example could be made safe for a "
"multi-threaded environment:"
msgstr ""

msgid "9223    * Delegate concurrency concerns upwards to the caller."
msgstr ""

msgid ""
"9224    * Mark the `static` variables as `thread_local` (which might make "
"caching less effective)."
msgstr ""

msgid ""
"9225    * Implement concurrency control, for example, protecting the two "
"`static` variables with a `static` lock (which might reduce performance)."
msgstr ""

msgid ""
"9226    * Have the caller provide the memory to be used for the cache, "
"thereby delegating both memory allocation and concurrency concerns upwards "
"to the caller."
msgstr ""

msgid "9227    * Refuse to build and/or run in a multi-threaded environment."
msgstr ""

msgid ""
"9228    * Provide two implementations, one which is used in single-threaded "
"environments and another which is used in multi-threaded environments."
msgstr ""

msgid "9229    ##### Exception"
msgstr ""

msgid "9230    Code that is never run in a multi-threaded environment."
msgstr ""

msgid ""
"9231    Be careful: there are many examples where code that was \"known\" to "
"never run in a multi-threaded program"
msgstr ""

msgid ""
"9232    was run as part of a multi-threaded program. Often years later."
msgstr ""

msgid ""
"9233    Typically, such programs lead to a painful effort to remove data "
"races."
msgstr ""

msgid ""
"9234    Therefore, code that is never intended to run in a multi-threaded "
"environment should be clearly labeled as such and ideally come with compile "
"or run-time enforcement mechanisms to catch those usage bugs early."
msgstr ""

msgid "9235    ### <a name=\"Rconc-races\"></a>CP.2: Avoid data races"
msgstr ""

msgid "9236    ##### Reason"
msgstr ""

msgid ""
"9237    Unless you do, nothing is guaranteed to work and subtle errors will "
"persist."
msgstr ""

msgid "9238    ##### Note"
msgstr ""

msgid ""
"9239    In a nutshell, if two threads can access the same object "
"concurrently (without synchronization), and at least one is a writer "
"(performing a non-`const` operation), you have a data race."
msgstr ""

msgid ""
"9240    For further information of how to use synchronization well to "
"eliminate data races, please consult a good book about concurrency."
msgstr ""

msgid "9241    ##### Example, bad"
msgstr ""

msgid ""
"9242    There are many examples of data races that exist, some of which are "
"running in"
msgstr ""

msgid ""
"9243    production software at this very moment. One very simple example:"
msgstr ""

msgid "9244        int get_id() {"
msgstr ""

msgid "9245          static int id = 1;"
msgstr ""

msgid "9246          return id++;"
msgstr ""

msgid "9247        }"
msgstr ""

msgid ""
"9248    The increment here is an example of a data race. This can go wrong "
"in many ways,"
msgstr ""

msgid "9249    including:"
msgstr ""

msgid ""
"9250    * Thread A loads the value of `id`, the OS context switches A out "
"for some"
msgstr ""

msgid ""
"9251      period, during which other threads create hundreds of IDs. Thread "
"A is then"
msgstr ""

msgid ""
"9252      allowed to run again, and `id` is written back to that location as "
"A's read of"
msgstr ""

msgid "9253      `id` plus one."
msgstr ""

msgid ""
"9254    * Thread A and B load `id` and increment it simultaneously.  They "
"both get the"
msgstr ""

msgid "9255      same ID."
msgstr ""

msgid "9256    Local static variables are a common source of data races."
msgstr ""

msgid "9257    ##### Example, bad:"
msgstr ""

msgid "9258        void f(fstream&  fs, regex pat)"
msgstr ""

msgid "9259        {"
msgstr ""

msgid "9260            array<double, max> buf;"
msgstr ""

msgid ""
"9261            int sz = read_vec(fs, buf, max);            // read from fs "
"into buf"
msgstr ""

msgid "9262            gsl::span<double> s {buf};"
msgstr ""

msgid "9263            // ..."
msgstr ""

msgid ""
"9264            auto h1 = async([&]{ sort(par, s); });     // spawn a task "
"to sort"
msgstr ""

msgid "9265            // ..."
msgstr ""

msgid ""
"9266            auto h2 = async([&]{ return find_all(buf, sz, pat); });   // "
"spawn a task to find matches"
msgstr ""

msgid "9267            // ..."
msgstr ""

msgid "9268        }"
msgstr ""

msgid ""
"9269    Here, we have a (nasty) data race on the elements of `buf` (`sort` "
"will both read and write)."
msgstr ""

msgid "9270    All data races are nasty."
msgstr ""

msgid "9271    Here, we managed to get a data race on data on the stack."
msgstr ""

msgid "9272    Not all data races are as easy to spot as this one."
msgstr ""

msgid "9273    ##### Example, bad:"
msgstr ""

msgid "9274        // code not controlled by a lock"
msgstr ""

msgid "9275        unsigned val;"
msgstr ""

msgid "9276        if (val < 5) {"
msgstr ""

msgid "9277            // ... other thread can change val here ..."
msgstr ""

msgid "9278            switch (val) {"
msgstr ""

msgid "9279            case 0: // ..."
msgstr ""

msgid "9280            case 1: // ..."
msgstr ""

msgid "9281            case 2: // ..."
msgstr ""

msgid "9282            case 3: // ..."
msgstr ""

msgid "9283            case 4: // ..."
msgstr ""

msgid "9284            }"
msgstr ""

msgid "9285        }"
msgstr ""

msgid ""
"9286    Now, a compiler that does not know that `val` can change will  most "
"likely implement that `switch` using a jump table with five entries."
msgstr ""

msgid ""
"9287    Then, a `val` outside the `[0..4]` range will cause a jump to an "
"address that could be anywhere in the program, and execution would proceed "
"there."
msgstr ""

msgid "9288    Really, \"all bets are off\" if you get a data race."
msgstr ""

msgid ""
"9289    Actually, it can be worse still: by looking at the generated code "
"you may be able to determine where the stray jump will go for a given value;"
msgstr ""

msgid "9290    this can be a security risk."
msgstr ""

msgid "9291    ##### Enforcement"
msgstr ""

msgid "9292    Some is possible, do at least something."
msgstr ""

msgid ""
"9293    There are commercial and open-source tools that try to address this "
"problem,"
msgstr ""

msgid "9294    but be aware that solutions have costs and blind spots."
msgstr ""

msgid ""
"9295    Static tools often have many false positives and run-time tools "
"often have a significant cost."
msgstr ""

msgid "9296    We hope for better tools."
msgstr ""

msgid ""
"9297    Using multiple tools can catch more problems than a single one."
msgstr ""

msgid ""
"9298    There are other ways you can mitigate the chance of data races:"
msgstr ""

msgid "9299    * Avoid global data"
msgstr ""

msgid "9300    * Avoid `static` variables"
msgstr ""

msgid ""
"9301    * More use of value types on the stack (and don't pass pointers "
"around too much)"
msgstr ""

msgid ""
"9302    * More use of immutable data (literals, `constexpr`, and `const`)"
msgstr ""

msgid ""
"9303    ### <a name=\"Rconc-data\"></a>CP.3: Minimize explicit sharing of "
"writable data"
msgstr ""

msgid "9304    ##### Reason"
msgstr ""

msgid "9305    If you don't share writable data, you can't have a data race."
msgstr ""

msgid ""
"9306    The less sharing you do, the less chance you have to forget to "
"synchronize access (and get data races)."
msgstr ""

msgid ""
"9307    The less sharing you do, the less chance you have to wait on a lock "
"(so performance can improve)."
msgstr ""

msgid "9308    ##### Example"
msgstr ""

msgid "9309        bool validate(const vector<Reading>&);"
msgstr ""

msgid ""
"9310        Graph<Temp_node> temperature_gradiants(const vector<Reading>&);"
msgstr ""

msgid "9311        Image altitude_map(const vector<Reading>&);"
msgstr ""

msgid "9312        // ..."
msgstr ""

msgid ""
"9313        void process_readings(const vector<Reading>& surface_readings)"
msgstr ""

msgid "9314        {"
msgstr ""

msgid ""
"9315            auto h1 = async([&] { if (!validate(surface_readings)) throw "
"Invalid_data{}; });"
msgstr ""

msgid ""
"9316            auto h2 = async([&] { return "
"temperature_gradiants(surface_readings); });"
msgstr ""

msgid ""
"9317            auto h3 = async([&] { return altitude_map(surface_readings); "
"});"
msgstr ""

msgid "9318            // ..."
msgstr ""

msgid "9319            h1.get();"
msgstr ""

msgid "9320            auto v2 = h2.get();"
msgstr ""

msgid "9321            auto v3 = h3.get();"
msgstr ""

msgid "9322            // ..."
msgstr ""

msgid "9323        }"
msgstr ""

msgid ""
"9324    Without those `const`s, we would have to review every asynchronously "
"invoked function for potential data races on `surface_readings`."
msgstr ""

msgid ""
"9325    Making `surface_readings` be `const` (with respect to this function) "
"allow reasoning using only the function body."
msgstr ""

msgid "9326    ##### Note"
msgstr ""

msgid "9327    Immutable data can be safely and efficiently shared."
msgstr ""

msgid ""
"9328    No locking is needed: You can't have a data race on a constant."
msgstr ""

msgid ""
"9329    See also [CP.mess: Message Passing](#SScp-mess) and [CP.31: prefer "
"pass by value](#Rconc-data-by-value)."
msgstr ""

msgid "9330    ##### Enforcement"
msgstr ""

msgid "9331    ???"
msgstr ""

msgid ""
"9332    ### <a name=\"Rconc-task\"></a>CP.4: Think in terms of tasks, rather "
"than threads"
msgstr ""

msgid "9333    ##### Reason"
msgstr ""

msgid ""
"9334    A `thread` is an implementation concept, a way of thinking about the "
"machine."
msgstr ""

msgid ""
"9335    A task is an application notion, something you'd like to do, "
"preferably concurrently with other tasks."
msgstr ""

msgid "9336    Application concepts are easier to reason about."
msgstr ""

msgid "9337    ##### Example"
msgstr ""

msgid "9338        void some_fun() {"
msgstr ""

msgid "9339            std::string  msg, msg2;"
msgstr ""

msgid ""
"9340            std::thread publisher([&] { msg = \"Hello\"; });       // "
"bad: less expressive"
msgstr ""

msgid ""
"9341                                                                 //      "
"and more error-prone"
msgstr ""

msgid ""
"9342            auto pubtask = std::async([&] { msg2 = \"Hello\"; });  // OK"
msgstr ""

msgid "9343            // ..."
msgstr ""

msgid "9344            publisher.join();"
msgstr ""

msgid "9345        }"
msgstr ""

msgid "9346    ##### Note"
msgstr ""

msgid ""
"9347    With the exception of `async()`, the standard-library facilities are "
"low-level, machine-oriented, threads-and-lock level."
msgstr ""

msgid ""
"9348    This is a necessary foundation, but we have to try to raise the "
"level of abstraction: for productivity, for reliability, and for performance."
""
msgstr ""

msgid ""
"9349    This is a potent argument for using higher level, more applications-"
"oriented libraries (if possibly, built on top of standard-library "
"facilities)."
msgstr ""

msgid "9350    ##### Enforcement"
msgstr ""

msgid "9351    ???"
msgstr ""

msgid ""
"9352    ### <a name=\"Rconc-volatile\"></a>CP.8: Don't try to use `volatile` "
"for synchronization"
msgstr ""

msgid "9353    ##### Reason"
msgstr ""

msgid ""
"9354    In C++, unlike some other languages, `volatile` does not provide "
"atomicity, does not synchronize between threads,"
msgstr ""

msgid ""
"9355    and does not prevent instruction reordering (neither compiler nor "
"hardware)."
msgstr ""

msgid "9356    It simply has nothing to do with concurrency."
msgstr ""

msgid "9357    ##### Example, bad:"
msgstr ""

msgid ""
"9358        int free_slots = max_slots; // current source of memory for "
"objects"
msgstr ""

msgid "9359        Pool* use()"
msgstr ""

msgid "9360        {"
msgstr ""

msgid "9361            if (int n = free_slots--) return &pool[n];"
msgstr ""

msgid "9362        }"
msgstr ""

msgid "9363    Here we have a problem:"
msgstr ""

msgid ""
"9364    This is perfectly good code in a single-threaded program, but have "
"two threads execute this and"
msgstr ""

msgid ""
"9365    there is a race condition on `free_slots` so that two threads might "
"get the same value and `free_slots`."
msgstr ""

msgid ""
"9366    That's (obviously) a bad data race, so people trained in other "
"languages may try to fix it like this:"
msgstr ""

msgid ""
"9367        volatile int free_slots = max_slots; // current source of memory "
"for objects"
msgstr ""

msgid "9368        Pool* use()"
msgstr ""

msgid "9369        {"
msgstr ""

msgid "9370            if (int n = free_slots--) return &pool[n];"
msgstr ""

msgid "9371        }"
msgstr ""

msgid ""
"9372    This has no effect on synchronization: The data race is still there!"
msgstr ""

msgid "9373    The C++ mechanism for this is `atomic` types:"
msgstr ""

msgid ""
"9374        atomic<int> free_slots = max_slots; // current source of memory "
"for objects"
msgstr ""

msgid "9375        Pool* use()"
msgstr ""

msgid "9376        {"
msgstr ""

msgid "9377            if (int n = free_slots--) return &pool[n];"
msgstr ""

msgid "9378        }"
msgstr ""

msgid "9379    Now the `--` operation is atomic,"
msgstr ""

msgid ""
"9380    rather than a read-increment-write sequence where another thread "
"might get in-between the individual operations."
msgstr ""

msgid "9381    ##### Alternative"
msgstr ""

msgid ""
"9382    Use `atomic` types where you might have used `volatile` in some "
"other language."
msgstr ""

msgid "9383    Use a `mutex` for more complicated examples."
msgstr ""

msgid "9384    ##### See also"
msgstr ""

msgid "9385    [(rare) proper uses of `volatile`](#Rconc-volatile2)"
msgstr ""

msgid ""
"9386    ### <a name=\"Rconc-tools\"></a>CP.9: Whenever feasible use tools to "
"validate your concurrent code"
msgstr ""

msgid ""
"9387    Experience shows that concurrent code is exceptionally hard to get "
"right"
msgstr ""

msgid ""
"9388    and that compile-time checking, run-time checks, and testing are "
"less effective at finding concurrency errors"
msgstr ""

msgid "9389    than they are at finding errors in sequential code."
msgstr ""

msgid ""
"9390    Subtle concurrency errors can have dramatically bad effects, "
"including memory corruption and deadlocks."
msgstr ""

msgid "9391    ##### Example"
msgstr ""

msgid "9392        ???"
msgstr ""

msgid "9393    ##### Note"
msgstr ""

msgid ""
"9394    Thread safety is challenging, often getting the better of "
"experienced programmers: tooling is an important strategy to mitigate those "
"risks."
msgstr ""

msgid ""
"9395    There are many tools \"out there\", both commercial and open-source "
"tools, both research and production tools."
msgstr ""

msgid ""
"9396    Unfortunately people's needs and constraints differ so dramatically "
"that we cannot make specific recommendations,"
msgstr ""

msgid "9397    but we can mention:"
msgstr ""

msgid ""
"9398    * Static enforcement tools: both [clang](http://clang.llvm.org/docs/"
"ThreadSafetyAnalysis.html)"
msgstr ""

msgid ""
"9399    and some older versions of [GCC](https://gcc.gnu.org/wiki/"
"ThreadSafetyAnnotation)"
msgstr ""

msgid ""
"9400    have some support for static annotation of thread safety properties."
msgstr ""

msgid ""
"9401    Consistent use of this technique turns many classes of thread-safety "
"errors into compile-time errors."
msgstr ""

msgid ""
"9402    The annotations are generally local (marking a particular member "
"variable as guarded by a particular mutex),"
msgstr ""

msgid ""
"9403    and are usually easy to learn. However, as with many static tools, "
"it can often present false negatives;"
msgstr ""

msgid "9404    cases that should have been caught but were allowed."
msgstr ""

msgid ""
"9405    * dynamic enforcement tools: Clang's [Thread Sanitizer](http://clang."
"llvm.org/docs/ThreadSanitizer.html) (aka TSAN)"
msgstr ""

msgid ""
"9406    is a powerful example of dynamic tools: it changes the build and "
"execution of your program to add bookkeeping on memory access,"
msgstr ""

msgid ""
"9407    absolutely identifying data races in a given execution of your "
"binary."
msgstr ""

msgid ""
"9408    The cost for this is both memory (5-10x in most cases) and CPU "
"slowdown (2-20x)."
msgstr ""

msgid ""
"9409    Dynamic tools like this are best when applied to integration tests, "
"canary pushes, or unittests that operate on multiple threads."
msgstr ""

msgid ""
"9410    Workload matters: When TSAN identifies a problem, it is effectively "
"always an actual data race,"
msgstr ""

msgid "9411    but it can only identify races seen in a given execution."
msgstr ""

msgid "9412    ##### Enforcement"
msgstr ""

msgid ""
"9413    It is up to an application builder to choose which support tools are "
"valuable for a particular applications."
msgstr ""

msgid "9414    ## <a name=\"SScp-con\"></a>CP.con: Concurrency"
msgstr ""

msgid ""
"9415    This section focuses on relatively ad-hoc uses of multiple threads "
"communicating through shared data."
msgstr ""

msgid "9416    * For parallel algorithms, see [parallelism](#SScp-par)"
msgstr ""

msgid ""
"9417    * For inter-task communication without explicit sharing, see "
"[messaging](#SScp-mess)"
msgstr ""

msgid "9418    * For vector parallel code, see [vectorization](#SScp-vec)"
msgstr ""

msgid "9419    * For lock-free programming, see [lock free](#SScp-free)"
msgstr ""

msgid "9420    Concurrency rule summary:"
msgstr ""

msgid ""
"9421    * [CP.20: Use RAII, never plain `lock()`/`unlock()`](#Rconc-raii)"
msgstr ""

msgid ""
"9422    * [CP.21: Use `std::lock()` or `std::scoped_lock` to acquire "
"multiple `mutex`es](#Rconc-lock)"
msgstr ""

msgid ""
"9423    * [CP.22: Never call unknown code while holding a lock (e.g., a "
"callback)](#Rconc-unknown)"
msgstr ""

msgid ""
"9424    * [CP.23: Think of a joining `thread` as a scoped container](#Rconc-"
"join)"
msgstr ""

msgid ""
"9425    * [CP.24: Think of a `thread` as a global container](#Rconc-detach)"
msgstr ""

msgid ""
"9426    * [CP.25: Prefer `gsl::joining_thread` over `std::thread`](#Rconc-"
"joining_thread)"
msgstr ""

msgid "9427    * [CP.26: Don't `detach()` a thread](#Rconc-detached_thread)"
msgstr ""

msgid ""
"9428    * [CP.31: Pass small amounts of data between threads by value, "
"rather than by reference or pointer](#Rconc-data-by-value)"
msgstr ""

msgid ""
"9429    * [CP.32: To share ownership between unrelated `thread`s use "
"`shared_ptr`](#Rconc-shared)"
msgstr ""

msgid "9430    * [CP.40: Minimize context switching](#Rconc-switch)"
msgstr ""

msgid ""
"9431    * [CP.41: Minimize thread creation and destruction](#Rconc-create)"
msgstr ""

msgid "9432    * [CP.42: Don't `wait` without a condition](#Rconc-wait)"
msgstr ""

msgid ""
"9433    * [CP.43: Minimize time spent in a critical section](#Rconc-time)"
msgstr ""

msgid ""
"9434    * [CP.44: Remember to name your `lock_guard`s and "
"`unique_lock`s](#Rconc-name)"
msgstr ""

msgid ""
"9435    * [CP.50: Define a `mutex` together with the data it guards. Use "
"`synchronized_value<T>` where possible](#Rconc-mutex)"
msgstr ""

msgid "9436    * ??? when to use a spinlock"
msgstr ""

msgid "9437    * ??? when to use `try_lock()`"
msgstr ""

msgid "9438    * ??? when to prefer `lock_guard` over `unique_lock`"
msgstr ""

msgid "9439    * ??? Time multiplexing"
msgstr ""

msgid "9440    * ??? when/how to use `new thread`"
msgstr ""

msgid ""
"9441    ### <a name=\"Rconc-raii\"></a>CP.20: Use RAII, never plain `lock()`/"
"`unlock()`"
msgstr ""

msgid "9442    ##### Reason"
msgstr ""

msgid "9443    Avoids nasty errors from unreleased locks."
msgstr ""

msgid "9444    ##### Example, bad"
msgstr ""

msgid "9445        mutex mtx;"
msgstr ""

msgid "9446        void do_stuff()"
msgstr ""

msgid "9447        {"
msgstr ""

msgid "9448            mtx.lock();"
msgstr ""

msgid "9449            // ... do stuff ..."
msgstr ""

msgid "9450            mtx.unlock();"
msgstr ""

msgid "9451        }"
msgstr ""

msgid ""
"9452    Sooner or later, someone will forget the `mtx.unlock()`, place a "
"`return` in the `... do stuff ...`, throw an exception, or something."
msgstr ""

msgid "9453        mutex mtx;"
msgstr ""

msgid "9454        void do_stuff()"
msgstr ""

msgid "9455        {"
msgstr ""

msgid "9456            unique_lock<mutex> lck {mtx};"
msgstr ""

msgid "9457            // ... do stuff ..."
msgstr ""

msgid "9458        }"
msgstr ""

msgid "9459    ##### Enforcement"
msgstr ""

msgid "9460    Flag calls of member `lock()` and `unlock()`.  ???"
msgstr ""

msgid ""
"9461    ### <a name=\"Rconc-lock\"></a>CP.21: Use `std::lock()` or `std::"
"scoped_lock` to acquire multiple `mutex`es"
msgstr ""

msgid "9462    ##### Reason"
msgstr ""

msgid "9463    To avoid deadlocks on multiple `mutex`es."
msgstr ""

msgid "9464    ##### Example"
msgstr ""

msgid "9465    This is asking for deadlock:"
msgstr ""

msgid "9466        // thread 1"
msgstr ""

msgid "9467        lock_guard<mutex> lck1(m1);"
msgstr ""

msgid "9468        lock_guard<mutex> lck2(m2);"
msgstr ""

msgid "9469        // thread 2"
msgstr ""

msgid "9470        lock_guard<mutex> lck2(m2);"
msgstr ""

msgid "9471        lock_guard<mutex> lck1(m1);"
msgstr ""

msgid "9472    Instead, use `lock()`:"
msgstr ""

msgid "9473        // thread 1"
msgstr ""

msgid "9474        lock(m1, m2);"
msgstr ""

msgid "9475        lock_guard<mutex> lck1(m1, adopt_lock);"
msgstr ""

msgid "9476        lock_guard<mutex> lck2(m2, adopt_lock);"
msgstr ""

msgid "9477        // thread 2"
msgstr ""

msgid "9478        lock(m2, m1);"
msgstr ""

msgid "9479        lock_guard<mutex> lck2(m2, adopt_lock);"
msgstr ""

msgid "9480        lock_guard<mutex> lck1(m1, adopt_lock);"
msgstr ""

msgid "9481    or (better, but C++17 only):"
msgstr ""

msgid "9482        // thread 1"
msgstr ""

msgid "9483        scoped_lock<mutex, mutex> lck1(m1, m2);"
msgstr ""

msgid "9484        // thread 2"
msgstr ""

msgid "9485        scoped_lock<mutex, mutex> lck2(m2, m1);"
msgstr ""

msgid ""
"9486    Here, the writers of `thread1` and `thread2` are still not agreeing "
"on the order of the `mutex`es, but order no longer matters."
msgstr ""

msgid "9487    ##### Note"
msgstr ""

msgid ""
"9488    In real code, `mutex`es are rarely named to conveniently remind the "
"programmer of an intended relation and intended order of acquisition."
msgstr ""

msgid ""
"9489    In real code, `mutex`es are not always conveniently acquired on "
"consecutive lines."
msgstr ""

msgid "9490    In C++17 it's possible to write plain"
msgstr ""

msgid "9491        lock_guard lck1(m1, adopt_lock);"
msgstr ""

msgid "9492    and have the `mutex` type deduced."
msgstr ""

msgid "9493    ##### Enforcement"
msgstr ""

msgid "9494    Detect the acquisition of multiple `mutex`es."
msgstr ""

msgid ""
"9495    This is undecidable in general, but catching common simple examples "
"(like the one above) is easy."
msgstr ""

msgid ""
"9496    ### <a name=\"Rconc-unknown\"></a>CP.22: Never call unknown code "
"while holding a lock (e.g., a callback)"
msgstr ""

msgid "9497    ##### Reason"
msgstr ""

msgid ""
"9498    If you don't know what a piece of code does, you are risking "
"deadlock."
msgstr ""

msgid "9499    ##### Example"
msgstr ""

msgid "9500        void do_this(Foo* p)"
msgstr ""

msgid "9501        {"
msgstr ""

msgid "9502            lock_guard<mutex> lck {my_mutex};"
msgstr ""

msgid "9503            // ... do something ..."
msgstr ""

msgid "9504            p->act(my_data);"
msgstr ""

msgid "9505            // ..."
msgstr ""

msgid "9506        }"
msgstr ""

msgid ""
"9507    If you don't know what `Foo::act` does (maybe it is a virtual "
"function invoking a derived class member of a class not yet written),"
msgstr ""

msgid ""
"9508    it may call `do_this` (recursively) and cause a deadlock on "
"`my_mutex`."
msgstr ""

msgid ""
"9509    Maybe it will lock on a different mutex and not return in a "
"reasonable time, causing delays to any code calling `do_this`."
msgstr ""

msgid "9510    ##### Example"
msgstr ""

msgid ""
"9511    A common example of the \"calling unknown code\" problem is a call "
"to a function that tries to gain locked access to the same object."
msgstr ""

msgid ""
"9512    Such problem can often be solved by using a `recursive_mutex`. For "
"example:"
msgstr ""

msgid "9513        recursive_mutex my_mutex;"
msgstr ""

msgid "9514        template<typename Action>"
msgstr ""

msgid "9515        void do_something(Action f)"
msgstr ""

msgid "9516        {"
msgstr ""

msgid "9517            unique_lock<recursive_mutex> lck {my_mutex};"
msgstr ""

msgid "9518            // ... do something ..."
msgstr ""

msgid "9519            f(this);    // f will do something to *this"
msgstr ""

msgid "9520            // ..."
msgstr ""

msgid "9521        }"
msgstr ""

msgid ""
"9522    If, as it is likely, `f()` invokes operations on `*this`, we must "
"make sure that the object's invariant holds before the call."
msgstr ""

msgid "9523    ##### Enforcement"
msgstr ""

msgid ""
"9524    * Flag calling a virtual function with a non-recursive `mutex` held"
msgstr ""

msgid "9525    * Flag calling a callback with a non-recursive `mutex` held"
msgstr ""

msgid ""
"9526    ### <a name=\"Rconc-join\"></a>CP.23: Think of a joining `thread` as "
"a scoped container"
msgstr ""

msgid "9527    ##### Reason"
msgstr ""

msgid ""
"9528    To maintain pointer safety and avoid leaks, we need to consider what "
"pointers are used by a `thread`."
msgstr ""

msgid ""
"9529    If a `thread` joins, we can safely pass pointers to objects in the "
"scope of the `thread` and its enclosing scopes."
msgstr ""

msgid "9530    ##### Example"
msgstr ""

msgid "9531        void f(int* p)"
msgstr ""

msgid "9532        {"
msgstr ""

msgid "9533            // ..."
msgstr ""

msgid "9534            *p = 99;"
msgstr ""

msgid "9535            // ..."
msgstr ""

msgid "9536        }"
msgstr ""

msgid "9537        int glob = 33;"
msgstr ""

msgid "9538        void some_fct(int* p)"
msgstr ""

msgid "9539        {"
msgstr ""

msgid "9540            int x = 77;"
msgstr ""

msgid "9541            joining_thread t0(f, &x);           // OK"
msgstr ""

msgid "9542            joining_thread t1(f, p);            // OK"
msgstr ""

msgid "9543            joining_thread t2(f, &glob);        // OK"
msgstr ""

msgid "9544            auto q = make_unique<int>(99);"
msgstr ""

msgid "9545            joining_thread t3(f, q.get());      // OK"
msgstr ""

msgid "9546            // ..."
msgstr ""

msgid "9547        }"
msgstr ""

msgid ""
"9548    A `gsl::joining_thread` is a `std::thread` with a destructor that "
"joins and that cannot be `detached()`."
msgstr ""

msgid ""
"9549    By \"OK\" we mean that the object will be in scope (\"live\") for as "
"long as a `thread` can use the pointer to it."
msgstr ""

msgid ""
"9550    The fact that `thread`s run concurrently doesn't affect the lifetime "
"or ownership issues here;"
msgstr ""

msgid ""
"9551    these `thread`s can be seen as just a function object called from "
"`some_fct`."
msgstr ""

msgid "9552    ##### Enforcement"
msgstr ""

msgid "9553    Ensure that `joining_thread`s don't `detach()`."
msgstr ""

msgid ""
"9554    After that, the usual lifetime and ownership (for local objects) "
"enforcement applies."
msgstr ""

msgid ""
"9555    ### <a name=\"Rconc-detach\"></a>CP.24: Think of a `thread` as a "
"global container"
msgstr ""

msgid "9556    ##### Reason"
msgstr ""

msgid ""
"9557    To maintain pointer safety and avoid leaks, we need to consider what "
"pointers are used by a `thread`."
msgstr ""

msgid ""
"9558    If a `thread` is detached, we can safely pass pointers to static and "
"free store objects (only)."
msgstr ""

msgid "9559    ##### Example"
msgstr ""

msgid "9560        void f(int* p)"
msgstr ""

msgid "9561        {"
msgstr ""

msgid "9562            // ..."
msgstr ""

msgid "9563            *p = 99;"
msgstr ""

msgid "9564            // ..."
msgstr ""

msgid "9565        }"
msgstr ""

msgid "9566        int glob = 33;"
msgstr ""

msgid "9567        void some_fct(int* p)"
msgstr ""

msgid "9568        {"
msgstr ""

msgid "9569            int x = 77;"
msgstr ""

msgid "9570            std::thread t0(f, &x);           // bad"
msgstr ""

msgid "9571            std::thread t1(f, p);            // bad"
msgstr ""

msgid "9572            std::thread t2(f, &glob);        // OK"
msgstr ""

msgid "9573            auto q = make_unique<int>(99);"
msgstr ""

msgid "9574            std::thread t3(f, q.get());      // bad"
msgstr ""

msgid "9575            // ..."
msgstr ""

msgid "9576            t0.detach();"
msgstr ""

msgid "9577            t1.detach();"
msgstr ""

msgid "9578            t2.detach();"
msgstr ""

msgid "9579            t3.detach();"
msgstr ""

msgid "9580            // ..."
msgstr ""

msgid "9581        }"
msgstr ""

msgid ""
"9582    By \"OK\" we mean that the object will be in scope (\"live\") for as "
"long as a `thread` can use the pointers to it."
msgstr ""

msgid ""
"9583    By \"bad\" we mean that a `thread` may use a pointer after the "
"pointed-to object is destroyed."
msgstr ""

msgid ""
"9584    The fact that `thread`s run concurrently doesn't affect the lifetime "
"or ownership issues here;"
msgstr ""

msgid ""
"9585    these `thread`s can be seen as just a function object called from "
"`some_fct`."
msgstr ""

msgid "9586    ##### Note"
msgstr ""

msgid ""
"9587    Even objects with static storage duration can be problematic if used "
"from detached threads: if the"
msgstr ""

msgid ""
"9588    thread continues until the end of the program, it might be running "
"concurrently with the destruction"
msgstr ""

msgid ""
"9589    of objects with static storage duration, and thus accesses to such "
"objects might race."
msgstr ""

msgid "9590    ##### Note"
msgstr ""

msgid ""
"9591    This rule is redundant if you [don't `detach()`](#Rconc-"
"detached_thread) and [use `gsl::joining_thread`](#Rconc-joining_thread)."
msgstr ""

msgid ""
"9592    However, converting code to follow those guidelines could be "
"difficult and even impossible for third-party libraries."
msgstr ""

msgid ""
"9593    In such cases, the rule becomes essential for lifetime safety and "
"type safety."
msgstr ""

msgid ""
"9594    In general, it is undecidable whether a `detach()` is executed for a "
"`thread`, but simple common cases are easily detected."
msgstr ""

msgid ""
"9595    If we cannot prove that a `thread` does not `detach()`, we must "
"assume that it does and that it outlives the scope in which it was "
"constructed;"
msgstr ""

msgid ""
"9596    After that, the usual lifetime and ownership (for global objects) "
"enforcement applies."
msgstr ""

msgid "9597    ##### Enforcement"
msgstr ""

msgid ""
"9598    Flag attempts to pass local variables to a thread that might "
"`detach()`."
msgstr ""

msgid ""
"9599    ### <a name=\"Rconc-joining_thread\"></a>CP.25: Prefer `gsl::"
"joining_thread` over `std::thread`"
msgstr ""

msgid "9600    ##### Reason"
msgstr ""

msgid ""
"9601    A `joining_thread` is a thread that joins at the end of its scope."
msgstr ""

msgid "9602    Detached threads are hard to monitor."
msgstr ""

msgid ""
"9603    It is harder to ensure absence of errors in detached threads (and "
"potentially detached threads)"
msgstr ""

msgid "9604    ##### Example, bad"
msgstr ""

msgid "9605        void f() { std::cout << \"Hello \"; }"
msgstr ""

msgid "9606        struct F {"
msgstr ""

msgid "9607            void operator()() { std::cout << \"parallel world \"; }"
msgstr ""

msgid "9608        };"
msgstr ""

msgid "9609        int main()"
msgstr ""

msgid "9610        {"
msgstr ""

msgid ""
"9611            std::thread t1{f};      // f() executes in separate thread"
msgstr ""

msgid ""
"9612            std::thread t2{F()};    // F()() executes in separate thread"
msgstr ""

msgid "9613        }  // spot the bugs"
msgstr ""

msgid "9614    ##### Example"
msgstr ""

msgid "9615        void f() { std::cout << \"Hello \"; }"
msgstr ""

msgid "9616        struct F {"
msgstr ""

msgid "9617            void operator()() { std::cout << \"parallel world \"; }"
msgstr ""

msgid "9618        };"
msgstr ""

msgid "9619        int main()"
msgstr ""

msgid "9620        {"
msgstr ""

msgid ""
"9621            std::thread t1{f};      // f() executes in separate thread"
msgstr ""

msgid ""
"9622            std::thread t2{F()};    // F()() executes in separate thread"
msgstr ""

msgid "9623            t1.join();"
msgstr ""

msgid "9624            t2.join();"
msgstr ""

msgid "9625        }  // one bad bug left"
msgstr ""

msgid "9626    ##### Example, bad"
msgstr ""

msgid ""
"9627    The code determining whether to `join()` or `detach()` may be "
"complicated and even decided in the thread of functions called from it or "
"functions called by the function that creates a thread:"
msgstr ""

msgid "9628        void tricky(thread* t, int n)"
msgstr ""

msgid "9629        {"
msgstr ""

msgid "9630            // ..."
msgstr ""

msgid "9631            if (is_odd(n))"
msgstr ""

msgid "9632                t->detach();"
msgstr ""

msgid "9633            // ..."
msgstr ""

msgid "9634        }"
msgstr ""

msgid "9635        void use(int n)"
msgstr ""

msgid "9636        {"
msgstr ""

msgid "9637            thread t { tricky, this, n };"
msgstr ""

msgid "9638            // ..."
msgstr ""

msgid "9639            // ... should I join here? ..."
msgstr ""

msgid "9640        }"
msgstr ""

msgid ""
"9641    This seriously complicates lifetime analysis, and in not too "
"unlikely cases makes lifetime analysis impossible."
msgstr ""

msgid ""
"9642    This implies that we cannot safely refer to local objects in `use()` "
"from the thread or refer to local objects in the thread from `use()`."
msgstr ""

msgid "9643    ##### Note"
msgstr ""

msgid ""
"9644    Make \"immortal threads\" globals, put them in an enclosing scope, "
"or put them on the free store rather than `detach()`."
msgstr ""

msgid "9645    [don't `detach`](#Rconc-detached_thread)."
msgstr ""

msgid "9646    ##### Note"
msgstr ""

msgid ""
"9647    Because of old code and third party libraries using `std::thread` "
"this rule can be hard to introduce."
msgstr ""

msgid "9648    ##### Enforcement"
msgstr ""

msgid "9649    Flag uses of `std::thread`:"
msgstr ""

msgid "9650    * Suggest use of `gsl::joining_thread`."
msgstr ""

msgid ""
"9651    * Suggest [\"exporting ownership\"](#Rconc-detached_thread) to an "
"enclosing scope if it detaches."
msgstr ""

msgid ""
"9652    * Seriously warn if it is not obvious whether if joins of detaches."
msgstr ""

msgid ""
"9653    ### <a name=\"Rconc-detached_thread\"></a>CP.26: Don't `detach()` a "
"thread"
msgstr ""

msgid "9654    ##### Reason"
msgstr ""

msgid ""
"9655    Often, the need to outlive the scope of its creation is inherent in "
"the `thread`s task,"
msgstr ""

msgid ""
"9656    but implementing that idea by `detach` makes it harder to monitor "
"and communicate with the detached thread."
msgstr ""

msgid ""
"9657    In particular, it is harder (though not impossible) to ensure that "
"the thread completed as expected or lives for as long as expected."
msgstr ""

msgid "9658    ##### Example"
msgstr ""

msgid "9659        void heartbeat();"
msgstr ""

msgid "9660        void use()"
msgstr ""

msgid "9661        {"
msgstr ""

msgid ""
"9662            std::thread t(heartbeat);             // don't join; "
"heartbeat is meant to run forever"
msgstr ""

msgid "9663            t.detach();"
msgstr ""

msgid "9664            // ..."
msgstr ""

msgid "9665        }"
msgstr ""

msgid ""
"9666    This is a reasonable use of a thread, for which `detach()` is "
"commonly used."
msgstr ""

msgid "9667    There are problems, though."
msgstr ""

msgid "9668    How do we monitor the detached thread to see if it is alive?"
msgstr ""

msgid ""
"9669    Something might go wrong with the heartbeat, and losing a heartbeat "
"can be very serious in a system for which it is needed."
msgstr ""

msgid "9670    So, we need to communicate with the heartbeat thread"
msgstr ""

msgid ""
"9671    (e.g., through a stream of messages or notification events using a "
"`condition_variable`)."
msgstr ""

msgid ""
"9672    An alternative, and usually superior solution is to control its "
"lifetime by placing it in a scope outside its point of creation (or "
"activation)."
msgstr ""

msgid "9673    For example:"
msgstr ""

msgid "9674        void heartbeat();"
msgstr ""

msgid ""
"9675        gsl::joining_thread t(heartbeat);             // heartbeat is "
"meant to run \"forever\""
msgstr ""

msgid ""
"9676    This heartbeat will (barring error, hardware problems, etc.) run for "
"as long as the program does."
msgstr ""

msgid ""
"9677    Sometimes, we need to separate the point of creation from the point "
"of ownership:"
msgstr ""

msgid "9678        void heartbeat();"
msgstr ""

msgid "9679        unique_ptr<gsl::joining_thread> tick_tock {nullptr};"
msgstr ""

msgid "9680        void use()"
msgstr ""

msgid "9681        {"
msgstr ""

msgid ""
"9682            // heartbeat is meant to run as long as tick_tock lives"
msgstr ""

msgid ""
"9683            tick_tock = make_unique<gsl::joining_thread>(heartbeat);"
msgstr ""

msgid "9684            // ..."
msgstr ""

msgid "9685        }"
msgstr ""

msgid "9686    #### Enforcement"
msgstr ""

msgid "9687    Flag `detach()`."
msgstr ""

msgid ""
"9688    ### <a name=\"Rconc-data-by-value\"></a>CP.31: Pass small amounts of "
"data between threads by value, rather than by reference or pointer"
msgstr ""

msgid "9689    ##### Reason"
msgstr ""

msgid ""
"9690    Copying a small amount of data is cheaper to copy and access than to "
"share it using some locking mechanism."
msgstr ""

msgid ""
"9691    Copying naturally gives unique ownership (simplifies code) and "
"eliminates the possibility of data races."
msgstr ""

msgid "9692    ##### Note"
msgstr ""

msgid "9693    Defining \"small amount\" precisely is impossible."
msgstr ""

msgid "9694    ##### Example"
msgstr ""

msgid "9695        string modify1(string);"
msgstr ""

msgid "9696        void modify2(string&);"
msgstr ""

msgid "9697        void fct(string& s)"
msgstr ""

msgid "9698        {"
msgstr ""

msgid "9699            auto res = async(modify1, s);"
msgstr ""

msgid "9700            async(modify2, s);"
msgstr ""

msgid "9701        }"
msgstr ""

msgid ""
"9702    The call of `modify1` involves copying two `string` values; the call "
"of `modify2` does not."
msgstr ""

msgid ""
"9703    On the other hand, the implementation of `modify1` is exactly as we "
"would have written it for single-threaded code,"
msgstr ""

msgid ""
"9704    whereas the implementation of `modify2` will need some form of "
"locking to avoid data races."
msgstr ""

msgid ""
"9705    If the string is short (say 10 characters), the call of `modify1` "
"can be surprisingly fast;"
msgstr ""

msgid ""
"9706    essentially all the cost is in the `thread` switch. If the string is "
"long (say 1,000,000 characters), copying it twice"
msgstr ""

msgid "9707    is probably not a good idea."
msgstr ""

msgid ""
"9708    Note that this argument has nothing to do with `async` as such. It "
"applies equally to considerations about whether to use"
msgstr ""

msgid "9709    message passing or shared memory."
msgstr ""

msgid "9710    ##### Enforcement"
msgstr ""

msgid "9711    ???"
msgstr ""

msgid ""
"9712    ### <a name=\"Rconc-shared\"></a>CP.32: To share ownership between "
"unrelated `thread`s use `shared_ptr`"
msgstr ""

msgid "9713    ##### Reason"
msgstr ""

msgid ""
"9714    If threads are unrelated (that is, not known to be in the same scope "
"or one within the lifetime of the other)"
msgstr ""

msgid ""
"9715    and they need to share free store memory that needs to be deleted, a "
"`shared_ptr` (or equivalent) is the only"
msgstr ""

msgid "9716    safe way to ensure proper deletion."
msgstr ""

msgid "9717    ##### Example"
msgstr ""

msgid "9718        ???"
msgstr ""

msgid "9719    ##### Note"
msgstr ""

msgid ""
"9720    * A static object (e.g. a global) can be shared because it is not "
"owned in the sense that some thread is responsible for its deletion."
msgstr ""

msgid ""
"9721    * An object on free store that is never to be deleted can be shared."
msgstr ""

msgid ""
"9722    * An object owned by one thread can be safely shared with another as "
"long as that second thread doesn't outlive the owner."
msgstr ""

msgid "9723    ##### Enforcement"
msgstr ""

msgid "9724    ???"
msgstr ""

msgid ""
"9725    ### <a name=\"Rconc-switch\"></a>CP.40: Minimize context switching"
msgstr ""

msgid "9726    ##### Reason"
msgstr ""

msgid "9727    Context switches are expensive."
msgstr ""

msgid "9728    ##### Example"
msgstr ""

msgid "9729        ???"
msgstr ""

msgid "9730    ##### Enforcement"
msgstr ""

msgid "9731    ???"
msgstr ""

msgid ""
"9732    ### <a name=\"Rconc-create\"></a>CP.41: Minimize thread creation and "
"destruction"
msgstr ""

msgid "9733    ##### Reason"
msgstr ""

msgid "9734    Thread creation is expensive."
msgstr ""

msgid "9735    ##### Example"
msgstr ""

msgid "9736        void worker(Message m)"
msgstr ""

msgid "9737        {"
msgstr ""

msgid "9738            // process"
msgstr ""

msgid "9739        }"
msgstr ""

msgid "9740        void master(istream& is)"
msgstr ""

msgid "9741        {"
msgstr ""

msgid "9742            for (Message m; is >> m; )"
msgstr ""

msgid "9743                run_list.push_back(new thread(worker, m));"
msgstr ""

msgid "9744        }"
msgstr ""

msgid ""
"9745    This spawns a `thread` per message, and the `run_list` is presumably "
"managed to destroy those tasks once they are finished."
msgstr ""

msgid ""
"9746    Instead, we could have a set of pre-created worker threads "
"processing the messages"
msgstr ""

msgid "9747        Sync_queue<Message> work;"
msgstr ""

msgid "9748        void master(istream& is)"
msgstr ""

msgid "9749        {"
msgstr ""

msgid "9750            for (Message m; is >> m; )"
msgstr ""

msgid "9751                work.put(m);"
msgstr ""

msgid "9752        }"
msgstr ""

msgid "9753        void worker()"
msgstr ""

msgid "9754        {"
msgstr ""

msgid "9755            for (Message m; m = work.get(); ) {"
msgstr ""

msgid "9756                // process"
msgstr ""

msgid "9757            }"
msgstr ""

msgid "9758        }"
msgstr ""

msgid ""
"9759        void workers()  // set up worker threads (specifically 4 worker "
"threads)"
msgstr ""

msgid "9760        {"
msgstr ""

msgid "9761            joining_thread w1 {worker};"
msgstr ""

msgid "9762            joining_thread w2 {worker};"
msgstr ""

msgid "9763            joining_thread w3 {worker};"
msgstr ""

msgid "9764            joining_thread w4 {worker};"
msgstr ""

msgid "9765        }"
msgstr ""

msgid "9766    ##### Note"
msgstr ""

msgid "9767    If your system has a good thread pool, use it."
msgstr ""

msgid "9768    If your system has a good message queue, use it."
msgstr ""

msgid "9769    ##### Enforcement"
msgstr ""

msgid "9770    ???"
msgstr ""

msgid ""
"9771    ### <a name=\"Rconc-wait\"></a>CP.42: Don't `wait` without a "
"condition"
msgstr ""

msgid "9772    ##### Reason"
msgstr ""

msgid ""
"9773    A `wait` without a condition can miss a wakeup or wake up simply to "
"find that there is no work to do."
msgstr ""

msgid "9774    ##### Example, bad"
msgstr ""

msgid "9775        std::condition_variable cv;"
msgstr ""

msgid "9776        std::mutex mx;"
msgstr ""

msgid "9777        void thread1()"
msgstr ""

msgid "9778        {"
msgstr ""

msgid "9779            while (true) {"
msgstr ""

msgid "9780                // do some work ..."
msgstr ""

msgid "9781                std::unique_lock<std::mutex> lock(mx);"
msgstr ""

msgid "9782                cv.notify_one();    // wake other thread"
msgstr ""

msgid "9783            }"
msgstr ""

msgid "9784        }"
msgstr ""

msgid "9785        void thread2()"
msgstr ""

msgid "9786        {"
msgstr ""

msgid "9787            while (true) {"
msgstr ""

msgid "9788                std::unique_lock<std::mutex> lock(mx);"
msgstr ""

msgid "9789                cv.wait(lock);    // might block forever"
msgstr ""

msgid "9790                // do work ..."
msgstr ""

msgid "9791            }"
msgstr ""

msgid "9792        }"
msgstr ""

msgid ""
"9793    Here, if some other `thread` consumes `thread1`'s notification, "
"`thread2` can wait forever."
msgstr ""

msgid "9794    ##### Example"
msgstr ""

msgid "9795        template<typename T>"
msgstr ""

msgid "9796        class Sync_queue {"
msgstr ""

msgid "9797        public:"
msgstr ""

msgid "9798            void put(const T& val);"
msgstr ""

msgid "9799            void put(T&& val);"
msgstr ""

msgid "9800            void get(T& val);"
msgstr ""

msgid "9801        private:"
msgstr ""

msgid "9802            mutex mtx;"
msgstr ""

msgid "9803            condition_variable cond;    // this controls access"
msgstr ""

msgid "9804            list<T> q;"
msgstr ""

msgid "9805        };"
msgstr ""

msgid "9806        template<typename T>"
msgstr ""

msgid "9807        void Sync_queue<T>::put(const T& val)"
msgstr ""

msgid "9808        {"
msgstr ""

msgid "9809            lock_guard<mutex> lck(mtx);"
msgstr ""

msgid "9810            q.push_back(val);"
msgstr ""

msgid "9811            cond.notify_one();"
msgstr ""

msgid "9812        }"
msgstr ""

msgid "9813        template<typename T>"
msgstr ""

msgid "9814        void Sync_queue<T>::get(T& val)"
msgstr ""

msgid "9815        {"
msgstr ""

msgid "9816            unique_lock<mutex> lck(mtx);"
msgstr ""

msgid ""
"9817            cond.wait(lck, [this]{ return !q.empty(); });    // prevent "
"spurious wakeup"
msgstr ""

msgid "9818            val = q.front();"
msgstr ""

msgid "9819            q.pop_front();"
msgstr ""

msgid "9820        }"
msgstr ""

msgid ""
"9821    Now if the queue is empty when a thread executing `get()` wakes up "
"(e.g., because another thread has gotten to `get()` before it),"
msgstr ""

msgid "9822    it will immediately go back to sleep, waiting."
msgstr ""

msgid "9823    ##### Enforcement"
msgstr ""

msgid "9824    Flag all `wait`s without conditions."
msgstr ""

msgid ""
"9825    ### <a name=\"Rconc-time\"></a>CP.43: Minimize time spent in a "
"critical section"
msgstr ""

msgid "9826    ##### Reason"
msgstr ""

msgid ""
"9827    The less time is spent with a `mutex` taken, the less chance that "
"another `thread` has to wait,"
msgstr ""

msgid "9828    and `thread` suspension and resumption are expensive."
msgstr ""

msgid "9829    ##### Example"
msgstr ""

msgid "9830        void do_something() // bad"
msgstr ""

msgid "9831        {"
msgstr ""

msgid "9832            unique_lock<mutex> lck(my_lock);"
msgstr ""

msgid "9833            do0();  // preparation: does not need lock"
msgstr ""

msgid "9834            do1();  // transaction: needs locking"
msgstr ""

msgid "9835            do2();  // cleanup: does not need locking"
msgstr ""

msgid "9836        }"
msgstr ""

msgid "9837    Here, we are holding the lock for longer than necessary:"
msgstr ""

msgid ""
"9838    We should not have taken the lock before we needed it and should "
"have released it again before starting the cleanup."
msgstr ""

msgid "9839    We could rewrite this to"
msgstr ""

msgid "9840        void do_something() // bad"
msgstr ""

msgid "9841        {"
msgstr ""

msgid "9842            do0();  // preparation: does not need lock"
msgstr ""

msgid "9843            my_lock.lock();"
msgstr ""

msgid "9844            do1();  // transaction: needs locking"
msgstr ""

msgid "9845            my_lock.unlock();"
msgstr ""

msgid "9846            do2();  // cleanup: does not need locking"
msgstr ""

msgid "9847        }"
msgstr ""

msgid ""
"9848    But that compromises safety and violates the [use RAII](#Rconc-raii) "
"rule."
msgstr ""

msgid "9849    Instead, add a block for the critical section:"
msgstr ""

msgid "9850        void do_something() // OK"
msgstr ""

msgid "9851        {"
msgstr ""

msgid "9852            do0();  // preparation: does not need lock"
msgstr ""

msgid "9853            {"
msgstr ""

msgid "9854                unique_lock<mutex> lck(my_lock);"
msgstr ""

msgid "9855                do1();  // transaction: needs locking"
msgstr ""

msgid "9856            }"
msgstr ""

msgid "9857            do2();  // cleanup: does not need locking"
msgstr ""

msgid "9858        }"
msgstr ""

msgid "9859    ##### Enforcement"
msgstr ""

msgid "9860    Impossible in general."
msgstr ""

msgid "9861    Flag \"naked\" `lock()` and `unlock()`."
msgstr ""

msgid ""
"9862    ### <a name=\"Rconc-name\"></a>CP.44: Remember to name your "
"`lock_guard`s and `unique_lock`s"
msgstr ""

msgid "9863    ##### Reason"
msgstr ""

msgid ""
"9864    An unnamed local objects is a temporary that immediately goes out of "
"scope."
msgstr ""

msgid "9865    ##### Example"
msgstr ""

msgid "9866        unique_lock<mutex>(m1);"
msgstr ""

msgid "9867        lock_guard<mutex> {m2};"
msgstr ""

msgid "9868        lock(m1, m2);"
msgstr ""

msgid "9869    This looks innocent enough, but it isn't."
msgstr ""

msgid "9870    ##### Enforcement"
msgstr ""

msgid "9871    Flag all unnamed `lock_guard`s and `unique_lock`s."
msgstr ""

msgid ""
"9872    ### <a name=\"Rconc-mutex\"></a>CP.50: Define a `mutex` together "
"with the data it guards. Use `synchronized_value<T>` where possible"
msgstr ""

msgid "9873    ##### Reason"
msgstr ""

msgid ""
"9874    It should be obvious to a reader that the data is to be guarded and "
"how. This decreases the chance of the wrong mutex being locked, or the mutex "
"not being locked."
msgstr ""

msgid ""
"9875    Using a `synchronized_value<T>` ensures that the data has a mutex, "
"and the right mutex is locked when the data is accessed."
msgstr ""

msgid ""
"9876    See the [WG21 proposal](http://wg21.link/p0290)) to add "
"`synchronized_value` to a future TS or revision of the C++ standard."
msgstr ""

msgid "9877    ##### Example"
msgstr ""

msgid "9878        struct Record {"
msgstr ""

msgid ""
"9879            std::mutex m;   // take this mutex before accessing other "
"members"
msgstr ""

msgid "9880            // ..."
msgstr ""

msgid "9881        };"
msgstr ""

msgid "9882        class MyClass {"
msgstr ""

msgid "9883            struct DataRecord {"
msgstr ""

msgid "9884               // ..."
msgstr ""

msgid "9885            };"
msgstr ""

msgid ""
"9886            synchronized_value<DataRecord> data; // Protect the data "
"with a mutex"
msgstr ""

msgid "9887        };"
msgstr ""

msgid "9888    ##### Enforcement"
msgstr ""

msgid "9889    ??? Possible?"
msgstr ""

msgid "9890    ## <a name=\"SScp-par\"></a>CP.par: Parallelism"
msgstr ""

msgid ""
"9891    By \"parallelism\" we refer to performing a task (more or less) "
"simultaneously (\"in parallel with\") on many data items."
msgstr ""

msgid "9892    Parallelism rule summary:"
msgstr ""

msgid "9893    * ???"
msgstr ""

msgid "9894    * ???"
msgstr ""

msgid ""
"9895    * Where appropriate, prefer the standard-library parallel algorithms"
msgstr ""

msgid ""
"9896    * Use algorithms that are designed for parallelism, not algorithms "
"with unnecessary dependency on linear evaluation"
msgstr ""

msgid "9897    ## <a name=\"SScp-mess\"></a>CP.mess: Message passing"
msgstr ""

msgid ""
"9898    The standard-library facilities are quite low-level, focused on the "
"needs of close-to the hardware critical programming using `thread`s, "
"`mutex`es, `atomic` types, etc."
msgstr ""

msgid ""
"9899    Most people shouldn't work at this level: it's error-prone and "
"development is slow."
msgstr ""

msgid ""
"9900    If possible, use a higher level facility: messaging libraries, "
"parallel algorithms, and vectorization."
msgstr ""

msgid ""
"9901    This section looks at passing messages so that a programmer doesn't "
"have to do explicit synchronization."
msgstr ""

msgid "9902    Message passing rules summary:"
msgstr ""

msgid ""
"9903    * [CP.60: Use a `future` to return a value from a concurrent "
"task](#Rconc-future)"
msgstr ""

msgid ""
"9904    * [CP.61: Use a `async()` to spawn a concurrent task](#Rconc-async)"
msgstr ""

msgid "9905    * message queues"
msgstr ""

msgid "9906    * messaging libraries"
msgstr ""

msgid ""
"9907    ???? should there be a \"use X rather than `std::async`\" where X is "
"something that would use a better specified thread pool?"
msgstr ""

msgid ""
"9908    ??? Is `std::async` worth using in light of future (and even "
"existing, as libraries) parallelism facilities? What should the guidelines "
"recommend if someone wants to parallelize, e.g., `std::accumulate` (with the "
"additional precondition of commutativity), or merge sort?"
msgstr ""

msgid ""
"9909    ### <a name=\"Rconc-future\"></a>CP.60: Use a `future` to return a "
"value from a concurrent task"
msgstr ""

msgid "9910    ##### Reason"
msgstr ""

msgid ""
"9911    A `future` preserves the usual function call return semantics for "
"asynchronous tasks."
msgstr ""

msgid ""
"9912    The is no explicit locking and both correct (value) return and error "
"(exception) return are handled simply."
msgstr ""

msgid "9913    ##### Example"
msgstr ""

msgid "9914        ???"
msgstr ""

msgid "9915    ##### Note"
msgstr ""

msgid "9916    ???"
msgstr ""

msgid "9917    ##### Enforcement"
msgstr ""

msgid "9918    ???"
msgstr ""

msgid ""
"9919    ### <a name=\"Rconc-async\"></a>CP.61: Use a `async()` to spawn a "
"concurrent task"
msgstr ""

msgid "9920    ##### Reason"
msgstr ""

msgid ""
"9921    A `future` preserves the usual function call return semantics for "
"asynchronous tasks."
msgstr ""

msgid ""
"9922    The is no explicit locking and both correct (value) return and error "
"(exception) return are handled simply."
msgstr ""

msgid "9923    ##### Example"
msgstr ""

msgid "9924        ???"
msgstr ""

msgid "9925    ##### Note"
msgstr ""

msgid "9926    Unfortunately, `async()` is not perfect."
msgstr ""

msgid ""
"9927    For example, there is no guarantee that a thread pool is used to "
"minimize thread construction."
msgstr ""

msgid "9928    In fact, most current `async()` implementations don't."
msgstr ""

msgid ""
"9929    However, `async()` is simple and logically correct so until "
"something better comes along"
msgstr ""

msgid ""
"9930    and unless you really need to optimize for many asynchronous tasks, "
"stick with `async()`."
msgstr ""

msgid "9931    ##### Enforcement"
msgstr ""

msgid "9932    ???"
msgstr ""

msgid "9933    ## <a name=\"SScp-vec\"></a>CP.vec: Vectorization"
msgstr ""

msgid ""
"9934    Vectorization is a technique for executing a number of tasks "
"concurrently without introducing explicit synchronization."
msgstr ""

msgid ""
"9935    An operation is simply applied to elements of a data structure (a "
"vector, an array, etc.) in parallel."
msgstr ""

msgid ""
"9936    Vectorization has the interesting property of often requiring no non-"
"local changes to a program."
msgstr ""

msgid ""
"9937    However, vectorization works best with simple data structures and "
"with algorithms specifically crafted to enable it."
msgstr ""

msgid "9938    Vectorization rule summary:"
msgstr ""

msgid "9939    * ???"
msgstr ""

msgid "9940    * ???"
msgstr ""

msgid "9941    ## <a name=\"SScp-free\"></a>CP.free: Lock-free programming"
msgstr ""

msgid ""
"9942    Synchronization using `mutex`es and `condition_variable`s can be "
"relatively expensive."
msgstr ""

msgid "9943    Furthermore, it can lead to deadlock."
msgstr ""

msgid ""
"9944    For performance and to eliminate the possibility of deadlock, we "
"sometimes have to use the tricky low-level \"lock-free\" facilities"
msgstr ""

msgid ""
"9945    that rely on briefly gaining exclusive (\"atomic\") access to memory."
""
msgstr ""

msgid ""
"9946    Lock-free programming is also used to implement higher-level "
"concurrency mechanisms, such as `thread`s and `mutex`es."
msgstr ""

msgid "9947    Lock-free programming rule summary:"
msgstr ""

msgid ""
"9948    * [CP.100: Don't use lock-free programming unless you absolutely "
"have to](#Rconc-lockfree)"
msgstr ""

msgid ""
"9949    * [CP.101: Distrust your hardware/compiler combination](#Rconc-"
"distrust)"
msgstr ""

msgid "9950    * [CP.102: Carefully study the literature](#Rconc-literature)"
msgstr ""

msgid "9951    * how/when to use atomics"
msgstr ""

msgid "9952    * avoid starvation"
msgstr ""

msgid ""
"9953    * use a lock-free data structure rather than hand-crafting specific "
"lock-free access"
msgstr ""

msgid ""
"9954    * [CP.110: Do not write your own double-checked locking for "
"initialization](#Rconc-double)"
msgstr ""

msgid ""
"9955    * [CP.111: Use a conventional pattern if you really need double-"
"checked locking](#Rconc-double-pattern)"
msgstr ""

msgid "9956    * how/when to compare and swap"
msgstr ""

msgid ""
"9957    ### <a name=\"Rconc-lockfree\"></a>CP.100: Don't use lock-free "
"programming unless you absolutely have to"
msgstr ""

msgid "9958    ##### Reason"
msgstr ""

msgid ""
"9959    It's error-prone and requires expert level knowledge of language "
"features, machine architecture, and data structures."
msgstr ""

msgid "9960    ##### Example, bad"
msgstr ""

msgid ""
"9961        extern atomic<Link*> head;        // the shared head of a linked "
"list"
msgstr ""

msgid ""
"9962        Link* nh = new Link(data, nullptr);    // make a link ready for "
"insertion"
msgstr ""

msgid ""
"9963        Link* h = head.load();                 // read the shared head "
"of the list"
msgstr ""

msgid "9964        do {"
msgstr ""

msgid ""
"9965            if (h->data <= data) break;        // if so, insert "
"elsewhere"
msgstr ""

msgid ""
"9966            nh->next = h;                      // next element is the "
"previous head"
msgstr ""

msgid ""
"9967        } while (!head.compare_exchange_weak(h, nh));    // write nh to "
"head or to h"
msgstr ""

msgid "9968    Spot the bug."
msgstr ""

msgid "9969    It would be really hard to find through testing."
msgstr ""

msgid "9970    Read up on the ABA problem."
msgstr ""

msgid "9971    ##### Exception"
msgstr ""

msgid ""
"9972    [Atomic variables](#???) can be used simply and safely, as long as "
"you are using the sequentially consistent memory model "
"(memory_order_seq_cst), which is the default."
msgstr ""

msgid "9973    ##### Note"
msgstr ""

msgid ""
"9974    Higher-level concurrency mechanisms, such as `thread`s and `mutex`es "
"are implemented using lock-free programming."
msgstr ""

msgid ""
"9975    **Alternative**: Use lock-free data structures implemented by others "
"as part of some library."
msgstr ""

msgid ""
"9976    ### <a name=\"Rconc-distrust\"></a>CP.101: Distrust your hardware/"
"compiler combination"
msgstr ""

msgid "9977    ##### Reason"
msgstr ""

msgid ""
"9978    The low-level hardware interfaces used by lock-free programming are "
"among the hardest to implement well and among"
msgstr ""

msgid "9979    the areas where the most subtle portability problems occur."
msgstr ""

msgid ""
"9980    If you are doing lock-free programming for performance, you need to "
"check for regressions."
msgstr ""

msgid "9981    ##### Note"
msgstr ""

msgid ""
"9982    Instruction reordering (static and dynamic) makes it hard for us to "
"think effectively at this level (especially if you use relaxed memory "
"models)."
msgstr ""

msgid ""
"9983    Experience, (semi)formal models and model checking can be useful."
msgstr ""

msgid "9984    Testing - often to an extreme extent - is essential."
msgstr ""

msgid "9985    \"Don't fly too close to the sun.\""
msgstr ""

msgid "9986    ##### Enforcement"
msgstr ""

msgid ""
"9987    Have strong rules for re-testing in place that covers any change in "
"hardware, operating system, compiler, and libraries."
msgstr ""

msgid ""
"9988    ### <a name=\"Rconc-literature\"></a>CP.102: Carefully study the "
"literature"
msgstr ""

msgid "9989    ##### Reason"
msgstr ""

msgid ""
"9990    With the exception of atomics and a few use standard patterns, lock-"
"free programming is really an expert-only topic."
msgstr ""

msgid ""
"9991    Become an expert before shipping lock-free code for others to use."
msgstr ""

msgid "9992    ##### References"
msgstr ""

msgid ""
"9993    * Anthony Williams: C++ concurrency in action. Manning Publications."
msgstr ""

msgid ""
"9994    * Boehm, Adve, You Don't Know Jack About Shared Variables or Memory "
"Models , Communications of the ACM, Feb 2012."
msgstr ""

msgid "9995    * Boehm, \"Threads Basics\", HPL TR 2009-259."
msgstr ""

msgid ""
"9996    * Adve, Boehm, \"Memory Models: A Case for Rethinking Parallel "
"Languages and Hardware\", Communications of the ACM, August 2010."
msgstr ""

msgid ""
"9997    * Boehm, Adve, \"Foundations of the C++ Concurrency Memory Model\", "
"PLDI 08."
msgstr ""

msgid ""
"9998    * Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark "
"Weber, \"Mathematizing C++ Concurrency\", POPL 2011."
msgstr ""

msgid ""
"9999    * Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: "
"Understanding and Effectively Preventing the ABA Problem in Descriptor-based "
"Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010."
""
msgstr ""

msgid ""
"10000    * Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking "
"Concurrent Objects for Mission Critical Code. ACM OOPSLA'09. October 2009"
msgstr ""

msgid ""
"10001    * Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne "
"Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time "
"Systems. Proc. 16th Annual IEEE International Conference and Workshop on the "
"Engineering of Computer Based Systems (IEEE ECBS). April 2009."
msgstr ""

msgid ""
"10002    ### <a name=\"Rconc-double\"></a>CP.110: Do not write your own "
"double-checked locking for initialization"
msgstr ""

msgid "10003    ##### Reason"
msgstr ""

msgid ""
"10004    Since C++11, static local variables are now initialized in a thread-"
"safe way. When combined with the RAII pattern, static local variables can "
"replace the need for writing your own double-checked locking for "
"initialization. std::call_once can also achieve the same purpose. Use either "
"static local variables of C++11 or std::call_once instead of writing your "
"own double-checked locking for initialization."
msgstr ""

msgid "10005    ##### Example"
msgstr ""

msgid "10006    Example with std::call_once."
msgstr ""

msgid "10007        void f()"
msgstr ""

msgid "10008        {"
msgstr ""

msgid "10009            static std::once_flag my_once_flag;"
msgstr ""

msgid "10010            std::call_once(my_once_flag, []()"
msgstr ""

msgid "10011            {"
msgstr ""

msgid "10012                // do this only once"
msgstr ""

msgid "10013            });"
msgstr ""

msgid "10014            // ..."
msgstr ""

msgid "10015        }"
msgstr ""

msgid "10016    Example with thread-safe static local variables of C++11."
msgstr ""

msgid "10017        void f()"
msgstr ""

msgid "10018        {"
msgstr ""

msgid "10019            // Assuming the compiler is compliant with C++11"
msgstr ""

msgid ""
"10020            static My_class my_object; // Constructor called only once"
msgstr ""

msgid "10021            // ..."
msgstr ""

msgid "10022        }"
msgstr ""

msgid "10023        class My_class"
msgstr ""

msgid "10024        {"
msgstr ""

msgid "10025        public:"
msgstr ""

msgid "10026            My_class()"
msgstr ""

msgid "10027            {"
msgstr ""

msgid "10028                // do this only once"
msgstr ""

msgid "10029            }"
msgstr ""

msgid "10030        };"
msgstr ""

msgid "10031    ##### Enforcement"
msgstr ""

msgid "10032    ??? Is it possible to detect the idiom?"
msgstr ""

msgid ""
"10033    ### <a name=\"Rconc-double-pattern\"></a>CP.111: Use a conventional "
"pattern if you really need double-checked locking"
msgstr ""

msgid "10034    ##### Reason"
msgstr ""

msgid ""
"10035    Double-checked locking is easy to mess up. If you really need to "
"write your own double-checked locking, in spite of the rules [CP.110: Do not "
"write your own double-checked locking for initialization](#Rconc-double) and "
"[CP.100: Don't use lock-free programming unless you absolutely have "
"to](#Rconc-lockfree), then do it in a conventional pattern."
msgstr ""

msgid ""
"10036    The uses of the double-checked locking pattern that are not in "
"violation of [CP.110: Do not write your own double-checked locking for "
"initialization](#Rconc-double) arise when a non-thread-safe action is both "
"hard and rare, and there exists a fast thread-safe test that can be used to "
"guarantee that the action is not needed, but cannot be used to guarantee the "
"converse."
msgstr ""

msgid "10037    ##### Example, bad"
msgstr ""

msgid ""
"10038    The use of volatile does not make the first check thread-safe, see "
"also [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-"
"volatile2)"
msgstr ""

msgid "10039        mutex action_mutex;"
msgstr ""

msgid "10040        volatile bool action_needed;"
msgstr ""

msgid "10041        if (action_needed) {"
msgstr ""

msgid "10042            std::lock_guard<std::mutex> lock(action_mutex);"
msgstr ""

msgid "10043            if (action_needed) {"
msgstr ""

msgid "10044                take_action();"
msgstr ""

msgid "10045                action_needed = false;"
msgstr ""

msgid "10046            }"
msgstr ""

msgid "10047        }"
msgstr ""

msgid "10048    ##### Example, good"
msgstr ""

msgid "10049        mutex action_mutex;"
msgstr ""

msgid "10050        atomic<bool> action_needed;"
msgstr ""

msgid "10051        if (action_needed) {"
msgstr ""

msgid "10052            std::lock_guard<std::mutex> lock(action_mutex);"
msgstr ""

msgid "10053            if (action_needed) {"
msgstr ""

msgid "10054                take_action();"
msgstr ""

msgid "10055                action_needed = false;"
msgstr ""

msgid "10056            }"
msgstr ""

msgid "10057        }"
msgstr ""

msgid ""
"10058    Fine-tuned memory order may be beneficial where acquire load is "
"more efficient than sequentially-consistent load"
msgstr ""

msgid "10059        mutex action_mutex;"
msgstr ""

msgid "10060        atomic<bool> action_needed;"
msgstr ""

msgid "10061        if (action_needed.load(memory_order_acquire)) {"
msgstr ""

msgid "10062            lock_guard<std::mutex> lock(action_mutex);"
msgstr ""

msgid "10063            if (action_needed.load(memory_order_relaxed)) {"
msgstr ""

msgid "10064                take_action();"
msgstr ""

msgid "10065                action_needed.store(false, memory_order_release);"
msgstr ""

msgid "10066            }"
msgstr ""

msgid "10067        }"
msgstr ""

msgid "10068    ##### Enforcement"
msgstr ""

msgid "10069    ??? Is it possible to detect the idiom?"
msgstr ""

msgid "10070    ## <a name=\"SScp-etc\"></a>CP.etc: Etc. concurrency rules"
msgstr ""

msgid "10071    These rules defy simple categorization:"
msgstr ""

msgid ""
"10072    * [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-"
"volatile2)"
msgstr ""

msgid "10073    * [CP.201: ??? Signals](#Rconc-signal)"
msgstr ""

msgid ""
"10074    ### <a name=\"Rconc-volatile2\"></a>CP.200: Use `volatile` only to "
"talk to non-C++ memory"
msgstr ""

msgid "10075    ##### Reason"
msgstr ""

msgid ""
"10076    `volatile` is used to refer to objects that are shared with \"non-"
"C++\" code or hardware that does not follow the C++ memory model."
msgstr ""

msgid "10077    ##### Example"
msgstr ""

msgid "10078        const volatile long clock;"
msgstr ""

msgid ""
"10079    This describes a register constantly updated by a clock circuit."
msgstr ""

msgid ""
"10080    `clock` is `volatile` because its value will change without any "
"action from the C++ program that uses it."
msgstr ""

msgid ""
"10081    For example, reading `clock` twice will often yield two different "
"values, so the optimizer had better not optimize away the second read in "
"this code:"
msgstr ""

msgid "10082        long t1 = clock;"
msgstr ""

msgid "10083        // ... no use of clock here ..."
msgstr ""

msgid "10084        long t2 = clock;"
msgstr ""

msgid ""
"10085    `clock` is `const` because the program should not try to write to "
"`clock`."
msgstr ""

msgid "10086    ##### Note"
msgstr ""

msgid ""
"10087    Unless you are writing the lowest level code manipulating hardware "
"directly, consider `volatile` an esoteric feature that is best avoided."
msgstr ""

msgid "10088    ##### Example"
msgstr ""

msgid ""
"10089    Usually C++ code receives `volatile` memory that is owned Elsewhere "
"(hardware or another language):"
msgstr ""

msgid "10090        int volatile* vi = get_hardware_memory_location();"
msgstr ""

msgid ""
"10091            // note: we get a pointer to someone else's memory here"
msgstr ""

msgid "10092            // volatile says \"treat this with extra respect\""
msgstr ""

msgid ""
"10093    Sometimes C++ code allocates the `volatile` memory and shares it "
"with \"elsewhere\" (hardware or another language) by deliberately escaping a "
"pointer:"
msgstr ""

msgid "10094        static volatile long vl;"
msgstr ""

msgid ""
"10095        please_use_this(&vl);   // escape a reference to this to "
"\"elsewhere\" (not C++)"
msgstr ""

msgid "10096    ##### Example; bad"
msgstr ""

msgid ""
"10097    `volatile` local variables are nearly always wrong -- how can they "
"be shared with other languages or hardware if they're ephemeral?"
msgstr ""

msgid ""
"10098    The same applies almost as strongly to member variables, for the "
"same reason."
msgstr ""

msgid "10099        void f() {"
msgstr ""

msgid "10100            volatile int i = 0; // bad, volatile local variable"
msgstr ""

msgid "10101            // etc."
msgstr ""

msgid "10102        }"
msgstr ""

msgid "10103        class My_type {"
msgstr ""

msgid ""
"10104            volatile int i = 0; // suspicious, volatile member variable"
msgstr ""

msgid "10105            // etc."
msgstr ""

msgid "10106        };"
msgstr ""

msgid "10107    ##### Note"
msgstr ""

msgid ""
"10108    In C++, unlike in some other languages, `volatile` has [nothing to "
"do with synchronization](#Rconc-volatile)."
msgstr ""

msgid "10109    ##### Enforcement"
msgstr ""

msgid ""
"10110    * Flag `volatile T` local and member variables; almost certainly "
"you intended to use `atomic<T>` instead."
msgstr ""

msgid "10111    * ???"
msgstr ""

msgid "10112    ### <a name=\"Rconc-signal\"></a>CP.201: ??? Signals"
msgstr ""

msgid ""
"10113    ???UNIX signal handling???. May be worth reminding how little is "
"async-signal-safe, and how to communicate with a signal handler (best is "
"probably \"not at all\")"
msgstr ""

msgid "10114    # <a name=\"S-errors\"></a>E: Error handling"
msgstr ""

msgid "10115    Error handling involves:"
msgstr ""

msgid "10116    * Detecting an error"
msgstr ""

msgid ""
"10117    * Transmitting information about an error to some handler code"
msgstr ""

msgid "10118    * Preserve the state of a program in a valid state"
msgstr ""

msgid "10119    * Avoid resource leaks"
msgstr ""

msgid ""
"10120    It is not possible to recover from all errors. If recovery from an "
"error is not possible, it is important to quickly \"get out\" in a well-"
"defined way. A strategy for error handling must be simple, or it becomes a "
"source of even worse errors.  Untested and rarely executed error-handling "
"code is itself the source of many bugs."
msgstr ""

msgid "10121    The rules are designed to help avoid several kinds of errors:"
msgstr ""

msgid "10122    * Type violations (e.g., misuse of `union`s and casts)"
msgstr ""

msgid "10123    * Resource leaks (including memory leaks)"
msgstr ""

msgid "10124    * Bounds errors"
msgstr ""

msgid ""
"10125    * Lifetime errors (e.g., accessing an object after is has been "
"`delete`d)"
msgstr ""

msgid ""
"10126    * Complexity errors (logical errors made likely by overly complex "
"expression of ideas)"
msgstr ""

msgid ""
"10127    * Interface errors (e.g., an unexpected value is passed through an "
"interface)"
msgstr ""

msgid "10128    Error-handling rule summary:"
msgstr ""

msgid ""
"10129    * [E.1: Develop an error-handling strategy early in a design](#Re-"
"design)"
msgstr ""

msgid ""
"10130    * [E.2: Throw an exception to signal that a function can't perform "
"its assigned task](#Re-throw)"
msgstr ""

msgid "10131    * [E.3: Use exceptions for error handling only](#Re-errors)"
msgstr ""

msgid ""
"10132    * [E.4: Design your error-handling strategy around invariants](#Re-"
"design-invariants)"
msgstr ""

msgid ""
"10133    * [E.5: Let a constructor establish an invariant, and throw if it "
"cannot](#Re-invariant)"
msgstr ""

msgid "10134    * [E.6: Use RAII to prevent leaks](#Re-raii)"
msgstr ""

msgid "10135    * [E.7: State your preconditions](#Re-precondition)"
msgstr ""

msgid "10136    * [E.8: State your postconditions](#Re-postcondition)"
msgstr ""

msgid ""
"10137    * [E.12: Use `noexcept` when exiting a function because of a "
"`throw` is impossible or unacceptable](#Re-noexcept)"
msgstr ""

msgid ""
"10138    * [E.13: Never throw while being the direct owner of an object](#Re-"
"never-throw)"
msgstr ""

msgid ""
"10139    * [E.14: Use purpose-designed user-defined types as exceptions (not "
"built-in types)](#Re-exception-types)"
msgstr ""

msgid ""
"10140    * [E.15: Catch exceptions from a hierarchy by reference](#Re-"
"exception-ref)"
msgstr ""

msgid ""
"10141    * [E.16: Destructors, deallocation, and `swap` must never fail](#Re-"
"never-fail)"
msgstr ""

msgid ""
"10142    * [E.17: Don't try to catch every exception in every function](#Re-"
"not-always)"
msgstr ""

msgid ""
"10143    * [E.18: Minimize the use of explicit `try`/`catch`](#Re-catch)"
msgstr ""

msgid ""
"10144    * [E.19: Use a `final_action` object to express cleanup if no "
"suitable resource handle is available](#Re-finally)"
msgstr ""

msgid ""
"10145    * [E.25: If you can't throw exceptions, simulate RAII for resource "
"management](#Re-no-throw-raii)"
msgstr ""

msgid ""
"10146    * [E.26: If you can't throw exceptions, consider failing fast](#Re-"
"no-throw-crash)"
msgstr ""

msgid ""
"10147    * [E.27: If you can't throw exceptions, use error codes "
"systematically](#Re-no-throw-codes)"
msgstr ""

msgid ""
"10148    * [E.28: Avoid error handling based on global state (e.g. "
"`errno`)](#Re-no-throw)"
msgstr ""

msgid ""
"10149    * [E.30: Don't use exception specifications](#Re-specifications)"
msgstr ""

msgid "10150    * [E.31: Properly order your `catch`-clauses](#Re_catch)"
msgstr ""

msgid ""
"10151    ### <a name=\"Re-design\"></a>E.1: Develop an error-handling "
"strategy early in a design"
msgstr ""

msgid "10152    ##### Reason"
msgstr ""

msgid ""
"10153    A consistent and complete strategy for handling errors and resource "
"leaks is hard to retrofit into a system."
msgstr ""

msgid ""
"10154    ### <a name=\"Re-throw\"></a>E.2: Throw an exception to signal that "
"a function can't perform its assigned task"
msgstr ""

msgid "10155    ##### Reason"
msgstr ""

msgid ""
"10156    To make error handling systematic, robust, and non-repetitive."
msgstr ""

msgid "10157    ##### Example"
msgstr ""

msgid "10158        struct Foo {"
msgstr ""

msgid "10159            vector<Thing> v;"
msgstr ""

msgid "10160            File_handle f;"
msgstr ""

msgid "10161            string s;"
msgstr ""

msgid "10162        };"
msgstr ""

msgid "10163        void use()"
msgstr ""

msgid "10164        {"
msgstr ""

msgid ""
"10165            Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {\"my_file\", "
"\"r\"}, \"Here we go!\"};"
msgstr ""

msgid "10166            // ..."
msgstr ""

msgid "10167        }"
msgstr ""

msgid ""
"10168    Here, `vector` and `string`s constructors may not be able to "
"allocate sufficient memory for their elements, `vector`s constructor may not "
"be able copy the `Thing`s in its initializer list, and `File_handle` may not "
"be able to open the required file."
msgstr ""

msgid ""
"10169    In each case, they throw an exception for `use()`'s caller to "
"handle."
msgstr ""

msgid ""
"10170    If `use()` could handle the failure to construct `bar` it can take "
"control using `try`/`catch`."
msgstr ""

msgid ""
"10171    In either case, `Foo`'s constructor correctly destroys constructed "
"members before passing control to whatever tried to create a `Foo`."
msgstr ""

msgid ""
"10172    Note that there is no return value that could contain an error code."
""
msgstr ""

msgid "10173    The `File_handle` constructor might be defined like this:"
msgstr ""

msgid ""
"10174        File_handle::File_handle(const string& name, const string& "
"mode)"
msgstr ""

msgid "10175            :f{fopen(name.c_str(), mode.c_str())}"
msgstr ""

msgid "10176        {"
msgstr ""

msgid "10177            if (!f)"
msgstr ""

msgid ""
"10178                throw runtime_error{\"File_handle: could not open \" + "
"name + \" as \" + mode};"
msgstr ""

msgid "10179        }"
msgstr ""

msgid "10180    ##### Note"
msgstr ""

msgid ""
"10181    It is often said that exceptions are meant to signal exceptional "
"events and failures."
msgstr ""

msgid "10182    However, that's a bit circular because \"what is exceptional?\""
msgstr ""

msgid "10183    Examples:"
msgstr ""

msgid "10184    * A precondition that cannot be met"
msgstr ""

msgid ""
"10185    * A constructor that cannot construct an object (failure to "
"establish its class's [invariant](#Rc-struct))"
msgstr ""

msgid "10186    * An out-of-range error (e.g., `v[v.size()] = 7`)"
msgstr ""

msgid "10187    * Inability to acquire a resource (e.g., the network is down)"
msgstr ""

msgid ""
"10188    In contrast, termination of an ordinary loop is not exceptional."
msgstr ""

msgid ""
"10189    Unless the loop was meant to be infinite, termination is normal and "
"expected."
msgstr ""

msgid "10190    ##### Note"
msgstr ""

msgid ""
"10191    Don't use a `throw` as simply an alternative way of returning a "
"value from a function."
msgstr ""

msgid "10192    ##### Exception"
msgstr ""

msgid ""
"10193    Some systems, such as hard-real-time systems require a guarantee "
"that an action is taken in a (typically short) constant maximum time known "
"before execution starts. Such systems can use exceptions only if there is "
"tool support for accurately predicting the maximum time to recover from a "
"`throw`."
msgstr ""

msgid "10194    **See also**: [RAII](#Re-raii)"
msgstr ""

msgid "10195    **See also**: [discussion](#Sd-noexcept)"
msgstr ""

msgid "10196    ##### Note"
msgstr ""

msgid ""
"10197    Before deciding that you cannot afford or don't like exception-"
"based error handling, have a look at the [alternatives](#Re-no-throw-raii);"
msgstr ""

msgid "10198    they have their own complexities and problems."
msgstr ""

msgid ""
"10199    Also, as far as possible, measure before making claims about "
"efficiency."
msgstr ""

msgid ""
"10200    ### <a name=\"Re-errors\"></a>E.3: Use exceptions for error "
"handling only"
msgstr ""

msgid "10201    ##### Reason"
msgstr ""

msgid "10202    To keep error handling separated from \"ordinary code.\""
msgstr ""

msgid ""
"10203    C++ implementations tend to be optimized based on the assumption "
"that exceptions are rare."
msgstr ""

msgid "10204    ##### Example, don't"
msgstr ""

msgid "10205        // don't: exception not used for error handling"
msgstr ""

msgid "10206        int find_index(vector<string>& vec, const string& x)"
msgstr ""

msgid "10207        {"
msgstr ""

msgid "10208            try {"
msgstr ""

msgid "10209                for (gsl::index i = 0; i < vec.size(); ++i)"
msgstr ""

msgid "10210                    if (vec[i] == x) throw i;  // found x"
msgstr ""

msgid "10211            } catch (int i) {"
msgstr ""

msgid "10212                return i;"
msgstr ""

msgid "10213            }"
msgstr ""

msgid "10214            return -1;   // not found"
msgstr ""

msgid "10215        }"
msgstr ""

msgid ""
"10216    This is more complicated and most likely runs much slower than the "
"obvious alternative."
msgstr ""

msgid ""
"10217    There is nothing exceptional about finding a value in a `vector`."
msgstr ""

msgid "10218    ##### Enforcement"
msgstr ""

msgid "10219    Would need to be heuristic."
msgstr ""

msgid "10220    Look for exception values \"leaked\" out of `catch` clauses."
msgstr ""

msgid ""
"10221    ### <a name=\"Re-design-invariants\"></a>E.4: Design your error-"
"handling strategy around invariants"
msgstr ""

msgid "10222    ##### Reason"
msgstr ""

msgid ""
"10223    To use an object it must be in a valid state (defined formally or "
"informally by an invariant) and to recover from an error every object not "
"destroyed must be in a valid state."
msgstr ""

msgid "10224    ##### Note"
msgstr ""

msgid ""
"10225    An [invariant](#Rc-struct) is logical condition for the members of "
"an object that a constructor must establish for the public member functions "
"to assume."
msgstr ""

msgid "10226    ##### Enforcement"
msgstr ""

msgid "10227    ???"
msgstr ""

msgid ""
"10228    ### <a name=\"Re-invariant\"></a>E.5: Let a constructor establish "
"an invariant, and throw if it cannot"
msgstr ""

msgid "10229    ##### Reason"
msgstr ""

msgid ""
"10230    Leaving an object without its invariant established is asking for "
"trouble."
msgstr ""

msgid "10231    Not all member functions can be called."
msgstr ""

msgid "10232    ##### Example"
msgstr ""

msgid "10233        class Vector {  // very simplified vector of doubles"
msgstr ""

msgid "10234            // if elem != nullptr then elem points to sz doubles"
msgstr ""

msgid "10235        public:"
msgstr ""

msgid "10236            Vector() : elem{nullptr}, sz{0}{}"
msgstr ""

msgid ""
"10237            Vector(int s) : elem{new double[s]}, sz{s} { /* initialize "
"elements */ }"
msgstr ""

msgid "10238            ~Vector() { delete [] elem; }"
msgstr ""

msgid "10239            double& operator[](int s) { return elem[s]; }"
msgstr ""

msgid "10240            // ..."
msgstr ""

msgid "10241        private:"
msgstr ""

msgid "10242            owner<double*> elem;"
msgstr ""

msgid "10243            int sz;"
msgstr ""

msgid "10244        };"
msgstr ""

msgid ""
"10245    The class invariant - here stated as a comment - is established by "
"the constructors."
msgstr ""

msgid "10246    `new` throws if it cannot allocate the required memory."
msgstr ""

msgid ""
"10247    The operators, notably the subscript operator, relies on the "
"invariant."
msgstr ""

msgid ""
"10248    **See also**: [If a constructor cannot construct a valid object, "
"throw an exception](#Rc-throw)"
msgstr ""

msgid "10249    ##### Enforcement"
msgstr ""

msgid ""
"10250    Flag classes with `private` state without a constructor (public, "
"protected, or private)."
msgstr ""

msgid "10251    ### <a name=\"Re-raii\"></a>E.6: Use RAII to prevent leaks"
msgstr ""

msgid "10252    ##### Reason"
msgstr ""

msgid "10253    Leaks are typically unacceptable."
msgstr ""

msgid "10254    Manual resource release is error-prone."
msgstr ""

msgid ""
"10255    RAII (\"Resource Acquisition Is Initialization\") is the simplest, "
"most systematic way of preventing leaks."
msgstr ""

msgid "10256    ##### Example"
msgstr ""

msgid "10257        void f1(int i)   // Bad: possibly leak"
msgstr ""

msgid "10258        {"
msgstr ""

msgid "10259            int* p = new int[12];"
msgstr ""

msgid "10260            // ..."
msgstr ""

msgid "10261            if (i < 17) throw Bad{\"in f()\", i};"
msgstr ""

msgid "10262            // ..."
msgstr ""

msgid "10263        }"
msgstr ""

msgid "10264    We could carefully release the resource before the throw:"
msgstr ""

msgid ""
"10265        void f2(int i)   // Clumsy and error-prone: explicit release"
msgstr ""

msgid "10266        {"
msgstr ""

msgid "10267            int* p = new int[12];"
msgstr ""

msgid "10268            // ..."
msgstr ""

msgid "10269            if (i < 17) {"
msgstr ""

msgid "10270                delete[] p;"
msgstr ""

msgid "10271                throw Bad{\"in f()\", i};"
msgstr ""

msgid "10272            }"
msgstr ""

msgid "10273            // ..."
msgstr ""

msgid "10274        }"
msgstr ""

msgid ""
"10275    This is verbose. In larger code with multiple possible `throw`s "
"explicit releases become repetitive and error-prone."
msgstr ""

msgid ""
"10276        void f3(int i)   // OK: resource management done by a handle "
"(but see below)"
msgstr ""

msgid "10277        {"
msgstr ""

msgid "10278            auto p = make_unique<int[]>(12);"
msgstr ""

msgid "10279            // ..."
msgstr ""

msgid "10280            if (i < 17) throw Bad{\"in f()\", i};"
msgstr ""

msgid "10281            // ..."
msgstr ""

msgid "10282        }"
msgstr ""

msgid ""
"10283    Note that this works even when the `throw` is implicit because it "
"happened in a called function:"
msgstr ""

msgid ""
"10284        void f4(int i)   // OK: resource management done by a handle "
"(but see below)"
msgstr ""

msgid "10285        {"
msgstr ""

msgid "10286            auto p = make_unique<int[]>(12);"
msgstr ""

msgid "10287            // ..."
msgstr ""

msgid "10288            helper(i);   // may throw"
msgstr ""

msgid "10289            // ..."
msgstr ""

msgid "10290        }"
msgstr ""

msgid ""
"10291    Unless you really need pointer semantics, use a local resource "
"object:"
msgstr ""

msgid ""
"10292        void f5(int i)   // OK: resource management done by local "
"object"
msgstr ""

msgid "10293        {"
msgstr ""

msgid "10294            vector<int> v(12);"
msgstr ""

msgid "10295            // ..."
msgstr ""

msgid "10296            helper(i);   // may throw"
msgstr ""

msgid "10297            // ..."
msgstr ""

msgid "10298        }"
msgstr ""

msgid "10299    That's even simpler and safer, and often more efficient."
msgstr ""

msgid "10300    ##### Note"
msgstr ""

msgid ""
"10301    If there is no obvious resource handle and for some reason defining "
"a proper RAII object/handle is infeasible,"
msgstr ""

msgid ""
"10302    as a last resort, cleanup actions can be represented by a "
"[`final_action`](#Re-finally) object."
msgstr ""

msgid "10303    ##### Note"
msgstr ""

msgid ""
"10304    But what do we do if we are writing a program where exceptions "
"cannot be used?"
msgstr ""

msgid ""
"10305    First challenge that assumption; there are many anti-exceptions "
"myths around."
msgstr ""

msgid "10306    We know of only a few good reasons:"
msgstr ""

msgid ""
"10307    * We are on a system so small that the exception support would eat "
"up most of our 2K memory."
msgstr ""

msgid ""
"10308    * We are in a hard-real-time system and we don't have tools that "
"guarantee us that an exception is handled within the required time."
msgstr ""

msgid ""
"10309    * We are in a system with tons of legacy code using lots of "
"pointers in difficult-to-understand ways"
msgstr ""

msgid ""
"10310      (in particular without a recognizable ownership strategy) so that "
"exceptions could cause leaks."
msgstr ""

msgid ""
"10311    * Our implementation of the C++ exception mechanisms is "
"unreasonably poor"
msgstr ""

msgid ""
"10312    (slow, memory consuming, failing to work correctly for dynamically "
"linked libraries, etc.)."
msgstr ""

msgid ""
"10313    Complain to your implementation purveyor; if no user complains, no "
"improvement will happen."
msgstr ""

msgid "10314    * We get fired if we challenge our manager's ancient wisdom."
msgstr ""

msgid ""
"10315    Only the first of these reasons is fundamental, so whenever "
"possible, use exceptions to implement RAII, or design your RAII objects to "
"never fail."
msgstr ""

msgid "10316    When exceptions cannot be used, simulate RAII."
msgstr ""

msgid ""
"10317    That is, systematically check that objects are valid after "
"construction and still release all resources in the destructor."
msgstr ""

msgid ""
"10318    One strategy is to add a `valid()` operation to every resource "
"handle:"
msgstr ""

msgid "10319        void f()"
msgstr ""

msgid "10320        {"
msgstr ""

msgid ""
"10321            vector<string> vs(100);   // not std::vector: valid() added"
msgstr ""

msgid "10322            if (!vs.valid()) {"
msgstr ""

msgid "10323                // handle error or exit"
msgstr ""

msgid "10324            }"
msgstr ""

msgid ""
"10325            ifstream fs(\"foo\");   // not std::ifstream: valid() added"
msgstr ""

msgid "10326            if (!fs.valid()) {"
msgstr ""

msgid "10327                // handle error or exit"
msgstr ""

msgid "10328            }"
msgstr ""

msgid "10329            // ..."
msgstr ""

msgid "10330        } // destructors clean up as usual"
msgstr ""

msgid ""
"10331    Obviously, this increases the size of the code, doesn't allow for "
"implicit propagation of \"exceptions\" (`valid()` checks), and `valid()` "
"checks can be forgotten."
msgstr ""

msgid "10332    Prefer to use exceptions."
msgstr ""

msgid "10333    **See also**: [Use of `noexcept`](#Se-noexcept)"
msgstr ""

msgid "10334    ##### Enforcement"
msgstr ""

msgid "10335    ???"
msgstr ""

msgid ""
"10336    ### <a name=\"Re-precondition\"></a>E.7: State your preconditions"
msgstr ""

msgid "10337    ##### Reason"
msgstr ""

msgid "10338    To avoid interface errors."
msgstr ""

msgid "10339    **See also**: [precondition rule](#Ri-pre)"
msgstr ""

msgid ""
"10340    ### <a name=\"Re-postcondition\"></a>E.8: State your postconditions"
msgstr ""

msgid "10341    ##### Reason"
msgstr ""

msgid "10342    To avoid interface errors."
msgstr ""

msgid "10343    **See also**: [postcondition rule](#Ri-post)"
msgstr ""

msgid ""
"10344    ### <a name=\"Re-noexcept\"></a>E.12: Use `noexcept` when exiting a "
"function because of a `throw` is impossible or unacceptable"
msgstr ""

msgid "10345    ##### Reason"
msgstr ""

msgid "10346    To make error handling systematic, robust, and efficient."
msgstr ""

msgid "10347    ##### Example"
msgstr ""

msgid "10348        double compute(double d) noexcept"
msgstr ""

msgid "10349        {"
msgstr ""

msgid "10350            return log(sqrt(d <= 0 ? 1 : d));"
msgstr ""

msgid "10351        }"
msgstr ""

msgid ""
"10352    Here, we know that `compute` will not throw because it is composed "
"out of operations that don't throw."
msgstr ""

msgid ""
"10353    By declaring `compute` to be `noexcept`, we give the compiler and "
"human readers information that can make it easier for them to understand and "
"manipulate `compute`."
msgstr ""

msgid "10354    ##### Note"
msgstr ""

msgid ""
"10355    Many standard-library functions are `noexcept` including all the "
"standard-library functions \"inherited\" from the C Standard Library."
msgstr ""

msgid "10356    ##### Example"
msgstr ""

msgid "10357        vector<double> munge(const vector<double>& v) noexcept"
msgstr ""

msgid "10358        {"
msgstr ""

msgid "10359            vector<double> v2(v.size());"
msgstr ""

msgid "10360            // ... do something ..."
msgstr ""

msgid "10361        }"
msgstr ""

msgid ""
"10362    The `noexcept` here states that I am not willing or able to handle "
"the situation where I cannot construct the local `vector`."
msgstr ""

msgid ""
"10363    That is, I consider memory exhaustion a serious design error (on "
"par with hardware failures) so that I'm willing to crash the program if it "
"happens."
msgstr ""

msgid "10364    ##### Note"
msgstr ""

msgid ""
"10365    Do not use traditional [exception-specifications](#Re-"
"specifications)."
msgstr ""

msgid "10366    ##### See also"
msgstr ""

msgid "10367    [discussion](#Sd-noexcept)."
msgstr ""

msgid ""
"10368    ### <a name=\"Re-never-throw\"></a>E.13: Never throw while being "
"the direct owner of an object"
msgstr ""

msgid "10369    ##### Reason"
msgstr ""

msgid "10370    That would be a leak."
msgstr ""

msgid "10371    ##### Example"
msgstr ""

msgid "10372        void leak(int x)   // don't: may leak"
msgstr ""

msgid "10373        {"
msgstr ""

msgid "10374            auto p = new int{7};"
msgstr ""

msgid ""
"10375            if (x < 0) throw Get_me_out_of_here{};  // may leak *p"
msgstr ""

msgid "10376            // ..."
msgstr ""

msgid "10377            delete p;   // we may never get here"
msgstr ""

msgid "10378        }"
msgstr ""

msgid ""
"10379    One way of avoiding such problems is to use resource handles "
"consistently:"
msgstr ""

msgid "10380        void no_leak(int x)"
msgstr ""

msgid "10381        {"
msgstr ""

msgid "10382            auto p = make_unique<int>(7);"
msgstr ""

msgid ""
"10383            if (x < 0) throw Get_me_out_of_here{};  // will delete *p "
"if necessary"
msgstr ""

msgid "10384            // ..."
msgstr ""

msgid "10385            // no need for delete p"
msgstr ""

msgid "10386        }"
msgstr ""

msgid ""
"10387    Another solution (often better) would be to use a local variable to "
"eliminate explicit use of pointers:"
msgstr ""

msgid "10388        void no_leak_simplified(int x)"
msgstr ""

msgid "10389        {"
msgstr ""

msgid "10390            vector<int> v(7);"
msgstr ""

msgid "10391            // ..."
msgstr ""

msgid "10392        }"
msgstr ""

msgid "10393    ##### Note"
msgstr ""

msgid ""
"10394    If you have local \"things\" that requires cleanup, but is not "
"represented by an object with a destructor, such cleanup must"
msgstr ""

msgid "10395    also be done before a `throw`."
msgstr ""

msgid ""
"10396    Sometimes, [`finally()`](#Re-finally) can make such unsystematic "
"cleanup a bit more manageable."
msgstr ""

msgid ""
"10397    ### <a name=\"Re-exception-types\"></a>E.14: Use purpose-designed "
"user-defined types as exceptions (not built-in types)"
msgstr ""

msgid "10398    ##### Reason"
msgstr ""

msgid ""
"10399    A user-defined type is unlikely to clash with other people's "
"exceptions."
msgstr ""

msgid "10400    ##### Example"
msgstr ""

msgid "10401        void my_code()"
msgstr ""

msgid "10402        {"
msgstr ""

msgid "10403            // ..."
msgstr ""

msgid "10404            throw Moonphase_error{};"
msgstr ""

msgid "10405            // ..."
msgstr ""

msgid "10406        }"
msgstr ""

msgid "10407        void your_code()"
msgstr ""

msgid "10408        {"
msgstr ""

msgid "10409            try {"
msgstr ""

msgid "10410                // ..."
msgstr ""

msgid "10411                my_code();"
msgstr ""

msgid "10412                // ..."
msgstr ""

msgid "10413            }"
msgstr ""

msgid "10414            catch(const Bufferpool_exhausted&) {"
msgstr ""

msgid "10415                // ..."
msgstr ""

msgid "10416            }"
msgstr ""

msgid "10417        }"
msgstr ""

msgid "10418    ##### Example, don't"
msgstr ""

msgid "10419        void my_code()     // Don't"
msgstr ""

msgid "10420        {"
msgstr ""

msgid "10421            // ..."
msgstr ""

msgid "10422            throw 7;       // 7 means \"moon in the 4th quarter\""
msgstr ""

msgid "10423            // ..."
msgstr ""

msgid "10424        }"
msgstr ""

msgid "10425        void your_code()   // Don't"
msgstr ""

msgid "10426        {"
msgstr ""

msgid "10427            try {"
msgstr ""

msgid "10428                // ..."
msgstr ""

msgid "10429                my_code();"
msgstr ""

msgid "10430                // ..."
msgstr ""

msgid "10431            }"
msgstr ""

msgid ""
"10432            catch(int i) {  // i == 7 means \"input buffer too small\""
msgstr ""

msgid "10433                // ..."
msgstr ""

msgid "10434            }"
msgstr ""

msgid "10435        }"
msgstr ""

msgid "10436    ##### Note"
msgstr ""

msgid ""
"10437    The standard-library classes derived from `exception` should be "
"used only as base classes or for exceptions that require only \"generic\" "
"handling. Like built-in types, their use could clash with other people's use "
"of them."
msgstr ""

msgid "10438    ##### Example, don't"
msgstr ""

msgid "10439        void my_code()   // Don't"
msgstr ""

msgid "10440        {"
msgstr ""

msgid "10441            // ..."
msgstr ""

msgid "10442            throw runtime_error{\"moon in the 4th quarter\"};"
msgstr ""

msgid "10443            // ..."
msgstr ""

msgid "10444        }"
msgstr ""

msgid "10445        void your_code()   // Don't"
msgstr ""

msgid "10446        {"
msgstr ""

msgid "10447            try {"
msgstr ""

msgid "10448                // ..."
msgstr ""

msgid "10449                my_code();"
msgstr ""

msgid "10450                // ..."
msgstr ""

msgid "10451            }"
msgstr ""

msgid ""
"10452            catch(const runtime_error&) {   // runtime_error means "
"\"input buffer too small\""
msgstr ""

msgid "10453                // ..."
msgstr ""

msgid "10454            }"
msgstr ""

msgid "10455        }"
msgstr ""

msgid "10456    **See also**: [Discussion](#Sd-???)"
msgstr ""

msgid "10457    ##### Enforcement"
msgstr ""

msgid ""
"10458    Catch `throw` and `catch` of a built-in type. Maybe warn about "
"`throw` and `catch` using a standard-library `exception` type. Obviously, "
"exceptions derived from the `std::exception` hierarchy are fine."
msgstr ""

msgid ""
"10459    ### <a name=\"Re-exception-ref\"></a>E.15: Catch exceptions from a "
"hierarchy by reference"
msgstr ""

msgid "10460    ##### Reason"
msgstr ""

msgid "10461    To prevent slicing."
msgstr ""

msgid "10462    ##### Example"
msgstr ""

msgid "10463        void f()"
msgstr ""

msgid "10464        {"
msgstr ""

msgid "10465            try {"
msgstr ""

msgid "10466                // ..."
msgstr ""

msgid "10467            }"
msgstr ""

msgid "10468            catch (exception e) {   // don't: may slice"
msgstr ""

msgid "10469                // ..."
msgstr ""

msgid "10470            }"
msgstr ""

msgid "10471        }"
msgstr ""

msgid "10472    Instead, use a reference:"
msgstr ""

msgid "10473        catch (exception& e) { /* ... */ }"
msgstr ""

msgid "10474    of - typically better still - a `const` reference:"
msgstr ""

msgid "10475        catch (const exception& e) { /* ... */ }"
msgstr ""

msgid ""
"10476    Most handlers do not modify their exception and in general we "
"[recommend use of `const`](#Res-const)."
msgstr ""

msgid "10477    ##### Note"
msgstr ""

msgid ""
"10478    To rethrow a caught exception use `throw;` not `throw e;`. Using "
"`throw e;` would throw a new copy of `e` (sliced to the static type `std::"
"exception`) instead of rethrowing the original exception of type `std::"
"runtime_error`. (But keep [Don't try to catch every exception in every "
"function](https://github.com/isocpp/CppCoreGuidelines/blob/master/"
"CppCoreGuidelines.md#Re-not-always) and [Minimize the use of explicit `try`/"
"`catch`](https://github.com/isocpp/CppCoreGuidelines/blob/master/"
"CppCoreGuidelines.md#Re-catch) in mind.)"
msgstr ""

msgid "10479    ##### Enforcement"
msgstr ""

msgid ""
"10480    Flag by-value exceptions if their types are part of a hierarchy "
"(could require whole-program analysis to be perfect)."
msgstr ""

msgid ""
"10481    ### <a name=\"Re-never-fail\"></a>E.16: Destructors, deallocation, "
"and `swap` must never fail"
msgstr ""

msgid "10482    ##### Reason"
msgstr ""

msgid ""
"10483    We don't know how to write reliable programs if a destructor, a "
"swap, or a memory deallocation fails; that is, if it exits by an exception "
"or simply doesn't perform its required action."
msgstr ""

msgid "10484    ##### Example, don't"
msgstr ""

msgid "10485        class Connection {"
msgstr ""

msgid "10486            // ..."
msgstr ""

msgid "10487        public:"
msgstr ""

msgid "10488            ~Connection()   // Don't: very bad destructor"
msgstr ""

msgid "10489            {"
msgstr ""

msgid ""
"10490                if (cannot_disconnect()) throw I_give_up{information};"
msgstr ""

msgid "10491                // ..."
msgstr ""

msgid "10492            }"
msgstr ""

msgid "10493        };"
msgstr ""

msgid "10494    ##### Note"
msgstr ""

msgid ""
"10495    Many have tried to write reliable code violating this rule for "
"examples, such as a network connection that \"refuses to close\"."
msgstr ""

msgid ""
"10496    To the best of our knowledge nobody has found a general way of "
"doing this."
msgstr ""

msgid ""
"10497    Occasionally, for very specific examples, you can get away with "
"setting some state for future cleanup."
msgstr ""

msgid ""
"10498    For example, we might put a socket that does not want to close on a "
"\"bad socket\" list,"
msgstr ""

msgid "10499    to be examined by a regular sweep of the system state."
msgstr ""

msgid ""
"10500    Every example we have seen of this is error-prone, specialized, and "
"often buggy."
msgstr ""

msgid "10501    ##### Note"
msgstr ""

msgid ""
"10502    The standard library assumes that destructors, deallocation "
"functions (e.g., `operator delete`), and `swap` do not throw. If they do, "
"basic standard-library invariants are broken."
msgstr ""

msgid "10503    ##### Note"
msgstr ""

msgid ""
"10504    Deallocation functions, including `operator delete`, must be "
"`noexcept`. `swap` functions must be `noexcept`."
msgstr ""

msgid "10505    Most destructors are implicitly `noexcept` by default."
msgstr ""

msgid "10506    Also, [make move operations `noexcept`](#Rc-move-noexcept)."
msgstr ""

msgid "10507    ##### Enforcement"
msgstr ""

msgid ""
"10508    Catch destructors, deallocation operations, and `swap`s that "
"`throw`."
msgstr ""

msgid "10509    Catch such operations that are not `noexcept`."
msgstr ""

msgid "10510    **See also**: [discussion](#Sd-never-fail)"
msgstr ""

msgid ""
"10511    ### <a name=\"Re-not-always\"></a>E.17: Don't try to catch every "
"exception in every function"
msgstr ""

msgid "10512    ##### Reason"
msgstr ""

msgid ""
"10513    Catching an exception in a function that cannot take a meaningful "
"recovery action leads to complexity and waste."
msgstr ""

msgid ""
"10514    Let an exception propagate until it reaches a function that can "
"handle it."
msgstr ""

msgid ""
"10515    Let cleanup actions on the unwinding path be handled by [RAII](#Re-"
"raii)."
msgstr ""

msgid "10516    ##### Example, don't"
msgstr ""

msgid "10517        void f()   // bad"
msgstr ""

msgid "10518        {"
msgstr ""

msgid "10519            try {"
msgstr ""

msgid "10520                // ..."
msgstr ""

msgid "10521            }"
msgstr ""

msgid "10522            catch (...) {"
msgstr ""

msgid "10523                // no action"
msgstr ""

msgid "10524                throw;   // propagate exception"
msgstr ""

msgid "10525            }"
msgstr ""

msgid "10526        }"
msgstr ""

msgid "10527    ##### Enforcement"
msgstr ""

msgid "10528    * Flag nested try-blocks."
msgstr ""

msgid ""
"10529    * Flag source code files with a too high ratio of try-blocks to "
"functions. (??? Problem: define \"too high\")"
msgstr ""

msgid ""
"10530    ### <a name=\"Re-catch\"></a>E.18: Minimize the use of explicit "
"`try`/`catch`"
msgstr ""

msgid "10531    ##### Reason"
msgstr ""

msgid "10532     `try`/`catch` is verbose and non-trivial uses error-prone."
msgstr ""

msgid ""
"10533     `try`/`catch` can be a sign of unsystematic and/or low-level "
"resource management or error handling."
msgstr ""

msgid "10534    ##### Example, Bad"
msgstr ""

msgid "10535        void f(zstring s)"
msgstr ""

msgid "10536        {"
msgstr ""

msgid "10537            Gadget* p;"
msgstr ""

msgid "10538            try {"
msgstr ""

msgid "10539                p = new Gadget(s);"
msgstr ""

msgid "10540                // ..."
msgstr ""

msgid "10541                delete p;"
msgstr ""

msgid "10542            }"
msgstr ""

msgid "10543            catch (Gadget_construction_failure) {"
msgstr ""

msgid "10544                delete p;"
msgstr ""

msgid "10545                throw;"
msgstr ""

msgid "10546            }"
msgstr ""

msgid "10547        }"
msgstr ""

msgid "10548    This code is messy."
msgstr ""

msgid ""
"10549    There could be a leak from the naked pointer in the `try` block."
msgstr ""

msgid "10550    Not all exceptions are handled."
msgstr ""

msgid ""
"10551    `deleting` an object that failed to construct is almost certainly a "
"mistake."
msgstr ""

msgid "10552    Better:"
msgstr ""

msgid "10553        void f2(zstring s)"
msgstr ""

msgid "10554        {"
msgstr ""

msgid "10555            Gadget g {s};"
msgstr ""

msgid "10556        }"
msgstr ""

msgid "10557    ##### Alternatives"
msgstr ""

msgid "10558    * proper resource handles and [RAII](#Re-raii)"
msgstr ""

msgid "10559    * [`finally`](#Re-finally)"
msgstr ""

msgid "10560    ##### Enforcement"
msgstr ""

msgid "10561    ??? hard, needs a heuristic"
msgstr ""

msgid ""
"10562    ### <a name=\"Re-finally\"></a>E.19: Use a `final_action` object to "
"express cleanup if no suitable resource handle is available"
msgstr ""

msgid "10563    ##### Reason"
msgstr ""

msgid ""
"10564    `finally` is less verbose and harder to get wrong than `try`/"
"`catch`."
msgstr ""

msgid "10565    ##### Example"
msgstr ""

msgid "10566        void f(int n)"
msgstr ""

msgid "10567        {"
msgstr ""

msgid "10568            void* p = malloc(1, n);"
msgstr ""

msgid "10569            auto _ = finally([p] { free(p); });"
msgstr ""

msgid "10570            // ..."
msgstr ""

msgid "10571        }"
msgstr ""

msgid "10572    ##### Note"
msgstr ""

msgid ""
"10573    `finally` is not as messy as `try`/`catch`, but it is still ad-hoc."
msgstr ""

msgid "10574    Prefer [proper resource management objects](#Re-raii)."
msgstr ""

msgid "10575    Consider `finally` a last resort."
msgstr ""

msgid "10576    ##### Note"
msgstr ""

msgid ""
"10577    Use of `finally` is a systematic and reasonably clean alternative "
"to the old [`goto exit;` technique](#Re-no-throw-codes)"
msgstr ""

msgid ""
"10578    for dealing with cleanup where resource management is not "
"systematic."
msgstr ""

msgid "10579    ##### Enforcement"
msgstr ""

msgid "10580    Heuristic: Detect `goto exit;`"
msgstr ""

msgid ""
"10581    ### <a name=\"Re-no-throw-raii\"></a>E.25: If you can't throw "
"exceptions, simulate RAII for resource management"
msgstr ""

msgid "10582    ##### Reason"
msgstr ""

msgid ""
"10583    Even without exceptions, [RAII](#Re-raii) is usually the best and "
"most systematic way of dealing with resources."
msgstr ""

msgid "10584    ##### Note"
msgstr ""

msgid ""
"10585    Error handling using exceptions is the only complete and systematic "
"way of handling non-local errors in C++."
msgstr ""

msgid ""
"10586    In particular, non-intrusively signaling failure to construct an "
"object requires an exception."
msgstr ""

msgid ""
"10587    Signaling errors in a way that cannot be ignored requires "
"exceptions."
msgstr ""

msgid ""
"10588    If you can't use exceptions, simulate their use as best you can."
msgstr ""

msgid "10589    A lot of fear of exceptions is misguided."
msgstr ""

msgid ""
"10590    When used for exceptional circumstances in code that is not "
"littered with pointers and complicated control structures,"
msgstr ""

msgid ""
"10591    exception handling is almost always affordable (in time and space) "
"and almost always leads to better code."
msgstr ""

msgid ""
"10592    This, of course, assumes a good implementation of the exception "
"handling mechanisms, which is not available on all systems."
msgstr ""

msgid ""
"10593    There are also cases where the problems above do not apply, but "
"exceptions cannot be used for other reasons."
msgstr ""

msgid ""
"10594    Some hard-real-time systems are an example: An operation has to be "
"completed within a fixed time with an error or a correct answer."
msgstr ""

msgid ""
"10595    In the absence of appropriate time estimation tools, this is hard "
"to guarantee for exceptions."
msgstr ""

msgid ""
"10596    Such systems (e.g. flight control software) typically also ban the "
"use of dynamic (heap) memory."
msgstr ""

msgid ""
"10597    So, the primary guideline for error handling is \"use exceptions "
"and [RAII](#Re-raii).\""
msgstr ""

msgid ""
"10598    This section deals with the cases where you either do not have an "
"efficient implementation of exceptions,"
msgstr ""

msgid "10599    or have such a rat's nest of old-style code"
msgstr ""

msgid ""
"10600    (e.g., lots of pointers, ill-defined ownership, and lots of "
"unsystematic error handling based on tests of error codes)"
msgstr ""

msgid ""
"10601    that it is infeasible to introduce simple and systematic exception "
"handling."
msgstr ""

msgid ""
"10602    Before condemning exceptions or complaining too much about their "
"cost, consider examples of the use of [error codes](#Re-no-throw-codes)."
msgstr ""

msgid "10603    Consider the cost and complexity of the use of error codes."
msgstr ""

msgid "10604    If performance is your worry, measure."
msgstr ""

msgid "10605    ##### Example"
msgstr ""

msgid "10606    Assume you wanted to write"
msgstr ""

msgid "10607        void func(zstring arg)"
msgstr ""

msgid "10608        {"
msgstr ""

msgid "10609            Gadget g {arg};"
msgstr ""

msgid "10610            // ..."
msgstr ""

msgid "10611        }"
msgstr ""

msgid ""
"10612    If the `gadget` isn't correctly constructed, `func` exits with an "
"exception."
msgstr ""

msgid ""
"10613    If we cannot throw an exception, we can simulate this RAII style of "
"resource handling by adding a `valid()` member function to `Gadget`:"
msgstr ""

msgid "10614        error_indicator func(zstring arg)"
msgstr ""

msgid "10615        {"
msgstr ""

msgid "10616            Gadget g {arg};"
msgstr ""

msgid "10617            if (!g.valid()) return gadget_construction_error;"
msgstr ""

msgid "10618            // ..."
msgstr ""

msgid "10619            return 0;   // zero indicates \"good\""
msgstr ""

msgid "10620        }"
msgstr ""

msgid ""
"10621    The problem is of course that the caller now has to remember to "
"test the return value."
msgstr ""

msgid "10622    **See also**: [Discussion](#Sd-???)"
msgstr ""

msgid "10623    ##### Enforcement"
msgstr ""

msgid ""
"10624    Possible (only) for specific versions of this idea: e.g., test for "
"systematic test of `valid()` after resource handle construction"
msgstr ""

msgid ""
"10625    ### <a name=\"Re-no-throw-crash\"></a>E.26: If you can't throw "
"exceptions, consider failing fast"
msgstr ""

msgid "10626    ##### Reason"
msgstr ""

msgid ""
"10627    If you can't do a good job at recovering, at least you can get out "
"before too much consequential damage is done."
msgstr ""

msgid "10628    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr ""

msgid "10629    ##### Note"
msgstr ""

msgid ""
"10630    If you cannot be systematic about error handling, consider "
"\"crashing\" as a response to any error that cannot be handled locally."
msgstr ""

msgid ""
"10631    That is, if you cannot recover from an error in the context of the "
"function that detected it, call `abort()`, `quick_exit()`,"
msgstr ""

msgid ""
"10632    or a similar function that will trigger some sort of system restart."
""
msgstr ""

msgid ""
"10633    In systems where you have lots of processes and/or lots of "
"computers, you need to expect and handle fatal crashes anyway,"
msgstr ""

msgid "10634    say from hardware failures."
msgstr ""

msgid ""
"10635    In such cases, \"crashing\" is simply leaving error handling to the "
"next level of the system."
msgstr ""

msgid "10636    ##### Example"
msgstr ""

msgid "10637        void f(int n)"
msgstr ""

msgid "10638        {"
msgstr ""

msgid "10639            // ..."
msgstr ""

msgid "10640            p = static_cast<X*>(malloc(n, X));"
msgstr ""

msgid "10641            if (!p) abort();     // abort if memory is exhausted"
msgstr ""

msgid "10642            // ..."
msgstr ""

msgid "10643        }"
msgstr ""

msgid ""
"10644    Most programs cannot handle memory exhaustion gracefully anyway. "
"This is roughly equivalent to"
msgstr ""

msgid "10645        void f(int n)"
msgstr ""

msgid "10646        {"
msgstr ""

msgid "10647            // ..."
msgstr ""

msgid ""
"10648            p = new X[n];    // throw if memory is exhausted (by "
"default, terminate)"
msgstr ""

msgid "10649            // ..."
msgstr ""

msgid "10650        }"
msgstr ""

msgid ""
"10651    Typically, it is a good idea to log the reason for the \"crash\" "
"before exiting."
msgstr ""

msgid "10652    ##### Enforcement"
msgstr ""

msgid "10653    Awkward"
msgstr ""

msgid ""
"10654    ### <a name=\"Re-no-throw-codes\"></a>E.27: If you can't throw "
"exceptions, use error codes systematically"
msgstr ""

msgid "10655    ##### Reason"
msgstr ""

msgid ""
"10656    Systematic use of any error-handling strategy minimizes the chance "
"of forgetting to handle an error."
msgstr ""

msgid "10657    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr ""

msgid "10658    ##### Note"
msgstr ""

msgid "10659    There are several issues to be addressed:"
msgstr ""

msgid ""
"10660    * how do you transmit an error indicator from out of a function?"
msgstr ""

msgid ""
"10661    * how do you release all resources from a function before doing an "
"error exit?"
msgstr ""

msgid "10662    * What do you use as an error indicator?"
msgstr ""

msgid ""
"10663    In general, returning an error indicator implies returning two "
"values: The result and an error indicator."
msgstr ""

msgid ""
"10664    The error indicator can be part of the object, e.g. an object can "
"have a `valid()` indicator"
msgstr ""

msgid "10665    or a pair of values can be returned."
msgstr ""

msgid "10666    ##### Example"
msgstr ""

msgid "10667        Gadget make_gadget(int n)"
msgstr ""

msgid "10668        {"
msgstr ""

msgid "10669            // ..."
msgstr ""

msgid "10670        }"
msgstr ""

msgid "10671        void user()"
msgstr ""

msgid "10672        {"
msgstr ""

msgid "10673            Gadget g = make_gadget(17);"
msgstr ""

msgid "10674            if (!g.valid()) {"
msgstr ""

msgid "10675                    // error handling"
msgstr ""

msgid "10676            }"
msgstr ""

msgid "10677            // ..."
msgstr ""

msgid "10678        }"
msgstr ""

msgid ""
"10679    This approach fits with [simulated RAII resource management](#Re-no-"
"throw-raii)."
msgstr ""

msgid ""
"10680    The `valid()` function could return an `error_indicator` (e.g. a "
"member of an `error_indicator` enumeration)."
msgstr ""

msgid "10681    ##### Example"
msgstr ""

msgid "10682    What if we cannot or do not want to modify the `Gadget` type?"
msgstr ""

msgid "10683    In that case, we must return a pair of values."
msgstr ""

msgid "10684    For example:"
msgstr ""

msgid "10685        std::pair<Gadget, error_indicator> make_gadget(int n)"
msgstr ""

msgid "10686        {"
msgstr ""

msgid "10687            // ..."
msgstr ""

msgid "10688        }"
msgstr ""

msgid "10689        void user()"
msgstr ""

msgid "10690        {"
msgstr ""

msgid "10691            auto r = make_gadget(17);"
msgstr ""

msgid "10692            if (!r.second) {"
msgstr ""

msgid "10693                    // error handling"
msgstr ""

msgid "10694            }"
msgstr ""

msgid "10695            Gadget& g = r.first;"
msgstr ""

msgid "10696            // ..."
msgstr ""

msgid "10697        }"
msgstr ""

msgid "10698    As shown, `std::pair` is a possible return type."
msgstr ""

msgid "10699    Some people prefer a specific type."
msgstr ""

msgid "10700    For example:"
msgstr ""

msgid "10701        Gval make_gadget(int n)"
msgstr ""

msgid "10702        {"
msgstr ""

msgid "10703            // ..."
msgstr ""

msgid "10704        }"
msgstr ""

msgid "10705        void user()"
msgstr ""

msgid "10706        {"
msgstr ""

msgid "10707            auto r = make_gadget(17);"
msgstr ""

msgid "10708            if (!r.err) {"
msgstr ""

msgid "10709                    // error handling"
msgstr ""

msgid "10710            }"
msgstr ""

msgid "10711            Gadget& g = r.val;"
msgstr ""

msgid "10712            // ..."
msgstr ""

msgid "10713        }"
msgstr ""

msgid ""
"10714    One reason to prefer a specific return type is to have names for "
"its members, rather than the somewhat cryptic `first` and `second`"
msgstr ""

msgid "10715    and to avoid confusion with other uses of `std::pair`."
msgstr ""

msgid "10716    ##### Example"
msgstr ""

msgid "10717    In general, you must clean up before an error exit."
msgstr ""

msgid "10718    This can be messy:"
msgstr ""

msgid "10719        std::pair<int, error_indicator> user()"
msgstr ""

msgid "10720        {"
msgstr ""

msgid "10721            Gadget g1 = make_gadget(17);"
msgstr ""

msgid "10722            if (!g1.valid()) {"
msgstr ""

msgid "10723                    return {0, g1_error};"
msgstr ""

msgid "10724            }"
msgstr ""

msgid "10725            Gadget g2 = make_gadget(17);"
msgstr ""

msgid "10726            if (!g2.valid()) {"
msgstr ""

msgid "10727                    cleanup(g1);"
msgstr ""

msgid "10728                    return {0, g2_error};"
msgstr ""

msgid "10729            }"
msgstr ""

msgid "10730            // ..."
msgstr ""

msgid "10731            if (all_foobar(g1, g2)) {"
msgstr ""

msgid "10732                cleanup(g1);"
msgstr ""

msgid "10733                cleanup(g2);"
msgstr ""

msgid "10734                return {0, foobar_error};"
msgstr ""

msgid "10735            // ..."
msgstr ""

msgid "10736            cleanup(g1);"
msgstr ""

msgid "10737            cleanup(g2);"
msgstr ""

msgid "10738            return {res, 0};"
msgstr ""

msgid "10739        }"
msgstr ""

msgid ""
"10740    Simulating RAII can be non-trivial, especially in functions with "
"multiple resources and multiple possible errors."
msgstr ""

msgid ""
"10741    A not uncommon technique is to gather cleanup at the end of the "
"function to avoid repetition:"
msgstr ""

msgid "10742        std::pair<int, error_indicator> user()"
msgstr ""

msgid "10743        {"
msgstr ""

msgid "10744            error_indicator err = 0;"
msgstr ""

msgid "10745            Gadget g1 = make_gadget(17);"
msgstr ""

msgid "10746            if (!g1.valid()) {"
msgstr ""

msgid "10747                    err = g1_error;"
msgstr ""

msgid "10748                    goto exit;"
msgstr ""

msgid "10749            }"
msgstr ""

msgid "10750            Gadget g2 = make_gadget(17);"
msgstr ""

msgid "10751            if (!g2.valid()) {"
msgstr ""

msgid "10752                    err = g2_error;"
msgstr ""

msgid "10753                    goto exit;"
msgstr ""

msgid "10754            }"
msgstr ""

msgid "10755            if (all_foobar(g1, g2)) {"
msgstr ""

msgid "10756                err = foobar_error;"
msgstr ""

msgid "10757                goto exit;"
msgstr ""

msgid "10758            }"
msgstr ""

msgid "10759            // ..."
msgstr ""

msgid "10760        exit:"
msgstr ""

msgid "10761          if (g1.valid()) cleanup(g1);"
msgstr ""

msgid "10762          if (g2.valid()) cleanup(g2);"
msgstr ""

msgid "10763          return {res, err};"
msgstr ""

msgid "10764        }"
msgstr ""

msgid ""
"10765    The larger the function, the more tempting this technique becomes."
msgstr ""

msgid "10766    `finally` can [ease the pain a bit](#Re-finally)."
msgstr ""

msgid ""
"10767    Also, the larger the program becomes the harder it is to apply an "
"error-indicator-based error-handling strategy systematically."
msgstr ""

msgid ""
"10768    We [prefer exception-based error handling](#Re-throw) and recommend "
"[keeping functions short](#Rf-single)."
msgstr ""

msgid "10769    **See also**: [Discussion](#Sd-???)"
msgstr ""

msgid "10770    **See also**: [Returning multiple values](#Rf-out-multi)"
msgstr ""

msgid "10771    ##### Enforcement"
msgstr ""

msgid "10772    Awkward."
msgstr ""

msgid ""
"10773    ### <a name=\"Re-no-throw\"></a>E.28: Avoid error handling based on "
"global state (e.g. `errno`)"
msgstr ""

msgid "10774    ##### Reason"
msgstr ""

msgid ""
"10775    Global state is hard to manage and it is easy to forget to check it."
""
msgstr ""

msgid "10776    When did you last test the return value of `printf()`?"
msgstr ""

msgid "10777    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr ""

msgid "10778    ##### Example, bad"
msgstr ""

msgid "10779        ???"
msgstr ""

msgid "10780    ##### Note"
msgstr ""

msgid ""
"10781    C-style error handling is based on the global variable `errno`, so "
"it is essentially impossible to avoid this style completely."
msgstr ""

msgid "10782    ##### Enforcement"
msgstr ""

msgid "10783    Awkward."
msgstr ""

msgid ""
"10784    ### <a name=\"Re-specifications\"></a>E.30: Don't use exception "
"specifications"
msgstr ""

msgid "10785    ##### Reason"
msgstr ""

msgid ""
"10786    Exception specifications make error handling brittle, impose a run-"
"time cost, and have been removed from the C++ standard."
msgstr ""

msgid "10787    ##### Example"
msgstr ""

msgid "10788        int use(int arg)"
msgstr ""

msgid "10789            throw(X, Y)"
msgstr ""

msgid "10790        {"
msgstr ""

msgid "10791            // ..."
msgstr ""

msgid "10792            auto x = f(arg);"
msgstr ""

msgid "10793            // ..."
msgstr ""

msgid "10794        }"
msgstr ""

msgid ""
"10795    If `f()` throws an exception different from `X` and `Y` the "
"unexpected handler is invoked, which by default terminates."
msgstr ""

msgid ""
"10796    That's OK, but say that we have checked that this cannot happen and "
"`f` is changed to throw a new exception `Z`,"
msgstr ""

msgid ""
"10797    we now have a crash on our hands unless we change `use()` (and re-"
"test everything)."
msgstr ""

msgid ""
"10798    The snag is that `f()` may be in a library we do not control and "
"the new exception is not anything that `use()` can do"
msgstr ""

msgid "10799    anything about or is in any way interested in."
msgstr ""

msgid ""
"10800    We can change `use()` to pass `Z` through, but now `use()`'s "
"callers probably needs to be modified."
msgstr ""

msgid "10801    This quickly becomes unmanageable."
msgstr ""

msgid ""
"10802    Alternatively, we can add a `try`-`catch` to `use()` to map `Z` "
"into an acceptable exception."
msgstr ""

msgid "10803    This too, quickly becomes unmanageable."
msgstr ""

msgid ""
"10804    Note that changes to the set of exceptions often happens at the "
"lowest level of a system"
msgstr ""

msgid ""
"10805    (e.g., because of changes to a network library or some middleware), "
"so changes \"bubble up\" through long call chains."
msgstr ""

msgid ""
"10806    In a large code base, this could mean that nobody could update to a "
"new version of a library until the last user was modified."
msgstr ""

msgid ""
"10807    If `use()` is part of a library, it may not be possible to update "
"it because a change could affect unknown clients."
msgstr ""

msgid ""
"10808    The policy of letting exceptions propagate until they reach a "
"function that potentially can handle it has proven itself over the years."
msgstr ""

msgid "10809    ##### Note"
msgstr ""

msgid ""
"10810    No. This would not be any better had exception specifications been "
"statically enforced."
msgstr ""

msgid "10811    For example, see [Stroustrup94](#Stroustrup94)."
msgstr ""

msgid "10812    ##### Note"
msgstr ""

msgid ""
"10813    If no exception may be thrown, use [`noexcept`](#Re-noexcept) or "
"its equivalent `throw()`."
msgstr ""

msgid "10814    ##### Enforcement"
msgstr ""

msgid "10815    Flag every exception specification."
msgstr ""

msgid ""
"10816    ### <a name=\"Re_catch\"></a>E.31: Properly order your `catch`-"
"clauses"
msgstr ""

msgid "10817    ##### Reason"
msgstr ""

msgid ""
"10818    `catch`-clauses are evaluated in the order they appear and one "
"clause can hide another."
msgstr ""

msgid "10819    ##### Example"
msgstr ""

msgid "10820        void f()"
msgstr ""

msgid "10821        {"
msgstr ""

msgid "10822            // ..."
msgstr ""

msgid "10823            try {"
msgstr ""

msgid "10824                    // ..."
msgstr ""

msgid "10825            }"
msgstr ""

msgid "10826            catch (Base& b) { /* ... */ }"
msgstr ""

msgid "10827            catch (Derived& d) { /* ... */ }"
msgstr ""

msgid "10828            catch (...) { /* ... */ }"
msgstr ""

msgid "10829            catch (std::exception& e){ /* ... */ }"
msgstr ""

msgid "10830        }"
msgstr ""

msgid ""
"10831    If `Derived`is derived from `Base` the `Derived`-handler will never "
"be invoked."
msgstr ""

msgid ""
"10832    The \"catch everything\" handler ensured that the `std::exception`-"
"handler will never be invoked."
msgstr ""

msgid "10833    ##### Enforcement"
msgstr ""

msgid "10834    Flag all \"hiding handlers\"."
msgstr ""

msgid "10835    # <a name=\"S-const\"></a>Con: Constants and immutability"
msgstr ""

msgid "10836    You can't have a race condition on a constant."
msgstr ""

msgid ""
"10837    It is easier to reason about a program when many of the objects "
"cannot change their values."
msgstr ""

msgid ""
"10838    Interfaces that promises \"no change\" of objects passed as "
"arguments greatly increase readability."
msgstr ""

msgid "10839    Constant rule summary:"
msgstr ""

msgid ""
"10840    * [Con.1: By default, make objects immutable](#Rconst-immutable)"
msgstr ""

msgid ""
"10841    * [Con.2: By default, make member functions `const`](#Rconst-fct)"
msgstr ""

msgid ""
"10842    * [Con.3: By default, pass pointers and references to "
"`const`s](#Rconst-ref)"
msgstr ""

msgid ""
"10843    * [Con.4: Use `const` to define objects with values that do not "
"change after construction](#Rconst-const)"
msgstr ""

msgid ""
"10844    * [Con.5: Use `constexpr` for values that can be computed at "
"compile time](#Rconst-constexpr)"
msgstr ""

msgid ""
"10845    ### <a name=\"Rconst-immutable\"></a>Con.1: By default, make "
"objects immutable"
msgstr ""

msgid "10846    ##### Reason"
msgstr ""

msgid ""
"10847    Immutable objects are easier to reason about, so make objects non-"
"`const` only when there is a need to change their value."
msgstr ""

msgid "10848    Prevents accidental or hard-to-notice change of value."
msgstr ""

msgid "10849    ##### Example"
msgstr ""

msgid ""
"10850        for (const int i : c) cout << i << '\\n';    // just reading: "
"const"
msgstr ""

msgid ""
"10851        for (int i : c) cout << i << '\\n';          // BAD: just "
"reading"
msgstr ""

msgid "10852    ##### Exception"
msgstr ""

msgid ""
"10853    Function arguments are rarely mutated, but also rarely declared "
"const."
msgstr ""

msgid ""
"10854    To avoid confusion and lots of false positives, don't enforce this "
"rule for function arguments."
msgstr ""

msgid "10855        void f(const char* const p); // pedantic"
msgstr ""

msgid "10856        void g(const int i);        // pedantic"
msgstr ""

msgid ""
"10857    Note that function parameter is a local variable so changes to it "
"are local."
msgstr ""

msgid "10858    ##### Enforcement"
msgstr ""

msgid ""
"10859    * Flag non-`const` variables that are not modified (except for "
"parameters to avoid many false positives)"
msgstr ""

msgid ""
"10860    ### <a name=\"Rconst-fct\"></a>Con.2: By default, make member "
"functions `const`"
msgstr ""

msgid "10861    ##### Reason"
msgstr ""

msgid ""
"10862    A member function should be marked `const` unless it changes the "
"object's observable state."
msgstr ""

msgid ""
"10863    This gives a more precise statement of design intent, better "
"readability, more errors caught by the compiler, and sometimes more "
"optimization opportunities."
msgstr ""

msgid "10864    ##### Example; bad"
msgstr ""

msgid "10865        class Point {"
msgstr ""

msgid "10866            int x, y;"
msgstr ""

msgid "10867        public:"
msgstr ""

msgid ""
"10868            int getx() { return x; }    // BAD, should be const as it "
"doesn't modify the object's state"
msgstr ""

msgid "10869            // ..."
msgstr ""

msgid "10870        };"
msgstr ""

msgid "10871        void f(const Point& pt) {"
msgstr ""

msgid ""
"10872            int x = pt.getx();          // ERROR, doesn't compile "
"because getx was not marked const"
msgstr ""

msgid "10873        }"
msgstr ""

msgid "10874    ##### Note"
msgstr ""

msgid ""
"10875    It is not inherently bad to pass a pointer or reference to non-"
"`const`,"
msgstr ""

msgid ""
"10876    but that should be done only when the called function is supposed "
"to modify the object."
msgstr ""

msgid ""
"10877    A reader of code must assume that a function that takes a \"plain\" "
"`T*` or `T&` will modify the object referred to."
msgstr ""

msgid ""
"10878    If it doesn't now, it might do so later without forcing "
"recompilation."
msgstr ""

msgid "10879    ##### Note"
msgstr ""

msgid ""
"10880    There are code/libraries that are offer functions that declare "
"a`T*` even though"
msgstr ""

msgid "10881    those function do not modify that `T`."
msgstr ""

msgid "10882    This is a problem for people modernizing code."
msgstr ""

msgid "10883    You can"
msgstr ""

msgid ""
"10884    * update the library to be `const`-correct; preferred long-term "
"solution"
msgstr ""

msgid "10885    * \"cast away `const`\"; [best avoided](#Res-casts-const)"
msgstr ""

msgid "10886    * provide a wrapper function"
msgstr ""

msgid "10887    Example:"
msgstr ""

msgid "10888        void f(int* p);   // old code: f() does not modify `*p`"
msgstr ""

msgid ""
"10889        void f(const int* p) { f(const_cast<int*>(p)); } // wrapper"
msgstr ""

msgid ""
"10890    Note that this wrapper solution is a patch that should be used only "
"when the declaration of `f()` cannot be modified,"
msgstr ""

msgid "10891    e.g. because it is in a library that you cannot modify."
msgstr ""

msgid "10892    ##### Note"
msgstr ""

msgid ""
"10893    A `const` member function can modify the value of an object that is "
"`mutable` or accessed through a pointer member."
msgstr ""

msgid ""
"10894    A common use is to maintain a cache rather than repeatedly do a "
"complicated computation."
msgstr ""

msgid ""
"10895    For example, here is a `Date` that caches (mnemonizes) its string "
"representation to simplify repeated uses:"
msgstr ""

msgid "10896        class Date {"
msgstr ""

msgid "10897        public:"
msgstr ""

msgid "10898            // ..."
msgstr ""

msgid "10899            const string& string_ref() const"
msgstr ""

msgid "10900            {"
msgstr ""

msgid "10901                if (string_val == \"\") compute_string_rep();"
msgstr ""

msgid "10902                return string_val;"
msgstr ""

msgid "10903            }"
msgstr ""

msgid "10904            // ..."
msgstr ""

msgid "10905        private:"
msgstr ""

msgid ""
"10906            void compute_string_rep() const;    // compute string "
"representation and place it in string_val"
msgstr ""

msgid "10907            mutable string string_val;"
msgstr ""

msgid "10908            // ..."
msgstr ""

msgid "10909        };"
msgstr ""

msgid ""
"10910    Another way of saying this is that `const`ness is not transitive."
msgstr ""

msgid ""
"10911    It is possible for a `const` member function to change the value of "
"`mutable` members and the value of objects accessed"
msgstr ""

msgid "10912    through non-`const` pointers."
msgstr ""

msgid ""
"10913    It is the job of the class to ensure such mutation is done only "
"when it makes sense according to the semantics (invariants)"
msgstr ""

msgid "10914    it offers to its users."
msgstr ""

msgid "10915    **See also**: [Pimpl](#Ri-pimpl)"
msgstr ""

msgid "10916    ##### Enforcement"
msgstr ""

msgid ""
"10917    * Flag a member function that is not marked `const`, but that does "
"not perform a non-`const` operation on any member variable."
msgstr ""

msgid ""
"10918    ### <a name=\"Rconst-ref\"></a>Con.3: By default, pass pointers and "
"references to `const`s"
msgstr ""

msgid "10919    ##### Reason"
msgstr ""

msgid "10920     To avoid a called function unexpectedly changing the value."
msgstr ""

msgid ""
"10921     It's far easier to reason about programs when called functions "
"don't modify state."
msgstr ""

msgid "10922    ##### Example"
msgstr ""

msgid ""
"10923        void f(char* p);        // does f modify *p? (assume it does)"
msgstr ""

msgid "10924        void g(const char* p);  // g does not modify *p"
msgstr ""

msgid "10925    ##### Note"
msgstr ""

msgid ""
"10926    It is not inherently bad to pass a pointer or reference to non-"
"`const`,"
msgstr ""

msgid ""
"10927    but that should be done only when the called function is supposed "
"to modify the object."
msgstr ""

msgid "10928    ##### Note"
msgstr ""

msgid "10929    [Do not cast away `const`](#Res-casts-const)."
msgstr ""

msgid "10930    ##### Enforcement"
msgstr ""

msgid ""
"10931    * Flag function that does not modify an object passed by  pointer "
"or reference to non-`const`"
msgstr ""

msgid ""
"10932    * Flag a function that (using a cast) modifies an object passed by "
"pointer or reference to `const`"
msgstr ""

msgid ""
"10933    ### <a name=\"Rconst-const\"></a>Con.4: Use `const` to define "
"objects with values that do not change after construction"
msgstr ""

msgid "10934    ##### Reason"
msgstr ""

msgid "10935     Prevent surprises from unexpectedly changed object values."
msgstr ""

msgid "10936    ##### Example"
msgstr ""

msgid "10937        void f()"
msgstr ""

msgid "10938        {"
msgstr ""

msgid "10939            int x = 7;"
msgstr ""

msgid "10940            const int y = 9;"
msgstr ""

msgid "10941            for (;;) {"
msgstr ""

msgid "10942                // ..."
msgstr ""

msgid "10943            }"
msgstr ""

msgid "10944            // ..."
msgstr ""

msgid "10945        }"
msgstr ""

msgid ""
"10946    As `x` is not `const`, we must assume that it is modified somewhere "
"in the loop."
msgstr ""

msgid "10947    ##### Enforcement"
msgstr ""

msgid "10948    * Flag unmodified non-`const` variables."
msgstr ""

msgid ""
"10949    ### <a name=\"Rconst-constexpr\"></a>Con.5: Use `constexpr` for "
"values that can be computed at compile time"
msgstr ""

msgid "10950    ##### Reason"
msgstr ""

msgid ""
"10951    Better performance, better compile-time checking, guaranteed "
"compile-time evaluation, no possibility of race conditions."
msgstr ""

msgid "10952    ##### Example"
msgstr ""

msgid ""
"10953        double x = f(2);            // possible run-time evaluation"
msgstr ""

msgid ""
"10954        const double y = f(2);      // possible run-time evaluation"
msgstr ""

msgid ""
"10955        constexpr double z = f(2);  // error unless f(2) can be "
"evaluated at compile time"
msgstr ""

msgid "10956    ##### Note"
msgstr ""

msgid "10957    See F.4."
msgstr ""

msgid "10958    ##### Enforcement"
msgstr ""

msgid ""
"10959    * Flag `const` definitions with constant expression initializers."
msgstr ""

msgid ""
"10960    # <a name=\"S-templates\"></a>T: Templates and generic programming"
msgstr ""

msgid ""
"10961    Generic programming is programming using types and algorithms "
"parameterized by types, values, and algorithms."
msgstr ""

msgid ""
"10962    In C++, generic programming is supported by the `template` language "
"mechanisms."
msgstr ""

msgid ""
"10963    Arguments to generic functions are characterized by sets of "
"requirements on the argument types and values involved."
msgstr ""

msgid ""
"10964    In C++, these requirements are expressed by compile-time predicates "
"called concepts."
msgstr ""

msgid ""
"10965    Templates can also be used for meta-programming; that is, programs "
"that compose code at compile time."
msgstr ""

msgid ""
"10966    A central notion in generic programming is \"concepts\"; that is, "
"requirements on template arguments presented as compile-time predicates."
msgstr ""

msgid ""
"10967    \"Concepts\" are defined in an ISO Technical specification: "
"[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553."
"pdf)."
msgstr ""

msgid ""
"10968    A draft of a set of standard-library concepts can be found in "
"another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/"
"2016/n4569.pdf)"
msgstr ""

msgid "10969    Concepts are supported in GCC 6.1 and later."
msgstr ""

msgid ""
"10970    Consequently, we comment out uses of concepts in examples; that is, "
"we use them as formalized comments only."
msgstr ""

msgid "10971    If you use GCC 6.1 or later, you can uncomment them."
msgstr ""

msgid "10972    Template use rule summary:"
msgstr ""

msgid ""
"10973    * [T.1: Use templates to raise the level of abstraction of "
"code](#Rt-raise)"
msgstr ""

msgid ""
"10974    * [T.2: Use templates to express algorithms that apply to many "
"argument types](#Rt-algo)"
msgstr ""

msgid ""
"10975    * [T.3: Use templates to express containers and ranges](#Rt-cont)"
msgstr ""

msgid ""
"10976    * [T.4: Use templates to express syntax tree manipulation](#Rt-"
"expr)"
msgstr ""

msgid ""
"10977    * [T.5: Combine generic and OO techniques to amplify their "
"strengths, not their costs](#Rt-generic-oo)"
msgstr ""

msgid "10978    Concept use rule summary:"
msgstr ""

msgid ""
"10979    * [T.10: Specify concepts for all template arguments](#Rt-concepts)"
msgstr ""

msgid ""
"10980    * [T.11: Whenever possible use standard concepts](#Rt-std-concepts)"
msgstr ""

msgid ""
"10981    * [T.12: Prefer concept names over `auto` for local variables](#Rt-"
"auto)"
msgstr ""

msgid ""
"10982    * [T.13: Prefer the shorthand notation for simple, single-type "
"argument concepts](#Rt-shorthand)"
msgstr ""

msgid "10983    * ???"
msgstr ""

msgid "10984    Concept definition rule summary:"
msgstr ""

msgid ""
"10985    * [T.20: Avoid \"concepts\" without meaningful semantics](#Rt-low)"
msgstr ""

msgid ""
"10986    * [T.21: Require a complete set of operations for a concept](#Rt-"
"complete)"
msgstr ""

msgid "10987    * [T.22: Specify axioms for concepts](#Rt-axiom)"
msgstr ""

msgid ""
"10988    * [T.23: Differentiate a refined concept from its more general case "
"by adding new use patterns](#Rt-refine)"
msgstr ""

msgid ""
"10989    * [T.24: Use tag classes or traits to differentiate concepts that "
"differ only in semantics](#Rt-tag)"
msgstr ""

msgid "10990    * [T.25: Avoid complementary constraints](#Rt-not)"
msgstr ""

msgid ""
"10991    * [T.26: Prefer to define concepts in terms of use-patterns rather "
"than simple syntax](#Rt-use)"
msgstr ""

msgid ""
"10992    * [T.30: Use concept negation (`!C<T>`) sparingly to express a "
"minor difference](#Rt-not)"
msgstr ""

msgid ""
"10993    * [T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to "
"express alternatives](#Rt-or)"
msgstr ""

msgid "10994    * ???"
msgstr ""

msgid "10995    Template interface rule summary:"
msgstr ""

msgid ""
"10996    * [T.40: Use function objects to pass operations to algorithms](#Rt-"
"fo)"
msgstr ""

msgid ""
"10997    * [T.41: Require only essential properties in a template's "
"concepts](#Rt-essential)"
msgstr ""

msgid ""
"10998    * [T.42: Use template aliases to simplify notation and hide "
"implementation details](#Rt-alias)"
msgstr ""

msgid ""
"10999    * [T.43: Prefer `using` over `typedef` for defining aliases](#Rt-"
"using)"
msgstr ""

msgid ""
"11000    * [T.44: Use function templates to deduce class template argument "
"types (where feasible)](#Rt-deduce)"
msgstr ""

msgid ""
"11001    * [T.46: Require template arguments to be at least `Regular` or "
"`SemiRegular`](#Rt-regular)"
msgstr ""

msgid ""
"11002    * [T.47: Avoid highly visible unconstrained templates with common "
"names](#Rt-visible)"
msgstr ""

msgid ""
"11003    * [T.48: If your compiler does not support concepts, fake them with "
"`enable_if`](#Rt-concept-def)"
msgstr ""

msgid "11004    * [T.49: Where possible, avoid type-erasure](#Rt-erasure)"
msgstr ""

msgid "11005    Template definition rule summary:"
msgstr ""

msgid ""
"11006    * [T.60: Minimize a template's context dependencies](#Rt-depend)"
msgstr ""

msgid "11007    * [T.61: Do not over-parameterize members (SCARY)](#Rt-scary)"
msgstr ""

msgid ""
"11008    * [T.62: Place non-dependent class template members in a non-"
"templated base class](#Rt-nondependent)"
msgstr ""

msgid ""
"11009    * [T.64: Use specialization to provide alternative implementations "
"of class templates](#Rt-specialization)"
msgstr ""

msgid ""
"11010    * [T.65: Use tag dispatch to provide alternative implementations of "
"functions](#Rt-tag-dispatch)"
msgstr ""

msgid ""
"11011    * [T.67: Use specialization to provide alternative implementations "
"for irregular types](#Rt-specialization2)"
msgstr ""

msgid ""
"11012    * [T.68: Use `{}` rather than `()` within templates to avoid "
"ambiguities](#Rt-cast)"
msgstr ""

msgid ""
"11013    * [T.69: Inside a template, don't make an unqualified nonmember "
"function call unless you intend it to be a customization point](#Rt-"
"customization)"
msgstr ""

msgid "11014    Template and hierarchy rule summary:"
msgstr ""

msgid ""
"11015    * [T.80: Do not naively templatize a class hierarchy](#Rt-hier)"
msgstr ""

msgid ""
"11016    * [T.81: Do not mix hierarchies and arrays](#Rt-array) // ??? "
"somewhere in \"hierarchies\""
msgstr ""

msgid ""
"11017    * [T.82: Linearize a hierarchy when virtual functions are "
"undesirable](#Rt-linear)"
msgstr ""

msgid ""
"11018    * [T.83: Do not declare a member function template virtual](#Rt-"
"virtual)"
msgstr ""

msgid ""
"11019    * [T.84: Use a non-template core implementation to provide an ABI-"
"stable interface](#Rt-abi)"
msgstr ""

msgid "11020    * [T.??: ????](#Rt-???)"
msgstr ""

msgid "11021    Variadic template rule summary:"
msgstr ""

msgid ""
"11022    * [T.100: Use variadic templates when you need a function that "
"takes a variable number of arguments of a variety of types](#Rt-variadic)"
msgstr ""

msgid ""
"11023    * [T.101: ??? How to pass arguments to a variadic template ???](#Rt-"
"variadic-pass)"
msgstr ""

msgid ""
"11024    * [T.102: ??? How to process arguments to a variadic template "
"???](#Rt-variadic-process)"
msgstr ""

msgid ""
"11025    * [T.103: Don't use variadic templates for homogeneous argument "
"lists](#Rt-variadic-not)"
msgstr ""

msgid "11026    * [T.??: ????](#Rt-???)"
msgstr ""

msgid "11027    Metaprogramming rule summary:"
msgstr ""

msgid ""
"11028    * [T.120: Use template metaprogramming only when you really need "
"to](#Rt-metameta)"
msgstr ""

msgid ""
"11029    * [T.121: Use template metaprogramming primarily to emulate "
"concepts](#Rt-emulate)"
msgstr ""

msgid ""
"11030    * [T.122: Use templates (usually template aliases) to compute types "
"at compile time](#Rt-tmp)"
msgstr ""

msgid ""
"11031    * [T.123: Use `constexpr` functions to compute values at compile "
"time](#Rt-fct)"
msgstr ""

msgid ""
"11032    * [T.124: Prefer to use standard-library TMP facilities](#Rt-std-"
"tmp)"
msgstr ""

msgid ""
"11033    * [T.125: If you need to go beyond the standard-library TMP "
"facilities, use an existing library](#Rt-lib)"
msgstr ""

msgid "11034    * [T.??: ????](#Rt-???)"
msgstr ""

msgid "11035    Other template rules summary:"
msgstr ""

msgid ""
"11036    * [T.140: Name all operations with potential for reuse](#Rt-name)"
msgstr ""

msgid ""
"11037    * [T.141: Use an unnamed lambda if you need a simple function "
"object in one place only](#Rt-lambda)"
msgstr ""

msgid ""
"11038    * [T.142: Use template variables to simplify notation](#Rt-var)"
msgstr ""

msgid ""
"11039    * [T.143: Don't write unintentionally nongeneric code](#Rt-"
"nongeneric)"
msgstr ""

msgid ""
"11040    * [T.144: Don't specialize function templates](#Rt-specialize-"
"function)"
msgstr ""

msgid ""
"11041    * [T.150: Check that a class matches a concept using "
"`static_assert`](#Rt-check-class)"
msgstr ""

msgid "11042    * [T.??: ????](#Rt-???)"
msgstr ""

msgid "11043    ## <a name=\"SS-GP\"></a>T.gp: Generic programming"
msgstr ""

msgid ""
"11044    Generic programming is programming using types and algorithms "
"parameterized by types, values, and algorithms."
msgstr ""

msgid ""
"11045    ### <a name=\"Rt-raise\"></a>T.1: Use templates to raise the level "
"of abstraction of code"
msgstr ""

msgid "11046    ##### Reason"
msgstr ""

msgid ""
"11047    Generality. Reuse. Efficiency. Encourages consistent definition of "
"user types."
msgstr ""

msgid "11048    ##### Example, bad"
msgstr ""

msgid ""
"11049    Conceptually, the following requirements are wrong because what we "
"want of `T` is more than just the very low-level concepts of \"can be "
"incremented\" or \"can be added\":"
msgstr ""

msgid "11050        template<typename T>"
msgstr ""

msgid "11051            // requires Incrementable<T>"
msgstr ""

msgid "11052        T sum1(vector<T>& v, T s)"
msgstr ""

msgid "11053        {"
msgstr ""

msgid "11054            for (auto x : v) s += x;"
msgstr ""

msgid "11055            return s;"
msgstr ""

msgid "11056        }"
msgstr ""

msgid "11057        template<typename T>"
msgstr ""

msgid "11058            // requires Simple_number<T>"
msgstr ""

msgid "11059        T sum2(vector<T>& v, T s)"
msgstr ""

msgid "11060        {"
msgstr ""

msgid "11061            for (auto x : v) s = s + x;"
msgstr ""

msgid "11062            return s;"
msgstr ""

msgid "11063        }"
msgstr ""

msgid ""
"11064    Assuming that `Incrementable` does not support `+` and "
"`Simple_number` does not support `+=`, we have overconstrained implementers "
"of `sum1` and `sum2`."
msgstr ""

msgid ""
"11065    And, in this case, missed an opportunity for a generalization."
msgstr ""

msgid "11066    ##### Example"
msgstr ""

msgid "11067        template<typename T>"
msgstr ""

msgid "11068            // requires Arithmetic<T>"
msgstr ""

msgid "11069        T sum(vector<T>& v, T s)"
msgstr ""

msgid "11070        {"
msgstr ""

msgid "11071            for (auto x : v) s += x;"
msgstr ""

msgid "11072            return s;"
msgstr ""

msgid "11073        }"
msgstr ""

msgid ""
"11074    Assuming that `Arithmetic` requires both `+` and `+=`, we have "
"constrained the user of `sum` to provide a complete arithmetic type."
msgstr ""

msgid ""
"11075    That is not a minimal requirement, but it gives the implementer of "
"algorithms much needed freedom and ensures that any `Arithmetic` type"
msgstr ""

msgid "11076    can be used for a wide variety of algorithms."
msgstr ""

msgid ""
"11077    For additional generality and reusability, we could also use a more "
"general `Container` or `Range` concept instead of committing to only one "
"container, `vector`."
msgstr ""

msgid "11078    ##### Note"
msgstr ""

msgid ""
"11079    If we define a template to require exactly the operations required "
"for a single implementation of a single algorithm"
msgstr ""

msgid ""
"11080    (e.g., requiring just `+=` rather than also `=` and `+`) and only "
"those, we have overconstrained maintainers."
msgstr ""

msgid ""
"11081    We aim to minimize requirements on template arguments, but the "
"absolutely minimal requirements of an implementation is rarely a meaningful "
"concept."
msgstr ""

msgid "11082    ##### Note"
msgstr ""

msgid ""
"11083    Templates can be used to express essentially everything (they are "
"Turing complete), but the aim of generic programming (as expressed using "
"templates)"
msgstr ""

msgid ""
"11084    is to efficiently generalize operations/algorithms over a set of "
"types with similar semantic properties."
msgstr ""

msgid "11085    ##### Note"
msgstr ""

msgid "11086    The `requires` in the comments are uses of `concepts`."
msgstr ""

msgid ""
"11087    \"Concepts\" are defined in an ISO Technical specification: "
"[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553."
"pdf)."
msgstr ""

msgid "11088    Concepts are supported in GCC 6.1 and later."
msgstr ""

msgid ""
"11089    Consequently, we comment out uses of concepts in examples; that is, "
"we use them as formalized comments only."
msgstr ""

msgid "11090    If you use GCC 6.1 or later, you can uncomment them."
msgstr ""

msgid "11091    ##### Enforcement"
msgstr ""

msgid ""
"11092    * Flag algorithms with \"overly simple\" requirements, such as "
"direct use of specific operators without a concept."
msgstr ""

msgid ""
"11093    * Do not flag the definition of the \"overly simple\" concepts "
"themselves; they may simply be building blocks for more useful concepts."
msgstr ""

msgid ""
"11094    ### <a name=\"Rt-algo\"></a>T.2: Use templates to express "
"algorithms that apply to many argument types"
msgstr ""

msgid "11095    ##### Reason"
msgstr ""

msgid ""
"11096    Generality. Minimizing the amount of source code. Interoperability. "
"Reuse."
msgstr ""

msgid "11097    ##### Example"
msgstr ""

msgid ""
"11098    That's the foundation of the STL. A single `find` algorithm easily "
"works with any kind of input range:"
msgstr ""

msgid "11099        template<typename Iter, typename Val>"
msgstr ""

msgid "11100            // requires Input_iterator<Iter>"
msgstr ""

msgid ""
"11101            //       && Equality_comparable<Value_type<Iter>, Val>"
msgstr ""

msgid "11102        Iter find(Iter b, Iter e, Val v)"
msgstr ""

msgid "11103        {"
msgstr ""

msgid "11104            // ..."
msgstr ""

msgid "11105        }"
msgstr ""

msgid "11106    ##### Note"
msgstr ""

msgid ""
"11107    Don't use a template unless you have a realistic need for more than "
"one template argument type."
msgstr ""

msgid "11108    Don't overabstract."
msgstr ""

msgid "11109    ##### Enforcement"
msgstr ""

msgid "11110    ??? tough, probably needs a human"
msgstr ""

msgid ""
"11111    ### <a name=\"Rt-cont\"></a>T.3: Use templates to express "
"containers and ranges"
msgstr ""

msgid "11112    ##### Reason"
msgstr ""

msgid ""
"11113    Containers need an element type, and expressing that as a template "
"argument is general, reusable, and type safe."
msgstr ""

msgid ""
"11114    It also avoids brittle or inefficient workarounds. Convention: "
"That's the way the STL does it."
msgstr ""

msgid "11115    ##### Example"
msgstr ""

msgid "11116        template<typename T>"
msgstr ""

msgid "11117            // requires Regular<T>"
msgstr ""

msgid "11118        class Vector {"
msgstr ""

msgid "11119            // ..."
msgstr ""

msgid "11120            T* elem;   // points to sz Ts"
msgstr ""

msgid "11121            int sz;"
msgstr ""

msgid "11122        };"
msgstr ""

msgid "11123        Vector<double> v(10);"
msgstr ""

msgid "11124        v[7] = 9.9;"
msgstr ""

msgid "11125    ##### Example, bad"
msgstr ""

msgid "11126        class Container {"
msgstr ""

msgid "11127            // ..."
msgstr ""

msgid "11128            void* elem;   // points to size elements of some type"
msgstr ""

msgid "11129            int sz;"
msgstr ""

msgid "11130        };"
msgstr ""

msgid "11131        Container c(10, sizeof(double));"
msgstr ""

msgid "11132        ((double*) c.elem)[7] = 9.9;"
msgstr ""

msgid ""
"11133    This doesn't directly express the intent of the programmer and "
"hides the structure of the program from the type system and optimizer."
msgstr ""

msgid ""
"11134    Hiding the `void*` behind macros simply obscures the problems and "
"introduces new opportunities for confusion."
msgstr ""

msgid ""
"11135    **Exceptions**: If you need an ABI-stable interface, you might have "
"to provide a base implementation and express the (type-safe) template in "
"terms of that."
msgstr ""

msgid "11136    See [Stable base](#Rt-abi)."
msgstr ""

msgid "11137    ##### Enforcement"
msgstr ""

msgid ""
"11138    * Flag uses of `void*`s and casts outside low-level implementation "
"code"
msgstr ""

msgid ""
"11139    ### <a name=\"Rt-expr\"></a>T.4: Use templates to express syntax "
"tree manipulation"
msgstr ""

msgid "11140    ##### Reason"
msgstr ""

msgid "11141     ???"
msgstr ""

msgid "11142    ##### Example"
msgstr ""

msgid "11143        ???"
msgstr ""

msgid "11144    **Exceptions**: ???"
msgstr ""

msgid ""
"11145    ### <a name=\"Rt-generic-oo\"></a>T.5: Combine generic and OO "
"techniques to amplify their strengths, not their costs"
msgstr ""

msgid "11146    ##### Reason"
msgstr ""

msgid "11147    Generic and OO techniques are complementary."
msgstr ""

msgid "11148    ##### Example"
msgstr ""

msgid ""
"11149    Static helps dynamic: Use static polymorphism to implement "
"dynamically polymorphic interfaces."
msgstr ""

msgid "11150        class Command {"
msgstr ""

msgid "11151            // pure virtual functions"
msgstr ""

msgid "11152        };"
msgstr ""

msgid "11153        // implementations"
msgstr ""

msgid "11154        template</*...*/>"
msgstr ""

msgid "11155        class ConcreteCommand : public Command {"
msgstr ""

msgid "11156            // implement virtuals"
msgstr ""

msgid "11157        };"
msgstr ""

msgid "11158    ##### Example"
msgstr ""

msgid ""
"11159    Dynamic helps static: Offer a generic, comfortable, statically "
"bound interface, but internally dispatch dynamically, so you offer a uniform "
"object layout."
msgstr ""

msgid ""
"11160    Examples include type erasure as with `std::shared_ptr`'s deleter "
"(but [don't overuse type erasure](#Rt-erasure))."
msgstr ""

msgid "11161    ##### Note"
msgstr ""

msgid ""
"11162    In a class template, nonvirtual functions are only instantiated if "
"they're used -- but virtual functions are instantiated every time."
msgstr ""

msgid ""
"11163    This can bloat code size, and may overconstrain a generic type by "
"instantiating functionality that is never needed."
msgstr ""

msgid ""
"11164    Avoid this, even though the standard-library facets made this "
"mistake."
msgstr ""

msgid "11165    ##### See also"
msgstr ""

msgid "11166    * ref ???"
msgstr ""

msgid "11167    * ref ???"
msgstr ""

msgid "11168    * ref ???"
msgstr ""

msgid "11169    ##### Enforcement"
msgstr ""

msgid "11170    See the reference to more specific rules."
msgstr ""

msgid "11171    ## <a name=\"SS-concepts\"></a>T.concepts: Concept rules"
msgstr ""

msgid ""
"11172    Concepts is a facility for specifying requirements for template "
"arguments."
msgstr ""

msgid ""
"11173    It is an [ISO technical specification](#Ref-conceptsTS), but "
"currently supported only by GCC."
msgstr ""

msgid ""
"11174    Concepts are, however, crucial in the thinking about generic "
"programming and the basis of much work on future C++ libraries"
msgstr ""

msgid "11175    (standard and other)."
msgstr ""

msgid "11176    This section assumes concept support"
msgstr ""

msgid "11177    Concept use rule summary:"
msgstr ""

msgid ""
"11178    * [T.10: Specify concepts for all template arguments](#Rt-concepts)"
msgstr ""

msgid ""
"11179    * [T.11: Whenever possible use standard concepts](#Rt-std-concepts)"
msgstr ""

msgid "11180    * [T.12: Prefer concept names over `auto`](#Rt-auto)"
msgstr ""

msgid ""
"11181    * [T.13: Prefer the shorthand notation for simple, single-type "
"argument concepts](#Rt-shorthand)"
msgstr ""

msgid "11182    * ???"
msgstr ""

msgid "11183    Concept definition rule summary:"
msgstr ""

msgid ""
"11184    * [T.20: Avoid \"concepts\" without meaningful semantics](#Rt-low)"
msgstr ""

msgid ""
"11185    * [T.21: Require a complete set of operations for a concept](#Rt-"
"complete)"
msgstr ""

msgid "11186    * [T.22: Specify axioms for concepts](#Rt-axiom)"
msgstr ""

msgid ""
"11187    * [T.23: Differentiate a refined concept from its more general case "
"by adding new use patterns](#Rt-refine)"
msgstr ""

msgid ""
"11188    * [T.24: Use tag classes or traits to differentiate concepts that "
"differ only in semantics](#Rt-tag)"
msgstr ""

msgid "11189    * [T.25: Avoid complimentary constraints](#Rt-not)"
msgstr ""

msgid ""
"11190    * [T.26: Prefer to define concepts in terms of use-patterns rather "
"than simple syntax](#Rt-use)"
msgstr ""

msgid "11191    * ???"
msgstr ""

msgid "11192    ## <a name=\"SS-concept-use\"></a>T.con-use: Concept use"
msgstr ""

msgid ""
"11193    ### <a name=\"Rt-concepts\"></a>T.10: Specify concepts for all "
"template arguments"
msgstr ""

msgid "11194    ##### Reason"
msgstr ""

msgid "11195    Correctness and readability."
msgstr ""

msgid ""
"11196    The assumed meaning (syntax and semantics) of a template argument "
"is fundamental to the interface of a template."
msgstr ""

msgid ""
"11197    A concept dramatically improves documentation and error handling "
"for the template."
msgstr ""

msgid ""
"11198    Specifying concepts for template arguments is a powerful design "
"tool."
msgstr ""

msgid "11199    ##### Example"
msgstr ""

msgid "11200        template<typename Iter, typename Val>"
msgstr ""

msgid "11201        //    requires Input_iterator<Iter>"
msgstr ""

msgid ""
"11202        //             && Equality_comparable<Value_type<Iter>, Val>"
msgstr ""

msgid "11203        Iter find(Iter b, Iter e, Val v)"
msgstr ""

msgid "11204        {"
msgstr ""

msgid "11205            // ..."
msgstr ""

msgid "11206        }"
msgstr ""

msgid "11207    or equivalently and more succinctly:"
msgstr ""

msgid "11208        template<Input_iterator Iter, typename Val>"
msgstr ""

msgid "11209        //    requires Equality_comparable<Value_type<Iter>, Val>"
msgstr ""

msgid "11210        Iter find(Iter b, Iter e, Val v)"
msgstr ""

msgid "11211        {"
msgstr ""

msgid "11212            // ..."
msgstr ""

msgid "11213        }"
msgstr ""

msgid "11214    ##### Note"
msgstr ""

msgid ""
"11215    \"Concepts\" are defined in an ISO Technical specification: "
"[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553."
"pdf)."
msgstr ""

msgid ""
"11216    A draft of a set of standard-library concepts can be found in "
"another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/"
"2016/n4569.pdf)"
msgstr ""

msgid "11217    Concepts are supported in GCC 6.1 and later."
msgstr ""

msgid ""
"11218    Consequently, we comment out uses of concepts in examples; that is, "
"we use them as formalized comments only."
msgstr ""

msgid "11219    If you use GCC 6.1 or later, you can uncomment them:"
msgstr ""

msgid "11220        template<typename Iter, typename Val>"
msgstr ""

msgid "11221            requires Input_iterator<Iter>"
msgstr ""

msgid "11222                   && Equality_comparable<Value_type<Iter>, Val>"
msgstr ""

msgid "11223        Iter find(Iter b, Iter e, Val v)"
msgstr ""

msgid "11224        {"
msgstr ""

msgid "11225            // ..."
msgstr ""

msgid "11226        }"
msgstr ""

msgid "11227    ##### Note"
msgstr ""

msgid ""
"11228    Plain `typename` (or `auto`) is the least constraining concept."
msgstr ""

msgid ""
"11229    It should be used only rarely when nothing more than \"it's a "
"type\" can be assumed."
msgstr ""

msgid ""
"11230    This is typically only needed when (as part of template "
"metaprogramming code) we manipulate pure expression trees, postponing type "
"checking."
msgstr ""

msgid "11231    **References**: TC++PL4, Palo Alto TR, Sutton"
msgstr ""

msgid "11232    ##### Enforcement"
msgstr ""

msgid "11233    Flag template type arguments without concepts"
msgstr ""

msgid ""
"11234    ### <a name=\"Rt-std-concepts\"></a>T.11: Whenever possible use "
"standard concepts"
msgstr ""

msgid "11235    ##### Reason"
msgstr ""

msgid ""
"11236     \"Standard\" concepts (as provided by the [GSL](#S-GSL) and the "
"[Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569."
"pdf), and hopefully soon the ISO standard itself)"
msgstr ""

msgid ""
"11237    saves us the work of thinking up our own concepts, are better "
"thought out than we can manage to do in a hurry, and improves "
"interoperability."
msgstr ""

msgid "11238    ##### Note"
msgstr ""

msgid ""
"11239    Unless you are creating a new generic library, most of the concepts "
"you need will already be defined by the standard library."
msgstr ""

msgid "11240    ##### Example (using TS concepts)"
msgstr ""

msgid "11241        template<typename T>"
msgstr ""

msgid "11242            // don't define this: Sortable is in the GSL"
msgstr ""

msgid ""
"11243        concept Ordered_container = Sequence<T> && "
"Random_access<Iterator<T>> && Ordered<Value_type<T>>;"
msgstr ""

msgid "11244        void sort(Ordered_container& s);"
msgstr ""

msgid ""
"11245    This `Ordered_container` is quite plausible, but it is very similar "
"to the `Sortable` concept in the GSL (and the Range TS)."
msgstr ""

msgid ""
"11246    Is it better? Is it right? Does it accurately reflect the "
"standard's requirements for `sort`?"
msgstr ""

msgid "11247    It is better and simpler just to use `Sortable`:"
msgstr ""

msgid "11248        void sort(Sortable& s);   // better"
msgstr ""

msgid "11249    ##### Note"
msgstr ""

msgid ""
"11250    The set of \"standard\" concepts is evolving as we approach an ISO "
"standard including concepts."
msgstr ""

msgid "11251    ##### Note"
msgstr ""

msgid "11252    Designing a useful concept is challenging."
msgstr ""

msgid "11253    ##### Enforcement"
msgstr ""

msgid "11254    Hard."
msgstr ""

msgid ""
"11255    * Look for unconstrained arguments, templates that use \"unusual\"/"
"non-standard concepts, templates that use \"homebrew\" concepts without "
"axioms."
msgstr ""

msgid ""
"11256    * Develop a concept-discovery tool (e.g., see [an early "
"experiment](http://www.stroustrup.com/sle2010_webversion.pdf))."
msgstr ""

msgid ""
"11257    ### <a name=\"Rt-auto\"></a>T.12: Prefer concept names over `auto` "
"for local variables"
msgstr ""

msgid "11258    ##### Reason"
msgstr ""

msgid ""
"11259     `auto` is the weakest concept. Concept names convey more meaning "
"than just `auto`."
msgstr ""

msgid "11260    ##### Example (using TS concepts)"
msgstr ""

msgid "11261        vector<string> v{ \"abc\", \"xyz\" };"
msgstr ""

msgid "11262        auto& x = v.front();     // bad"
msgstr ""

msgid ""
"11263        String& s = v.front();   // good (String is a GSL concept)"
msgstr ""

msgid "11264    ##### Enforcement"
msgstr ""

msgid "11265    * ???"
msgstr ""

msgid ""
"11266    ### <a name=\"Rt-shorthand\"></a>T.13: Prefer the shorthand "
"notation for simple, single-type argument concepts"
msgstr ""

msgid "11267    ##### Reason"
msgstr ""

msgid "11268    Readability. Direct expression of an idea."
msgstr ""

msgid "11269    ##### Example (using TS concepts)"
msgstr ""

msgid "11270    To say \"`T` is `Sortable`\":"
msgstr ""

msgid ""
"11271        template<typename T>       // Correct but verbose: \"The "
"parameter is"
msgstr ""

msgid ""
"11272        //    requires Sortable<T>   // of type T which is the name of "
"a type"
msgstr ""

msgid "11273        void sort(T&);             // that is Sortable\""
msgstr ""

msgid ""
"11274        template<Sortable T>       // Better (assuming support for "
"concepts): \"The parameter is of type T"
msgstr ""

msgid "11275        void sort(T&);             // which is Sortable\""
msgstr ""

msgid ""
"11276        void sort(Sortable&);      // Best (assuming support for "
"concepts): \"The parameter is Sortable\""
msgstr ""

msgid ""
"11277    The shorter versions better match the way we speak. Note that many "
"templates don't need to use the `template` keyword."
msgstr ""

msgid "11278    ##### Note"
msgstr ""

msgid ""
"11279    \"Concepts\" are defined in an ISO Technical specification: "
"[concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553."
"pdf)."
msgstr ""

msgid ""
"11280    A draft of a set of standard-library concepts can be found in "
"another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/"
"2016/n4569.pdf)"
msgstr ""

msgid "11281    Concepts are supported in GCC 6.1 and later."
msgstr ""

msgid ""
"11282    Consequently, we comment out uses of concepts in examples; that is, "
"we use them as formalized comments only."
msgstr ""

msgid ""
"11283    If you use a compiler that supports concepts (e.g., GCC 6.1 or "
"later), you can remove the `//`."
msgstr ""

msgid "11284    ##### Enforcement"
msgstr ""

msgid ""
"11285    * Not feasible in the short term when people convert from the "
"`<typename T>` and `<class T`> notation."
msgstr ""

msgid ""
"11286    * Later, flag declarations that first introduces a typename and "
"then constrains it with a simple, single-type-argument concept."
msgstr ""

msgid ""
"11287    ## <a name=\"SS-concepts-def\"></a>T.concepts.def: Concept "
"definition rules"
msgstr ""

msgid "11288    Defining good concepts is non-trivial."
msgstr ""

msgid ""
"11289    Concepts are meant to represent fundamental concepts in an "
"application domain (hence the name \"concepts\")."
msgstr ""

msgid ""
"11290    Similarly throwing together a set of syntactic constraints to be "
"used for a the arguments for a single class or algorithm is not what "
"concepts were designed for"
msgstr ""

msgid "11291    and will not give the full benefits of the mechanism."
msgstr ""

msgid ""
"11292    Obviously, defining concepts will be most useful for code that can "
"use an implementation (e.g., GCC 6.1 or later),"
msgstr ""

msgid ""
"11293    but defining concepts is in itself a useful design technique and "
"help catch conceptual errors and clean up the concepts (sic!) of an "
"implementation."
msgstr ""

msgid ""
"11294    ### <a name=\"Rt-low\"></a>T.20: Avoid \"concepts\" without "
"meaningful semantics"
msgstr ""

msgid "11295    ##### Reason"
msgstr ""

msgid ""
"11296    Concepts are meant to express semantic notions, such as \"a "
"number\", \"a range\" of elements, and \"totally ordered.\""
msgstr ""

msgid ""
"11297    Simple constraints, such as \"has a `+` operator\" and \"has a `>` "
"operator\" cannot be meaningfully specified in isolation"
msgstr ""

msgid ""
"11298    and should be used only as building blocks for meaningful concepts, "
"rather than in user code."
msgstr ""

msgid "11299    ##### Example, bad (using TS concepts)"
msgstr ""

msgid "11300        template<typename T>"
msgstr ""

msgid "11301        concept Addable = has_plus<T>;    // bad; insufficient"
msgstr ""

msgid ""
"11302        template<Addable N> auto algo(const N& a, const N& b) // use "
"two numbers"
msgstr ""

msgid "11303        {"
msgstr ""

msgid "11304            // ..."
msgstr ""

msgid "11305            return a + b;"
msgstr ""

msgid "11306        }"
msgstr ""

msgid "11307        int x = 7;"
msgstr ""

msgid "11308        int y = 9;"
msgstr ""

msgid "11309        auto z = algo(x, y);   // z = 16"
msgstr ""

msgid "11310        string xx = \"7\";"
msgstr ""

msgid "11311        string yy = \"9\";"
msgstr ""

msgid "11312        auto zz = algo(xx, yy);   // zz = \"79\""
msgstr ""

msgid ""
"11313    Maybe the concatenation was expected. More likely, it was an "
"accident. Defining minus equivalently would give dramatically different sets "
"of accepted types."
msgstr ""

msgid ""
"11314    This `Addable` violates the mathematical rule that addition is "
"supposed to be commutative: `a+b == b+a`."
msgstr ""

msgid "11315    ##### Note"
msgstr ""

msgid ""
"11316    The ability to specify a meaningful semantics is a defining "
"characteristic of a true concept, as opposed to a syntactic constraint."
msgstr ""

msgid "11317    ##### Example (using TS concepts)"
msgstr ""

msgid "11318        template<typename T>"
msgstr ""

msgid ""
"11319        // The operators +, -, *, and / for a number are assumed to "
"follow the usual mathematical rules"
msgstr ""

msgid "11320        concept Number = has_plus<T>"
msgstr ""

msgid "11321                         && has_minus<T>"
msgstr ""

msgid "11322                         && has_multiply<T>"
msgstr ""

msgid "11323                         && has_divide<T>;"
msgstr ""

msgid "11324        template<Number N> auto algo(const N& a, const N& b)"
msgstr ""

msgid "11325        {"
msgstr ""

msgid "11326            // ..."
msgstr ""

msgid "11327            return a + b;"
msgstr ""

msgid "11328        }"
msgstr ""

msgid "11329        int x = 7;"
msgstr ""

msgid "11330        int y = 9;"
msgstr ""

msgid "11331        auto z = algo(x, y);   // z = 16"
msgstr ""

msgid "11332        string xx = \"7\";"
msgstr ""

msgid "11333        string yy = \"9\";"
msgstr ""

msgid ""
"11334        auto zz = algo(xx, yy);   // error: string is not a Number"
msgstr ""

msgid "11335    ##### Note"
msgstr ""

msgid ""
"11336    Concepts with multiple operations have far lower chance of "
"accidentally matching a type than a single-operation concept."
msgstr ""

msgid "11337    ##### Enforcement"
msgstr ""

msgid ""
"11338    * Flag single-operation `concepts` when used outside the definition "
"of other `concepts`."
msgstr ""

msgid ""
"11339    * Flag uses of `enable_if` that appears to simulate single-"
"operation `concepts`."
msgstr ""

msgid ""
"11340    ### <a name=\"Rt-complete\"></a>T.21: Require a complete set of "
"operations for a concept"
msgstr ""

msgid "11341    ##### Reason"
msgstr ""

msgid "11342    Ease of comprehension."
msgstr ""

msgid "11343    Improved interoperability."
msgstr ""

msgid "11344    Helps implementers and maintainers."
msgstr ""

msgid "11345    ##### Note"
msgstr ""

msgid ""
"11346    This is a specific variant of the general rule that [a concept must "
"make semantic sense](#Rt-low)."
msgstr ""

msgid "11347    ##### Example, bad (using TS concepts)"
msgstr ""

msgid ""
"11348        template<typename T> concept Subtractable = requires(T a, T, b) "
"{ a-b; };"
msgstr ""

msgid "11349    This makes no semantic sense."
msgstr ""

msgid "11350    You need at least `+` to make `-` meaningful and useful."
msgstr ""

msgid "11351    Examples of complete sets are"
msgstr ""

msgid "11352    * `Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`"
msgstr ""

msgid "11353    * `Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`"
msgstr ""

msgid "11354    ##### Note"
msgstr ""

msgid ""
"11355    This rule applies whether we use direct language support for "
"concepts or not."
msgstr ""

msgid ""
"11356    It is a general design rule that even applies to non-templates:"
msgstr ""

msgid "11357        class Minimal {"
msgstr ""

msgid "11358            // ..."
msgstr ""

msgid "11359        };"
msgstr ""

msgid "11360        bool operator==(const Minimal&, const Minimal&);"
msgstr ""

msgid "11361        bool operator<(const Minimal&, const Minimal&);"
msgstr ""

msgid "11362        Minimal operator+(const Minimal&, const Minimal&);"
msgstr ""

msgid "11363        // no other operators"
msgstr ""

msgid "11364        void f(const Minimal& x, const Minimal& y)"
msgstr ""

msgid "11365        {"
msgstr ""

msgid "11366            if (!(x == y)) { /* ... */ }    // OK"
msgstr ""

msgid "11367            if (x != y) { /* ... */ }       // surprise! error"
msgstr ""

msgid "11368            while (!(x < y)) { /* ... */ }  // OK"
msgstr ""

msgid "11369            while (x >= y) { /* ... */ }    // surprise! error"
msgstr ""

msgid "11370            x = x + y;          // OK"
msgstr ""

msgid "11371            x += y;             // surprise! error"
msgstr ""

msgid "11372        }"
msgstr ""

msgid "11373    This is minimal, but surprising and constraining for users."
msgstr ""

msgid "11374    It could even be less efficient."
msgstr ""

msgid ""
"11375    The rule supports the view that a concept should reflect a "
"(mathematically) coherent set of operations."
msgstr ""

msgid "11376    ##### Example"
msgstr ""

msgid "11377        class Convenient {"
msgstr ""

msgid "11378            // ..."
msgstr ""

msgid "11379        };"
msgstr ""

msgid "11380        bool operator==(const Convenient&, const Convenient&);"
msgstr ""

msgid "11381        bool operator<(const Convenient&, const Convenient&);"
msgstr ""

msgid "11382        // ... and the other comparison operators ..."
msgstr ""

msgid "11383        Minimal operator+(const Convenient&, const Convenient&);"
msgstr ""

msgid "11384        // .. and the other arithmetic operators ..."
msgstr ""

msgid "11385        void f(const Convenient& x, const Convenient& y)"
msgstr ""

msgid "11386        {"
msgstr ""

msgid "11387            if (!(x == y)) { /* ... */ }    // OK"
msgstr ""

msgid "11388            if (x != y) { /* ... */ }       // OK"
msgstr ""

msgid "11389            while (!(x < y)) { /* ... */ }  // OK"
msgstr ""

msgid "11390            while (x >= y) { /* ... */ }    // OK"
msgstr ""

msgid "11391            x = x + y;     // OK"
msgstr ""

msgid "11392            x += y;        // OK"
msgstr ""

msgid "11393        }"
msgstr ""

msgid "11394    It can be a nuisance to define all operators, but not hard."
msgstr ""

msgid ""
"11395    Ideally, that rule should be language supported by giving you "
"comparison operators by default."
msgstr ""

msgid "11396    ##### Enforcement"
msgstr ""

msgid ""
"11397    * Flag classes that support \"odd\" subsets of a set of operators, "
"e.g., `==` but not `!=` or `+` but not `-`."
msgstr ""

msgid ""
"11398      Yes, `std::string` is \"odd\", but it's too late to change that."
msgstr ""

msgid "11399    ### <a name=\"Rt-axiom\"></a>T.22: Specify axioms for concepts"
msgstr ""

msgid "11400    ##### Reason"
msgstr ""

msgid "11401    A meaningful/useful concept has a semantic meaning."
msgstr ""

msgid ""
"11402    Expressing these semantics in an informal, semi-formal, or formal "
"way makes the concept comprehensible to readers and the effort to express it "
"can catch conceptual errors."
msgstr ""

msgid "11403    Specifying semantics is a powerful design tool."
msgstr ""

msgid "11404    ##### Example (using TS concepts)"
msgstr ""

msgid "11405        template<typename T>"
msgstr ""

msgid ""
"11406            // The operators +, -, *, and / for a number are assumed to "
"follow the usual mathematical rules"
msgstr ""

msgid ""
"11407            // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + "
"c) == a * b + a * c; /*...*/ }"
msgstr ""

msgid "11408            concept Number = requires(T a, T b) {"
msgstr ""

msgid ""
"11409                {a + b} -> T;   // the result of a + b is convertible "
"to T"
msgstr ""

msgid "11410                {a - b} -> T;"
msgstr ""

msgid "11411                {a * b} -> T;"
msgstr ""

msgid "11412                {a / b} -> T;"
msgstr ""

msgid "11413            }"
msgstr ""

msgid "11414    ##### Note"
msgstr ""

msgid ""
"11415    This is an axiom in the mathematical sense: something that may be "
"assumed without proof."
msgstr ""

msgid ""
"11416    In general, axioms are not provable, and when they are the proof is "
"often beyond the capability of a compiler."
msgstr ""

msgid ""
"11417    An axiom may not be general, but the template writer may assume "
"that it holds for all inputs actually used (similar to a precondition)."
msgstr ""

msgid "11418    ##### Note"
msgstr ""

msgid "11419    In this context axioms are Boolean expressions."
msgstr ""

msgid "11420    See the [Palo Alto TR](#S-references) for examples."
msgstr ""

msgid ""
"11421    Currently, C++ does not support axioms (even the ISO Concepts TS), "
"so we have to make do with comments for a longish while."
msgstr ""

msgid ""
"11422    Once language support is available, the `//` in front of the axiom "
"can be removed"
msgstr ""

msgid "11423    ##### Note"
msgstr ""

msgid ""
"11424    The GSL concepts have well-defined semantics; see the Palo Alto TR "
"and the Ranges TS."
msgstr ""

msgid "11425    ##### Exception (using TS concepts)"
msgstr ""

msgid ""
"11426    Early versions of a new \"concept\" still under development will "
"often just define simple sets of constraints without a well-specified "
"semantics."
msgstr ""

msgid "11427    Finding good semantics can take effort and time."
msgstr ""

msgid "11428    An incomplete set of constraints can still be very useful:"
msgstr ""

msgid "11429        // balancer for a generic binary tree"
msgstr ""

msgid ""
"11430        template<typename Node> concept bool Balancer = requires(Node* "
"p) {"
msgstr ""

msgid "11431            add_fixup(p);"
msgstr ""

msgid "11432            touch(p);"
msgstr ""

msgid "11433            detach(p);"
msgstr ""

msgid "11434        }"
msgstr ""

msgid ""
"11435    So a `Balancer` must supply at least thee operations on a tree "
"`Node`,"
msgstr ""

msgid ""
"11436    but we are not yet ready to specify detailed semantics because a "
"new kind of balanced tree might require more operations"
msgstr ""

msgid ""
"11437    and the precise general semantics for all nodes is hard to pin down "
"in the early stages of design."
msgstr ""

msgid ""
"11438    A \"concept\" that is incomplete or without a well-specified "
"semantics can still be useful."
msgstr ""

msgid ""
"11439    For example, it allows for some checking during initial "
"experimentation."
msgstr ""

msgid "11440    However, it should not be assumed to be stable."
msgstr ""

msgid ""
"11441    Each new use case may require such an incomplete concepts to be "
"improved."
msgstr ""

msgid "11442    ##### Enforcement"
msgstr ""

msgid "11443    * Look for the word \"axiom\" in concept definition comments"
msgstr ""

msgid ""
"11444    ### <a name=\"Rt-refine\"></a>T.23: Differentiate a refined concept "
"from its more general case by adding new use patterns."
msgstr ""

msgid "11445    ##### Reason"
msgstr ""

msgid ""
"11446    Otherwise they cannot be distinguished automatically by the "
"compiler."
msgstr ""

msgid "11447    ##### Example (using TS concepts)"
msgstr ""

msgid "11448        template<typename I>"
msgstr ""

msgid "11449        concept bool Input_iter = requires(I iter) { ++iter; };"
msgstr ""

msgid "11450        template<typename I>"
msgstr ""

msgid ""
"11451        concept bool Fwd_iter = Input_iter<I> && requires(I iter) { "
"iter++; }"
msgstr ""

msgid ""
"11452    The compiler can determine refinement based on the sets of required "
"operations (here, suffix `++`)."
msgstr ""

msgid ""
"11453    This decreases the burden on implementers of these types since"
msgstr ""

msgid ""
"11454    they do not need any special declarations to \"hook into the "
"concept\"."
msgstr ""

msgid ""
"11455    If two concepts have exactly the same requirements, they are "
"logically equivalent (there is no refinement)."
msgstr ""

msgid "11456    ##### Enforcement"
msgstr ""

msgid ""
"11457    * Flag a concept that has exactly the same requirements as another "
"already-seen concept (neither is more refined)."
msgstr ""

msgid "11458    To disambiguate them, see [T.24](#Rt-tag)."
msgstr ""

msgid ""
"11459    ### <a name=\"Rt-tag\"></a>T.24: Use tag classes or traits to "
"differentiate concepts that differ only in semantics."
msgstr ""

msgid "11460    ##### Reason"
msgstr ""

msgid ""
"11461    Two concepts requiring the same syntax but having different "
"semantics leads to ambiguity unless the programmer differentiates them."
msgstr ""

msgid "11462    ##### Example (using TS concepts)"
msgstr ""

msgid ""
"11463        template<typename I>    // iterator providing random access"
msgstr ""

msgid "11464        concept bool RA_iter = ...;"
msgstr ""

msgid ""
"11465        template<typename I>    // iterator providing random access to "
"contiguous data"
msgstr ""

msgid "11466        concept bool Contiguous_iter ="
msgstr ""

msgid ""
"11467            RA_iter<I> && is_contiguous<I>::value;  // using "
"is_contiguous trait"
msgstr ""

msgid ""
"11468    The programmer (in a library) must define `is_contiguous` (a trait) "
"appropriately."
msgstr ""

msgid ""
"11469    Wrapping a tag class into a concept leads to a simpler expression "
"of this idea:"
msgstr ""

msgid ""
"11470        template<typename I> concept Contiguous = is_contiguous<I>::"
"value;"
msgstr ""

msgid "11471        template<typename I>"
msgstr ""

msgid ""
"11472        concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>;"
msgstr ""

msgid ""
"11473    The programmer (in a library) must define `is_contiguous` (a trait) "
"appropriately."
msgstr ""

msgid "11474    ##### Note"
msgstr ""

msgid "11475    Traits can be trait classes or type traits."
msgstr ""

msgid "11476    These can be user-defined or standard-library ones."
msgstr ""

msgid "11477    Prefer the standard-library ones."
msgstr ""

msgid "11478    ##### Enforcement"
msgstr ""

msgid "11479    * The compiler flags ambiguous use of identical concepts."
msgstr ""

msgid "11480    * Flag the definition of identical concepts."
msgstr ""

msgid ""
"11481    ### <a name=\"Rt-not\"></a>T.25: Avoid complementary constraints"
msgstr ""

msgid "11482    ##### Reason"
msgstr ""

msgid "11483    Clarity. Maintainability."
msgstr ""

msgid ""
"11484    Functions with complementary requirements expressed using negation "
"are brittle."
msgstr ""

msgid "11485    ##### Example (using TS concepts)"
msgstr ""

msgid ""
"11486    Initially, people will try to define functions with complementary "
"requirements:"
msgstr ""

msgid "11487        template<typename T>"
msgstr ""

msgid "11488            requires !C<T>    // bad"
msgstr ""

msgid "11489        void f();"
msgstr ""

msgid "11490        template<typename T>"
msgstr ""

msgid "11491            requires C<T>"
msgstr ""

msgid "11492        void f();"
msgstr ""

msgid "11493    This is better:"
msgstr ""

msgid "11494        template<typename T>   // general template"
msgstr ""

msgid "11495            void f();"
msgstr ""

msgid "11496        template<typename T>   // specialization by concept"
msgstr ""

msgid "11497            requires C<T>"
msgstr ""

msgid "11498        void f();"
msgstr ""

msgid ""
"11499    The compiler will choose the unconstrained template only when "
"`C<T>` is"
msgstr ""

msgid ""
"11500    unsatisfied. If you do not want to (or cannot) define an "
"unconstrained"
msgstr ""

msgid "11501    version of `f()`, then delete it."
msgstr ""

msgid "11502        template<typename T>"
msgstr ""

msgid "11503        void f() = delete;"
msgstr ""

msgid ""
"11504    The compiler will select the overload and emit an appropriate error."
""
msgstr ""

msgid "11505    ##### Note"
msgstr ""

msgid ""
"11506    Complementary constraints are unfortunately common in `enable_if` "
"code:"
msgstr ""

msgid "11507        template<typename T>"
msgstr ""

msgid "11508        enable_if<!C<T>, void>   // bad"
msgstr ""

msgid "11509        f();"
msgstr ""

msgid "11510        template<typename T>"
msgstr ""

msgid "11511        enable_if<C<T>, void>"
msgstr ""

msgid "11512        f();"
msgstr ""

msgid "11513    ##### Note"
msgstr ""

msgid ""
"11514    Complementary requirements on one requirements is sometimes "
"(wrongly) considered manageable."
msgstr ""

msgid ""
"11515    However, for two or more requirements the number of definitions "
"needs can go up exponentially (2,4,9,16,...):"
msgstr ""

msgid "11516        C1<T> && C2<T>"
msgstr ""

msgid "11517        !C1<T> && C2<T>"
msgstr ""

msgid "11518        C1<T> && !C2<T>"
msgstr ""

msgid "11519        !C1<T> && !C2<T>"
msgstr ""

msgid "11520    Now the opportunities for errors multiply."
msgstr ""

msgid "11521    ##### Enforcement"
msgstr ""

msgid "11522    * Flag pairs of functions with `C<T>` and `!C<T>` constraints"
msgstr ""

msgid ""
"11523    ### <a name=\"Rt-use\"></a>T.26: Prefer to define concepts in terms "
"of use-patterns rather than simple syntax"
msgstr ""

msgid "11524    ##### Reason"
msgstr ""

msgid ""
"11525    The definition is more readable and corresponds directly to what a "
"user has to write."
msgstr ""

msgid ""
"11526    Conversions are taken into account. You don't have to remember the "
"names of all the type traits."
msgstr ""

msgid "11527    ##### Example (using TS concepts)"
msgstr ""

msgid ""
"11528    You might be tempted to define a concept `Equality` like this:"
msgstr ""

msgid ""
"11529        template<typename T> concept Equality = has_equal<T> && "
"has_not_equal<T>;"
msgstr ""

msgid ""
"11530    Obviously, it would be better and easier just to use the standard "
"`EqualityComparable`,"
msgstr ""

msgid ""
"11531    but - just as an example - if you had to define such a concept, "
"prefer:"
msgstr ""

msgid ""
"11532        template<typename T> concept Equality = requires(T a, T b) {"
msgstr ""

msgid "11533            bool == { a == b }"
msgstr ""

msgid "11534            bool == { a != b }"
msgstr ""

msgid "11535            // axiom { !(a == b) == (a != b) }"
msgstr ""

msgid "11536            // axiom { a = b; => a == b }  // => means \"implies\""
msgstr ""

msgid "11537        }"
msgstr ""

msgid ""
"11538    as opposed to defining two meaningless concepts `has_equal` and "
"`has_not_equal` just as helpers in the definition of `Equality`."
msgstr ""

msgid ""
"11539    By \"meaningless\" we mean that we cannot specify the semantics of "
"`has_equal` in isolation."
msgstr ""

msgid "11540    ##### Enforcement"
msgstr ""

msgid "11541    ???"
msgstr ""

msgid "11542    ## <a name=\"SS-temp-interface\"></a>Template interfaces"
msgstr ""

msgid ""
"11543    Over the years, programming with templates have suffered from a "
"weak distinction between the interface of a template"
msgstr ""

msgid "11544    and its implementation."
msgstr ""

msgid ""
"11545    Before concepts, that distinction had no direct language support."
msgstr ""

msgid ""
"11546    However, the interface to a template is a critical concept - a "
"contract between a user and an implementer - and should be carefully "
"designed."
msgstr ""

msgid ""
"11547    ### <a name=\"Rt-fo\"></a>T.40: Use function objects to pass "
"operations to algorithms"
msgstr ""

msgid "11548    ##### Reason"
msgstr ""

msgid ""
"11549    Function objects can carry more information through an interface "
"than a \"plain\" pointer to function."
msgstr ""

msgid ""
"11550    In general, passing function objects gives better performance than "
"passing pointers to functions."
msgstr ""

msgid "11551    ##### Example (using TS concepts)"
msgstr ""

msgid "11552        bool greater(double x, double y) { return x > y; }"
msgstr ""

msgid ""
"11553        sort(v, greater);                                    // pointer "
"to function: potentially slow"
msgstr ""

msgid ""
"11554        sort(v, [](double x, double y) { return x > y; });   // "
"function object"
msgstr ""

msgid ""
"11555        sort(v, std::greater<>);                             // "
"function object"
msgstr ""

msgid "11556        bool greater_than_7(double x) { return x > 7; }"
msgstr ""

msgid ""
"11557        auto x = find_if(v, greater_than_7);                 // pointer "
"to function: inflexible"
msgstr ""

msgid ""
"11558        auto y = find_if(v, [](double x) { return x > 7; }); // "
"function object: carries the needed data"
msgstr ""

msgid ""
"11559        auto z = find_if(v, Greater_than<double>(7));        // "
"function object: carries the needed data"
msgstr ""

msgid ""
"11560    You can, of course, generalize those functions using `auto` or "
"(when and where available) concepts. For example:"
msgstr ""

msgid ""
"11561        auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // "
"require an ordered type"
msgstr ""

msgid ""
"11562        auto z1 = find_if(v, [](auto x) { return x > 7; });    // hope "
"that the type has a >"
msgstr ""

msgid "11563    ##### Note"
msgstr ""

msgid "11564    Lambdas generate function objects."
msgstr ""

msgid "11565    ##### Note"
msgstr ""

msgid ""
"11566    The performance argument depends on compiler and optimizer "
"technology."
msgstr ""

msgid "11567    ##### Enforcement"
msgstr ""

msgid "11568    * Flag pointer to function template arguments."
msgstr ""

msgid ""
"11569    * Flag pointers to functions passed as arguments to a template "
"(risk of false positives)."
msgstr ""

msgid ""
"11570    ### <a name=\"Rt-essential\"></a>T.41: Require only essential "
"properties in a template's concepts"
msgstr ""

msgid "11571    ##### Reason"
msgstr ""

msgid "11572    Keep interfaces simple and stable."
msgstr ""

msgid "11573    ##### Example (using TS concepts)"
msgstr ""

msgid ""
"11574    Consider, a `sort` instrumented with (oversimplified) simple debug "
"support:"
msgstr ""

msgid "11575        void sort(Sortable& s)  // sort sequence s"
msgstr ""

msgid "11576        {"
msgstr ""

msgid "11577            if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";"
msgstr ""

msgid "11578            // ..."
msgstr ""

msgid "11579            if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";"
msgstr ""

msgid "11580        }"
msgstr ""

msgid "11581    Should this be rewritten to:"
msgstr ""

msgid "11582        template<Sortable S>"
msgstr ""

msgid "11583            requires Streamable<S>"
msgstr ""

msgid "11584        void sort(S& s)  // sort sequence s"
msgstr ""

msgid "11585        {"
msgstr ""

msgid "11586            if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";"
msgstr ""

msgid "11587            // ..."
msgstr ""

msgid "11588            if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";"
msgstr ""

msgid "11589        }"
msgstr ""

msgid ""
"11590    After all, there is nothing in `Sortable` that requires `iostream` "
"support."
msgstr ""

msgid ""
"11591    On the other hand, there is nothing in the fundamental idea of "
"sorting that says anything about debugging."
msgstr ""

msgid "11592    ##### Note"
msgstr ""

msgid ""
"11593    If we require every operation used to be listed among the "
"requirements, the interface becomes unstable:"
msgstr ""

msgid ""
"11594    Every time we change the debug facilities, the usage data "
"gathering, testing support, error reporting, etc."
msgstr ""

msgid ""
"11595    The definition of the template would need change and every use of "
"the template would have to be recompiled."
msgstr ""

msgid "11596    This is cumbersome, and in some environments infeasible."
msgstr ""

msgid ""
"11597    Conversely, if we use an operation in the implementation that is "
"not guaranteed by concept checking,"
msgstr ""

msgid "11598    we may get a late compile-time error."
msgstr ""

msgid ""
"11599    By not using concept checking for properties of a template argument "
"that is not considered essential,"
msgstr ""

msgid "11600    we delay checking until instantiation time."
msgstr ""

msgid "11601    We consider this a worthwhile tradeoff."
msgstr ""

msgid ""
"11602    Note that using non-local, non-dependent names (such as `debug` and "
"`cerr`) also introduces context dependencies that may lead to \"mysterious\" "
"errors."
msgstr ""

msgid "11603    ##### Note"
msgstr ""

msgid ""
"11604    It can be hard to decide which properties of a type is essential "
"and which are not."
msgstr ""

msgid "11605    ##### Enforcement"
msgstr ""

msgid "11606    ???"
msgstr ""

msgid ""
"11607    ### <a name=\"Rt-alias\"></a>T.42: Use template aliases to simplify "
"notation and hide implementation details"
msgstr ""

msgid "11608    ##### Reason"
msgstr ""

msgid "11609    Improved readability."
msgstr ""

msgid "11610    Implementation hiding."
msgstr ""

msgid ""
"11611    Note that template aliases replace many uses of traits to compute a "
"type."
msgstr ""

msgid "11612    They can also be used to wrap a trait."
msgstr ""

msgid "11613    ##### Example"
msgstr ""

msgid "11614        template<typename T, size_t N>"
msgstr ""

msgid "11615        class Matrix {"
msgstr ""

msgid "11616            // ..."
msgstr ""

msgid "11617            using Iterator = typename std::vector<T>::iterator;"
msgstr ""

msgid "11618            // ..."
msgstr ""

msgid "11619        };"
msgstr ""

msgid ""
"11620    This saves the user of `Matrix` from having to know that its "
"elements are stored in a `vector` and also saves the user from repeatedly "
"typing `typename std::vector<T>::`."
msgstr ""

msgid "11621    ##### Example"
msgstr ""

msgid "11622        template<typename T>"
msgstr ""

msgid "11623        void user(T& c)"
msgstr ""

msgid "11624        {"
msgstr ""

msgid "11625            // ..."
msgstr ""

msgid ""
"11626            typename container_traits<T>::value_type x; // bad, verbose"
msgstr ""

msgid "11627            // ..."
msgstr ""

msgid "11628        }"
msgstr ""

msgid "11629        template<typename T>"
msgstr ""

msgid ""
"11630        using Value_type = typename container_traits<T>::value_type;"
msgstr ""

msgid ""
"11631    This saves the user of `Value_type` from having to know the "
"technique used to implement `value_type`s."
msgstr ""

msgid "11632        template<typename T>"
msgstr ""

msgid "11633        void user2(T& c)"
msgstr ""

msgid "11634        {"
msgstr ""

msgid "11635            // ..."
msgstr ""

msgid "11636            Value_type<T> x;"
msgstr ""

msgid "11637            // ..."
msgstr ""

msgid "11638        }"
msgstr ""

msgid "11639    ##### Note"
msgstr ""

msgid "11640    A simple, common use could be expressed: \"Wrap traits!\""
msgstr ""

msgid "11641    ##### Enforcement"
msgstr ""

msgid ""
"11642    * Flag use of `typename` as a disambiguator outside `using` "
"declarations."
msgstr ""

msgid "11643    * ???"
msgstr ""

msgid ""
"11644    ### <a name=\"Rt-using\"></a>T.43: Prefer `using` over `typedef` "
"for defining aliases"
msgstr ""

msgid "11645    ##### Reason"
msgstr ""

msgid ""
"11646    Improved readability: With `using`, the new name comes first rather "
"than being embedded somewhere in a declaration."
msgstr ""

msgid ""
"11647    Generality: `using` can be used for template aliases, whereas "
"`typedef`s can't easily be templates."
msgstr ""

msgid "11648    Uniformity: `using` is syntactically similar to `auto`."
msgstr ""

msgid "11649    ##### Example"
msgstr ""

msgid "11650        typedef int (*PFI)(int);   // OK, but convoluted"
msgstr ""

msgid "11651        using PFI2 = int (*)(int);   // OK, preferred"
msgstr ""

msgid "11652        template<typename T>"
msgstr ""

msgid "11653        typedef int (*PFT)(T);      // error"
msgstr ""

msgid "11654        template<typename T>"
msgstr ""

msgid "11655        using PFT2 = int (*)(T);   // OK"
msgstr ""

msgid "11656    ##### Enforcement"
msgstr ""

msgid "11657    * Flag uses of `typedef`. This will give a lot of \"hits\" :-("
msgstr ""

msgid ""
"11658    ### <a name=\"Rt-deduce\"></a>T.44: Use function templates to "
"deduce class template argument types (where feasible)"
msgstr ""

msgid "11659    ##### Reason"
msgstr ""

msgid ""
"11660    Writing the template argument types explicitly can be tedious and "
"unnecessarily verbose."
msgstr ""

msgid "11661    ##### Example"
msgstr ""

msgid ""
"11662        tuple<int, string, double> t1 = {1, \"Hamlet\", 3.14};   // "
"explicit type"
msgstr ""

msgid ""
"11663        auto t2 = make_tuple(1, \"Ophelia\"s, 3.14);         // better; "
"deduced type"
msgstr ""

msgid ""
"11664    Note the use of the `s` suffix to ensure that the string is a `std::"
"string`, rather than a C-style string."
msgstr ""

msgid "11665    ##### Note"
msgstr ""

msgid ""
"11666    Since you can trivially write a `make_T` function, so could the "
"compiler. Thus, `make_T` functions may become redundant in the future."
msgstr ""

msgid "11667    ##### Exception"
msgstr ""

msgid ""
"11668    Sometimes there isn't a good way of getting the template arguments "
"deduced and sometimes, you want to specify the arguments explicitly:"
msgstr ""

msgid "11669        vector<double> v = { 1, 2, 3, 7.9, 15.99 };"
msgstr ""

msgid "11670        list<Record*> lst;"
msgstr ""

msgid "11671    ##### Note"
msgstr ""

msgid ""
"11672    Note that C++17 will make this rule redundant by allowing the "
"template arguments to be deduced directly from constructor arguments:"
msgstr ""

msgid ""
"11673    [Template parameter deduction for constructors (Rev. 3)](http://www."
"open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html)."
msgstr ""

msgid "11674    For example:"
msgstr ""

msgid ""
"11675        tuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, "
"string, double>"
msgstr ""

msgid "11676    ##### Enforcement"
msgstr ""

msgid ""
"11677    Flag uses where an explicitly specialized type exactly matches the "
"types of the arguments used."
msgstr ""

msgid ""
"11678    ### <a name=\"Rt-regular\"></a>T.46: Require template arguments to "
"be at least `Regular` or `SemiRegular`"
msgstr ""

msgid "11679    ##### Reason"
msgstr ""

msgid "11680     Readability."
msgstr ""

msgid "11681     Preventing surprises and errors."
msgstr ""

msgid "11682     Most uses support that anyway."
msgstr ""

msgid "11683    ##### Example"
msgstr ""

msgid "11684        class X {"
msgstr ""

msgid "11685                // ..."
msgstr ""

msgid "11686        public:"
msgstr ""

msgid "11687            explicit X(int);"
msgstr ""

msgid "11688            X(const X&);            // copy"
msgstr ""

msgid "11689            X operator=(const X&);"
msgstr ""

msgid "11690            X(X&&) noexcept;                 // move"
msgstr ""

msgid "11691            X& operator=(X&&) noexcept;"
msgstr ""

msgid "11692            ~X();"
msgstr ""

msgid "11693            // ... no more constructors ..."
msgstr ""

msgid "11694        };"
msgstr ""

msgid "11695        X x {1};    // fine"
msgstr ""

msgid "11696        X y = x;      // fine"
msgstr ""

msgid "11697        std::vector<X> v(10); // error: no default constructor"
msgstr ""

msgid "11698    ##### Note"
msgstr ""

msgid "11699    Semiregular requires default constructible."
msgstr ""

msgid "11700    ##### Enforcement"
msgstr ""

msgid "11701    * Flag types that are not at least `SemiRegular`."
msgstr ""

msgid ""
"11702    ### <a name=\"Rt-visible\"></a>T.47: Avoid highly visible "
"unconstrained templates with common names"
msgstr ""

msgid "11703    ##### Reason"
msgstr ""

msgid ""
"11704     An unconstrained template argument is a perfect match for anything "
"so such a template can be preferred over more specific types that require "
"minor conversions."
msgstr ""

msgid "11705     This is particularly annoying/dangerous when ADL is used."
msgstr ""

msgid "11706     Common names make this problem more likely."
msgstr ""

msgid "11707    ##### Example"
msgstr ""

msgid "11708        namespace Bad {"
msgstr ""

msgid "11709            struct S { int m; };"
msgstr ""

msgid "11710            template<typename T1, typename T2>"
msgstr ""

msgid ""
"11711            bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; "
"}"
msgstr ""

msgid "11712        }"
msgstr ""

msgid "11713        namespace T0 {"
msgstr ""

msgid ""
"11714            bool operator==(int, Bad::S) { cout << \"T0\\n\"; return "
"true; }  // compare to int"
msgstr ""

msgid "11715            void test()"
msgstr ""

msgid "11716            {"
msgstr ""

msgid "11717                Bad::S bad{ 1 };"
msgstr ""

msgid "11718                vector<int> v(10);"
msgstr ""

msgid "11719                bool b = 1 == bad;"
msgstr ""

msgid "11720                bool b2 = v.size() == bad;"
msgstr ""

msgid "11721            }"
msgstr ""

msgid "11722        }"
msgstr ""

msgid "11723    This prints `T0` and `Bad`."
msgstr ""

msgid ""
"11724    Now the `==` in `Bad` was designed to cause trouble, but would you "
"have spotted the problem in real code?"
msgstr ""

msgid ""
"11725    The problem is that `v.size()` returns an `unsigned` integer so "
"that a conversion is needed to call the local `==`;"
msgstr ""

msgid "11726    the `==` in `Bad` requires no conversions."
msgstr ""

msgid ""
"11727    Realistic types, such as the standard-library iterators can be made "
"to exhibit similar anti-social tendencies."
msgstr ""

msgid "11728    ##### Note"
msgstr ""

msgid ""
"11729    If an unconstrained template is defined in the same namespace as a "
"type,"
msgstr ""

msgid ""
"11730    that unconstrained template can be found by ADL (as happened in the "
"example)."
msgstr ""

msgid "11731    That is, it is highly visible."
msgstr ""

msgid "11732    ##### Note"
msgstr ""

msgid ""
"11733    This rule should not be necessary, but the committee cannot agree "
"to exclude unconstrained templated from ADL."
msgstr ""

msgid ""
"11734    Unfortunately this will get many false positives; the standard "
"library violates this widely, by putting many unconstrained templates and "
"types into the single namespace `std`."
msgstr ""

msgid "11735    ##### Enforcement"
msgstr ""

msgid ""
"11736    Flag templates defined in a namespace where concrete types are also "
"defined (maybe not feasible until we have concepts)."
msgstr ""

msgid ""
"11737    ### <a name=\"Rt-concept-def\"></a>T.48: If your compiler does not "
"support concepts, fake them with `enable_if`"
msgstr ""

msgid "11738    ##### Reason"
msgstr ""

msgid ""
"11739    Because that's the best we can do without direct concept support."
msgstr ""

msgid ""
"11740    `enable_if` can be used to conditionally define functions and to "
"select among a set of functions."
msgstr ""

msgid "11741    ##### Example"
msgstr ""

msgid "11742        enable_if<???>"
msgstr ""

msgid "11743    ##### Note"
msgstr ""

msgid "11744    Beware of [complementary constraints](# T.25)."
msgstr ""

msgid ""
"11745    Faking concept overloading using `enable_if` sometimes forces us to "
"use that error-prone design technique."
msgstr ""

msgid "11746    ##### Enforcement"
msgstr ""

msgid "11747    ???"
msgstr ""

msgid ""
"11748    ### <a name=\"Rt-erasure\"></a>T.49: Where possible, avoid type-"
"erasure"
msgstr ""

msgid "11749    ##### Reason"
msgstr ""

msgid ""
"11750    Type erasure incurs an extra level of indirection by hiding type "
"information behind a separate compilation boundary."
msgstr ""

msgid "11751    ##### Example"
msgstr ""

msgid "11752        ???"
msgstr ""

msgid ""
"11753    **Exceptions**: Type erasure is sometimes appropriate, such as for "
"`std::function`."
msgstr ""

msgid "11754    ##### Enforcement"
msgstr ""

msgid "11755    ???"
msgstr ""

msgid "11756    ##### Note"
msgstr ""

msgid "11757    ## <a name=\"SS-temp-def\"></a>T.def: Template definitions"
msgstr ""

msgid ""
"11758    A template definition (class or function) can contain arbitrary "
"code, so only a comprehensive review of C++ programming techniques would "
"cover this topic."
msgstr ""

msgid ""
"11759    However, this section focuses on what is specific to template "
"implementation."
msgstr ""

msgid ""
"11760    In particular, it focuses on a template definition's dependence on "
"its context."
msgstr ""

msgid ""
"11761    ### <a name=\"Rt-depend\"></a>T.60: Minimize a template's context "
"dependencies"
msgstr ""

msgid "11762    ##### Reason"
msgstr ""

msgid "11763    Eases understanding."
msgstr ""

msgid "11764    Minimizes errors from unexpected dependencies."
msgstr ""

msgid "11765    Eases tool creation."
msgstr ""

msgid "11766    ##### Example"
msgstr ""

msgid "11767        template<typename C>"
msgstr ""

msgid "11768        void sort(C& c)"
msgstr ""

msgid "11769        {"
msgstr ""

msgid ""
"11770            std::sort(begin(c), end(c)); // necessary and useful "
"dependency"
msgstr ""

msgid "11771        }"
msgstr ""

msgid "11772        template<typename Iter>"
msgstr ""

msgid "11773        Iter algo(Iter first, Iter last) {"
msgstr ""

msgid "11774            for (; first != last; ++first) {"
msgstr ""

msgid ""
"11775                auto x = sqrt(*first); // potentially surprising "
"dependency: which sqrt()?"
msgstr ""

msgid ""
"11776                helper(first, x);      // potentially surprising "
"dependency:"
msgstr ""

msgid ""
"11777                                       // helper is chosen based on "
"first and x"
msgstr ""

msgid ""
"11778                TT var = 7;            // potentially surprising "
"dependency: which TT?"
msgstr ""

msgid "11779            }"
msgstr ""

msgid "11780        }"
msgstr ""

msgid "11781    ##### Note"
msgstr ""

msgid ""
"11782    Templates typically appear in header files so their context "
"dependencies are more vulnerable to `#include` order dependencies than "
"functions in `.cpp` files."
msgstr ""

msgid "11783    ##### Note"
msgstr ""

msgid ""
"11784    Having a template operate only on its arguments would be one way of "
"reducing the number of dependencies to a minimum, but that would generally "
"be unmanageable."
msgstr ""

msgid ""
"11785    For example, an algorithm usually uses other algorithms and invoke "
"operations that does not exclusively operate on arguments."
msgstr ""

msgid "11786    And don't get us started on macros!"
msgstr ""

msgid "11787    **See also**: [T.69](#Rt-customization)"
msgstr ""

msgid "11788    ##### Enforcement"
msgstr ""

msgid "11789    ??? Tricky"
msgstr ""

msgid ""
"11790    ### <a name=\"Rt-scary\"></a>T.61: Do not over-parameterize members "
"(SCARY)"
msgstr ""

msgid "11791    ##### Reason"
msgstr ""

msgid ""
"11792    A member that does not depend on a template parameter cannot be "
"used except for a specific template argument."
msgstr ""

msgid "11793    This limits use and typically increases code size."
msgstr ""

msgid "11794    ##### Example, bad"
msgstr ""

msgid "11795        template<typename T, typename A = std::allocator{}>"
msgstr ""

msgid "11796            // requires Regular<T> && Allocator<A>"
msgstr ""

msgid "11797        class List {"
msgstr ""

msgid "11798        public:"
msgstr ""

msgid "11799            struct Link {   // does not depend on A"
msgstr ""

msgid "11800                T elem;"
msgstr ""

msgid "11801                T* pre;"
msgstr ""

msgid "11802                T* suc;"
msgstr ""

msgid "11803            };"
msgstr ""

msgid "11804            using iterator = Link*;"
msgstr ""

msgid "11805            iterator first() const { return head; }"
msgstr ""

msgid "11806            // ..."
msgstr ""

msgid "11807        private:"
msgstr ""

msgid "11808            Link* head;"
msgstr ""

msgid "11809        };"
msgstr ""

msgid "11810        List<int> lst1;"
msgstr ""

msgid "11811        List<int, My_allocator> lst2;"
msgstr ""

msgid "11812        ???"
msgstr ""

msgid "11813    This looks innocent enough, but ???"
msgstr ""

msgid "11814        template<typename T>"
msgstr ""

msgid "11815        struct Link {"
msgstr ""

msgid "11816            T elem;"
msgstr ""

msgid "11817            T* pre;"
msgstr ""

msgid "11818            T* suc;"
msgstr ""

msgid "11819        };"
msgstr ""

msgid "11820        template<typename T, typename A = std::allocator{}>"
msgstr ""

msgid "11821            // requires Regular<T> && Allocator<A>"
msgstr ""

msgid "11822        class List2 {"
msgstr ""

msgid "11823        public:"
msgstr ""

msgid "11824            using iterator = Link<T>*;"
msgstr ""

msgid "11825            iterator first() const { return head; }"
msgstr ""

msgid "11826            // ..."
msgstr ""

msgid "11827        private:"
msgstr ""

msgid "11828            Link* head;"
msgstr ""

msgid "11829        };"
msgstr ""

msgid "11830        List<int> lst1;"
msgstr ""

msgid "11831        List<int, My_allocator> lst2;"
msgstr ""

msgid "11832        ???"
msgstr ""

msgid "11833    ##### Enforcement"
msgstr ""

msgid ""
"11834    * Flag member types that do not depend on every template argument"
msgstr ""

msgid ""
"11835    * Flag member functions that do not depend on every template "
"argument"
msgstr ""

msgid ""
"11836    ### <a name=\"Rt-nondependent\"></a>T.62: Place non-dependent class "
"template members in a non-templated base class"
msgstr ""

msgid "11837    ##### Reason"
msgstr ""

msgid ""
"11838     Allow the base class members to be used without specifying "
"template arguments and without template instantiation."
msgstr ""

msgid "11839    ##### Example"
msgstr ""

msgid "11840        template<typename T>"
msgstr ""

msgid "11841        class Foo {"
msgstr ""

msgid "11842        public:"
msgstr ""

msgid "11843            enum { v1, v2 };"
msgstr ""

msgid "11844            // ..."
msgstr ""

msgid "11845        };"
msgstr ""

msgid "11846    ???"
msgstr ""

msgid "11847        struct Foo_base {"
msgstr ""

msgid "11848            enum { v1, v2 };"
msgstr ""

msgid "11849            // ..."
msgstr ""

msgid "11850        };"
msgstr ""

msgid "11851        template<typename T>"
msgstr ""

msgid "11852        class Foo : public Foo_base {"
msgstr ""

msgid "11853        public:"
msgstr ""

msgid "11854            // ..."
msgstr ""

msgid "11855        };"
msgstr ""

msgid "11856    ##### Note"
msgstr ""

msgid "11857    A more general version of this rule would be"
msgstr ""

msgid ""
"11858    \"If a template class member depends on only N template parameters "
"out of M, place it in a base class with only N parameters.\""
msgstr ""

msgid ""
"11859    For N == 1, we have a choice of a base class of a class in the "
"surrounding scope as in [T.61](#Rt-scary)."
msgstr ""

msgid "11860    ??? What about constants? class statics?"
msgstr ""

msgid "11861    ##### Enforcement"
msgstr ""

msgid "11862    * Flag ???"
msgstr ""

msgid ""
"11863    ### <a name=\"Rt-specialization\"></a>T.64: Use specialization to "
"provide alternative implementations of class templates"
msgstr ""

msgid "11864    ##### Reason"
msgstr ""

msgid "11865    A template defines a general interface."
msgstr ""

msgid ""
"11866    Specialization offers a powerful mechanism for providing "
"alternative implementations of that interface."
msgstr ""

msgid "11867    ##### Example"
msgstr ""

msgid "11868        ??? string specialization (==)"
msgstr ""

msgid "11869        ??? representation specialization ?"
msgstr ""

msgid "11870    ##### Note"
msgstr ""

msgid "11871    ???"
msgstr ""

msgid "11872    ##### Enforcement"
msgstr ""

msgid "11873    ???"
msgstr ""

msgid ""
"11874    ### <a name=\"Rt-tag-dispatch\"></a>T.65: Use tag dispatch to "
"provide alternative implementations of a function"
msgstr ""

msgid "11875    ##### Reason"
msgstr ""

msgid "11876    * A template defines a general interface."
msgstr ""

msgid ""
"11877    * Tag dispatch allows us to select implementations based on "
"specific properties of an argument type."
msgstr ""

msgid "11878    * Performance."
msgstr ""

msgid "11879    ##### Example"
msgstr ""

msgid ""
"11880    This is a simplified version of `std::copy` (ignoring the "
"possibility of non-contiguous sequences)"
msgstr ""

msgid "11881        struct pod_tag {};"
msgstr ""

msgid "11882        struct non_pod_tag {};"
msgstr ""

msgid ""
"11883        template<class T> struct copy_trait { using tag = non_pod_tag; "
"};   // T is not \"plain old data\""
msgstr ""

msgid ""
"11884        template<> struct copy_trait<int> { using tag = pod_tag; };     "
"    // int is \"plain old data\""
msgstr ""

msgid "11885        template<class Iter>"
msgstr ""

msgid "11886        Out copy_helper(Iter first, Iter last, Iter out, pod_tag)"
msgstr ""

msgid "11887        {"
msgstr ""

msgid "11888            // use memmove"
msgstr ""

msgid "11889        }"
msgstr ""

msgid "11890        template<class Iter>"
msgstr ""

msgid ""
"11891        Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)"
msgstr ""

msgid "11892        {"
msgstr ""

msgid "11893            // use loop calling copy constructors"
msgstr ""

msgid "11894        }"
msgstr ""

msgid "11895        template<class Itert>"
msgstr ""

msgid "11896        Out copy(Iter first, Iter last, Iter out)"
msgstr ""

msgid "11897        {"
msgstr ""

msgid ""
"11898            return copy_helper(first, last, out, typename "
"copy_trait<Iter>::tag{})"
msgstr ""

msgid "11899        }"
msgstr ""

msgid ""
"11900        void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, "
"vector<string>& vs2)"
msgstr ""

msgid "11901        {"
msgstr ""

msgid ""
"11902            copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove"
msgstr ""

msgid ""
"11903            copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop "
"calling copy constructors"
msgstr ""

msgid "11904        }"
msgstr ""

msgid ""
"11905    This is a general and powerful technique for compile-time algorithm "
"selection."
msgstr ""

msgid "11906    ##### Note"
msgstr ""

msgid ""
"11907    When `concept`s become widely available such alternatives can be "
"distinguished directly:"
msgstr ""

msgid "11908        template<class Iter>"
msgstr ""

msgid "11909            requires Pod<Value_type<iter>>"
msgstr ""

msgid "11910        Out copy_helper(In, first, In last, Out out)"
msgstr ""

msgid "11911        {"
msgstr ""

msgid "11912            // use memmove"
msgstr ""

msgid "11913        }"
msgstr ""

msgid "11914        template<class Iter>"
msgstr ""

msgid "11915        Out copy_helper(In, first, In last, Out out)"
msgstr ""

msgid "11916        {"
msgstr ""

msgid "11917            // use loop calling copy constructors"
msgstr ""

msgid "11918        }"
msgstr ""

msgid "11919    ##### Enforcement"
msgstr ""

msgid "11920    ???"
msgstr ""

msgid ""
"11921    ### <a name=\"Rt-specialization2\"></a>T.67: Use specialization to "
"provide alternative implementations for irregular types"
msgstr ""

msgid "11922    ##### Reason"
msgstr ""

msgid "11923     ???"
msgstr ""

msgid "11924    ##### Example"
msgstr ""

msgid "11925        ???"
msgstr ""

msgid "11926    ##### Enforcement"
msgstr ""

msgid "11927    ???"
msgstr ""

msgid ""
"11928    ### <a name=\"Rt-cast\"></a>T.68: Use `{}` rather than `()` within "
"templates to avoid ambiguities"
msgstr ""

msgid "11929    ##### Reason"
msgstr ""

msgid "11930     `()` is vulnerable to grammar ambiguities."
msgstr ""

msgid "11931    ##### Example"
msgstr ""

msgid "11932        template<typename T, typename U>"
msgstr ""

msgid "11933        void f(T t, U u)"
msgstr ""

msgid "11934        {"
msgstr ""

msgid "11935            T v1(x);    // is v1 a function of a variable?"
msgstr ""

msgid "11936            T v2 {x};   // variable"
msgstr ""

msgid "11937            auto x = T(u);  // construction or cast?"
msgstr ""

msgid "11938        }"
msgstr ""

msgid "11939        f(1, \"asdf\"); // bad: cast from const char* to int"
msgstr ""

msgid "11940    ##### Enforcement"
msgstr ""

msgid "11941    * flag `()` initializers"
msgstr ""

msgid "11942    * flag function-style casts"
msgstr ""

msgid ""
"11943    ### <a name=\"Rt-customization\"></a>T.69: Inside a template, don't "
"make an unqualified nonmember function call unless you intend it to be a "
"customization point"
msgstr ""

msgid "11944    ##### Reason"
msgstr ""

msgid "11945    * Provide only intended flexibility."
msgstr ""

msgid "11946    * Avoid vulnerability to accidental environmental changes."
msgstr ""

msgid "11947    ##### Example"
msgstr ""

msgid ""
"11948    There are three major ways to let calling code customize a template."
""
msgstr ""

msgid "11949        template<class T>"
msgstr ""

msgid "11950            // Call a member function"
msgstr ""

msgid "11951        void test1(T t)"
msgstr ""

msgid "11952        {"
msgstr ""

msgid "11953            t.f();    // require T to provide f()"
msgstr ""

msgid "11954        }"
msgstr ""

msgid "11955        template<class T>"
msgstr ""

msgid "11956        void test2(T t)"
msgstr ""

msgid "11957            // Call a nonmember function without qualification"
msgstr ""

msgid "11958        {"
msgstr ""

msgid ""
"11959            f(t);  // require f(/*T*/) be available in caller's scope "
"or in T's namespace"
msgstr ""

msgid "11960        }"
msgstr ""

msgid "11961        template<class T>"
msgstr ""

msgid "11962        void test3(T t)"
msgstr ""

msgid "11963            // Invoke a \"trait\""
msgstr ""

msgid "11964        {"
msgstr ""

msgid ""
"11965            test_traits<T>::f(t); // require customizing test_traits<>"
msgstr ""

msgid ""
"11966                                  // to get non-default functions/types"
msgstr ""

msgid "11967        }"
msgstr ""

msgid "11968    A trait is usually a type alias to compute a type,"
msgstr ""

msgid "11969    a `constexpr` function to compute a value,"
msgstr ""

msgid ""
"11970    or a traditional traits template to be specialized on the user's "
"type."
msgstr ""

msgid "11971    ##### Note"
msgstr ""

msgid ""
"11972    If you intend to call your own helper function `helper(t)` with a "
"value `t` that depends on a template type parameter,"
msgstr ""

msgid ""
"11973    put it in a `::detail` namespace and qualify the call as `detail::"
"helper(t);`."
msgstr ""

msgid ""
"11974    An unqualified call becomes a customization point where any "
"function `helper` in the namespace of `t`'s type can be invoked;"
msgstr ""

msgid ""
"11975    this can cause problems like [unintentionally invoking "
"unconstrained function templates](#Rt-unconstrained-adl)."
msgstr ""

msgid "11976    ##### Enforcement"
msgstr ""

msgid ""
"11977    * In a template, flag an unqualified call to a nonmember function "
"that passes a variable of dependent type when there is a nonmember function "
"of the same name in the template's namespace."
msgstr ""

msgid ""
"11978    ## <a name=\"SS-temp-hier\"></a>T.temp-hier: Template and hierarchy "
"rules:"
msgstr ""

msgid ""
"11979    Templates are the backbone of C++'s support for generic programming "
"and class hierarchies the backbone of its support"
msgstr ""

msgid "11980    for object-oriented programming."
msgstr ""

msgid ""
"11981    The two language mechanisms can be used effectively in combination, "
"but a few design pitfalls must be avoided."
msgstr ""

msgid ""
"11982    ### <a name=\"Rt-hier\"></a>T.80: Do not naively templatize a class "
"hierarchy"
msgstr ""

msgid "11983    ##### Reason"
msgstr ""

msgid ""
"11984    Templating a class hierarchy that has many functions, especially "
"many virtual functions, can lead to code bloat."
msgstr ""

msgid "11985    ##### Example, bad"
msgstr ""

msgid "11986        template<typename T>"
msgstr ""

msgid "11987        struct Container {         // an interface"
msgstr ""

msgid "11988            virtual T* get(int i);"
msgstr ""

msgid "11989            virtual T* first();"
msgstr ""

msgid "11990            virtual T* next();"
msgstr ""

msgid "11991            virtual void sort();"
msgstr ""

msgid "11992        };"
msgstr ""

msgid "11993        template<typename T>"
msgstr ""

msgid "11994        class Vector : public Container<T> {"
msgstr ""

msgid "11995        public:"
msgstr ""

msgid "11996            // ..."
msgstr ""

msgid "11997        };"
msgstr ""

msgid "11998        Vector<int> vi;"
msgstr ""

msgid "11999        Vector<string> vs;"
msgstr ""

msgid ""
"12000    It is probably a dumb idea to define a `sort` as a member function "
"of a container, but it is not unheard of and it makes a good example of what "
"not to do."
msgstr ""

msgid ""
"12001    Given this, the compiler cannot know if `vector<int>::sort()` is "
"called, so it must generate code for it."
msgstr ""

msgid "12002    Similar for `vector<string>::sort()`."
msgstr ""

msgid "12003    Unless those two functions are called that's code bloat."
msgstr ""

msgid ""
"12004    Imagine what this would do to a class hierarchy with dozens of "
"member functions and dozens of derived classes with many instantiations."
msgstr ""

msgid "12005    ##### Note"
msgstr ""

msgid ""
"12006    In many cases you can provide a stable interface by not "
"parameterizing a base;"
msgstr ""

msgid "12007    see [\"stable base\"](#Rt-abi) and [OO and GP](#Rt-generic-oo)"
msgstr ""

msgid "12008    ##### Enforcement"
msgstr ""

msgid ""
"12009    * Flag virtual functions that depend on a template argument. ??? "
"False positives"
msgstr ""

msgid ""
"12010    ### <a name=\"Rt-array\"></a>T.81: Do not mix hierarchies and "
"arrays"
msgstr ""

msgid "12011    ##### Reason"
msgstr ""

msgid ""
"12012    An array of derived classes can implicitly \"decay\" to a pointer "
"to a base class with potential disastrous results."
msgstr ""

msgid "12013    ##### Example"
msgstr ""

msgid "12014    Assume that `Apple` and `Pear` are two kinds of `Fruit`s."
msgstr ""

msgid "12015        void maul(Fruit* p)"
msgstr ""

msgid "12016        {"
msgstr ""

msgid "12017            *p = Pear{};     // put a Pear into *p"
msgstr ""

msgid "12018            p[1] = Pear{};   // put a Pear into p[1]"
msgstr ""

msgid "12019        }"
msgstr ""

msgid ""
"12020        Apple aa [] = { an_apple, another_apple };   // aa contains "
"Apples (obviously!)"
msgstr ""

msgid "12021        maul(aa);"
msgstr ""

msgid "12022        Apple& a0 = &aa[0];   // a Pear?"
msgstr ""

msgid "12023        Apple& a1 = &aa[1];   // a Pear?"
msgstr ""

msgid ""
"12024    Probably, `aa[0]` will be a `Pear` (without the use of a cast!)."
msgstr ""

msgid ""
"12025    If `sizeof(Apple) != sizeof(Pear)` the access to `aa[1]` will not "
"be aligned to the proper start of an object in the array."
msgstr ""

msgid ""
"12026    We have a type violation and possibly (probably) a memory "
"corruption."
msgstr ""

msgid "12027    Never write such code."
msgstr ""

msgid ""
"12028    Note that `maul()` violates the a [`T*` points to an individual "
"object rule](#Rf-ptr)."
msgstr ""

msgid "12029    **Alternative**: Use a proper (templatized) container:"
msgstr ""

msgid "12030        void maul2(Fruit* p)"
msgstr ""

msgid "12031        {"
msgstr ""

msgid "12032            *p = Pear{};   // put a Pear into *p"
msgstr ""

msgid "12033        }"
msgstr ""

msgid ""
"12034        vector<Apple> va = { an_apple, another_apple };   // va "
"contains Apples (obviously!)"
msgstr ""

msgid ""
"12035        maul2(va);       // error: cannot convert a vector<Apple> to a "
"Fruit*"
msgstr ""

msgid "12036        maul2(&va[0]);   // you asked for it"
msgstr ""

msgid "12037        Apple& a0 = &va[0];   // a Pear?"
msgstr ""

msgid ""
"12038    Note that the assignment in `maul2()` violated the [no-slicing "
"rule](#Res-slice)."
msgstr ""

msgid "12039    ##### Enforcement"
msgstr ""

msgid "12040    * Detect this horror!"
msgstr ""

msgid ""
"12041    ### <a name=\"Rt-linear\"></a>T.82: Linearize a hierarchy when "
"virtual functions are undesirable"
msgstr ""

msgid "12042    ##### Reason"
msgstr ""

msgid "12043     ???"
msgstr ""

msgid "12044    ##### Example"
msgstr ""

msgid "12045        ???"
msgstr ""

msgid "12046    ##### Enforcement"
msgstr ""

msgid "12047    ???"
msgstr ""

msgid ""
"12048    ### <a name=\"Rt-virtual\"></a>T.83: Do not declare a member "
"function template virtual"
msgstr ""

msgid "12049    ##### Reason"
msgstr ""

msgid "12050    C++ does not support that."
msgstr ""

msgid "12051    If it did, vtbls could not be generated until link time."
msgstr ""

msgid ""
"12052    And in general, implementations must deal with dynamic linking."
msgstr ""

msgid "12053    ##### Example, don't"
msgstr ""

msgid "12054        class Shape {"
msgstr ""

msgid "12055            // ..."
msgstr ""

msgid "12056            template<class T>"
msgstr ""

msgid ""
"12057            virtual bool intersect(T* p);   // error: template cannot "
"be virtual"
msgstr ""

msgid "12058        };"
msgstr ""

msgid "12059    ##### Note"
msgstr ""

msgid "12060    We need a rule because people keep asking about this"
msgstr ""

msgid "12061    ##### Alternative"
msgstr ""

msgid "12062    Double dispatch, visitors, calculate which function to call"
msgstr ""

msgid "12063    ##### Enforcement"
msgstr ""

msgid "12064    The compiler handles that."
msgstr ""

msgid ""
"12065    ### <a name=\"Rt-abi\"></a>T.84: Use a non-template core "
"implementation to provide an ABI-stable interface"
msgstr ""

msgid "12066    ##### Reason"
msgstr ""

msgid "12067    Improve stability of code."
msgstr ""

msgid "12068    Avoid code bloat."
msgstr ""

msgid "12069    ##### Example"
msgstr ""

msgid "12070    It could be a base class:"
msgstr ""

msgid "12071        struct Link_base {   // stable"
msgstr ""

msgid "12072            Link_base* suc;"
msgstr ""

msgid "12073            Link_base* pre;"
msgstr ""

msgid "12074        };"
msgstr ""

msgid ""
"12075        template<typename T>   // templated wrapper to add type safety"
msgstr ""

msgid "12076        struct Link : Link_base {"
msgstr ""

msgid "12077            T val;"
msgstr ""

msgid "12078        };"
msgstr ""

msgid "12079        struct List_base {"
msgstr ""

msgid "12080            Link_base* first;   // first element (if any)"
msgstr ""

msgid "12081            int sz;             // number of elements"
msgstr ""

msgid "12082            void add_front(Link_base* p);"
msgstr ""

msgid "12083            // ..."
msgstr ""

msgid "12084        };"
msgstr ""

msgid "12085        template<typename T>"
msgstr ""

msgid "12086        class List : List_base {"
msgstr ""

msgid "12087        public:"
msgstr ""

msgid ""
"12088            void put_front(const T& e) { add_front(new Link<T>{e}); }   "
"// implicit cast to Link_base"
msgstr ""

msgid ""
"12089            T& front() { static_cast<Link<T>*>(first).val; }   // "
"explicit cast back to Link<T>"
msgstr ""

msgid "12090            // ..."
msgstr ""

msgid "12091        };"
msgstr ""

msgid "12092        List<int> li;"
msgstr ""

msgid "12093        List<string> ls;"
msgstr ""

msgid ""
"12094    Now there is only one copy of the operations linking and unlinking "
"elements of a `List`."
msgstr ""

msgid ""
"12095    The `Link` and `List` classes do nothing but type manipulation."
msgstr ""

msgid ""
"12096    Instead of using a separate \"base\" type, another common technique "
"is to specialize for `void` or `void*` and have the general template for `T` "
"be just the safely-encapsulated casts to and from the core `void` "
"implementation."
msgstr ""

msgid "12097    **Alternative**: Use a [Pimpl](#Ri-pimpl) implementation."
msgstr ""

msgid "12098    ##### Enforcement"
msgstr ""

msgid "12099    ???"
msgstr ""

msgid "12100    ## <a name=\"SS-variadic\"></a>T.var: Variadic template rules"
msgstr ""

msgid "12101    ???"
msgstr ""

msgid ""
"12102    ### <a name=\"Rt-variadic\"></a>T.100: Use variadic templates when "
"you need a function that takes a variable number of arguments of a variety "
"of types"
msgstr ""

msgid "12103    ##### Reason"
msgstr ""

msgid ""
"12104    Variadic templates is the most general mechanism for that, and is "
"both efficient and type-safe. Don't use C varargs."
msgstr ""

msgid "12105    ##### Example"
msgstr ""

msgid "12106        ??? printf"
msgstr ""

msgid "12107    ##### Enforcement"
msgstr ""

msgid "12108    * Flag uses of `va_arg` in user code."
msgstr ""

msgid ""
"12109    ### <a name=\"Rt-variadic-pass\"></a>T.101: ??? How to pass "
"arguments to a variadic template ???"
msgstr ""

msgid "12110    ##### Reason"
msgstr ""

msgid "12111     ???"
msgstr ""

msgid "12112    ##### Example"
msgstr ""

msgid "12113        ??? beware of move-only and reference arguments"
msgstr ""

msgid "12114    ##### Enforcement"
msgstr ""

msgid "12115    ???"
msgstr ""

msgid ""
"12116    ### <a name=\"Rt-variadic-process\"></a>T.102: How to process "
"arguments to a variadic template"
msgstr ""

msgid "12117    ##### Reason"
msgstr ""

msgid "12118     ???"
msgstr ""

msgid "12119    ##### Example"
msgstr ""

msgid "12120        ??? forwarding, type checking, references"
msgstr ""

msgid "12121    ##### Enforcement"
msgstr ""

msgid "12122    ???"
msgstr ""

msgid ""
"12123    ### <a name=\"Rt-variadic-not\"></a>T.103: Don't use variadic "
"templates for homogeneous argument lists"
msgstr ""

msgid "12124    ##### Reason"
msgstr ""

msgid ""
"12125    There are more precise ways of specifying a homogeneous sequence, "
"such as an `initializer_list`."
msgstr ""

msgid "12126    ##### Example"
msgstr ""

msgid "12127        ???"
msgstr ""

msgid "12128    ##### Enforcement"
msgstr ""

msgid "12129    ???"
msgstr ""

msgid ""
"12130    ## <a name=\"SS-meta\"></a>T.meta: Template metaprogramming (TMP)"
msgstr ""

msgid ""
"12131    Templates provide a general mechanism for compile-time programming."
msgstr ""

msgid ""
"12132    Metaprogramming is programming where at least one input or one "
"result is a type."
msgstr ""

msgid ""
"12133    Templates offer Turing-complete (modulo memory capacity) duck "
"typing at compile time."
msgstr ""

msgid "12134    The syntax and techniques needed are pretty horrendous."
msgstr ""

msgid ""
"12135    ### <a name=\"Rt-metameta\"></a>T.120: Use template metaprogramming "
"only when you really need to"
msgstr ""

msgid "12136    ##### Reason"
msgstr ""

msgid ""
"12137    Template metaprogramming is hard to get right, slows down "
"compilation, and is often very hard to maintain."
msgstr ""

msgid ""
"12138    However, there are real-world examples where template "
"metaprogramming provides better performance than any alternative short of "
"expert-level assembly code."
msgstr ""

msgid ""
"12139    Also, there are real-world examples where template metaprogramming "
"expresses the fundamental ideas better than run-time code."
msgstr ""

msgid ""
"12140    For example, if you really need AST manipulation at compile time (e."
"g., for optional matrix operation folding) there may be no other way in C++."
msgstr ""

msgid "12141    ##### Example, bad"
msgstr ""

msgid "12142        ???"
msgstr ""

msgid "12143    ##### Example, bad"
msgstr ""

msgid "12144        enable_if"
msgstr ""

msgid ""
"12145    Instead, use concepts. But see [How to emulate concepts if you "
"don't have language support](#Rt-emulate)."
msgstr ""

msgid "12146    ##### Example"
msgstr ""

msgid "12147        ??? good"
msgstr ""

msgid ""
"12148    **Alternative**: If the result is a value, rather than a type, use "
"a [`constexpr` function](#Rt-fct)."
msgstr ""

msgid "12149    ##### Note"
msgstr ""

msgid ""
"12150    If you feel the need to hide your template metaprogramming in "
"macros, you have probably gone too far."
msgstr ""

msgid ""
"12151    ### <a name=\"Rt-emulate\"></a>T.121: Use template metaprogramming "
"primarily to emulate concepts"
msgstr ""

msgid "12152    ##### Reason"
msgstr ""

msgid ""
"12153    Until concepts become generally available, we need to emulate them "
"using TMP."
msgstr ""

msgid ""
"12154    Use cases that require concepts (e.g. overloading based on "
"concepts) are among the most common (and simple) uses of TMP."
msgstr ""

msgid "12155    ##### Example"
msgstr ""

msgid "12156        template<typename Iter>"
msgstr ""

msgid ""
"12157            /*requires*/ enable_if<random_access_iterator<Iter>, void>"
msgstr ""

msgid "12158        advance(Iter p, int n) { p += n; }"
msgstr ""

msgid "12159        template<typename Iter>"
msgstr ""

msgid "12160            /*requires*/ enable_if<forward_iterator<Iter>, void>"
msgstr ""

msgid ""
"12161        advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;}"
msgstr ""

msgid "12162    ##### Note"
msgstr ""

msgid "12163    Such code is much simpler using concepts:"
msgstr ""

msgid "12164        void advance(RandomAccessIterator p, int n) { p += n; }"
msgstr ""

msgid ""
"12165        void advance(ForwardIterator p, int n) { assert(n >= 0); while "
"(n--) ++p;}"
msgstr ""

msgid "12166    ##### Enforcement"
msgstr ""

msgid "12167    ???"
msgstr ""

msgid ""
"12168    ### <a name=\"Rt-tmp\"></a>T.122: Use templates (usually template "
"aliases) to compute types at compile time"
msgstr ""

msgid "12169    ##### Reason"
msgstr ""

msgid ""
"12170    Template metaprogramming is the only directly supported and half-"
"way principled way of generating types at compile time."
msgstr ""

msgid "12171    ##### Note"
msgstr ""

msgid ""
"12172    \"Traits\" techniques are mostly replaced by template aliases to "
"compute types and `constexpr` functions to compute values."
msgstr ""

msgid "12173    ##### Example"
msgstr ""

msgid "12174        ??? big object / small object optimization"
msgstr ""

msgid "12175    ##### Enforcement"
msgstr ""

msgid "12176    ???"
msgstr ""

msgid ""
"12177    ### <a name=\"Rt-fct\"></a>T.123: Use `constexpr` functions to "
"compute values at compile time"
msgstr ""

msgid "12178    ##### Reason"
msgstr ""

msgid ""
"12179    A function is the most obvious and conventional way of expressing "
"the computation of a value."
msgstr ""

msgid ""
"12180    Often a `constexpr` function implies less compile-time overhead "
"than alternatives."
msgstr ""

msgid "12181    ##### Note"
msgstr ""

msgid ""
"12182    \"Traits\" techniques are mostly replaced by template aliases to "
"compute types and `constexpr` functions to compute values."
msgstr ""

msgid "12183    ##### Example"
msgstr ""

msgid "12184        template<typename T>"
msgstr ""

msgid "12185            // requires Number<T>"
msgstr ""

msgid "12186        constexpr T pow(T v, int n)   // power/exponential"
msgstr ""

msgid "12187        {"
msgstr ""

msgid "12188            T res = 1;"
msgstr ""

msgid "12189            while (n--) res *= v;"
msgstr ""

msgid "12190            return res;"
msgstr ""

msgid "12191        }"
msgstr ""

msgid "12192        constexpr auto f7 = pow(pi, 7);"
msgstr ""

msgid "12193    ##### Enforcement"
msgstr ""

msgid ""
"12194    * Flag template metaprograms yielding a value. These should be "
"replaced with `constexpr` functions."
msgstr ""

msgid ""
"12195    ### <a name=\"Rt-std-tmp\"></a>T.124: Prefer to use standard-"
"library TMP facilities"
msgstr ""

msgid "12196    ##### Reason"
msgstr ""

msgid ""
"12197    Facilities defined in the standard, such as `conditional`, "
"`enable_if`, and `tuple`, are portable and can be assumed to be known."
msgstr ""

msgid "12198    ##### Example"
msgstr ""

msgid "12199        ???"
msgstr ""

msgid "12200    ##### Enforcement"
msgstr ""

msgid "12201    ???"
msgstr ""

msgid ""
"12202    ### <a name=\"Rt-lib\"></a>T.125: If you need to go beyond the "
"standard-library TMP facilities, use an existing library"
msgstr ""

msgid "12203    ##### Reason"
msgstr ""

msgid ""
"12204    Getting advanced TMP facilities is not easy and using a library "
"makes you part of a (hopefully supportive) community."
msgstr ""

msgid ""
"12205    Write your own \"advanced TMP support\" only if you really have to."
msgstr ""

msgid "12206    ##### Example"
msgstr ""

msgid "12207        ???"
msgstr ""

msgid "12208    ##### Enforcement"
msgstr ""

msgid "12209    ???"
msgstr ""

msgid "12210    ## <a name=\"SS-temp-other\"></a>Other template rules"
msgstr ""

msgid ""
"12211    ### <a name=\"Rt-name\"></a>T.140: Name all operations with "
"potential for reuse"
msgstr ""

msgid "12212    ##### Reason"
msgstr ""

msgid "12213    Documentation, readability, opportunity for reuse."
msgstr ""

msgid "12214    ##### Example"
msgstr ""

msgid "12215        struct Rec {"
msgstr ""

msgid "12216            string name;"
msgstr ""

msgid "12217            string addr;"
msgstr ""

msgid "12218            int id;         // unique identifier"
msgstr ""

msgid "12219        };"
msgstr ""

msgid "12220        bool same(const Rec& a, const Rec& b)"
msgstr ""

msgid "12221        {"
msgstr ""

msgid "12222            return a.id == b.id;"
msgstr ""

msgid "12223        }"
msgstr ""

msgid ""
"12224        vector<Rec*> find_id(const string& name);    // find all "
"records for \"name\""
msgstr ""

msgid "12225        auto x = find_if(vr.begin(), vr.end(),"
msgstr ""

msgid "12226            [&](Rec& r) {"
msgstr ""

msgid ""
"12227                if (r.name.size() != n.size()) return false; // name to "
"compare to is in n"
msgstr ""

msgid "12228                for (int i = 0; i < r.name.size(); ++i)"
msgstr ""

msgid ""
"12229                    if (tolower(r.name[i]) != tolower(n[i])) return "
"false;"
msgstr ""

msgid "12230                return true;"
msgstr ""

msgid "12231            }"
msgstr ""

msgid "12232        );"
msgstr ""

msgid ""
"12233    There is a useful function lurking here (case insensitive string "
"comparison), as there often is when lambda arguments get large."
msgstr ""

msgid ""
"12234        bool compare_insensitive(const string& a, const string& b)"
msgstr ""

msgid "12235        {"
msgstr ""

msgid "12236            if (a.size() != b.size()) return false;"
msgstr ""

msgid ""
"12237            for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != "
"tolower(b[i])) return false;"
msgstr ""

msgid "12238            return true;"
msgstr ""

msgid "12239        }"
msgstr ""

msgid "12240        auto x = find_if(vr.begin(), vr.end(),"
msgstr ""

msgid "12241            [&](Rec& r) { compare_insensitive(r.name, n); }"
msgstr ""

msgid "12242        );"
msgstr ""

msgid ""
"12243    Or maybe (if you prefer to avoid the implicit name binding to n):"
msgstr ""

msgid ""
"12244        auto cmp_to_n = [&n](const string& a) { return "
"compare_insensitive(a, n); };"
msgstr ""

msgid "12245        auto x = find_if(vr.begin(), vr.end(),"
msgstr ""

msgid "12246            [](const Rec& r) { return cmp_to_n(r.name); }"
msgstr ""

msgid "12247        );"
msgstr ""

msgid "12248    ##### Note"
msgstr ""

msgid "12249    whether functions, lambdas, or operators."
msgstr ""

msgid "12250    ##### Exception"
msgstr ""

msgid ""
"12251    * Lambdas logically used only locally, such as an argument to "
"`for_each` and similar control flow algorithms."
msgstr ""

msgid "12252    * Lambdas as [initializers](#???)"
msgstr ""

msgid "12253    ##### Enforcement"
msgstr ""

msgid "12254    * (hard) flag similar lambdas"
msgstr ""

msgid "12255    * ???"
msgstr ""

msgid ""
"12256    ### <a name=\"Rt-lambda\"></a>T.141: Use an unnamed lambda if you "
"need a simple function object in one place only"
msgstr ""

msgid "12257    ##### Reason"
msgstr ""

msgid ""
"12258    That makes the code concise and gives better locality than "
"alternatives."
msgstr ""

msgid "12259    ##### Example"
msgstr ""

msgid ""
"12260        auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),"
msgstr ""

msgid ""
"12261                                            [](const User &a) { return "
"a.id > 100; });"
msgstr ""

msgid "12262    ##### Exception"
msgstr ""

msgid ""
"12263    Naming a lambda can be useful for clarity even if it is used only "
"once."
msgstr ""

msgid "12264    ##### Enforcement"
msgstr ""

msgid ""
"12265    * Look for identical and near identical lambdas (to be replaced "
"with named functions or named lambdas)."
msgstr ""

msgid ""
"12266    ### <a name=\"Rt-var\"></a>T.142?: Use template variables to "
"simplify notation"
msgstr ""

msgid "12267    ##### Reason"
msgstr ""

msgid "12268    Improved readability."
msgstr ""

msgid "12269    ##### Example"
msgstr ""

msgid "12270        ???"
msgstr ""

msgid "12271    ##### Enforcement"
msgstr ""

msgid "12272    ???"
msgstr ""

msgid ""
"12273    ### <a name=\"Rt-nongeneric\"></a>T.143: Don't write "
"unintentionally nongeneric code"
msgstr ""

msgid "12274    ##### Reason"
msgstr ""

msgid ""
"12275    Generality. Reusability. Don't gratuitously commit to details; use "
"the most general facilities available."
msgstr ""

msgid "12276    ##### Example"
msgstr ""

msgid ""
"12277    Use `!=` instead of `<` to compare iterators; `!=` works for more "
"objects because it doesn't rely on ordering."
msgstr ""

msgid "12278        for (auto i = first; i < last; ++i) {   // less generic"
msgstr ""

msgid "12279            // ..."
msgstr ""

msgid "12280        }"
msgstr ""

msgid ""
"12281        for (auto i = first; i != last; ++i) {   // good; more generic"
msgstr ""

msgid "12282            // ..."
msgstr ""

msgid "12283        }"
msgstr ""

msgid ""
"12284    Of course, range-`for` is better still where it does what you want."
msgstr ""

msgid "12285    ##### Example"
msgstr ""

msgid ""
"12286    Use the least-derived class that has the functionality you need."
msgstr ""

msgid "12287        class Base {"
msgstr ""

msgid "12288        public:"
msgstr ""

msgid "12289            Bar f();"
msgstr ""

msgid "12290            Bar g();"
msgstr ""

msgid "12291        };"
msgstr ""

msgid "12292        class Derived1 : public Base {"
msgstr ""

msgid "12293        public:"
msgstr ""

msgid "12294            Bar h();"
msgstr ""

msgid "12295        };"
msgstr ""

msgid "12296        class Derived2 : public Base {"
msgstr ""

msgid "12297        public:"
msgstr ""

msgid "12298            Bar j();"
msgstr ""

msgid "12299        };"
msgstr ""

msgid ""
"12300        // bad, unless there is a specific reason for limiting to "
"Derived1 objects only"
msgstr ""

msgid "12301        void my_func(Derived1& param)"
msgstr ""

msgid "12302        {"
msgstr ""

msgid "12303            use(param.f());"
msgstr ""

msgid "12304            use(param.g());"
msgstr ""

msgid "12305        }"
msgstr ""

msgid "12306        // good, uses only Base interface so only commit to that"
msgstr ""

msgid "12307        void my_func(Base& param)"
msgstr ""

msgid "12308        {"
msgstr ""

msgid "12309            use(param.f());"
msgstr ""

msgid "12310            use(param.g());"
msgstr ""

msgid "12311        }"
msgstr ""

msgid "12312    ##### Enforcement"
msgstr ""

msgid "12313    * Flag comparison of iterators using `<` instead of `!=`."
msgstr ""

msgid ""
"12314    * Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is "
"available. Emptiness works for more containers than size(), because some "
"containers don't know their size or are conceptually of unbounded size."
msgstr ""

msgid ""
"12315    * Flag functions that take a pointer or reference to a more-derived "
"type but only use functions declared in a base type."
msgstr ""

msgid ""
"12316    ### <a name=\"Rt-specialize-function\"></a>T.144: Don't specialize "
"function templates"
msgstr ""

msgid "12317    ##### Reason"
msgstr ""

msgid ""
"12318    You can't partially specialize a function template per language "
"rules. You can fully specialize a function template but you almost certainly "
"want to overload instead -- because function template specializations don't "
"participate in overloading, they don't act as you probably wanted. Rarely, "
"you should actually specialize by delegating to a class template that you "
"can specialize properly."
msgstr ""

msgid "12319    ##### Example"
msgstr ""

msgid "12320        ???"
msgstr ""

msgid ""
"12321    **Exceptions**: If you do have a valid reason to specialize a "
"function template, just write a single function template that delegates to a "
"class template, then specialize the class template (including the ability to "
"write partial specializations)."
msgstr ""

msgid "12322    ##### Enforcement"
msgstr ""

msgid ""
"12323    * Flag all specializations of a function template. Overload instead."
""
msgstr ""

msgid ""
"12324    ### <a name=\"Rt-check-class\"></a>T.150: Check that a class "
"matches a concept using `static_assert`"
msgstr ""

msgid "12325    ##### Reason"
msgstr ""

msgid ""
"12326    If you intend for a class to match a concept, verifying that early "
"saves users pain."
msgstr ""

msgid "12327    ##### Example"
msgstr ""

msgid "12328        class X {"
msgstr ""

msgid "12329        public:"
msgstr ""

msgid "12330            X() = delete;"
msgstr ""

msgid "12331            X(const X&) = default;"
msgstr ""

msgid "12332            X(X&&) = default;"
msgstr ""

msgid "12333            X& operator=(const X&) = default;"
msgstr ""

msgid "12334            // ..."
msgstr ""

msgid "12335        };"
msgstr ""

msgid ""
"12336    Somewhere, possibly in an implementation file, let the compiler "
"check the desired properties of `X`:"
msgstr ""

msgid ""
"12337        static_assert(Default_constructible<X>);    // error: X has no "
"default constructor"
msgstr ""

msgid ""
"12338        static_assert(Copyable<X>);                 // error: we forgot "
"to define X's move constructor"
msgstr ""

msgid "12339    ##### Enforcement"
msgstr ""

msgid "12340    Not feasible."
msgstr ""

msgid "12341    # <a name=\"S-cpl\"></a>CPL: C-style programming"
msgstr ""

msgid "12342    C and C++ are closely related languages."
msgstr ""

msgid ""
"12343    They both originate in \"Classic C\" from 1978 and have evolved in "
"ISO committees since then."
msgstr ""

msgid ""
"12344    Many attempts have been made to keep them compatible, but neither "
"is a subset of the other."
msgstr ""

msgid "12345    C rule summary:"
msgstr ""

msgid "12346    * [CPL.1: Prefer C++ to C](#Rcpl-C)"
msgstr ""

msgid ""
"12347    * [CPL.2: If you must use C, use the common subset of C and C++, "
"and compile the C code as C++](#Rcpl-subset)"
msgstr ""

msgid ""
"12348    * [CPL.3: If you must use C for interfaces, use C++ in the calling "
"code using such interfaces](#Rcpl-interface)"
msgstr ""

msgid "12349    ### <a name=\"Rcpl-C\"></a>CPL.1: Prefer C++ to C"
msgstr ""

msgid "12350    ##### Reason"
msgstr ""

msgid ""
"12351    C++ provides better type checking and more notational support."
msgstr ""

msgid ""
"12352    It provides better support for high-level programming and often "
"generates faster code."
msgstr ""

msgid "12353    ##### Example"
msgstr ""

msgid "12354        char ch = 7;"
msgstr ""

msgid "12355        void* pv = &ch;"
msgstr ""

msgid "12356        int* pi = pv;   // not C++"
msgstr ""

msgid "12357        *pi = 999;      // overwrite sizeof(int) bytes near &ch"
msgstr ""

msgid ""
"12358    The rules for implicit casting to and from `void*` in C are subtle "
"and unenforced."
msgstr ""

msgid ""
"12359    In particular, this example violates a rule against converting to a "
"type with stricter alignment."
msgstr ""

msgid "12360    ##### Enforcement"
msgstr ""

msgid "12361    Use a C++ compiler."
msgstr ""

msgid ""
"12362    ### <a name=\"Rcpl-subset\"></a>CPL.2: If you must use C, use the "
"common subset of C and C++, and compile the C code as C++"
msgstr ""

msgid "12363    ##### Reason"
msgstr ""

msgid ""
"12364    That subset can be compiled with both C and C++ compilers, and when "
"compiled as C++ is better type checked than \"pure C.\""
msgstr ""

msgid "12365    ##### Example"
msgstr ""

msgid ""
"12366        int* p1 = malloc(10 * sizeof(int));                      // not "
"C++"
msgstr ""

msgid ""
"12367        int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // not "
"C, C-style C++"
msgstr ""

msgid ""
"12368        int* p3 = new int[10];                                   // not "
"C"
msgstr ""

msgid ""
"12369        int* p4 = (int*) malloc(10 * sizeof(int));               // "
"both C and C++"
msgstr ""

msgid "12370    ##### Enforcement"
msgstr ""

msgid "12371    * Flag if using a build mode that compiles code as C."
msgstr ""

msgid ""
"12372      * The C++ compiler will enforce that the code is valid C++ unless "
"you use C extension options."
msgstr ""

msgid ""
"12373    ### <a name=\"Rcpl-interface\"></a>CPL.3: If you must use C for "
"interfaces, use C++ in the calling code using such interfaces"
msgstr ""

msgid "12374    ##### Reason"
msgstr ""

msgid ""
"12375    C++ is more expressive than C and offers better support for many "
"types of programming."
msgstr ""

msgid "12376    ##### Example"
msgstr ""

msgid ""
"12377    For example, to use a 3rd party C library or C systems interface, "
"define the low-level interface in the common subset of C and C++ for better "
"type checking."
msgstr ""

msgid ""
"12378    Whenever possible encapsulate the low-level interface in an "
"interface that follows the C++ guidelines (for better abstraction, memory "
"safety, and resource safety) and use that C++ interface in C++ code."
msgstr ""

msgid "12379    ##### Example"
msgstr ""

msgid "12380    You can call C from C++:"
msgstr ""

msgid "12381        // in C:"
msgstr ""

msgid "12382        double sqrt(double);"
msgstr ""

msgid "12383        // in C++:"
msgstr ""

msgid "12384        extern \"C\" double sqrt(double);"
msgstr ""

msgid "12385        sqrt(2);"
msgstr ""

msgid "12386    ##### Example"
msgstr ""

msgid "12387    You can call C++ from C:"
msgstr ""

msgid "12388        // in C:"
msgstr ""

msgid "12389        X call_f(struct Y*, int);"
msgstr ""

msgid "12390        // in C++:"
msgstr ""

msgid "12391        extern \"C\" X call_f(Y* p, int i)"
msgstr ""

msgid "12392        {"
msgstr ""

msgid "12393            return p->f(i);   // possibly a virtual function call"
msgstr ""

msgid "12394        }"
msgstr ""

msgid "12395    ##### Enforcement"
msgstr ""

msgid "12396    None needed"
msgstr ""

msgid "12397    # <a name=\"S-source\"></a>SF: Source files"
msgstr ""

msgid ""
"12398    Distinguish between declarations (used as interfaces) and "
"definitions (used as implementations)."
msgstr ""

msgid ""
"12399    Use header files to represent interfaces and to emphasize logical "
"structure."
msgstr ""

msgid "12400    Source file rule summary:"
msgstr ""

msgid ""
"12401    * [SF.1: Use a `.cpp` suffix for code files and `.h` for interface "
"files if your project doesn't already follow another convention](#Rs-file-"
"suffix)"
msgstr ""

msgid ""
"12402    * [SF.2: A `.h` file may not contain object definitions or non-"
"inline function definitions](#Rs-inline)"
msgstr ""

msgid ""
"12403    * [SF.3: Use `.h` files for all declarations used in multiple "
"source files](#Rs-declaration-header)"
msgstr ""

msgid ""
"12404    * [SF.4: Include `.h` files before other declarations in a "
"file](#Rs-include-order)"
msgstr ""

msgid ""
"12405    * [SF.5: A `.cpp` file must include the `.h` file(s) that defines "
"its interface](#Rs-consistency)"
msgstr ""

msgid ""
"12406    * [SF.6: Use `using namespace` directives for transition, for "
"foundation libraries (such as `std`), or within a local scope (only)](#Rs-"
"using)"
msgstr ""

msgid ""
"12407    * [SF.7: Don't write `using namespace` at global scope in a header "
"file](#Rs-using-directive)"
msgstr ""

msgid ""
"12408    * [SF.8: Use `#include` guards for all `.h` files](#Rs-guards)"
msgstr ""

msgid ""
"12409    * [SF.9: Avoid cyclic dependencies among source files](#Rs-cycles)"
msgstr ""

msgid ""
"12410    * [SF.10: Avoid dependencies on implicitly `#include`d names](#Rs-"
"implicit)"
msgstr ""

msgid ""
"12411    * [SF.11: Header files should be self-contained](#Rs-contained)"
msgstr ""

msgid ""
"12412    * [SF.20: Use `namespace`s to express logical structure](#Rs-"
"namespace)"
msgstr ""

msgid ""
"12413    * [SF.21: Don't use an unnamed (anonymous) namespace in a "
"header](#Rs-unnamed)"
msgstr ""

msgid ""
"12414    * [SF.22: Use an unnamed (anonymous) namespace for all internal/"
"nonexported entities](#Rs-unnamed2)"
msgstr ""

msgid ""
"12415    ### <a name=\"Rs-file-suffix\"></a>SF.1: Use a `.cpp` suffix for "
"code files and `.h` for interface files if your project doesn't already "
"follow another convention"
msgstr ""

msgid "12416    ##### Reason"
msgstr ""

msgid "12417    It's a longstanding convention."
msgstr ""

msgid ""
"12418    But consistency is more important, so if your project uses "
"something else, follow that."
msgstr ""

msgid "12419    ##### Note"
msgstr ""

msgid "12420    This convention reflects a common use pattern:"
msgstr ""

msgid ""
"12421    Headers are more often shared with C to compile as both C++ and C, "
"which typically uses `.h`,"
msgstr ""

msgid ""
"12422    and it's easier to name all headers `.h` instead of having "
"different extensions for just those headers that are intended to be shared "
"with C."
msgstr ""

msgid ""
"12423    On the other hand, implementation files are rarely shared with C "
"and so should typically be distinguished from `.c` files,"
msgstr ""

msgid ""
"12424    so it's normally best to name all C++ implementation files "
"something else (such as `.cpp`)."
msgstr ""

msgid ""
"12425    The specific names `.h` and `.cpp` are not required (just "
"recommended as a default) and other names are in widespread use."
msgstr ""

msgid ""
"12426    Examples are `.hh`, `.C`, and `.cxx`. Use such names equivalently."
msgstr ""

msgid ""
"12427    In this document, we refer to `.h` and `.cpp` as a shorthand for "
"header and implementation files,"
msgstr ""

msgid "12428    even though the actual extension may be different."
msgstr ""

msgid ""
"12429    Your IDE (if you use one) may have strong opinions about suffices."
msgstr ""

msgid "12430    ##### Example"
msgstr ""

msgid "12431        // foo.h:"
msgstr ""

msgid "12432        extern int a;   // a declaration"
msgstr ""

msgid "12433        extern void foo();"
msgstr ""

msgid "12434        // foo.cpp:"
msgstr ""

msgid "12435        int a;   // a definition"
msgstr ""

msgid "12436        void foo() { ++a; }"
msgstr ""

msgid ""
"12437    `foo.h` provides the interface to `foo.cpp`. Global variables are "
"best avoided."
msgstr ""

msgid "12438    ##### Example, bad"
msgstr ""

msgid "12439        // foo.h:"
msgstr ""

msgid "12440        int a;   // a definition"
msgstr ""

msgid "12441        void foo() { ++a; }"
msgstr ""

msgid ""
"12442    `#include <foo.h>` twice in a program and you get a linker error "
"for two one-definition-rule violations."
msgstr ""

msgid "12443    ##### Enforcement"
msgstr ""

msgid "12444    * Flag non-conventional file names."
msgstr ""

msgid ""
"12445    * Check that `.h` and `.cpp` (and equivalents) follow the rules "
"below."
msgstr ""

msgid ""
"12446    ### <a name=\"Rs-inline\"></a>SF.2: A `.h` file may not contain "
"object definitions or non-inline function definitions"
msgstr ""

msgid "12447    ##### Reason"
msgstr ""

msgid ""
"12448    Including entities subject to the one-definition rule leads to "
"linkage errors."
msgstr ""

msgid "12449    ##### Example"
msgstr ""

msgid "12450        // file.h:"
msgstr ""

msgid "12451        namespace Foo {"
msgstr ""

msgid "12452            int x = 7;"
msgstr ""

msgid "12453            int xx() { return x+x; }"
msgstr ""

msgid "12454        }"
msgstr ""

msgid "12455        // file1.cpp:"
msgstr ""

msgid "12456        #include <file.h>"
msgstr ""

msgid "12457        // ... more ..."
msgstr ""

msgid "12458         // file2.cpp:"
msgstr ""

msgid "12459        #include <file.h>"
msgstr ""

msgid "12460        // ... more ..."
msgstr ""

msgid ""
"12461    Linking `file1.cpp` and `file2.cpp` will give two linker errors."
msgstr ""

msgid "12462    **Alternative formulation**: A `.h` file must contain only:"
msgstr ""

msgid ""
"12463    * `#include`s of other `.h` files (possibly with include guards)"
msgstr ""

msgid "12464    * templates"
msgstr ""

msgid "12465    * class definitions"
msgstr ""

msgid "12466    * function declarations"
msgstr ""

msgid "12467    * `extern` declarations"
msgstr ""

msgid "12468    * `inline` function definitions"
msgstr ""

msgid "12469    * `constexpr` definitions"
msgstr ""

msgid "12470    * `const` definitions"
msgstr ""

msgid "12471    * `using` alias definitions"
msgstr ""

msgid "12472    * ???"
msgstr ""

msgid "12473    ##### Enforcement"
msgstr ""

msgid "12474    Check the positive list above."
msgstr ""

msgid ""
"12475    ### <a name=\"Rs-declaration-header\"></a>SF.3: Use `.h` files for "
"all declarations used in multiple source files"
msgstr ""

msgid "12476    ##### Reason"
msgstr ""

msgid "12477    Maintainability. Readability."
msgstr ""

msgid "12478    ##### Example, bad"
msgstr ""

msgid "12479        // bar.cpp:"
msgstr ""

msgid "12480        void bar() { cout << \"bar\\n\"; }"
msgstr ""

msgid "12481        // foo.cpp:"
msgstr ""

msgid "12482        extern void bar();"
msgstr ""

msgid "12483        void foo() { bar(); }"
msgstr ""

msgid ""
"12484    A maintainer of `bar` cannot find all declarations of `bar` if its "
"type needs changing."
msgstr ""

msgid ""
"12485    The user of `bar` cannot know if the interface used is complete and "
"correct. At best, error messages come (late) from the linker."
msgstr ""

msgid "12486    ##### Enforcement"
msgstr ""

msgid ""
"12487    * Flag declarations of entities in other source files not placed in "
"a `.h`."
msgstr ""

msgid ""
"12488    ### <a name=\"Rs-include-order\"></a>SF.4: Include `.h` files "
"before other declarations in a file"
msgstr ""

msgid "12489    ##### Reason"
msgstr ""

msgid "12490    Minimize context dependencies and increase readability."
msgstr ""

msgid "12491    ##### Example"
msgstr ""

msgid "12492        #include <vector>"
msgstr ""

msgid "12493        #include <algorithm>"
msgstr ""

msgid "12494        #include <string>"
msgstr ""

msgid "12495        // ... my code here ..."
msgstr ""

msgid "12496    ##### Example, bad"
msgstr ""

msgid "12497        #include <vector>"
msgstr ""

msgid "12498        // ... my code here ..."
msgstr ""

msgid "12499        #include <algorithm>"
msgstr ""

msgid "12500        #include <string>"
msgstr ""

msgid "12501    ##### Note"
msgstr ""

msgid "12502    This applies to both `.h` and `.cpp` files."
msgstr ""

msgid "12503    ##### Note"
msgstr ""

msgid ""
"12504    There is an argument for insulating code from declarations and "
"macros in header files by `#including` headers *after* the code we want to "
"protect"
msgstr ""

msgid "12505    (as in the example labeled \"bad\")."
msgstr ""

msgid "12506    However"
msgstr ""

msgid ""
"12507    * that only works for one file (at one level): Use that technique "
"in a header included with other headers and the vulnerability reappears."
msgstr ""

msgid ""
"12508    * a namespace (an \"implementation namespace\") can protect against "
"many context dependencies."
msgstr ""

msgid "12509    * full protection and flexibility require modules."
msgstr ""

msgid "12510    **See also**:"
msgstr ""

msgid ""
"12511    * [Working Draft, Extensions to C++ for Modules](http://www.open-"
"std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)"
msgstr ""

msgid ""
"12512    * [Modules, Componentization, and Transition](http://www.open-std."
"org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)"
msgstr ""

msgid "12513    ##### Enforcement"
msgstr ""

msgid "12514    Easy."
msgstr ""

msgid ""
"12515    ### <a name=\"Rs-consistency\"></a>SF.5: A `.cpp` file must include "
"the `.h` file(s) that defines its interface"
msgstr ""

msgid "12516    ##### Reason"
msgstr ""

msgid "12517    This enables the compiler to do an early consistency check."
msgstr ""

msgid "12518    ##### Example, bad"
msgstr ""

msgid "12519        // foo.h:"
msgstr ""

msgid "12520        void foo(int);"
msgstr ""

msgid "12521        int bar(long);"
msgstr ""

msgid "12522        int foobar(int);"
msgstr ""

msgid "12523        // foo.cpp:"
msgstr ""

msgid "12524        void foo(int) { /* ... */ }"
msgstr ""

msgid "12525        int bar(double) { /* ... */ }"
msgstr ""

msgid "12526        double foobar(int);"
msgstr ""

msgid ""
"12527    The errors will not be caught until link time for a program calling "
"`bar` or `foobar`."
msgstr ""

msgid "12528    ##### Example"
msgstr ""

msgid "12529        // foo.h:"
msgstr ""

msgid "12530        void foo(int);"
msgstr ""

msgid "12531        int bar(long);"
msgstr ""

msgid "12532        int foobar(int);"
msgstr ""

msgid "12533        // foo.cpp:"
msgstr ""

msgid "12534        #include <foo.h>"
msgstr ""

msgid "12535        void foo(int) { /* ... */ }"
msgstr ""

msgid "12536        int bar(double) { /* ... */ }"
msgstr ""

msgid "12537        double foobar(int);   // error: wrong return type"
msgstr ""

msgid ""
"12538    The return-type error for `foobar` is now caught immediately when "
"`foo.cpp` is compiled."
msgstr ""

msgid ""
"12539    The argument-type error for `bar` cannot be caught until link time "
"because of the possibility of overloading, but systematic use of `.h` files "
"increases the likelihood that it is caught earlier by the programmer."
msgstr ""

msgid "12540    ##### Enforcement"
msgstr ""

msgid "12541    ???"
msgstr ""

msgid ""
"12542    ### <a name=\"Rs-using\"></a>SF.6: Use `using namespace` directives "
"for transition, for foundation libraries (such as `std`), or within a local "
"scope (only)"
msgstr ""

msgid "12543    ##### Reason"
msgstr ""

msgid ""
"12544     `using namespace` can lead to name clashes, so it should be used "
"sparingly."
msgstr ""

msgid ""
"12545     However, it is not always possible to qualify every name from a "
"namespace in user code (e.g., during transition)"
msgstr ""

msgid ""
"12546     and sometimes a namespace is so fundamental and prevalent in a "
"code base, that consistent qualification would be verbose and distracting."
msgstr ""

msgid "12547    ##### Example"
msgstr ""

msgid "12548        #include <string>"
msgstr ""

msgid "12549        #include <vector>"
msgstr ""

msgid "12550        #include <iostream>"
msgstr ""

msgid "12551        #include <memory>"
msgstr ""

msgid "12552        #include <algorithm>"
msgstr ""

msgid "12553        using namespace std;"
msgstr ""

msgid "12554        // ..."
msgstr ""

msgid ""
"12555    Here (obviously), the standard library is used pervasively and "
"apparently no other library is used, so requiring `std::` everywhere"
msgstr ""

msgid "12556    could be distracting."
msgstr ""

msgid "12557    ##### Example"
msgstr ""

msgid ""
"12558    The use of `using namespace std;` leaves the programmer open to a "
"name clash with a name from the standard library"
msgstr ""

msgid "12559        #include <cmath>"
msgstr ""

msgid "12560        using namespace std;"
msgstr ""

msgid "12561        int g(int x)"
msgstr ""

msgid "12562        {"
msgstr ""

msgid "12563            int sqrt = 7;"
msgstr ""

msgid "12564            // ..."
msgstr ""

msgid "12565            return sqrt(x); // error"
msgstr ""

msgid "12566        }"
msgstr ""

msgid ""
"12567    However, this is not particularly likely to lead to a resolution "
"that is not an error and"
msgstr ""

msgid ""
"12568    people who use `using namespace std` are supposed to know about "
"`std` and about this risk."
msgstr ""

msgid "12569    ##### Note"
msgstr ""

msgid "12570    A `.cpp` file is a form of local scope."
msgstr ""

msgid ""
"12571    There is little difference in the opportunities for name clashes in "
"an N-line `.cpp` containing a `using namespace X`,"
msgstr ""

msgid "12572    an N-line function containing a `using namespace X`,"
msgstr ""

msgid ""
"12573    and M functions each containing a `using namespace X`with N lines "
"of code in total."
msgstr ""

msgid "12574    ##### Note"
msgstr ""

msgid ""
"12575    [Don't write `using namespace` in a header file](#Rs-using-"
"directive)."
msgstr ""

msgid "12576    ##### Enforcement"
msgstr ""

msgid ""
"12577    Flag multiple `using namespace` directives for different namespaces "
"in a single source file."
msgstr ""

msgid ""
"12578    ### <a name=\"Rs-using-directive\"></a>SF.7: Don't write `using "
"namespace` at global scope in a header file"
msgstr ""

msgid "12579    ##### Reason"
msgstr ""

msgid ""
"12580    Doing so takes away an `#include`r's ability to effectively "
"disambiguate and to use alternatives. It also makes `#include`d headers "
"order-dependent as they may have different meaning when included in "
"different orders."
msgstr ""

msgid "12581    ##### Example"
msgstr ""

msgid "12582        // bad.h"
msgstr ""

msgid "12583        #include <iostream>"
msgstr ""

msgid "12584        using namespace std; // bad"
msgstr ""

msgid "12585        // user.cpp"
msgstr ""

msgid "12586        #include \"bad.h\""
msgstr ""

msgid ""
"12587        bool copy(/*... some parameters ...*/);    // some function "
"that happens to be named copy"
msgstr ""

msgid "12588        int main() {"
msgstr ""

msgid ""
"12589            copy(/*...*/);    // now overloads local ::copy and std::"
"copy, could be ambiguous"
msgstr ""

msgid "12590        }"
msgstr ""

msgid "12591    ##### Enforcement"
msgstr ""

msgid "12592    Flag `using namespace` at global scope in a header file."
msgstr ""

msgid ""
"12593    ### <a name=\"Rs-guards\"></a>SF.8: Use `#include` guards for all `."
"h` files"
msgstr ""

msgid "12594    ##### Reason"
msgstr ""

msgid "12595    To avoid files being `#include`d several times."
msgstr ""

msgid ""
"12596    In order to avoid include guard collisions, do not just name the "
"guard after the filename."
msgstr ""

msgid ""
"12597    Be sure to also include a key and good differentiator, such as the "
"name of library or component"
msgstr ""

msgid "12598    the header file is part of."
msgstr ""

msgid "12599    ##### Example"
msgstr ""

msgid "12600        // file foobar.h:"
msgstr ""

msgid "12601        #ifndef LIBRARY_FOOBAR_H"
msgstr ""

msgid "12602        #define LIBRARY_FOOBAR_H"
msgstr ""

msgid "12603        // ... declarations ..."
msgstr ""

msgid "12604        #endif // LIBRARY_FOOBAR_H"
msgstr ""

msgid "12605    ##### Enforcement"
msgstr ""

msgid "12606    Flag `.h` files without `#include` guards."
msgstr ""

msgid "12607    ##### Note"
msgstr ""

msgid ""
"12608    Some implementations offer vendor extensions like `#pragma once` as "
"alternative to include guards."
msgstr ""

msgid ""
"12609    It is not standard and it is not portable.  It injects the hosting "
"machine's filesystem semantics"
msgstr ""

msgid ""
"12610    into your program, in addition to locking you down to a vendor."
msgstr ""

msgid ""
"12611    Our recommendation is to write in ISO C++: See [rule P.2](#Rp-"
"Cplusplus)."
msgstr ""

msgid ""
"12612    ### <a name=\"Rs-cycles\"></a>SF.9: Avoid cyclic dependencies among "
"source files"
msgstr ""

msgid "12613    ##### Reason"
msgstr ""

msgid "12614    Cycles complicates comprehension and slows down compilation."
msgstr ""

msgid ""
"12615    Complicates conversion to use language-supported modules (when they "
"become available)."
msgstr ""

msgid "12616    ##### Note"
msgstr ""

msgid ""
"12617    Eliminate cycles; don't just break them with `#include` guards."
msgstr ""

msgid "12618    ##### Example, bad"
msgstr ""

msgid "12619        // file1.h:"
msgstr ""

msgid "12620        #include \"file2.h\""
msgstr ""

msgid "12621        // file2.h:"
msgstr ""

msgid "12622        #include \"file3.h\""
msgstr ""

msgid "12623        // file3.h:"
msgstr ""

msgid "12624        #include \"file1.h\""
msgstr ""

msgid "12625    ##### Enforcement"
msgstr ""

msgid "12626    Flag all cycles."
msgstr ""

msgid ""
"12627    ### <a name=\"Rs-implicit\"></a>SF.10: Avoid dependencies on "
"implicitly `#include`d names"
msgstr ""

msgid "12628    ##### Reason"
msgstr ""

msgid "12629    Avoid surprises."
msgstr ""

msgid ""
"12630    Avoid having to change `#include`s if an `#include`d header changes."
""
msgstr ""

msgid ""
"12631    Avoid accidentally becoming dependent on implementation details and "
"logically separate entities included in a header."
msgstr ""

msgid "12632    ##### Example"
msgstr ""

msgid "12633        #include <iostream>"
msgstr ""

msgid "12634        using namespace std;"
msgstr ""

msgid "12635        void use()                  // bad"
msgstr ""

msgid "12636        {"
msgstr ""

msgid "12637            string s;"
msgstr ""

msgid "12638            cin >> s;               // fine"
msgstr ""

msgid ""
"12639            getline(cin, s);        // error: getline() not defined"
msgstr ""

msgid "12640            if (s == \"surprise\") {  // error == not defined"
msgstr ""

msgid "12641                // ..."
msgstr ""

msgid "12642            }"
msgstr ""

msgid "12643        }"
msgstr ""

msgid ""
"12644    `<iostream>` exposes the definition of `std::string` (\"why?\" "
"makes for a fun trivia question),"
msgstr ""

msgid ""
"12645    but it is not required to do so by transitively including the "
"entire `<string>` header,"
msgstr ""

msgid ""
"12646    resulting in the popular beginner question \"why doesn't "
"`getline(cin,s);` work?\""
msgstr ""

msgid ""
"12647    or even an occasional \"`string`s cannot be compared with `==`)."
msgstr ""

msgid "12648    The solution is to explicitly `#include <string>`:"
msgstr ""

msgid "12649        #include <iostream>"
msgstr ""

msgid "12650        #include <string>"
msgstr ""

msgid "12651        using namespace std;"
msgstr ""

msgid "12652        void use()"
msgstr ""

msgid "12653        {"
msgstr ""

msgid "12654            string s;"
msgstr ""

msgid "12655            cin >> s;               // fine"
msgstr ""

msgid "12656            getline(cin, s);        // fine"
msgstr ""

msgid "12657            if (s == \"surprise\") {  // fine"
msgstr ""

msgid "12658                // ..."
msgstr ""

msgid "12659            }"
msgstr ""

msgid "12660        }"
msgstr ""

msgid "12661    ##### Note"
msgstr ""

msgid ""
"12662    Some headers exist exactly to collect a set of consistent "
"declarations from a variety of headers."
msgstr ""

msgid "12663    For example:"
msgstr ""

msgid "12664        // basic_std_lib.h:"
msgstr ""

msgid "12665        #include <vector>"
msgstr ""

msgid "12666        #include <string>"
msgstr ""

msgid "12667        #include <map>"
msgstr ""

msgid "12668        #include <iostream>"
msgstr ""

msgid "12669        #include <random>"
msgstr ""

msgid "12670        #include <vector>"
msgstr ""

msgid ""
"12671    a user can now get that set of declarations with a single "
"`#include`\""
msgstr ""

msgid "12672        #include \"basic_std_lib.h\""
msgstr ""

msgid ""
"12673    This rule against implicit inclusion is not meant to prevent such "
"deliberate aggregation."
msgstr ""

msgid "12674    ##### Enforcement"
msgstr ""

msgid ""
"12675    Enforcement would require some knowledge about what in a header is "
"meant to be \"exported\" to users and what is there to enable implementation."
""
msgstr ""

msgid "12676    No really good solution is possible until we have modules."
msgstr ""

msgid ""
"12677    ### <a name=\"Rs-contained\"></a>SF.11: Header files should be self-"
"contained"
msgstr ""

msgid "12678    ##### Reason"
msgstr ""

msgid ""
"12679    Usability, headers should be simple to use and work when included "
"on their own."
msgstr ""

msgid "12680    Headers should encapsulate the functionality they provide."
msgstr ""

msgid ""
"12681    Avoid clients of a header having to manage that header's "
"dependencies."
msgstr ""

msgid "12682    ##### Example"
msgstr ""

msgid "12683        #include \"helpers.h\""
msgstr ""

msgid "12684        // helpers.h depends on std::string and includes <string>"
msgstr ""

msgid "12685    ##### Note"
msgstr ""

msgid ""
"12686    Failing to follow this results in difficult to diagnose errors for "
"clients of a header."
msgstr ""

msgid "12687    ##### Enforcement"
msgstr ""

msgid ""
"12688    A test should verify that the header file itself compiles or that a "
"cpp file which only includes the header file compiles."
msgstr ""

msgid ""
"12689    ### <a name=\"Rs-namespace\"></a>SF.20: Use `namespace`s to express "
"logical structure"
msgstr ""

msgid "12690    ##### Reason"
msgstr ""

msgid "12691     ???"
msgstr ""

msgid "12692    ##### Example"
msgstr ""

msgid "12693        ???"
msgstr ""

msgid "12694    ##### Enforcement"
msgstr ""

msgid "12695    ???"
msgstr ""

msgid ""
"12696    ### <a name=\"Rs-unnamed\"></a>SF.21: Don't use an unnamed "
"(anonymous) namespace in a header"
msgstr ""

msgid "12697    ##### Reason"
msgstr ""

msgid ""
"12698    It is almost always a bug to mention an unnamed namespace in a "
"header file."
msgstr ""

msgid "12699    ##### Example"
msgstr ""

msgid "12700        ???"
msgstr ""

msgid "12701    ##### Enforcement"
msgstr ""

msgid "12702    * Flag any use of an anonymous namespace in a header file."
msgstr ""

msgid ""
"12703    ### <a name=\"Rs-unnamed2\"></a>SF.22: Use an unnamed (anonymous) "
"namespace for all internal/nonexported entities"
msgstr ""

msgid "12704    ##### Reason"
msgstr ""

msgid ""
"12705    Nothing external can depend on an entity in a nested unnamed "
"namespace."
msgstr ""

msgid ""
"12706    Consider putting every definition in an implementation source file "
"in an unnamed namespace unless that is defining an \"external/exported\" "
"entity."
msgstr ""

msgid "12707    ##### Example"
msgstr ""

msgid ""
"12708    An API class and its members can't live in an unnamed namespace; "
"but any \"helper\" class or function that is defined in an implementation "
"source file should be at an unnamed namespace scope."
msgstr ""

msgid "12709        ???"
msgstr ""

msgid "12710    ##### Enforcement"
msgstr ""

msgid "12711    * ???"
msgstr ""

msgid "12712    # <a name=\"S-stdlib\"></a>SL: The Standard Library"
msgstr ""

msgid ""
"12713    Using only the bare language, every task is tedious (in any "
"language)."
msgstr ""

msgid "12714    Using a suitable library any task can be reasonably simple."
msgstr ""

msgid "12715    The standard library has steadily grown over the years."
msgstr ""

msgid ""
"12716    Its description in the standard is now larger than that of the "
"language features."
msgstr ""

msgid ""
"12717    So, it is likely that this library section of the guidelines will "
"eventually grow in size to equal or exceed all the rest."
msgstr ""

msgid "12718    << ??? We need another level of rule numbering ??? >>"
msgstr ""

msgid "12719    C++ Standard Library component summary:"
msgstr ""

msgid "12720    * [SL.con: Containers](#SS-con)"
msgstr ""

msgid "12721    * [SL.str: String](#SS-string)"
msgstr ""

msgid "12722    * [SL.io: Iostream](#SS-io)"
msgstr ""

msgid "12723    * [SL.regex: Regex](#SS-regex)"
msgstr ""

msgid "12724    * [SL.chrono: Time](#SS-chrono)"
msgstr ""

msgid "12725    * [SL.C: The C Standard Library](#SS-clib)"
msgstr ""

msgid "12726    Standard-library rule summary:"
msgstr ""

msgid "12727    * [SL.1: Use libraries wherever possible](#Rsl-lib)"
msgstr ""

msgid ""
"12728    * [SL.2: Prefer the standard library to other libraries](#Rsl-sl)"
msgstr ""

msgid ""
"12729    * [SL.3: Do not add non-standard entities to namespace `std`](#sl-"
"std)"
msgstr ""

msgid ""
"12730    * [SL.4: Use the standard library in a type-safe manner](#sl-safe)"
msgstr ""

msgid "12731    * ???"
msgstr ""

msgid ""
"12732    ### <a name=\"Rsl-lib\"></a>SL.1:  Use libraries wherever possible"
msgstr ""

msgid "12733    ##### Reason"
msgstr ""

msgid "12734    Save time. Don't re-invent the wheel."
msgstr ""

msgid "12735    Don't replicate the work of others."
msgstr ""

msgid "12736    Benefit from other people's work when they make improvements."
msgstr ""

msgid "12737    Help other people when you make improvements."
msgstr ""

msgid ""
"12738    ### <a name=\"Rsl-sl\"></a>SL.2: Prefer the standard library to "
"other libraries"
msgstr ""

msgid "12739    ##### Reason"
msgstr ""

msgid "12740    More people know the standard library."
msgstr ""

msgid ""
"12741    It is more likely to be stable, well-maintained, and widely "
"available than your own code or most other libraries."
msgstr ""

msgid ""
"12742    ### <a name=\"sl-std\"></a>SL.3: Do not add non-standard entities "
"to namespace `std`"
msgstr ""

msgid "12743    ##### Reason"
msgstr ""

msgid ""
"12744    Adding to `std` may change the meaning of otherwise standards "
"conforming code."
msgstr ""

msgid ""
"12745    Additions to `std` may clash with future versions of the standard."
msgstr ""

msgid "12746    ##### Example"
msgstr ""

msgid "12747        ???"
msgstr ""

msgid "12748    ##### Enforcement"
msgstr ""

msgid ""
"12749    Possible, but messy and likely to cause problems with platforms."
msgstr ""

msgid ""
"12750    ### <a name=\"sl-safe\"></a>SL.4: Use the standard library in a "
"type-safe manner"
msgstr ""

msgid "12751    ##### Reason"
msgstr ""

msgid ""
"12752    Because, obviously, breaking this rule can lead to undefined "
"behavior, memory corruption, and all kinds of other bad errors."
msgstr ""

msgid "12753    ##### Note"
msgstr ""

msgid ""
"12754    This is a semi-philosophical meta-rule, which needs many supporting "
"concrete rules."
msgstr ""

msgid "12755    We need it as an umbrella for the more specific rules."
msgstr ""

msgid "12756    Summary of more specific rules:"
msgstr ""

msgid ""
"12757    * [SL.4: Use the standard library in a type-safe manner](#sl-safe)"
msgstr ""

msgid "12758    ## <a name=\"SS-con\"></a>SL.con: Containers"
msgstr ""

msgid "12759    ???"
msgstr ""

msgid "12760    Container rule summary:"
msgstr ""

msgid ""
"12761    * [SL.con.1: Prefer using STL `array` or `vector` instead of a C "
"array](#Rsl-arrays)"
msgstr ""

msgid ""
"12762    * [SL.con.2: Prefer using STL `vector` by default unless you have a "
"reason to use a different container](#Rsl-vector)"
msgstr ""

msgid "12763    * [SL.con.3: Avoid bounds errors](#Rsl-bounds)"
msgstr ""

msgid "12764    *  ???"
msgstr ""

msgid ""
"12765    ### <a name=\"Rsl-arrays\"></a>SL.con.1: Prefer using STL `array` "
"or `vector` instead of a C array"
msgstr ""

msgid "12766    ##### Reason"
msgstr ""

msgid ""
"12767    C arrays are less safe, and have no advantages over `array` and "
"`vector`."
msgstr ""

msgid ""
"12768    For a fixed-length array, use `std::array`, which does not "
"degenerate to a pointer when passed to a function and does know its size."
msgstr ""

msgid ""
"12769    Also, like a built-in array, a stack-allocated `std::array` keeps "
"its elements on the stack."
msgstr ""

msgid ""
"12770    For a variable-length array, use `std::vector`, which additionally "
"can change its size and handles memory allocation."
msgstr ""

msgid "12771    ##### Example"
msgstr ""

msgid "12772        int v[SIZE];                        // BAD"
msgstr ""

msgid "12773        std::array<int, SIZE> w;             // ok"
msgstr ""

msgid "12774    ##### Example"
msgstr ""

msgid ""
"12775        int* v = new int[initial_size];     // BAD, owning raw pointer"
msgstr ""

msgid "12776        delete[] v;                         // BAD, manual delete"
msgstr ""

msgid "12777        std::vector<int> w(initial_size);   // ok"
msgstr ""

msgid "12778    ##### Note"
msgstr ""

msgid "12779    Use `gsl::span` for non-owning references into a container."
msgstr ""

msgid "12780    ##### Note"
msgstr ""

msgid ""
"12781    Comparing the performance of a fixed-sized array allocated on the "
"stack against a `vector` with its elements on the free store is bogus."
msgstr ""

msgid ""
"12782    You could just as well compare a `std::array` on the stack against "
"the result of a `malloc()` accessed through a pointer."
msgstr ""

msgid ""
"12783    For most code, even the difference between stack allocation and "
"free-store allocation doesn't matter, but the convenience and safety of "
"`vector` does."
msgstr ""

msgid ""
"12784    People working with code for which that difference matters are "
"quite capable of choosing between `array` and `vector`."
msgstr ""

msgid "12785    ##### Enforcement"
msgstr ""

msgid ""
"12786    * Flag declaration of a C array inside a function or class that "
"also declares an STL container (to avoid excessive noisy warnings on legacy "
"non-STL code). To fix: At least change the C array to a `std::array`."
msgstr ""

msgid ""
"12787    ### <a name=\"Rsl-vector\"></a>SL.con.2: Prefer using STL `vector` "
"by default unless you have a reason to use a different container"
msgstr ""

msgid "12788    ##### Reason"
msgstr ""

msgid ""
"12789    `vector` and `array` are the only standard containers that offer "
"the fastest general-purpose access (random access, including being "
"vectorization-friendly), the fastest default access pattern (begin-to-end or "
"end-to-begin is prefetcher-friendly), and the lowest space overhead "
"(contiguous layout has zero per-element overhead, which is cache-friendly)."
msgstr ""

msgid ""
"12790    Usually you need to add and remove elements from the container, so "
"use `vector` by default; if you don't need to modify the container's size, "
"use `array`."
msgstr ""

msgid ""
"12791    Even when other containers seem more suited, such a `map` for O(log "
"N) lookup performance or a `list` for efficient insertion in the middle, a "
"`vector` will usually still perform better for containers up to a few KB in "
"size."
msgstr ""

msgid "12792    ##### Note"
msgstr ""

msgid ""
"12793    `string` should not be used as a container of individual characters."
" A `string` is a textual string; if you want a container of characters, use "
"`vector</*char_type*/>` or `array</*char_type*/>` instead."
msgstr ""

msgid "12794    ##### Exceptions"
msgstr ""

msgid ""
"12795    If you have a good reason to use another container, use that "
"instead. For example:"
msgstr ""

msgid ""
"12796    * If `vector` suits your needs but you don't need the container to "
"be variable size, use `array` instead."
msgstr ""

msgid ""
"12797    * If you want a dictionary-style lookup container that guarantees "
"O(K) or O(log N) lookups, the container will be larger (more than a few KB) "
"and you perform frequent inserts so that the overhead of maintaining a "
"sorted `vector` is infeasible, go ahead and use an `unordered_map` or `map` "
"instead."
msgstr ""

msgid "12798    ##### Enforcement"
msgstr ""

msgid ""
"12799    * Flag a `vector` whose size never changes after construction (such "
"as because it's `const` or because no non-`const` functions are called on "
"it). To fix: Use an `array` instead."
msgstr ""

msgid "12800    ### <a name=\"Rsl-bounds\"></a>SL.con.3: Avoid bounds errors"
msgstr ""

msgid "12801    ##### Reason"
msgstr ""

msgid ""
"12802    Read or write beyond an allocated range of elements typically leads "
"to bad errors, wrong results, crashes, and security violations."
msgstr ""

msgid "12803    ##### Note"
msgstr ""

msgid ""
"12804    The standard-library functions that apply to ranges of elements all "
"have (or could have) bounds-safe overloads that take `span`."
msgstr ""

msgid ""
"12805    Standard types such as `vector` can be modified to perform bounds-"
"checks under the bounds profile (in a compatible way, such as by adding "
"contracts), or used with `at()`."
msgstr ""

msgid ""
"12806    Ideally, the in-bounds guarantee should be statically enforced."
msgstr ""

msgid "12807    For example:"
msgstr ""

msgid ""
"12808    * a range-`for` cannot loop beyond the range of the container to "
"which it is applied"
msgstr ""

msgid ""
"12809    * a `v.begin(),v.end()` is easily determined to be bounds safe"
msgstr ""

msgid "12810    Such loops are as fast as any unchecked/unsafe equivalent."
msgstr ""

msgid ""
"12811    Often a simple pre-check can eliminate the need for checking of "
"individual indices."
msgstr ""

msgid "12812    For example"
msgstr ""

msgid ""
"12813    * for `v.begin(),v.begin()+i` the `i` can easily be checked against "
"`v.size()`"
msgstr ""

msgid ""
"12814    Such loops can be much faster than individually checked element "
"accesses."
msgstr ""

msgid "12815    ##### Example, bad"
msgstr ""

msgid "12816        void f()"
msgstr ""

msgid "12817        {"
msgstr ""

msgid "12818            array<int, 10> a, b;"
msgstr ""

msgid ""
"12819            memset(a.data(), 0, 10);         // BAD, and contains a "
"length error (length = 10 * sizeof(int))"
msgstr ""

msgid ""
"12820            memcmp(a.data(), b.data(), 10);  // BAD, and contains a "
"length error (length = 10 * sizeof(int))"
msgstr ""

msgid "12821        }"
msgstr ""

msgid ""
"12822    Also, `std::array<>::fill()` or `std::fill()` or even an empty "
"initializer are better candidate than `memset()`."
msgstr ""

msgid "12823    ##### Example, good"
msgstr ""

msgid "12824        void f()"
msgstr ""

msgid "12825        {"
msgstr ""

msgid ""
"12826            array<int, 10> a, b, c{};       // c is initialized to zero"
msgstr ""

msgid "12827            a.fill(0);"
msgstr ""

msgid "12828            fill(b.begin(), b.end(), 0);    // std::fill()"
msgstr ""

msgid ""
"12829            fill(b, 0);                     // std::fill() + Ranges TS"
msgstr ""

msgid "12830            if ( a == b ) {"
msgstr ""

msgid "12831              // ..."
msgstr ""

msgid "12832            }"
msgstr ""

msgid "12833        }"
msgstr ""

msgid "12834    ##### Example"
msgstr ""

msgid ""
"12835    If code is using an unmodified standard library, then there are "
"still workarounds that enable use of `std::array` and `std::vector` in a "
"bounds-safe manner. Code can call the `.at()` member function on each class, "
"which will result in an `std::out_of_range` exception being thrown. "
"Alternatively, code can call the `at()` free function, which will result in "
"fail-fast (or a customized action) on a bounds violation."
msgstr ""

msgid "12836        void f(std::vector<int>& v, std::array<int, 12> a, int i)"
msgstr ""

msgid "12837        {"
msgstr ""

msgid "12838            v[0] = a[0];        // BAD"
msgstr ""

msgid "12839            v.at(0) = a[0];     // OK (alternative 1)"
msgstr ""

msgid "12840            at(v, 0) = a[0];    // OK (alternative 2)"
msgstr ""

msgid "12841            v.at(0) = a[i];     // BAD"
msgstr ""

msgid "12842            v.at(0) = a.at(i);  // OK (alternative 1)"
msgstr ""

msgid "12843            v.at(0) = at(a, i); // OK (alternative 2)"
msgstr ""

msgid "12844        }"
msgstr ""

msgid "12845    ##### Enforcement"
msgstr ""

msgid ""
"12846    * Issue a diagnostic for any call to a standard-library function "
"that is not bounds-checked."
msgstr ""

msgid "12847    ??? insert link to a list of banned functions"
msgstr ""

msgid "12848    This rule is part of the [bounds profile](#SS-bounds)."
msgstr ""

msgid "12849    **TODO Notes**:"
msgstr ""

msgid ""
"12850    * Impact on the standard library will require close coordination "
"with WG21, if only to ensure compatibility even if never standardized."
msgstr ""

msgid ""
"12851    * We are considering specifying bounds-safe overloads for stdlib "
"(especially C stdlib) functions like `memcmp` and shipping them in the GSL."
msgstr ""

msgid ""
"12852    * For existing stdlib functions and types like `vector` that are "
"not fully bounds-checked, the goal is for these features to be bounds-"
"checked when called from code with the bounds profile on, and unchecked when "
"called from legacy code, possibly using contracts (concurrently being "
"proposed by several WG21 members)."
msgstr ""

msgid "12853    ## <a name=\"SS-string\"></a>SL.str: String"
msgstr ""

msgid "12854    Text manipulation is a huge topic."
msgstr ""

msgid "12855    `std::string` doesn't cover all of it."
msgstr ""

msgid ""
"12856    This section primarily tries to clarify `std::string`'s relation to "
"`char*`, `zstring`, `string_view`, and `gsl::string_span`."
msgstr ""

msgid ""
"12857    The important issue of non-ASCII character sets and encodings (e.g."
", `wchar_t`, Unicode, and UTF-8) will be covered elsewhere."
msgstr ""

msgid "12858    **See also**: [regular expressions](#SS-regex)"
msgstr ""

msgid ""
"12859    Here, we use \"sequence of characters\" or \"string\" to refer to a "
"sequence of characters meant to be read as text (somehow, eventually)."
msgstr ""

msgid "12860    We don't consider"
msgstr ""

msgid "12861    String summary:"
msgstr ""

msgid ""
"12862    * [SL.str.1: Use `std::string` to own character sequences](#Rstr-"
"string)"
msgstr ""

msgid ""
"12863    * [SL.str.2: Use `std::string_view` or `gsl::string_span` to refer "
"to character sequences](#Rstr-view)"
msgstr ""

msgid ""
"12864    * [SL.str.3: Use `zstring` or `czstring` to refer to a C-style, "
"zero-terminated, sequence of characters](#Rstr-zstring)"
msgstr ""

msgid ""
"12865    * [SL.str.4: Use `char*` to refer to a single character](#Rstr-"
"char*)"
msgstr ""

msgid ""
"12866    * [SL.str.5: Use `std::byte` to refer to byte values that do not "
"necessarily represent characters](#Rstr-byte)"
msgstr ""

msgid ""
"12867    * [SL.str.10: Use `std::string` when you need to perform locale-"
"sensitive string operations](#Rstr-locale)"
msgstr ""

msgid ""
"12868    * [SL.str.11: Use `gsl::string_span` rather than `std::string_view` "
"when you need to mutate a string](#Rstr-span)"
msgstr ""

msgid ""
"12869    * [SL.str.12: Use the `s` suffix for string literals meant to be "
"standard-library `string`s](#Rstr-s)"
msgstr ""

msgid "12870    **See also**:"
msgstr ""

msgid "12871    * [F.24 span](#Rf-range)"
msgstr ""

msgid "12872    * [F.25 zstring](#Rf-zstring)"
msgstr ""

msgid ""
"12873    ### <a name=\"Rstr-string\"></a>SL.str.1: Use `std::string` to own "
"character sequences"
msgstr ""

msgid "12874    ##### Reason"
msgstr ""

msgid ""
"12875    `string` correctly handles allocation, ownership, copying, gradual "
"expansion, and offers a variety of useful operations."
msgstr ""

msgid "12876    ##### Example"
msgstr ""

msgid "12877        vector<string> read_until(const string& terminator)"
msgstr ""

msgid "12878        {"
msgstr ""

msgid "12879            vector<string> res;"
msgstr ""

msgid ""
"12880            for (string s; cin >> s && s != terminator; ) // read a "
"word"
msgstr ""

msgid "12881                res.push_back(s);"
msgstr ""

msgid "12882            return res;"
msgstr ""

msgid "12883        }"
msgstr ""

msgid ""
"12884    Note how `>>` and `!=` are provided for `string` (as examples of "
"useful operations) and there are no explicit"
msgstr ""

msgid ""
"12885    allocations, deallocations, or range checks (`string` takes care of "
"those)."
msgstr ""

msgid ""
"12886    In C++17, we might use `string_view` as the argument, rather than "
"`const string*` to allow more flexibility to callers:"
msgstr ""

msgid ""
"12887        vector<string> read_until(string_view terminator)   // C++17"
msgstr ""

msgid "12888        {"
msgstr ""

msgid "12889            vector<string> res;"
msgstr ""

msgid ""
"12890            for (string s; cin >> s && s != terminator; ) // read a "
"word"
msgstr ""

msgid "12891                res.push_back(s);"
msgstr ""

msgid "12892            return res;"
msgstr ""

msgid "12893        }"
msgstr ""

msgid ""
"12894    The `gsl::string_span` is a current alternative offering most of "
"the benefits of `std::string_view` for simple examples:"
msgstr ""

msgid "12895        vector<string> read_until(string_span terminator)"
msgstr ""

msgid "12896        {"
msgstr ""

msgid "12897            vector<string> res;"
msgstr ""

msgid ""
"12898            for (string s; cin >> s && s != terminator; ) // read a "
"word"
msgstr ""

msgid "12899                res.push_back(s);"
msgstr ""

msgid "12900            return res;"
msgstr ""

msgid "12901        }"
msgstr ""

msgid "12902    ##### Example, bad"
msgstr ""

msgid ""
"12903    Don't use C-style strings for operations that require non-trivial "
"memory management"
msgstr ""

msgid "12904        char* cat(const char* s1, const char* s2)   // beware!"
msgstr ""

msgid "12905            // return s1 + '.' + s2"
msgstr ""

msgid "12906        {"
msgstr ""

msgid "12907            int l1 = strlen(s1);"
msgstr ""

msgid "12908            int l2 = strlen(s2);"
msgstr ""

msgid "12909            char* p = (char*) malloc(l1 + l2 + 2);"
msgstr ""

msgid "12910            strcpy(p, s1, l1);"
msgstr ""

msgid "12911            p[l1] = '.';"
msgstr ""

msgid "12912            strcpy(p + l1 + 1, s2, l2);"
msgstr ""

msgid "12913            p[l1 + l2 + 1] = 0;"
msgstr ""

msgid "12914            return p;"
msgstr ""

msgid "12915        }"
msgstr ""

msgid "12916    Did we get that right?"
msgstr ""

msgid "12917    Will the caller remember to `free()` the returned pointer?"
msgstr ""

msgid "12918    Will this code pass a security review?"
msgstr ""

msgid "12919    ##### Note"
msgstr ""

msgid ""
"12920    Do not assume that `string` is slower than lower-level techniques "
"without measurement and remember than not all code is performance critical."
msgstr ""

msgid "12921    [Don't optimize prematurely](#Rper-Knuth)"
msgstr ""

msgid "12922    ##### Enforcement"
msgstr ""

msgid "12923    ???"
msgstr ""

msgid ""
"12924    ### <a name=\"Rstr-view\"></a>SL.str.2: Use `std::string_view` or "
"`gsl::string_span` to refer to character sequences"
msgstr ""

msgid "12925    ##### Reason"
msgstr ""

msgid ""
"12926    `std::string_view` or `gsl::string_span` provides simple and "
"(potentially) safe access to character sequences independently of how"
msgstr ""

msgid "12927    those sequences are allocated and stored."
msgstr ""

msgid "12928    ##### Example"
msgstr ""

msgid "12929        vector<string> read_until(string_span terminator);"
msgstr ""

msgid "12930        void user(zstring p, const string& s, string_span ss)"
msgstr ""

msgid "12931        {"
msgstr ""

msgid "12932            auto v1 = read_until(p);"
msgstr ""

msgid "12933            auto v2 = read_until(s);"
msgstr ""

msgid "12934            auto v3 = read_until(ss);"
msgstr ""

msgid "12935            // ..."
msgstr ""

msgid "12936        }"
msgstr ""

msgid "12937    ##### Note"
msgstr ""

msgid "12938    `std::string_view` (C++17) is read-only."
msgstr ""

msgid "12939    ##### Enforcement"
msgstr ""

msgid "12940    ???"
msgstr ""

msgid ""
"12941    ### <a name=\"Rstr-zstring\"></a>SL.str.3: Use `zstring` or "
"`czstring` to refer to a C-style, zero-terminated, sequence of characters"
msgstr ""

msgid "12942    ##### Reason"
msgstr ""

msgid "12943    Readability."
msgstr ""

msgid "12944    Statement of intent."
msgstr ""

msgid ""
"12945    A plain `char*` can be a pointer to a single character, a pointer "
"to an array of characters, a pointer to a C-style (zero-terminated) string, "
"or even to a small integer."
msgstr ""

msgid ""
"12946    Distinguishing these alternatives prevents misunderstandings and "
"bugs."
msgstr ""

msgid "12947    ##### Example"
msgstr ""

msgid "12948        void f1(const char* s); // s is probably a string"
msgstr ""

msgid ""
"12949    All we know is that it is supposed to be the nullptr or point to at "
"least one character"
msgstr ""

msgid ""
"12950        void f1(zstring s);     // s is a C-style string or the nullptr"
msgstr ""

msgid ""
"12951        void f1(czstring s);    // s is a C-style string constant or "
"the nullptr"
msgstr ""

msgid ""
"12952        void f1(std::byte* s);  // s is a pointer to a byte (C++17)"
msgstr ""

msgid "12953    ##### Note"
msgstr ""

msgid ""
"12954    Don't convert a C-style string to `string` unless there is a reason "
"to."
msgstr ""

msgid "12955    ##### Note"
msgstr ""

msgid ""
"12956    Like any other \"plain pointer\", a `zstring` should not represent "
"ownership."
msgstr ""

msgid "12957    ##### Note"
msgstr ""

msgid ""
"12958    There are billions of lines of C++ \"out there\", most use `char*` "
"and `const char*` without documenting intent."
msgstr ""

msgid ""
"12959    They are used in a wide variety of ways, including to represent "
"ownership and as generic pointers to memory (instead of `void*`)."
msgstr ""

msgid ""
"12960    It is hard to separate these uses, so this guideline is hard to "
"follow."
msgstr ""

msgid ""
"12961    This is one of the major sources of bugs in C and C++ programs, so "
"it is worthwhile to follow this guideline wherever feasible.."
msgstr ""

msgid "12962    ##### Enforcement"
msgstr ""

msgid "12963    * Flag uses of `[]` on a `char*`"
msgstr ""

msgid "12964    * Flag uses of `delete` on a `char*`"
msgstr ""

msgid "12965    * Flag uses of `free()` on a `char*`"
msgstr ""

msgid ""
"12966    ### <a name=\"Rstr-char*\"></a>SL.str.4: Use `char*` to refer to a "
"single character"
msgstr ""

msgid "12967    ##### Reason"
msgstr ""

msgid ""
"12968    The variety of uses of `char*` in current code is a major source of "
"errors."
msgstr ""

msgid "12969    ##### Example, bad"
msgstr ""

msgid "12970        char arr[] = {'a', 'b', 'c'};"
msgstr ""

msgid "12971        void print(const char* p)"
msgstr ""

msgid "12972        {"
msgstr ""

msgid "12973            cout << p << '\\n';"
msgstr ""

msgid "12974        }"
msgstr ""

msgid "12975        void use()"
msgstr ""

msgid "12976        {"
msgstr ""

msgid "12977            print(arr);   // run-time error; potentially very bad"
msgstr ""

msgid "12978        }"
msgstr ""

msgid ""
"12979    The array `arr` is not a C-style string because it is not zero-"
"terminated."
msgstr ""

msgid "12980    ##### Alternative"
msgstr ""

msgid ""
"12981    See [`zstring`](#Rstr-zstring), [`string`](#Rstr-string), and "
"[`string_span`](#Rstr-view)."
msgstr ""

msgid "12982    ##### Enforcement"
msgstr ""

msgid "12983    * Flag uses of `[]` on a `char*`"
msgstr ""

msgid ""
"12984    ### <a name=\"Rstr-byte\"></a>SL.str.5: Use `std::byte` to refer to "
"byte values that do not necessarily represent characters"
msgstr ""

msgid "12985    ##### Reason"
msgstr ""

msgid ""
"12986    Use of `char*` to represent a pointer to something that is not "
"necessarily a character causes confusion"
msgstr ""

msgid "12987    and disables valuable optimizations."
msgstr ""

msgid "12988    ##### Example"
msgstr ""

msgid "12989        ???"
msgstr ""

msgid "12990    ##### Note"
msgstr ""

msgid "12991    C++17"
msgstr ""

msgid "12992    ##### Enforcement"
msgstr ""

msgid "12993    ???"
msgstr ""

msgid ""
"12994    ### <a name=\"Rstr-locale\"></a>SL.str.10: Use `std::string` when "
"you need to perform locale-sensitive string operations"
msgstr ""

msgid "12995    ##### Reason"
msgstr ""

msgid ""
"12996    `std::string` supports standard-library [`locale` facilities](#Rstr-"
"locale)"
msgstr ""

msgid "12997    ##### Example"
msgstr ""

msgid "12998        ???"
msgstr ""

msgid "12999    ##### Note"
msgstr ""

msgid "13000    ???"
msgstr ""

msgid "13001    ##### Enforcement"
msgstr ""

msgid "13002    ???"
msgstr ""

msgid ""
"13003    ### <a name=\"Rstr-span\"></a>SL.str.11: Use `gsl::string_span` "
"rather than `std::string_view` when you need to mutate a string"
msgstr ""

msgid "13004    ##### Reason"
msgstr ""

msgid "13005    `std::string_view` is read-only."
msgstr ""

msgid "13006    ##### Example"
msgstr ""

msgid "13007    ???"
msgstr ""

msgid "13008    ##### Note"
msgstr ""

msgid "13009    ???"
msgstr ""

msgid "13010    ##### Enforcement"
msgstr ""

msgid "13011    The compiler will flag attempts to write to a `string_view`."
msgstr ""

msgid ""
"13012    ### <a name=\"Rstr-s\"></a>SL.str.12: Use the `s` suffix for string "
"literals meant to be standard-library `string`s"
msgstr ""

msgid "13013    ##### Reason"
msgstr ""

msgid "13014    Direct expression of an idea minimizes mistakes."
msgstr ""

msgid "13015    ##### Example"
msgstr ""

msgid ""
"13016        auto pp1 = make_pair(\"Tokyo\", 9.00);         // {C-style "
"string,double} intended?"
msgstr ""

msgid ""
"13017        pair<string, double> pp2 = {\"Tokyo\", 9.00};  // a bit verbose"
msgstr ""

msgid ""
"13018        auto pp3 = make_pair(\"Tokyo\"s, 9.00);        // {std::"
"string,double}    // C++14"
msgstr ""

msgid ""
"13019        pair pp4 = {\"Tokyo\"s, 9.00};                 // {std::"
"string,double}    // C++17"
msgstr ""

msgid "13020    ##### Note"
msgstr ""

msgid "13021    C++14"
msgstr ""

msgid "13022    ##### Enforcement"
msgstr ""

msgid "13023    ???"
msgstr ""

msgid "13024    ## <a name=\"SS-io\"></a>SL.io: Iostream"
msgstr ""

msgid ""
"13025    `iostream`s is a type safe, extensible, formatted and unformatted I/"
"O library for streaming I/O."
msgstr ""

msgid ""
"13026    It supports multiple (and user extensible) buffering strategies and "
"multiple locales."
msgstr ""

msgid ""
"13027    It can be used for conventional I/O, reading and writing to memory "
"(string streams),"
msgstr ""

msgid ""
"13028    and user-defines extensions, such as streaming across networks "
"(asio: not yet standardized)."
msgstr ""

msgid "13029    Iostream rule summary:"
msgstr ""

msgid ""
"13030    * [SL.io.1: Use character-level input only when you have to](#Rio-"
"low)"
msgstr ""

msgid ""
"13031    * [SL.io.2: When reading, always consider ill-formed input](#Rio-"
"validate)"
msgstr ""

msgid "13032    * [SL.io.3: Prefer iostreams for I/O](#Rio-streams)"
msgstr ""

msgid ""
"13033    * [SL.io.10: Unless you use `printf`-family functions call "
"`ios_base::sync_with_stdio(false)`](#Rio-sync)"
msgstr ""

msgid "13034    * [SL.io.50: Avoid `endl`](#Rio-endl)"
msgstr ""

msgid "13035    * [???](#???)"
msgstr ""

msgid ""
"13036    ### <a name=\"Rio-low\"></a>SL.io.1: Use character-level input only "
"when you have to"
msgstr ""

msgid "13037    ##### Reason"
msgstr ""

msgid ""
"13038    Unless you genuinely just deal with individual characters, using "
"character-level input leads to the user code performing potentially error-"
"prone"
msgstr ""

msgid ""
"13039    and potentially inefficient composition of tokens out of characters."
""
msgstr ""

msgid "13040    ##### Example"
msgstr ""

msgid "13041        char c;"
msgstr ""

msgid "13042        char buf[128];"
msgstr ""

msgid "13043        int i = 0;"
msgstr ""

msgid "13044        while (cin.get(c) && !isspace(c) && i < 128)"
msgstr ""

msgid "13045            buf[i++] = c;"
msgstr ""

msgid "13046        if (i == 128) {"
msgstr ""

msgid "13047            // ... handle too long string ...."
msgstr ""

msgid "13048        }"
msgstr ""

msgid "13049    Better (much simpler and probably faster):"
msgstr ""

msgid "13050        string s;"
msgstr ""

msgid "13051        s.reserve(128);"
msgstr ""

msgid "13052        cin >> s;"
msgstr ""

msgid "13053    and the `reserve(128)` is probably not worthwhile."
msgstr ""

msgid "13054    ##### Enforcement"
msgstr ""

msgid "13055    ???"
msgstr ""

msgid ""
"13056    ### <a name=\"Rio-validate\"></a>SL.io.2: When reading, always "
"consider ill-formed input"
msgstr ""

msgid "13057    ##### Reason"
msgstr ""

msgid "13058    Errors are typically best handled as soon as possible."
msgstr ""

msgid ""
"13059    If input isn't validated, every function must be written to cope "
"with bad data (and that is not practical)."
msgstr ""

msgid "13060    ##### Example"
msgstr ""

msgid "13061        ???"
msgstr ""

msgid "13062    ##### Enforcement"
msgstr ""

msgid "13063    ???"
msgstr ""

msgid ""
"13064    ### <a name=\"Rio-streams\"></a>SL.io.3: Prefer `iostream`s for I/O"
msgstr ""

msgid "13065    ##### Reason"
msgstr ""

msgid "13066    `iostream`s are safe, flexible, and extensible."
msgstr ""

msgid "13067    ##### Example"
msgstr ""

msgid "13068        // write a complex number:"
msgstr ""

msgid "13069        complex<double> z{ 3, 4 };"
msgstr ""

msgid "13070        cout << z << '\\n';"
msgstr ""

msgid ""
"13071    `complex` is a user-defined type and its I/O is defined without "
"modifying the `iostream` library."
msgstr ""

msgid "13072    ##### Example"
msgstr ""

msgid "13073        // read a file of complex numbers:"
msgstr ""

msgid "13074        for (complex<double> z; cin >> z; )"
msgstr ""

msgid "13075            v.push_back(z);"
msgstr ""

msgid "13076    ##### Exception"
msgstr ""

msgid "13077    ??? performance ???"
msgstr ""

msgid "13078    ##### Discussion: `iostream`s vs. the `printf()` family"
msgstr ""

msgid ""
"13079    It is often (and often correctly) pointed out that the `printf()` "
"family has two advantages compared to `iostream`s:"
msgstr ""

msgid "13080    flexibility of formatting and performance."
msgstr ""

msgid ""
"13081    This has to be weighed against `iostream`s advantages of "
"extensibility to handle user-defined types, resilient against security "
"violations,"
msgstr ""

msgid "13082    implicit memory management, and `locale` handling."
msgstr ""

msgid ""
"13083    If you need I/O performance, you can almost always do better than "
"`printf()`."
msgstr ""

msgid ""
"13084    `gets()` `scanf()` using `s`, and `printf()` using `%s` are "
"security hazards (vulnerable to buffer overflow and generally error-prone)."
msgstr ""

msgid ""
"13085    In C11, they are replaced by `gets_s()`, `scanf_s()`, and "
"`printf_s()` as safer alternatives, but they are still not type safe."
msgstr ""

msgid "13086    ##### Enforcement"
msgstr ""

msgid "13087    Optionally flag `<cstdio>` and `<stdio.h>`."
msgstr ""

msgid ""
"13088    ### <a name=\"Rio-sync\"></a>SL.io.10: Unless you use `printf`-"
"family functions call `ios_base::sync_with_stdio(false)`"
msgstr ""

msgid "13089    ##### Reason"
msgstr ""

msgid ""
"13090    Synchronizing `iostreams` with `printf-style` I/O can be costly."
msgstr ""

msgid "13091    `cin` and `cout` are by default synchronized with `printf`."
msgstr ""

msgid "13092    ##### Example"
msgstr ""

msgid "13093        int main()"
msgstr ""

msgid "13094        {"
msgstr ""

msgid "13095            ios_base::sync_with_stdio(false);"
msgstr ""

msgid "13096            // ... use iostreams ..."
msgstr ""

msgid "13097        }"
msgstr ""

msgid "13098    ##### Enforcement"
msgstr ""

msgid "13099    ???"
msgstr ""

msgid "13100    ### <a name=\"Rio-endl\"></a>SL.io.50: Avoid `endl`"
msgstr ""

msgid "13101    ##### Reason"
msgstr ""

msgid ""
"13102    The `endl` manipulator is mostly equivalent to `'\\n'` and "
"`\"\\n\"`;"
msgstr ""

msgid ""
"13103    as most commonly used it simply slows down output by doing "
"redundant `flush()`s."
msgstr ""

msgid ""
"13104    This slowdown can be significant compared to `printf`-style output."
msgstr ""

msgid "13105    ##### Example"
msgstr ""

msgid ""
"13106        cout << \"Hello, World!\" << endl;    // two output operations "
"and a flush"
msgstr ""

msgid ""
"13107        cout << \"Hello, World!\\n\";          // one output operation "
"and no flush"
msgstr ""

msgid "13108    ##### Note"
msgstr ""

msgid ""
"13109    For `cin`/`cout` (and equivalent) interaction, there is no reason "
"to flush; that's done automatically."
msgstr ""

msgid "13110    For writing to a file, there is rarely a need to `flush`."
msgstr ""

msgid "13111    ##### Note"
msgstr ""

msgid "13112    Apart from the (occasionally important) issue of performance,"
msgstr ""

msgid ""
"13113    the choice between `'\\n'` and `endl` is almost completely "
"aesthetic."
msgstr ""

msgid "13114    ## <a name=\"SS-regex\"></a>SL.regex: Regex"
msgstr ""

msgid "13115    `<regex>` is the standard C++ regular expression library."
msgstr ""

msgid ""
"13116    It supports a variety of regular expression pattern conventions."
msgstr ""

msgid "13117    ## <a name=\"SS-chrono\"></a>SL.chrono: Time"
msgstr ""

msgid ""
"13118    `<chrono>` (defined in namespace `std::chrono`) provides the "
"notions of `time_point` and `duration` together with functions for"
msgstr ""

msgid "13119    outputting time in various units."
msgstr ""

msgid "13120    It provides clocks for registering `time_points`."
msgstr ""

msgid "13121    ## <a name=\"SS-clib\"></a>SL.C: The C Standard Library"
msgstr ""

msgid "13122    ???"
msgstr ""

msgid "13123    C Standard Library rule summary:"
msgstr ""

msgid "13124    * [S.C.1: Don't use setjmp/longjmp](#Rclib-jmp)"
msgstr ""

msgid "13125    * [???](#???)"
msgstr ""

msgid "13126    * [???](#???)"
msgstr ""

msgid "13127    ### <a name=\"Rclib-jmp\"></a>SL.C.1: Don't use setjmp/longjmp"
msgstr ""

msgid "13128    ##### Reason"
msgstr ""

msgid ""
"13129    a `longjmp` ignores destructors, thus invalidating all resource-"
"management strategies relying on RAII"
msgstr ""

msgid "13130    ##### Enforcement"
msgstr ""

msgid "13131    Flag all occurrences of `longjmp`and `setjmp`"
msgstr ""

msgid "13132    # <a name=\"S-A\"></a>A: Architectural ideas"
msgstr ""

msgid ""
"13133    This section contains ideas about higher-level architectural ideas "
"and libraries."
msgstr ""

msgid "13134    Architectural rule summary:"
msgstr ""

msgid ""
"13135    * [A.1: Separate stable from less stable part of code](#Ra-stable)"
msgstr ""

msgid ""
"13136    * [A.2: Express potentially reusable parts as a library](#Ra-lib)"
msgstr ""

msgid "13137    * [A.4: There should be no cycles among libraries](#?Ra-dag)"
msgstr ""

msgid "13138    * [???](#???)"
msgstr ""

msgid "13139    * [???](#???)"
msgstr ""

msgid "13140    * [???](#???)"
msgstr ""

msgid "13141    * [???](#???)"
msgstr ""

msgid "13142    * [???](#???)"
msgstr ""

msgid "13143    * [???](#???)"
msgstr ""

msgid ""
"13144    ### <a name=\"Ra-stable\"></a>A.1: Separate stable from less stable "
"part of code"
msgstr ""

msgid "13145    ???"
msgstr ""

msgid ""
"13146    ### <a name=\"Ra-lib\"></a>A.2: Express potentially reusable parts "
"as a library"
msgstr ""

msgid "13147    ##### Reason"
msgstr ""

msgid "13148    ##### Note"
msgstr ""

msgid ""
"13149    A library is a collection of declarations and definitions "
"maintained, documented, and shipped together."
msgstr ""

msgid ""
"13150    A library could be a set of headers (a \"header only library\") or "
"a set of headers plus a set of object files."
msgstr ""

msgid ""
"13151    A library can be statically or dynamically linked into a program, "
"or it may be `#include`d"
msgstr ""

msgid ""
"13152    ### <a name=\"Ra-dag\"></a>A.4: There should be no cycles among "
"libraries"
msgstr ""

msgid "13153    ##### Reason"
msgstr ""

msgid "13154    * A cycle implies complication of the build process."
msgstr ""

msgid ""
"13155    * Cycles are hard to understand and may introduce indeterminism "
"(unspecified behavior)."
msgstr ""

msgid "13156    ##### Note"
msgstr ""

msgid ""
"13157    A library can contain cyclic references in the definition of its "
"components."
msgstr ""

msgid "13158    For example:"
msgstr ""

msgid "13159        ???"
msgstr ""

msgid ""
"13160    However, a library should not depend on another that depends on it."
msgstr ""

msgid "13161    # <a name=\"S-not\"></a>NR: Non-Rules and myths"
msgstr ""

msgid ""
"13162    This section contains rules and guidelines that are popular "
"somewhere, but that we deliberately don't recommend."
msgstr ""

msgid ""
"13163    We know full well that there have been times and places where these "
"rules made sense, and we have used them ourselves at times."
msgstr ""

msgid ""
"13164    However, in the context of the styles of programming we recommend "
"and support with the guidelines, these \"non-rules\" would do harm."
msgstr ""

msgid "13165    Even today, there can be contexts where the rules make sense."
msgstr ""

msgid ""
"13166    For example, lack of suitable tool support can make exceptions "
"unsuitable in hard-real-time systems,"
msgstr ""

msgid ""
"13167    but please don't blindly trust \"common wisdom\" (e.g., unsupported "
"statements about \"efficiency\");"
msgstr ""

msgid ""
"13168    such \"wisdom\" may be based on decades-old information or "
"experienced from languages with very different properties than C++"
msgstr ""

msgid "13169    (e.g., C or Java)."
msgstr ""

msgid ""
"13170    The positive arguments for alternatives to these non-rules are "
"listed in the rules offered as \"Alternatives\"."
msgstr ""

msgid "13171    Non-rule summary:"
msgstr ""

msgid ""
"13172    * [NR.1: Don't: All declarations should be at the top of a "
"function](#Rnr-top)"
msgstr ""

msgid ""
"13173    * [NR.2: Don't: Have only a single `return`-statement in a "
"function](#Rnr-single-return)"
msgstr ""

msgid "13174    * [NR.3: Don't: Don't use exceptions](#Rnr-no-exceptions)"
msgstr ""

msgid ""
"13175    * [NR.4: Don't: Place each class declaration in its own source "
"file](#Rnr-lots-of-files)"
msgstr ""

msgid ""
"13176    * [NR.5: Don't: Don't do substantive work in a constructor; instead "
"use two-phase initialization](#Rnr-two-phase-init)"
msgstr ""

msgid ""
"13177    * [NR.6: Don't: Place all cleanup actions at the end of a function "
"and `goto exit`](#Rnr-goto-exit)"
msgstr ""

msgid ""
"13178    * [NR.7: Don't: Make all data members `protected`](#Rnr-protected-"
"data)"
msgstr ""

msgid "13179    * ???"
msgstr ""

msgid ""
"13180    ### <a name=\"Rnr-top\"></a>NR.1: Don't: All declarations should be "
"at the top of a function"
msgstr ""

msgid "13181    ##### Reason (not to follow this rule)"
msgstr ""

msgid ""
"13182    This rule is a legacy of old programming languages that didn't "
"allow initialization of variables and constants after a statement."
msgstr ""

msgid ""
"13183    This leads to longer programs and more errors caused by "
"uninitialized and wrongly initialized variables."
msgstr ""

msgid "13184    ##### Example, bad"
msgstr ""

msgid "13185        int use(int x)"
msgstr ""

msgid "13186        {"
msgstr ""

msgid "13187            int i;"
msgstr ""

msgid "13188            char c;"
msgstr ""

msgid "13189            double d;"
msgstr ""

msgid "13190            // ... some stuff ..."
msgstr ""

msgid "13191            if (x < i) {"
msgstr ""

msgid "13192                // ..."
msgstr ""

msgid "13193                i = f(x, d);"
msgstr ""

msgid "13194            }"
msgstr ""

msgid "13195            if (i < x) {"
msgstr ""

msgid "13196                // ..."
msgstr ""

msgid "13197                i = g(x, c);"
msgstr ""

msgid "13198            }"
msgstr ""

msgid "13199            return i;"
msgstr ""

msgid "13200        }"
msgstr ""

msgid ""
"13201    The larger the distance between the uninitialized variable and its "
"use, the larger the chance of a bug."
msgstr ""

msgid "13202    Fortunately, compilers catch many \"used before set\" errors."
msgstr ""

msgid ""
"13203    Unfortunately, compilers cannot catch all such errors and "
"unfortunately, the bugs aren't always as simple to spot as in this small "
"example."
msgstr ""

msgid "13204    ##### Alternative"
msgstr ""

msgid "13205    * [Always initialize an object](#Res-always)"
msgstr ""

msgid ""
"13206    * [ES.21: Don't introduce a variable (or constant) before you need "
"to use it](#Res-introduce)"
msgstr ""

msgid ""
"13207    ### <a name=\"Rnr-single-return\"></a>NR.2: Don't: Have only a "
"single `return`-statement in a function"
msgstr ""

msgid "13208    ##### Reason (not to follow this rule)"
msgstr ""

msgid ""
"13209    The single-return rule can lead to unnecessarily convoluted code "
"and the introduction of extra state variables."
msgstr ""

msgid ""
"13210    In particular, the single-return rule makes it harder to "
"concentrate error checking at the top of a function."
msgstr ""

msgid "13211    ##### Example"
msgstr ""

msgid "13212        template<class T>"
msgstr ""

msgid "13213        //  requires Number<T>"
msgstr ""

msgid "13214        string sign(T x)"
msgstr ""

msgid "13215        {"
msgstr ""

msgid "13216            if (x < 0)"
msgstr ""

msgid "13217                return \"negative\";"
msgstr ""

msgid "13218            else if (x > 0)"
msgstr ""

msgid "13219                return \"positive\";"
msgstr ""

msgid "13220            return \"zero\";"
msgstr ""

msgid "13221        }"
msgstr ""

msgid ""
"13222    to use a single return only we would have to do something like"
msgstr ""

msgid "13223        template<class T>"
msgstr ""

msgid "13224        //  requires Number<T>"
msgstr ""

msgid "13225        string sign(T x)        // bad"
msgstr ""

msgid "13226        {"
msgstr ""

msgid "13227            string res;"
msgstr ""

msgid "13228            if (x < 0)"
msgstr ""

msgid "13229                res = \"negative\";"
msgstr ""

msgid "13230            else if (x > 0)"
msgstr ""

msgid "13231                res = \"positive\";"
msgstr ""

msgid "13232            else"
msgstr ""

msgid "13233                res = \"zero\";"
msgstr ""

msgid "13234            return res;"
msgstr ""

msgid "13235        }"
msgstr ""

msgid "13236    This is both longer and likely to be less efficient."
msgstr ""

msgid ""
"13237    The larger and more complicated the function is, the more painful "
"the workarounds get."
msgstr ""

msgid ""
"13238    Of course many simple functions will naturally have just one "
"`return` because of their simpler inherent logic."
msgstr ""

msgid "13239    ##### Example"
msgstr ""

msgid "13240        int index(const char* p)"
msgstr ""

msgid "13241        {"
msgstr ""

msgid ""
"13242            if (!p) return -1;  // error indicator: alternatively "
"\"throw nullptr_error{}\""
msgstr ""

msgid "13243            // ... do a lookup to find the index for p"
msgstr ""

msgid "13244            return i;"
msgstr ""

msgid "13245        }"
msgstr ""

msgid "13246    If we applied the rule, we'd get something like"
msgstr ""

msgid "13247        int index2(const char* p)"
msgstr ""

msgid "13248        {"
msgstr ""

msgid "13249            int i;"
msgstr ""

msgid "13250            if (!p)"
msgstr ""

msgid "13251                i = -1;  // error indicator"
msgstr ""

msgid "13252            else {"
msgstr ""

msgid "13253                // ... do a lookup to find the index for p"
msgstr ""

msgid "13254            }"
msgstr ""

msgid "13255            return i;"
msgstr ""

msgid "13256        }"
msgstr ""

msgid ""
"13257    Note that we (deliberately) violated the rule against uninitialized "
"variables because this style commonly leads to that."
msgstr ""

msgid ""
"13258    Also, this style is a temptation to use the [goto exit](#Rnr-goto-"
"exit) non-rule."
msgstr ""

msgid "13259    ##### Alternative"
msgstr ""

msgid "13260    * Keep functions short and simple"
msgstr ""

msgid ""
"13261    * Feel free to use multiple `return` statements (and to throw "
"exceptions)."
msgstr ""

msgid ""
"13262    ### <a name=\"Rnr-no-exceptions\"></a>NR.3: Don't: Don't use "
"exceptions"
msgstr ""

msgid "13263    ##### Reason (not to follow this rule)"
msgstr ""

msgid "13264    There seem to be three main reasons given for this non-rule:"
msgstr ""

msgid "13265    * exceptions are inefficient"
msgstr ""

msgid "13266    * exceptions lead to leaks and errors"
msgstr ""

msgid "13267    * exception performance is not predictable"
msgstr ""

msgid ""
"13268    There is no way we can settle this issue to the satisfaction of "
"everybody."
msgstr ""

msgid ""
"13269    After all, the discussions about exceptions have been going on for "
"40+ years."
msgstr ""

msgid ""
"13270    Some languages cannot be used without exceptions, but others do not "
"support them."
msgstr ""

msgid ""
"13271    This leads to strong traditions for the use and non-use of "
"exceptions, and to heated debates."
msgstr ""

msgid ""
"13272    However, we can briefly outline why we consider exceptions the best "
"alternative for general-purpose programming"
msgstr ""

msgid "13273    and in the context of these guidelines."
msgstr ""

msgid "13274    Simple arguments for and against are often inconclusive."
msgstr ""

msgid ""
"13275    There are specialized applications where exceptions indeed can be "
"inappropriate"
msgstr ""

msgid ""
"13276    (e.g., hard-real-time systems without support for reliable "
"estimates of the cost of handling an exception)."
msgstr ""

msgid "13277    Consider the major objections to exceptions in turn"
msgstr ""

msgid "13278    * Exceptions are inefficient:"
msgstr ""

msgid "13279    Compared to what?"
msgstr ""

msgid ""
"13280    When comparing make sure that the same set of errors are handled "
"and that they are handled equivalently."
msgstr ""

msgid ""
"13281    In particular, do not compare a program that immediately terminate "
"on seeing an error with a program"
msgstr ""

msgid "13282    that carefully cleans up resources before logging an error."
msgstr ""

msgid ""
"13283    Yes, some systems have poor exception handling implementations; "
"sometimes, such implementations force us to use"
msgstr ""

msgid ""
"13284    other error-handling approaches, but that's not a fundamental "
"problem with exceptions."
msgstr ""

msgid ""
"13285    When using an efficiency argument - in any context - be careful "
"that you have good data that actually provides"
msgstr ""

msgid "13286    insight into the problem under discussion."
msgstr ""

msgid "13287    * Exceptions lead to leaks and errors."
msgstr ""

msgid "13288    They do not."
msgstr ""

msgid ""
"13289    If your program is a rat's nest of pointers without an overall "
"strategy for resource management,"
msgstr ""

msgid "13290    you have a problem whatever you do."
msgstr ""

msgid "13291    If your system consists of a million lines of such code,"
msgstr ""

msgid "13292    you probably will not be able to use exceptions,"
msgstr ""

msgid ""
"13293    but that's a problem with excessive and undisciplined pointer use, "
"rather than with exceptions."
msgstr ""

msgid ""
"13294    In our opinion, you need RAII to make exception-based error "
"handling simple and safe -- simpler and safer than alternatives."
msgstr ""

msgid "13295    * Exception performance is not predictable."
msgstr ""

msgid ""
"13296    If you are in a hard-real-time system where you must guarantee "
"completion of a task in a given time,"
msgstr ""

msgid "13297    you need tools to back up such guarantees."
msgstr ""

msgid ""
"13298    As far as we know such tools are not available (at least not to "
"most programmers)."
msgstr ""

msgid ""
"13299    Many, possibly most, problems with exceptions stem from historical "
"needs to interact with messy old code."
msgstr ""

msgid "13300    The fundamental arguments for the use of exceptions are"
msgstr ""

msgid ""
"13301    * They clearly differentiate between erroneous return and ordinary "
"return"
msgstr ""

msgid "13302    * They cannot be forgotten or ignored"
msgstr ""

msgid "13303    * They can be used systematically"
msgstr ""

msgid "13304    Remember"
msgstr ""

msgid ""
"13305    * Exceptions are for reporting errors (in C++; other languages can "
"have different uses for exceptions)."
msgstr ""

msgid "13306    * Exceptions are not for errors that can be handled locally."
msgstr ""

msgid ""
"13307    * Don't try to catch every exception in every function (that's "
"tedious, clumsy, and leads to slow code)."
msgstr ""

msgid ""
"13308    * Exceptions are not for errors that require instant termination of "
"a module/system after a non-recoverable error."
msgstr ""

msgid "13309    ##### Example"
msgstr ""

msgid "13310        ???"
msgstr ""

msgid "13311    ##### Alternative"
msgstr ""

msgid "13312    * [RAII](#Re-raii)"
msgstr ""

msgid ""
"13313    * Contracts/assertions: Use GSL's `Expects` and `Ensures` (until we "
"get language support for contracts)"
msgstr ""

msgid ""
"13314    ### <a name=\"Rnr-lots-of-files\"></a>NR.4: Don't: Place each class "
"declaration in its own source file"
msgstr ""

msgid "13315    ##### Reason (not to follow this rule)"
msgstr ""

msgid ""
"13316    The resulting number of files are hard to manage and can slow down "
"compilation."
msgstr ""

msgid ""
"13317    Individual classes are rarely a good logical unit of maintenance "
"and distribution."
msgstr ""

msgid "13318    ##### Example"
msgstr ""

msgid "13319        ???"
msgstr ""

msgid "13320    ##### Alternative"
msgstr ""

msgid ""
"13321    * Use namespaces containing logically cohesive sets of classes and "
"functions."
msgstr ""

msgid ""
"13322    ### <a name=\"Rnr-two-phase-init\"></a>NR.5: Don't: Don't do "
"substantive work in a constructor; instead use two-phase initialization"
msgstr ""

msgid "13323    ##### Reason (not to follow this rule)"
msgstr ""

msgid "13324    Following this rule leads to weaker invariants,"
msgstr ""

msgid ""
"13325    more complicated code (having to deal with semi-constructed "
"objects),"
msgstr ""

msgid ""
"13326    and errors (when we didn't deal correctly with semi-constructed "
"objects consistently)."
msgstr ""

msgid "13327    ##### Example"
msgstr ""

msgid "13328        ???"
msgstr ""

msgid "13329    ##### Alternative"
msgstr ""

msgid "13330    * Always establish a class invariant in a constructor."
msgstr ""

msgid "13331    * Don't define an object before it is needed."
msgstr ""

msgid ""
"13332    ### <a name=\"Rnr-goto-exit\"></a>NR.6: Don't: Place all cleanup "
"actions at the end of a function and `goto exit`"
msgstr ""

msgid "13333    ##### Reason (not to follow this rule)"
msgstr ""

msgid "13334    `goto` is error-prone."
msgstr ""

msgid ""
"13335    This technique is a pre-exception technique for RAII-like resource "
"and error handling."
msgstr ""

msgid "13336    ##### Example, bad"
msgstr ""

msgid "13337        void do_something(int n)"
msgstr ""

msgid "13338        {"
msgstr ""

msgid "13339            if (n < 100) goto exit;"
msgstr ""

msgid "13340            // ..."
msgstr ""

msgid "13341            int* p = (int*) malloc(n);"
msgstr ""

msgid "13342            // ..."
msgstr ""

msgid "13343            if (some_error) goto_exit;"
msgstr ""

msgid "13344            // ..."
msgstr ""

msgid "13345        exit:"
msgstr ""

msgid "13346            free(p);"
msgstr ""

msgid "13347        }"
msgstr ""

msgid "13348    and spot the bug."
msgstr ""

msgid "13349    ##### Alternative"
msgstr ""

msgid "13350    * Use exceptions and [RAII](#Re-raii)"
msgstr ""

msgid "13351    * for non-RAII resources, use [`finally`](#Re-finally)."
msgstr ""

msgid ""
"13352    ### <a name=\"Rnr-protected-data\"></a>NR.7: Don't: Make all data "
"members `protected`"
msgstr ""

msgid "13353    ##### Reason (not to follow this rule)"
msgstr ""

msgid "13354    `protected` data is a source of errors."
msgstr ""

msgid ""
"13355    `protected` data can be manipulated from an unbounded amount of "
"code in various places."
msgstr ""

msgid ""
"13356    `protected` data is the class hierarchy equivalent to global data."
msgstr ""

msgid "13357    ##### Example"
msgstr ""

msgid "13358        ???"
msgstr ""

msgid "13359    ##### Alternative"
msgstr ""

msgid ""
"13360    * [Make member data `public` or (preferably) `private`](#Rh-"
"protected)"
msgstr ""

msgid "13361    # <a name=\"S-references\"></a>RF: References"
msgstr ""

msgid ""
"13362    Many coding standards, rules, and guidelines have been written for "
"C++, and especially for specialized uses of C++."
msgstr ""

msgid "13363    Many"
msgstr ""

msgid ""
"13364    * focus on lower-level issues, such as the spelling of identifiers"
msgstr ""

msgid "13365    * are written by C++ novices"
msgstr ""

msgid ""
"13366    * see \"stopping programmers from doing unusual things\" as their "
"primary aim"
msgstr ""

msgid ""
"13367    * aim at portability across many compilers (some 10 years old)"
msgstr ""

msgid "13368    * are written to preserve decades old code bases"
msgstr ""

msgid "13369    * aim at a single application domain"
msgstr ""

msgid "13370    * are downright counterproductive"
msgstr ""

msgid ""
"13371    * are ignored (must be ignored by programmers to get their work "
"done well)"
msgstr ""

msgid "13372    A bad coding standard is worse than no coding standard."
msgstr ""

msgid ""
"13373    However an appropriate set of guidelines are much better than no "
"standards: \"Form is liberating.\""
msgstr ""

msgid ""
"13374    Why can't we just have a language that allows all we want and "
"disallows all we don't want (\"a perfect language\")?"
msgstr ""

msgid ""
"13375    Fundamentally, because affordable languages (and their tool chains) "
"also serve people with needs that differ from yours and serve more needs "
"than you have today."
msgstr ""

msgid ""
"13376    Also, your needs change over time and a general-purpose language is "
"needed to allow you to adapt."
msgstr ""

msgid ""
"13377    A language that is ideal for today would be overly restrictive "
"tomorrow."
msgstr ""

msgid ""
"13378    Coding guidelines adapt the use of a language to specific needs."
msgstr ""

msgid "13379    Thus, there cannot be a single coding style for everybody."
msgstr ""

msgid ""
"13380    We expect different organizations to provide additions, typically "
"with more restrictions and firmer style rules."
msgstr ""

msgid "13381    Reference sections:"
msgstr ""

msgid "13382    * [RF.rules: Coding rules](#SS-rules)"
msgstr ""

msgid "13383    * [RF.books: Books with coding guidelines](#SS-books)"
msgstr ""

msgid "13384    * [RF.C++: C++ Programming (C++11/C++14)](#SS-Cplusplus)"
msgstr ""

msgid "13385    * [RF.web: Websites](#SS-web)"
msgstr ""

msgid "13386    * [RS.video: Videos about \"modern C++\"](#SS-vid)"
msgstr ""

msgid "13387    * [RF.man: Manuals](#SS-man)"
msgstr ""

msgid "13388    * [RF.core: Core Guidelines materials](#SS-core)"
msgstr ""

msgid "13389    ## <a name=\"SS-rules\"></a>RF.rules: Coding rules"
msgstr ""

msgid ""
"13390    * [Boost Library Requirements and Guidelines](http://www.boost.org/"
"development/requirements.html)."
msgstr ""

msgid "13391      ???."
msgstr ""

msgid ""
"13392    * [Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/"
"CodingStandards.pdf)."
msgstr ""

msgid "13393      Has a strong emphasis on code organization and layout."
msgstr ""

msgid "13394    * Facebook: ???"
msgstr ""

msgid ""
"13395    * [GCC Coding Conventions](https://gcc.gnu.org/codingconventions."
"html)."
msgstr ""

msgid "13396      C++03 and (reasonably) a bit backwards looking."
msgstr ""

msgid ""
"13397    * [Google C++ Style Guide](https://google.github.io/styleguide/"
"cppguide.html)."
msgstr ""

msgid ""
"13398      Geared toward C++03 and (also) older code bases. Google experts "
"are now actively collaborating here on helping to improve these Guidelines, "
"and hopefully to merge efforts so these can be a modern common set they "
"could also recommend."
msgstr ""

msgid ""
"13399    * [JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING "
"STANDARDS](http://www.stroustrup.com/JSF-AV-rules.pdf)."
msgstr ""

msgid "13400      Document Number 2RDU00001 Rev C. December 2005."
msgstr ""

msgid "13401      For flight control software."
msgstr ""

msgid "13402      For hard-real-time."
msgstr ""

msgid ""
"13403      This means that it is necessarily very restrictive (\"if the "
"program fails somebody dies\")."
msgstr ""

msgid ""
"13404      For example, no free store allocation or deallocation may occur "
"after the plane takes off (no memory overflow and no fragmentation allowed)."
msgstr ""

msgid ""
"13405      No exception may be used (because there was no available tool for "
"guaranteeing that an exception would be handled within a fixed short time)."
msgstr ""

msgid ""
"13406      Libraries used have to have been approved for mission critical "
"applications."
msgstr ""

msgid ""
"13407      Any similarities to this set of guidelines are unsurprising "
"because Bjarne Stroustrup was an author of JSF++."
msgstr ""

msgid "13408      Recommended, but note its very specific focus."
msgstr ""

msgid ""
"13409    * [Mozilla Portability Guide](https://developer.mozilla.org/en-US/"
"docs/Mozilla/C%2B%2B_Portability_Guide)."
msgstr ""

msgid ""
"13410      As the name indicates, this aims for portability across many "
"(old) compilers."
msgstr ""

msgid "13411      As such, it is restrictive."
msgstr ""

msgid ""
"13412    * [Geosoft.no: C++ Programming Style Guidelines](http://geosoft.no/"
"development/cppstyle.html)."
msgstr ""

msgid "13413      ???."
msgstr ""

msgid ""
"13414    * [Possibility.com: C++ Coding Standard](http://www.possibility.com/"
"Cpp/CppCodingStandard.html)."
msgstr ""

msgid "13415      ???."
msgstr ""

msgid ""
"13416    * [SEI CERT: Secure C++ Coding Standard](https://www.securecoding."
"cert.org/confluence/pages/viewpage.action?pageId=637)."
msgstr ""

msgid ""
"13417      A very nicely done set of rules (with examples and rationales) "
"done for security-sensitive code."
msgstr ""

msgid "13418      Many of their rules apply generally."
msgstr ""

msgid ""
"13419    * [High Integrity C++ Coding Standard](http://www.codingstandard."
"com/)."
msgstr ""

msgid "13420    * [llvm](http://llvm.org/docs/CodingStandards.html)."
msgstr ""

msgid ""
"13421      Somewhat brief, pre-C++11, and (not unreasonably) adjusted to its "
"domain."
msgstr ""

msgid "13422    * ???"
msgstr ""

msgid ""
"13423    ## <a name=\"SS-books\"></a>RF.books: Books with coding guidelines"
msgstr ""

msgid ""
"13424    * [Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-"
"Wesley 1996."
msgstr ""

msgid ""
"13425    * [Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second "
"Edition*. Addison-Wesley 1997."
msgstr ""

msgid ""
"13426    * [Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-"
"Wesley 2001."
msgstr ""

msgid ""
"13427    * [Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third "
"Edition*. Addison-Wesley 2005."
msgstr ""

msgid ""
"13428    * [Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. "
"O'Reilly 2015."
msgstr ""

msgid ""
"13429    * [SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding "
"Standards*. Addison-Wesley 2005. More a set of meta-rules than a set of "
"rules. Pre-C++11."
msgstr ""

msgid ""
"13430    * [Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for "
"semantically enhanced library languages](http://www.stroustrup.com/"
"SELLrationale.pdf)."
msgstr ""

msgid "13431      LCSD05. October 2005."
msgstr ""

msgid ""
"13432    * [Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](http://"
"www.stroustrup.com/Tour.html)."
msgstr ""

msgid "13433      Addison Wesley 2014."
msgstr ""

msgid ""
"13434      Each chapter ends with an advice section consisting of a set of "
"recommendations."
msgstr ""

msgid ""
"13435    * [Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming "
"Language (4th Edition)](http://www.stroustrup.com/4th.html)."
msgstr ""

msgid "13436      Addison Wesley 2013."
msgstr ""

msgid ""
"13437      Each chapter ends with an advice section consisting of a set of "
"recommendations."
msgstr ""

msgid ""
"13438    * Stroustrup: [Style Guide](http://www.stroustrup.com/Programming/"
"PPP-style.pdf)"
msgstr ""

msgid ""
"13439      for [Programming: Principles and Practice using C++](http://www."
"stroustrup.com/programming.html)."
msgstr ""

msgid "13440      Mostly low-level naming and layout rules."
msgstr ""

msgid "13441      Primarily a teaching tool."
msgstr ""

msgid ""
"13442    ## <a name=\"SS-Cplusplus\"></a>RF.C++: C++ Programming (C++11/"
"C++14)"
msgstr ""

msgid "13443    * [TC++PL4](http://www.stroustrup.com/4th.html):"
msgstr ""

msgid ""
"13444    A thorough description of the C++ language and standard libraries "
"for experienced programmers."
msgstr ""

msgid "13445    * [Tour++](http://www.stroustrup.com/Tour.html):"
msgstr ""

msgid ""
"13446    An overview of the C++ language and standard libraries for "
"experienced programmers."
msgstr ""

msgid ""
"13447    * [Programming: Principles and Practice using C++](http://www."
"stroustrup.com/programming.html):"
msgstr ""

msgid "13448    A textbook for beginners and relative novices."
msgstr ""

msgid "13449    ## <a name=\"SS-web\"></a>RF.web: Websites"
msgstr ""

msgid "13450    * [isocpp.org](https://isocpp.org)"
msgstr ""

msgid "13451    * [Bjarne Stroustrup's home pages](http://www.stroustrup.com)"
msgstr ""

msgid "13452    * [WG21](http://www.open-std.org/jtc1/sc22/wg21/)"
msgstr ""

msgid "13453    * [Boost](http://www.boost.org)<a name=\"Boost\"></a>"
msgstr ""

msgid "13454    * [Adobe open source](http://www.adobe.com/open-source.html)"
msgstr ""

msgid "13455    * [Poco libraries](http://pocoproject.org/)"
msgstr ""

msgid "13456    * Sutter's Mill?"
msgstr ""

msgid "13457    * ???"
msgstr ""

msgid "13458    ## <a name=\"SS-vid\"></a>RS.video: Videos about \"modern C++\""
msgstr ""

msgid ""
"13459    * Bjarne Stroustrup: [C++11 Style](http://channel9.msdn.com/Events/"
"GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style). 2012."
msgstr ""

msgid ""
"13460    * Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, "
"C++98, C++11, and C++14](http://channel9.msdn.com/Events/GoingNative/2013/"
"Opening-Keynote-Bjarne-Stroustrup). 2013"
msgstr ""

msgid ""
"13461    * All the talks from [CppCon '14](https://isocpp.org/blog/2014/11/"
"cppcon-videos-c9)"
msgstr ""

msgid ""
"13462    * Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/"
"watch?v=86xWVb4XIyE) at the University of Edinburgh. 2014."
msgstr ""

msgid ""
"13463    * Bjarne Stroustrup: [The Evolution of C++ Past, Present and "
"Future](https://www.youtube.com/watch?v=_wzc7a3McOs). CppCon 2016 keynote."
msgstr ""

msgid ""
"13464    * Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www."
"youtube.com/watch?v=nesCaocNjtQ). CppCon 2014 keynote."
msgstr ""

msgid ""
"13465    * Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/"
"watch?v=1OEu9C51K2A). CppCon 2015 keynote about the Core Guidelines."
msgstr ""

msgid ""
"13466    * Herb Sutter: [Writing Good C++14... By Default](https://www."
"youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote about the Core "
"Guidelines."
msgstr ""

msgid "13467    * CppCon 15"
msgstr ""

msgid "13468    * ??? C++ Next"
msgstr ""

msgid "13469    * ??? Meting C++"
msgstr ""

msgid "13470    * ??? more ???"
msgstr ""

msgid "13471    ## <a name=\"SS-man\"></a>RF.man: Manuals"
msgstr ""

msgid "13472    * ISO C++ Standard C++11."
msgstr ""

msgid "13473    * ISO C++ Standard C++14."
msgstr ""

msgid ""
"13474    * [ISO C++ Standard C++17 CD](http://www.open-std.org/jtc1/sc22/"
"wg21/docs/papers/2016/n4606.pdf). Committee Draft."
msgstr ""

msgid ""
"13475    * [Palo Alto \"Concepts\" TR](http://www.open-std.org/jtc1/sc22/"
"wg21/docs/papers/2012/n3351.pdf)."
msgstr ""

msgid ""
"13476    * [ISO C++ Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/"
"papers/2015/n4553.pdf)."
msgstr ""

msgid ""
"13477    * [WG21 Ranges report](http://www.open-std.org/jtc1/sc22/wg21/docs/"
"papers/2016/n4569.pdf). Draft."
msgstr ""

msgid "13478    ## <a name=\"SS-core\"></a>RF.core: Core Guidelines materials"
msgstr ""

msgid ""
"13479    This section contains materials that has been useful for presenting "
"the core guidelines and the ideas behind them:"
msgstr ""

msgid ""
"13480    * [Our documents directory](https://github.com/isocpp/"
"CppCoreGuidelines/tree/master/docs)"
msgstr ""

msgid ""
"13481    * Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++'s "
"model for type- and resource-safety](http://www.stroustrup.com/resource-"
"model.pdf). A paper with lots of examples."
msgstr ""

msgid ""
"13482    * Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/"
"watch?v=DyLwdl_6vmU)"
msgstr ""

msgid ""
"13483    and here are the [slides](http://2017.cppconf.ru/talks/sergey-"
"zubkov). In Russian. 2017."
msgstr ""

msgid ""
"13484    * Neil MacIntosh: [The Guideline Support Library: One Year "
"Later](https://www.youtube.com/watch?v=_GhNnCuaEjo). CppCon 2016."
msgstr ""

msgid ""
"13485    * Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/"
"watch?v=1OEu9C51K2A). CppCon 2015 keynote."
msgstr ""

msgid ""
"13486    * Herb Sutter: [Writing Good C++14... By Default](https://www."
"youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote."
msgstr ""

msgid ""
"13487    * Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code "
"Base](https://www.youtube.com/watch?v=fQ926v4ZzAM). ACCU 2017."
msgstr ""

msgid ""
"13488    * Bjarne Stroustrup: [No Littering!](https://www.youtube.com/"
"watch?v=01zI9kV4h8c). Bay Area ACCU 2016."
msgstr ""

msgid ""
"13489    It gives some idea of the ambition level for the Core Guidelines."
msgstr ""

msgid ""
"13490    Note that slides for CppCon presentations are available (links with "
"the posted videos)."
msgstr ""

msgid "13491    Contributions to this list would be most welcome."
msgstr ""

msgid "13492    ## <a name=\"SS-ack\"></a>Acknowledgements"
msgstr ""

msgid ""
"13493    Thanks to the many people who contributed rules, suggestions, "
"supporting information, references, etc.:"
msgstr ""

msgid "13494    * Peter Juhl"
msgstr ""

msgid "13495    * Neil MacIntosh"
msgstr ""

msgid "13496    * Axel Naumann"
msgstr ""

msgid "13497    * Andrew Pardoe"
msgstr ""

msgid "13498    * Gabriel Dos Reis"
msgstr ""

msgid "13499    * Zhuang, Jiangang (Jeff)"
msgstr ""

msgid "13500    * Sergey Zubkov"
msgstr ""

msgid "13501    and see the contributor list on the github."
msgstr ""

msgid "13502    # <a name=\"S-profile\"></a>Pro: Profiles"
msgstr ""

msgid "13503    Ideally, we would follow all of the guidelines."
msgstr ""

msgid ""
"13504    That would give the cleanest, most regular, least error-prone, and "
"often the fastest code."
msgstr ""

msgid ""
"13505    Unfortunately, that is usually impossible because we have to fit "
"our code into large code bases and use existing libraries."
msgstr ""

msgid ""
"13506    Often, such code has been written over decades and does not follow "
"these guidelines."
msgstr ""

msgid "13507    We must aim for [gradual adoption](#S-modernizing)."
msgstr ""

msgid ""
"13508    Whatever strategy for gradual adoption we adopt, we need to be able "
"to apply sets of related guidelines to address some set"
msgstr ""

msgid "13509    of problems first and leave the rest until later."
msgstr ""

msgid ""
"13510    A similar idea of \"related guidelines\" becomes important when "
"some, but not all, guidelines are considered relevant to a code base"
msgstr ""

msgid ""
"13511    or if a set of specialized guidelines is to be applied for a "
"specialized application area."
msgstr ""

msgid "13512    We call such a set of related guidelines a \"profile\"."
msgstr ""

msgid ""
"13513    We aim for such a set of guidelines to be coherent so that they "
"together help us reach a specific goal, such as \"absence of range errors\""
msgstr ""

msgid "13514    or \"static type safety.\""
msgstr ""

msgid "13515    Each profile is designed to eliminate a class of errors."
msgstr ""

msgid ""
"13516    Enforcement of \"random\" rules in isolation is more likely to be "
"disruptive to a code base than delivering a definite improvement."
msgstr ""

msgid ""
"13517    A \"profile\" is a set of deterministic and portably enforceable "
"subset rules (i.e., restrictions) that are designed to achieve a specific "
"guarantee."
msgstr ""

msgid ""
"13518    \"Deterministic\" means they require only local analysis and could "
"be implemented in a compiler (though they don't need to be)."
msgstr ""

msgid ""
"13519    \"Portably enforceable\" means they are like language rules, so "
"programmers can count on different enforcement tools giving the same answer "
"for the same code."
msgstr ""

msgid ""
"13520    Code written to be warning-free using such a language profile is "
"considered to conform to the profile."
msgstr ""

msgid ""
"13521    Conforming code is considered to be safe by construction with "
"regard to the safety properties targeted by that profile."
msgstr ""

msgid ""
"13522    Conforming code will not be the root cause of errors for that "
"property,"
msgstr ""

msgid ""
"13523    although such errors may be introduced into a program by other "
"code, libraries or the external environment."
msgstr ""

msgid ""
"13524    A profile may also introduce additional library types to ease "
"conformance and encourage correct code."
msgstr ""

msgid "13525    Profiles summary:"
msgstr ""

msgid "13526    * [Pro.type: Type safety](#SS-type)"
msgstr ""

msgid "13527    * [Pro.bounds: Bounds safety](#SS-bounds)"
msgstr ""

msgid "13528    * [Pro.lifetime: Lifetime safety](#SS-lifetime)"
msgstr ""

msgid ""
"13529    In the future, we expect to define many more profiles and add more "
"checks to existing profiles."
msgstr ""

msgid "13530    Candidates include:"
msgstr ""

msgid ""
"13531    * narrowing arithmetic promotions/conversions (likely part of a "
"separate safe-arithmetic profile)"
msgstr ""

msgid ""
"13532    * arithmetic cast from negative floating point to unsigned integral "
"type (ditto)"
msgstr ""

msgid ""
"13533    * selected undefined behavior: Start with Gabriel Dos Reis's UB "
"list developed for the WG21 study group"
msgstr ""

msgid ""
"13534    * selected unspecified behavior: Addressing portability concerns."
msgstr ""

msgid ""
"13535    * `const` violations: Mostly done by compilers already, but we can "
"catch inappropriate casting and underuse of `const`."
msgstr ""

msgid ""
"13536    Enabling a profile is implementation defined; typically, it is set "
"in the analysis tool used."
msgstr ""

msgid ""
"13537    To suppress enforcement of a profile check, place a `suppress` "
"annotation on a language contract. For example:"
msgstr ""

msgid ""
"13538        [[suppress(bounds)]] char* raw_find(char* p, int n, char x)    /"
"/ find x in p[0]..p[n - 1]"
msgstr ""

msgid "13539        {"
msgstr ""

msgid "13540            // ..."
msgstr ""

msgid "13541        }"
msgstr ""

msgid "13542    Now `raw_find()` can scramble memory to its heart's content."
msgstr ""

msgid "13543    Obviously, suppression should be very rare."
msgstr ""

msgid "13544    ## <a name=\"SS-type\"></a>Pro.safety: Type-safety profile"
msgstr ""

msgid ""
"13545    This profile makes it easier to construct code that uses types "
"correctly and avoids inadvertent type punning."
msgstr ""

msgid ""
"13546    It does so by focusing on removing the primary sources of type "
"violations, including unsafe uses of casts and unions."
msgstr ""

msgid "13547    For the purposes of this section,"
msgstr ""

msgid ""
"13548    type-safety is defined to be the property that a variable is not "
"used in a way that doesn't obey the rules for the type of its definition."
msgstr ""

msgid ""
"13549    Memory accessed as a type `T` should not be valid memory that "
"actually contains an object of an unrelated type `U`."
msgstr ""

msgid ""
"13550    Note that the safety is intended to be complete when combined also "
"with [Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime)."
msgstr ""

msgid ""
"13551    An implementation of this profile shall recognize the following "
"patterns in source code as non-conforming and issue a diagnostic."
msgstr ""

msgid "13552    Type safety profile summary:"
msgstr ""

msgid ""
"13553    * <a name=\"Pro-type-avoidcasts\"></a>Type.1: [Avoid casts](#Res-"
"casts):"
msgstr ""

msgid ""
"13554    <a name=\"Pro-type-reinterpretcast\">a. </a>Don't use "
"`reinterpret_cast`; A strict version of [Avoid casts](#Res-casts) and "
"[prefer named casts](#Res-casts-named)."
msgstr ""

msgid ""
"13555    <a name=\"Pro-type-arithmeticcast\">b. </a>Don't use `static_cast` "
"for arithmetic types; A strict version of [Avoid casts](#Res-casts) and "
"[prefer named casts](#Res-casts-named)."
msgstr ""

msgid ""
"13556    <a name=\"Pro-type-identitycast\">c. </a>Don't cast between pointer "
"types where the source type and the target type are the same; A strict "
"version of [Avoid casts](#Res-casts)."
msgstr ""

msgid ""
"13557    <a name=\"Pro-type-implicitpointercast\">d. </a>Don't cast between "
"pointer types when the conversion could be implicit; A strict version of "
"[Avoid casts](#Res-casts)."
msgstr ""

msgid ""
"13558    * <a name=\"Pro-type-downcast\"></a>Type.2: Don't use `static_cast` "
"to downcast:"
msgstr ""

msgid "13559    [Use `dynamic_cast` instead](#Rh-dynamic_cast)."
msgstr ""

msgid ""
"13560    * <a name=\"Pro-type-constcast\"></a>Type.3: Don't use `const_cast` "
"to cast away `const` (i.e., at all):"
msgstr ""

msgid "13561    [Don't cast away const](#Res-casts-const)."
msgstr ""

msgid ""
"13562    * <a name=\"Pro-type-cstylecast\"></a>Type.4: Don't use C-style "
"`(T)expression` or functional `T(expression)` casts:"
msgstr ""

msgid ""
"13563    Prefer [construction](#Res-construct) or [named casts](#Res-cast-"
"named)."
msgstr ""

msgid ""
"13564    * <a name=\"Pro-type-init\"></a>Type.5: Don't use a variable before "
"it has been initialized:"
msgstr ""

msgid "13565    [always initialize](#Res-always)."
msgstr ""

msgid ""
"13566    * <a name=\"Pro-type-memberinit\"></a>Type.6: Always initialize a "
"member variable:"
msgstr ""

msgid "13567    [always initialize](#Res-always),"
msgstr ""

msgid "13568    possibly using [default constructors](#Rc-default0) or"
msgstr ""

msgid "13569    [default member initializers](#Rc-in-class-initializers)."
msgstr ""

msgid "13570    * <a name=\"Pro-type-unon\"></a>Type.7: Avoid naked union:"
msgstr ""

msgid "13571    [Use `variant` instead](#Ru-naked)."
msgstr ""

msgid "13572    * <a name=\"Pro-type-varargs\"></a>Type.8: Avoid varargs:"
msgstr ""

msgid "13573    [Don't use `va_arg` arguments](#F-varargs)."
msgstr ""

msgid "13574    ##### Impact"
msgstr ""

msgid ""
"13575    With the type-safety profile you can trust that every operation is "
"applied to a valid object."
msgstr ""

msgid ""
"13576    Exception may be thrown to indicate errors that cannot be detected "
"statically (at compile time)."
msgstr ""

msgid ""
"13577    Note that this type-safety can be complete only if we also have "
"[Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime)."
msgstr ""

msgid ""
"13578    Without those guarantees, a region of memory could be accessed "
"independent of which object, objects, or parts of objects are stored in it."
msgstr ""

msgid "13579    ## <a name=\"SS-bounds\"></a>Pro.bounds: Bounds safety profile"
msgstr ""

msgid ""
"13580    This profile makes it easier to construct code that operates within "
"the bounds of allocated blocks of memory."
msgstr ""

msgid ""
"13581    It does so by focusing on removing the primary sources of bounds "
"violations: pointer arithmetic and array indexing."
msgstr ""

msgid ""
"13582    One of the core features of this profile is to restrict pointers to "
"only refer to single objects, not arrays."
msgstr ""

msgid ""
"13583    We define bounds-safety to be the property that a program does not "
"use an object to access memory outside of the range that was allocated for "
"it."
msgstr ""

msgid ""
"13584    Bounds safety is intended to be complete only when combined with "
"[Type safety](#SS-type) and [Lifetime safety](#SS-lifetime),"
msgstr ""

msgid ""
"13585    which cover other unsafe operations that allow bounds violations."
msgstr ""

msgid "13586    Bounds safety profile summary:"
msgstr ""

msgid ""
"13587    * <a href=\"Pro-bounds-arithmetic\"></a>Bounds.1: Don't use pointer "
"arithmetic. Use `span` instead:"
msgstr ""

msgid ""
"13588    [Pass pointers to single objects (only)](#Ri-array) and [Keep "
"pointer arithmetic simple](#Res-simple)."
msgstr ""

msgid ""
"13589    * <a href=\"Pro-bounds-arrayindex\"></a>Bounds.2: Only index into "
"arrays using constant expressions:"
msgstr ""

msgid ""
"13590    [Pass pointers to single objects (only)](#Ri-array) and [Keep "
"pointer arithmetic simple](#Res-simple)."
msgstr ""

msgid ""
"13591    * <a href=\"Pro-bounds-decay\"></a>Bounds.3: No array-to-pointer "
"decay:"
msgstr ""

msgid ""
"13592    [Pass pointers to single objects (only)](#Ri-array) and [Keep "
"pointer arithmetic simple](#Res-simple)."
msgstr ""

msgid ""
"13593    * <a href=\"Pro-bounds-stdlib\"></a>Bounds.4: Don't use standard-"
"library functions and types that are not bounds-checked:"
msgstr ""

msgid ""
"13594    [Use the standard library in a type-safe manner](#Rsl-bounds)."
msgstr ""

msgid "13595    ##### Impact"
msgstr ""

msgid ""
"13596    Bounds safety implies that access to an object - notably arrays - "
"does not access beyond the object's memory allocation."
msgstr ""

msgid ""
"13597    This eliminates a large class of insidious and hard-to-find errors, "
"including the (in)famous \"buffer overflow\" errors."
msgstr ""

msgid ""
"13598    This closes security loopholes as well as a prominent source of "
"memory corruption (when writing out of bounds)."
msgstr ""

msgid ""
"13599    Even an out-of-bounds access is \"just a read\", it can lead to "
"invariant violations (when the accessed isn't of the assumed type)"
msgstr ""

msgid "13600    and \"mysterious values.\""
msgstr ""

msgid ""
"13601    ## <a name=\"SS-lifetime\"></a>Pro.lifetime: Lifetime safety "
"profile"
msgstr ""

msgid ""
"13602    Accessing through a pointer that doesn't point to anything is a "
"major source of errors,"
msgstr ""

msgid ""
"13603    and very hard to avoid in many traditional C or C++ styles of "
"programming."
msgstr ""

msgid ""
"13604    For example, a pointer may be uninitialized, the `nullptr`, point "
"beyond the range of an array, or to a deleted object."
msgstr ""

msgid ""
"13605    See /docs folder for the initial design. The detailed formal rules "
"are in progress (as of May 2017)."
msgstr ""

msgid "13606    Lifetime safety profile summary:"
msgstr ""

msgid ""
"13607    * <a href=\"Pro-lifetime-invalid-deref\"></a>Lifetime.1: Don't "
"dereference a possibly invalid pointer:"
msgstr ""

msgid "13608    [detect or avoid](#Res-deref)."
msgstr ""

msgid "13609    ##### Impact"
msgstr ""

msgid ""
"13610    Once completely enforced through a combination of style rules, "
"static analysis, and library support, this profile"
msgstr ""

msgid "13611    * eliminates one of the major sources of nasty errors in C++"
msgstr ""

msgid "13612    * eliminates a major source of potential security violations"
msgstr ""

msgid ""
"13613    * improves performance by eliminating redundant \"paranoia\" checks"
msgstr ""

msgid "13614    * increases confidence in correctness of code"
msgstr ""

msgid ""
"13615    * avoids undefined behavior by enforcing a key C++ language rule"
msgstr ""

msgid "13616    # <a name=\"S-gsl\"></a>GSL: Guidelines support library"
msgstr ""

msgid ""
"13617    The GSL is a small library of facilities designed to support this "
"set of guidelines."
msgstr ""

msgid ""
"13618    Without these facilities, the guidelines would have to be far more "
"restrictive on language details."
msgstr ""

msgid ""
"13619    The Core Guidelines support library is defined in namespace `gsl` "
"and the names may be aliases for standard library or other well-known "
"library names. Using the (compile-time) indirection through the `gsl` "
"namespace allows for experimentation and for local variants of the support "
"facilities."
msgstr ""

msgid ""
"13620    The GSL is header only, and can be found at [GSL: Guidelines "
"support library](https://github.com/Microsoft/GSL)."
msgstr ""

msgid ""
"13621    The support library facilities are designed to be extremely "
"lightweight (zero-overhead) so that they impose no overhead compared to "
"using conventional alternatives."
msgstr ""

msgid ""
"13622    Where desirable, they can be \"instrumented\" with additional "
"functionality (e.g., checks) for tasks such as debugging."
msgstr ""

msgid ""
"13623    These Guidelines assume a `variant` type, but this is not currently "
"in GSL."
msgstr ""

msgid ""
"13624    Eventually, use [the one voted into C++17](http://www.open-std.org/"
"jtc1/sc22/wg21/docs/papers/2016/p0088r3.html)."
msgstr ""

msgid "13625    Summary of GSL components:"
msgstr ""

msgid "13626    * [GSL.view: Views](#SS-views)"
msgstr ""

msgid "13627    * [GSL.owner](#SS-ownership)"
msgstr ""

msgid "13628    * [GSL.assert: Assertions](#SS-assertions)"
msgstr ""

msgid "13629    * [GSL.util: Utilities](#SS-utilities)"
msgstr ""

msgid "13630    * [GSL.concept: Concepts](#SS-gsl-concepts)"
msgstr ""

msgid ""
"13631    We plan for a \"ISO C++ standard style\" semi-formal specification "
"of the GSL."
msgstr ""

msgid ""
"13632    We rely on the ISO C++ Standard Library and hope for parts of the "
"GSL to be absorbed into the standard library."
msgstr ""

msgid "13633    ## <a name=\"SS-views\"></a>GSL.view: Views"
msgstr ""

msgid ""
"13634    These types allow the user to distinguish between owning and non-"
"owning pointers and between pointers to a single object and pointers to the "
"first element of a sequence."
msgstr ""

msgid "13635    These \"views\" are never owners."
msgstr ""

msgid ""
"13636    References are never owners (see [R.4](#Rr-ref). Note: References "
"have many opportunities to outlive the objects they refer to (returning a "
"local variable by reference, holding a reference to an element of a vector "
"and doing `push_back`, binding to `std::max(x, y + 1)`, etc. The Lifetime "
"safety profile aims to address those things, but even so `owner<T&>` does "
"not make sense and is discouraged."
msgstr ""

msgid ""
"13637    The names are mostly ISO standard-library style (lower case and "
"underscore):"
msgstr ""

msgid ""
"13638    * `T*`      // The `T*` is not an owner, may be null; assumed to be "
"pointing to a single element."
msgstr ""

msgid ""
"13639    * `T&`      // The `T&` is not an owner and can never be a \"null "
"reference\"; references are always bound to objects."
msgstr ""

msgid ""
"13640    The \"raw-pointer\" notation (e.g. `int*`) is assumed to have its "
"most common meaning; that is, a pointer points to an object, but does not "
"own it."
msgstr ""

msgid ""
"13641    Owners should be converted to resource handles (e.g., `unique_ptr` "
"or `vector<T>`) or marked `owner<T*>`."
msgstr ""

msgid ""
"13642    * `owner<T*>`   // a `T*` that owns the object pointed/referred to; "
"may be `nullptr`."
msgstr ""

msgid ""
"13643    `owner` is used to mark owning pointers in code that cannot be "
"upgraded to use proper resource handles."
msgstr ""

msgid "13644    Reasons for that include:"
msgstr ""

msgid "13645    * Cost of conversion."
msgstr ""

msgid "13646    * The pointer is used with an ABI."
msgstr ""

msgid ""
"13647    * The pointer is part of the implementation of a resource handle."
msgstr ""

msgid ""
"13648    An `owner<T>` differs from a resource handle for a `T` by still "
"requiring an explicit `delete`."
msgstr ""

msgid ""
"13649    An `owner<T>` is assumed to refer to an object on the free store "
"(heap)."
msgstr ""

msgid "13650    If something is not supposed to be `nullptr`, say so:"
msgstr ""

msgid ""
"13651    * `not_null<T>`   // `T` is usually a pointer type (e.g., "
"`not_null<int*>` and `not_null<owner<Foo*>>`) that may not be `nullptr`."
msgstr ""

msgid "13652      `T` can be any type for which `==nullptr` is meaningful."
msgstr ""

msgid ""
"13653    * `span<T>`       // `[p:p+n)`, constructor from `{p, q}` and `{p, "
"n}`; `T` is the pointer type"
msgstr ""

msgid ""
"13654    * `span_p<T>`     // `{p, predicate}` `[p:q)` where `q` is the "
"first element for which `predicate(*p)` is true"
msgstr ""

msgid "13655    * `string_span`   // `span<char>`"
msgstr ""

msgid "13656    * `cstring_span`  // `span<const char>`"
msgstr ""

msgid ""
"13657    A `span<T>` refers to zero or more mutable `T`s unless `T` is a "
"`const` type."
msgstr ""

msgid "13658    \"Pointer arithmetic\" is best done within `span`s."
msgstr ""

msgid ""
"13659    A `char*` that points to more than one `char` but is not a C-style "
"string (e.g., a pointer into an input buffer) should be represented by a "
"`span`."
msgstr ""

msgid ""
"13660    * `zstring`    // a `char*` supposed to be a C-style string; that "
"is, a zero-terminated sequence of `char` or `nullptr`"
msgstr ""

msgid ""
"13661    * `czstring`   // a `const char*` supposed to be a C-style string; "
"that is, a zero-terminated sequence of `const` `char` or `nullptr`"
msgstr ""

msgid ""
"13662    Logically, those last two aliases are not needed, but we are not "
"always logical, and they make the distinction between a pointer to one "
"`char` and a pointer to a C-style string explicit."
msgstr ""

msgid ""
"13663    A sequence of characters that is not assumed to be zero-terminated "
"should be a `char*`, rather than a `zstring`."
msgstr ""

msgid "13664    French accent optional."
msgstr ""

msgid ""
"13665    Use `not_null<zstring>` for C-style strings that cannot be "
"`nullptr`. ??? Do we need a name for `not_null<zstring>`? or is its ugliness "
"a feature?"
msgstr ""

msgid "13666    ## <a name=\"SS-ownership\"></a>GSL.owner: Ownership pointers"
msgstr ""

msgid ""
"13667    * `unique_ptr<T>`     // unique ownership: `std::unique_ptr<T>`"
msgstr ""

msgid ""
"13668    * `shared_ptr<T>`     // shared ownership: `std::shared_ptr<T>` (a "
"counted pointer)"
msgstr ""

msgid ""
"13669    * `stack_array<T>`    // A stack-allocated array. The number of "
"elements are determined at construction and fixed thereafter. The elements "
"are mutable unless `T` is a `const` type."
msgstr ""

msgid ""
"13670    * `dyn_array<T>`      // ??? needed ??? A heap-allocated array. The "
"number of elements are determined at construction and fixed thereafter."
msgstr ""

msgid ""
"13671      The elements are mutable unless `T` is a `const` type. Basically "
"a `span` that allocates and owns its elements."
msgstr ""

msgid "13672    ## <a name=\"SS-assertions\"></a>GSL.assert: Assertions"
msgstr ""

msgid ""
"13673    * `Expects`     // precondition assertion. Currently placed in "
"function bodies. Later, should be moved to declarations."
msgstr ""

msgid ""
"13674                    // `Expects(p)` terminates the program unless `p == "
"true`"
msgstr ""

msgid ""
"13675                    // `Expect` in under control of some options "
"(enforcement, error message, alternatives to terminate)"
msgstr ""

msgid ""
"13676    * `Ensures`     // postcondition assertion. Currently placed in "
"function bodies. Later, should be moved to declarations."
msgstr ""

msgid ""
"13677    These assertions are currently macros (yuck!) and must appear in "
"function definitions (only)"
msgstr ""

msgid ""
"13678    pending standard committee decisions on contracts and assertion "
"syntax."
msgstr ""

msgid ""
"13679    See [the contract proposal](http://www.open-std.org/jtc1/sc22/wg21/"
"docs/papers/2016/p0380r1.pdf); using the attribute syntax,"
msgstr ""

msgid "13680    for example, `Expects(p)` will become `[[expects: p]]`."
msgstr ""

msgid "13681    ## <a name=\"SS-utilities\"></a>GSL.util: Utilities"
msgstr ""

msgid ""
"13682    * `finally`        // `finally(f)` makes a `final_action{f}` with a "
"destructor that invokes `f`"
msgstr ""

msgid ""
"13683    * `narrow_cast`    // `narrow_cast<T>(x)` is `static_cast<T>(x)`"
msgstr ""

msgid ""
"13684    * `narrow`         // `narrow<T>(x)` is `static_cast<T>(x)` if "
"`static_cast<T>(x) == x` or it throws `narrowing_error`"
msgstr ""

msgid ""
"13685    * `[[implicit]]`   // \"Marker\" to put on single-argument "
"constructors to explicitly make them non-explicit."
msgstr ""

msgid ""
"13686    * `move_owner`     // `p = move_owner(q)` means `p = q` but ???"
msgstr ""

msgid ""
"13687    * `joining_thread` // a RAII style version of `std::thread` that "
"joins."
msgstr ""

msgid ""
"13688    * `index`          // a type to use for all container and array "
"indexing (currently an alias for `ptrdiff_t`)"
msgstr ""

msgid "13689    ## <a name=\"SS-gsl-concepts\"></a>GSL.concept: Concepts"
msgstr ""

msgid "13690    These concepts (type predicates) are borrowed from"
msgstr ""

msgid "13691    Andrew Sutton's Origin library,"
msgstr ""

msgid "13692    the Range proposal,"
msgstr ""

msgid "13693    and the ISO WG21 Palo Alto TR."
msgstr ""

msgid ""
"13694    They are likely to be very similar to what will become part of the "
"ISO C++ standard."
msgstr ""

msgid ""
"13695    The notation is that of the ISO WG21 [Concepts TS](http://www.open-"
"std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr ""

msgid ""
"13696    Most of the concepts below are defined in [the Ranges TS](http://"
"www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)."
msgstr ""

msgid "13697    * `Range`"
msgstr ""

msgid "13698    * `String`   // ???"
msgstr ""

msgid "13699    * `Number`   // ???"
msgstr ""

msgid "13700    * `Sortable`"
msgstr ""

msgid ""
"13701    * `Pointer`  // A type with `*`, `->`, `==`, and default "
"construction (default construction is assumed to set the singular \"null\" "
"value); see [smart pointers](#SS-gsl-smartptrconcepts)"
msgstr ""

msgid ""
"13702    * `Unique_ptr`  // A type that matches `Pointer`, has move (not "
"copy), and matches the Lifetime profile criteria for a `unique` owner type; "
"see [smart pointers](#SS-gsl-smartptrconcepts)"
msgstr ""

msgid ""
"13703    * `Shared_ptr`   // A type that matches `Pointer`, has copy, and "
"matches the Lifetime profile criteria for a `shared` owner type; see [smart "
"pointers](#SS-gsl-smartptrconcepts)"
msgstr ""

msgid "13704    * `EqualityComparable`   // ???Must we suffer CaMelcAse???"
msgstr ""

msgid "13705    * `Convertible`"
msgstr ""

msgid "13706    * `Common`"
msgstr ""

msgid "13707    * `Boolean`"
msgstr ""

msgid "13708    * `Integral`"
msgstr ""

msgid "13709    * `SignedIntegral`"
msgstr ""

msgid "13710    * `SemiRegular` // ??? Copyable?"
msgstr ""

msgid "13711    * `Regular`"
msgstr ""

msgid "13712    * `TotallyOrdered`"
msgstr ""

msgid "13713    * `Function`"
msgstr ""

msgid "13714    * `RegularFunction`"
msgstr ""

msgid "13715    * `Predicate`"
msgstr ""

msgid "13716    * `Relation`"
msgstr ""

msgid "13717    * ..."
msgstr ""

msgid ""
"13718    ### <a name=\"SS-gsl-smartptrconcepts\"></a>GSL.ptr: Smart pointer "
"concepts"
msgstr ""

msgid ""
"13719    See [Lifetimes paper](https://github.com/isocpp/CppCoreGuidelines/"
"blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf)."
msgstr ""

msgid "13720    # <a name=\"S-naming\"></a>NL: Naming and layout rules"
msgstr ""

msgid "13721    Consistent naming and layout are helpful."
msgstr ""

msgid ""
"13722    If for no other reason because it minimizes \"my style is better "
"than your style\" arguments."
msgstr ""

msgid ""
"13723    However, there are many, many, different styles around and people "
"are passionate about them (pro and con)."
msgstr ""

msgid ""
"13724    Also, most real-world projects includes code from many sources, so "
"standardizing on a single style for all code is often impossible."
msgstr ""

msgid ""
"13725    We present a set of rules that you might use if you have no better "
"ideas, but the real aim is consistency, rather than any particular rule set."
msgstr ""

msgid "13726    IDEs and tools can help (as well as hinder)."
msgstr ""

msgid "13727    Naming and layout rules:"
msgstr ""

msgid ""
"13728    * [NL.1: Don't say in comments what can be clearly stated in "
"code](#Rl-comments)"
msgstr ""

msgid "13729    * [NL.2: State intent in comments](#Rl-comments-intent)"
msgstr ""

msgid "13730    * [NL.3: Keep comments crisp](#Rl-comments-crisp)"
msgstr ""

msgid "13731    * [NL.4: Maintain a consistent indentation style](#Rl-indent)"
msgstr ""

msgid ""
"13732    * [NL.5: Avoid encoding type information in names](#Rl-name-type)"
msgstr ""

msgid ""
"13733    * [NL.7: Make the length of a name roughly proportional to the "
"length of its scope](#Rl-name-length)"
msgstr ""

msgid "13734    * [NL.8: Use a consistent naming style](#Rl-name)"
msgstr ""

msgid "13735    * [NL.9: Use `ALL_CAPS` for macro names only](#Rl-all-caps)"
msgstr ""

msgid "13736    * [NL.10: Prefer `underscore_style` names](#Rl-camel)"
msgstr ""

msgid "13737    * [NL.11: Make literals readable](#Rl-literals)"
msgstr ""

msgid "13738    * [NL.15: Use spaces sparingly](#Rl-space)"
msgstr ""

msgid ""
"13739    * [NL.16: Use a conventional class member declaration order](#Rl-"
"order)"
msgstr ""

msgid "13740    * [NL.17: Use K&R-derived layout](#Rl-knr)"
msgstr ""

msgid "13741    * [NL.18: Use C++-style declarator layout](#Rl-ptr)"
msgstr ""

msgid "13742    * [NL.19: Avoid names that are easily misread](#Rl-misread)"
msgstr ""

msgid ""
"13743    * [NL.20: Don't place two statements on the same line](#Rl-stmt)"
msgstr ""

msgid "13744    * [NL.21: Declare one name (only) per declaration](#Rl-dcl)"
msgstr ""

msgid "13745    * [NL.25: Don't use `void` as an argument type](#Rl-void)"
msgstr ""

msgid "13746    * [NL.26: Use conventional `const` notation](#Rl-const)"
msgstr ""

msgid ""
"13747    Most of these rules are aesthetic and programmers hold strong "
"opinions."
msgstr ""

msgid "13748    IDEs also tend to have defaults and a range of alternatives."
msgstr ""

msgid ""
"13749    These rules are suggested defaults to follow unless you have "
"reasons not to."
msgstr ""

msgid ""
"13750    We have had comments to the effect that naming and layout are so "
"personal and/or arbitrary that we should not try to \"legislate\" them."
msgstr ""

msgid "13751    We are not \"legislating\" (see the previous paragraph)."
msgstr ""

msgid ""
"13752    However, we have had many requests for a set of naming and layout "
"conventions to use when there are no external constraints."
msgstr ""

msgid "13753    More specific and detailed rules are easier to enforce."
msgstr ""

msgid ""
"13754    These rules bear a strong resemblance to the recommendations in the "
"[PPP Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)"
msgstr ""

msgid ""
"13755    written in support of Stroustrup's [Programming: Principles and "
"Practice using C++](http://www.stroustrup.com/programming.html)."
msgstr ""

msgid ""
"13756    ### <a name=\"Rl-comments\"></a>NL.1: Don't say in comments what "
"can be clearly stated in code"
msgstr ""

msgid "13757    ##### Reason"
msgstr ""

msgid "13758    Compilers do not read comments."
msgstr ""

msgid "13759    Comments are less precise than code."
msgstr ""

msgid "13760    Comments are not updated as consistently as code."
msgstr ""

msgid "13761    ##### Example, bad"
msgstr ""

msgid ""
"13762        auto x = m * v1 + vv;   // multiply m with v1 and add the "
"result to vv"
msgstr ""

msgid "13763    ##### Enforcement"
msgstr ""

msgid ""
"13764    Build an AI program that interprets colloquial English text and see "
"if what is said could be better expressed in C++."
msgstr ""

msgid ""
"13765    ### <a name=\"Rl-comments-intent\"></a>NL.2: State intent in "
"comments"
msgstr ""

msgid "13766    ##### Reason"
msgstr ""

msgid ""
"13767    Code says what is done, not what is supposed to be done. Often "
"intent can be stated more clearly and concisely than the implementation."
msgstr ""

msgid "13768    ##### Example"
msgstr ""

msgid "13769        void stable_sort(Sortable& c)"
msgstr ""

msgid ""
"13770            // sort c in the order determined by <, keep equal elements "
"(as defined by ==) in"
msgstr ""

msgid "13771            // their original relative order"
msgstr ""

msgid "13772        {"
msgstr ""

msgid "13773            // ... quite a few lines of non-trivial code ..."
msgstr ""

msgid "13774        }"
msgstr ""

msgid "13775    ##### Note"
msgstr ""

msgid ""
"13776    If the comment and the code disagree, both are likely to be wrong."
msgstr ""

msgid "13777    ### <a name=\"Rl-comments-crisp\"></a>NL.3: Keep comments crisp"
msgstr ""

msgid "13778    ##### Reason"
msgstr ""

msgid ""
"13779    Verbosity slows down understanding and makes the code harder to "
"read by spreading it around in the source file."
msgstr ""

msgid "13780    ##### Note"
msgstr ""

msgid "13781    Use intelligible English."
msgstr ""

msgid ""
"13782    I may be fluent in Danish, but most programmers are not; the "
"maintainers of my code may not be."
msgstr ""

msgid ""
"13783    Avoid SMS lingo and watch your grammar, punctuation, and "
"capitalization."
msgstr ""

msgid "13784    Aim for professionalism, not \"cool.\""
msgstr ""

msgid "13785    ##### Enforcement"
msgstr ""

msgid "13786    not possible."
msgstr ""

msgid ""
"13787    ### <a name=\"Rl-indent\"></a>NL.4: Maintain a consistent "
"indentation style"
msgstr ""

msgid "13788    ##### Reason"
msgstr ""

msgid "13789    Readability. Avoidance of \"silly mistakes.\""
msgstr ""

msgid "13790    ##### Example, bad"
msgstr ""

msgid "13791        int i;"
msgstr ""

msgid "13792        for (i = 0; i < max; ++i); // bug waiting to happen"
msgstr ""

msgid "13793        if (i == j)"
msgstr ""

msgid "13794            return i;"
msgstr ""

msgid "13795    ##### Note"
msgstr ""

msgid ""
"13796    Always indenting the statement after `if (...)`, `for (...)`, and "
"`while (...)` is usually a good idea:"
msgstr ""

msgid "13797        if (i < 0) error(\"negative argument\");"
msgstr ""

msgid "13798        if (i < 0)"
msgstr ""

msgid "13799            error(\"negative argument\");"
msgstr ""

msgid "13800    ##### Enforcement"
msgstr ""

msgid "13801    Use a tool."
msgstr ""

msgid ""
"13802    ### <a name=\"Rl-name-type\"></a>NL.5: Avoid encoding type "
"information in names"
msgstr ""

msgid "13803    ##### Rationale"
msgstr ""

msgid ""
"13804    If names reflect types rather than functionality, it becomes hard "
"to change the types used to provide that functionality."
msgstr ""

msgid ""
"13805    Also, if the type of a variable is changed, code using it will have "
"to be modified."
msgstr ""

msgid "13806    Minimize unintentional conversions."
msgstr ""

msgid "13807    ##### Example, bad"
msgstr ""

msgid "13808        void print_int(int i);"
msgstr ""

msgid "13809        void print_string(const char*);"
msgstr ""

msgid ""
"13810        print_int(1);          // repetitive, manual type matching"
msgstr ""

msgid ""
"13811        print_string(\"xyzzy\"); // repetitive, manual type matching"
msgstr ""

msgid "13812    ##### Example, good"
msgstr ""

msgid "13813        void print(int i);"
msgstr ""

msgid ""
"13814        void print(string_view);    // also works on any string-like "
"sequence"
msgstr ""

msgid "13815        print(1);              // clear, automatic type matching"
msgstr ""

msgid "13816        print(\"xyzzy\");        // clear, automatic type matching"
msgstr ""

msgid "13817    ##### Note"
msgstr ""

msgid "13818    Names with types encoded are either verbose or cryptic."
msgstr ""

msgid "13819        printS  // print a std::string"
msgstr ""

msgid "13820        prints  // print a C-style string"
msgstr ""

msgid "13821        printi  // print an int"
msgstr ""

msgid ""
"13822    Requiring techniques like Hungarian notation to encode a type in a "
"name is needed in C, but is generally unnecessary and actively harmful in a "
"strongly statically-typed language like C++, because the annotations get out "
"of date (the warts are just like comments and rot just like them) and they "
"interfere with good use of the language (use the same name and overload "
"resolution instead)."
msgstr ""

msgid "13823    ##### Note"
msgstr ""

msgid ""
"13824    Some styles use very general (not type-specific) prefixes to denote "
"the general use of a variable."
msgstr ""

msgid "13825        auto p = new User();"
msgstr ""

msgid "13826        auto p = make_unique<User>();"
msgstr ""

msgid ""
"13827        // note: \"p\" is not being used to say \"raw pointer to type "
"User,\""
msgstr ""

msgid "13828        //       just generally to say \"this is an indirection\""
msgstr ""

msgid "13829        auto cntHits = calc_total_of_hits(/*...*/);"
msgstr ""

msgid "13830        // note: \"cnt\" is not being used to encode a type,"
msgstr ""

msgid ""
"13831        //       just generally to say \"this is a count of something\""
msgstr ""

msgid ""
"13832    This is not harmful and does not fall under this guideline because "
"it does not encode type information."
msgstr ""

msgid "13833    ##### Note"
msgstr ""

msgid ""
"13834    Some styles distinguishes members from local variable, and/or from "
"global variable."
msgstr ""

msgid "13835        struct S {"
msgstr ""

msgid "13836            int m_;"
msgstr ""

msgid "13837            S(int m) :m_{abs(m)} { }"
msgstr ""

msgid "13838        };"
msgstr ""

msgid ""
"13839    This is not harmful and does not fall under this guideline because "
"it does not encode type information."
msgstr ""

msgid "13840    ##### Note"
msgstr ""

msgid "13841    Like C++, some styles distinguishes types from non-types."
msgstr ""

msgid ""
"13842    For example, by capitalizing type names, but not the names of "
"functions and variables."
msgstr ""

msgid "13843        typename<typename T>"
msgstr ""

msgid "13844        class HashTable {   // maps string to T"
msgstr ""

msgid "13845            // ..."
msgstr ""

msgid "13846        };"
msgstr ""

msgid "13847        HashTable<int> index;"
msgstr ""

msgid ""
"13848    This is not harmful and does not fall under this guideline because "
"it does not encode type information."
msgstr ""

msgid ""
"13849    ### <a name=\"Rl-name-length\"></a>NL.7: Make the length of a name "
"roughly proportional to the length of its scope"
msgstr ""

msgid ""
"13850    **Rationale**: The larger the scope the greater the chance of "
"confusion and of an unintended name clash."
msgstr ""

msgid "13851    ##### Example"
msgstr ""

msgid ""
"13852        double sqrt(double x);   // return the square root of x; x must "
"be non-negative"
msgstr ""

msgid ""
"13853        int length(const char* p);  // return the number of characters "
"in a zero-terminated C-style string"
msgstr ""

msgid ""
"13854        int length_of_string(const char "
"zero_terminated_array_of_char[])    // bad: verbose"
msgstr ""

msgid "13855        int g;      // bad: global variable with a cryptic name"
msgstr ""

msgid ""
"13856        int open;   // bad: global variable with a short, popular name"
msgstr ""

msgid ""
"13857    The use of `p` for pointer and `x` for a floating-point variable is "
"conventional and non-confusing in a restricted scope."
msgstr ""

msgid "13858    ##### Enforcement"
msgstr ""

msgid "13859    ???"
msgstr ""

msgid "13860    ### <a name=\"Rl-name\"></a>NL.8: Use a consistent naming style"
msgstr ""

msgid ""
"13861    **Rationale**: Consistence in naming and naming style increases "
"readability."
msgstr ""

msgid "13862    ##### Note"
msgstr ""

msgid ""
"13863    There are many styles and when you use multiple libraries, you "
"can't follow all their different conventions."
msgstr ""

msgid ""
"13864    Choose a \"house style\", but leave \"imported\" libraries with "
"their original style."
msgstr ""

msgid "13865    ##### Example"
msgstr ""

msgid ""
"13866    ISO Standard, use lower case only and digits, separate words with "
"underscores:"
msgstr ""

msgid "13867    * `int`"
msgstr ""

msgid "13868    * `vector`"
msgstr ""

msgid "13869    * `my_map`"
msgstr ""

msgid "13870    Avoid double underscores `__`."
msgstr ""

msgid "13871    ##### Example"
msgstr ""

msgid ""
"13872    [Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):"
msgstr ""

msgid ""
"13873    ISO Standard, but with upper case used for your own types and "
"concepts:"
msgstr ""

msgid "13874    * `int`"
msgstr ""

msgid "13875    * `vector`"
msgstr ""

msgid "13876    * `My_map`"
msgstr ""

msgid "13877    ##### Example"
msgstr ""

msgid "13878    CamelCase: capitalize each word in a multi-word identifier:"
msgstr ""

msgid "13879    * `int`"
msgstr ""

msgid "13880    * `vector`"
msgstr ""

msgid "13881    * `MyMap`"
msgstr ""

msgid "13882    * `myMap`"
msgstr ""

msgid "13883    Some conventions capitalize the first letter, some don't."
msgstr ""

msgid "13884    ##### Note"
msgstr ""

msgid ""
"13885    Try to be consistent in your use of acronyms and lengths of "
"identifiers:"
msgstr ""

msgid "13886        int mtbf {12};"
msgstr ""

msgid "13887        int mean_time_between_failures {12}; // make up your mind"
msgstr ""

msgid "13888    ##### Enforcement"
msgstr ""

msgid ""
"13889    Would be possible except for the use of libraries with varying "
"conventions."
msgstr ""

msgid ""
"13890    ### <a name=\"Rl-all-caps\"></a>NL.9: Use `ALL_CAPS` for macro "
"names only"
msgstr ""

msgid "13891    ##### Reason"
msgstr ""

msgid ""
"13892    To avoid confusing macros with names that obey scope and type rules."
""
msgstr ""

msgid "13893    ##### Example"
msgstr ""

msgid "13894        void f()"
msgstr ""

msgid "13895        {"
msgstr ""

msgid "13896            const int SIZE{1000};  // Bad, use 'size' instead"
msgstr ""

msgid "13897            int v[SIZE];"
msgstr ""

msgid "13898        }"
msgstr ""

msgid "13899    ##### Note"
msgstr ""

msgid "13900    This rule applies to non-macro symbolic constants:"
msgstr ""

msgid "13901        enum bad { BAD, WORSE, HORRIBLE }; // BAD"
msgstr ""

msgid "13902    ##### Enforcement"
msgstr ""

msgid "13903    * Flag macros with lower-case letters"
msgstr ""

msgid "13904    * Flag `ALL_CAPS` non-macro names"
msgstr ""

msgid ""
"13905    ### <a name=\"Rl-camel\"></a>NL.10: Prefer `underscore_style` names"
msgstr ""

msgid "13906    ##### Reason"
msgstr ""

msgid ""
"13907    The use of underscores to separate parts of a name is the original "
"C and C++ style and used in the C++ Standard Library."
msgstr ""

msgid "13908    ##### Note"
msgstr ""

msgid "13909    This rule is a default to use only if you have a choice."
msgstr ""

msgid ""
"13910    Often, you don't have a choice and must follow an established style "
"for [consistency](#Rl-name)."
msgstr ""

msgid "13911    The need for consistency beats personal taste."
msgstr ""

msgid "13912    ##### Example"
msgstr ""

msgid ""
"13913    [Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):"
msgstr ""

msgid ""
"13914    ISO Standard, but with upper case used for your own types and "
"concepts:"
msgstr ""

msgid "13915    * `int`"
msgstr ""

msgid "13916    * `vector`"
msgstr ""

msgid "13917    * `My_map`"
msgstr ""

msgid "13918    ##### Enforcement"
msgstr ""

msgid "13919    Impossible."
msgstr ""

msgid "13920    ### <a name=\"Rl-space\"></a>NL.15: Use spaces sparingly"
msgstr ""

msgid "13921    ##### Reason"
msgstr ""

msgid "13922    Too much space makes the text larger and distracts."
msgstr ""

msgid "13923    ##### Example, bad"
msgstr ""

msgid "13924        #include < map >"
msgstr ""

msgid "13925        int main(int argc, char * argv [ ])"
msgstr ""

msgid "13926        {"
msgstr ""

msgid "13927            // ..."
msgstr ""

msgid "13928        }"
msgstr ""

msgid "13929    ##### Example"
msgstr ""

msgid "13930        #include <map>"
msgstr ""

msgid "13931        int main(int argc, char* argv[])"
msgstr ""

msgid "13932        {"
msgstr ""

msgid "13933            // ..."
msgstr ""

msgid "13934        }"
msgstr ""

msgid "13935    ##### Note"
msgstr ""

msgid "13936    Some IDEs have their own opinions and add distracting space."
msgstr ""

msgid "13937    ##### Note"
msgstr ""

msgid ""
"13938    We value well-placed whitespace as a significant help for "
"readability. Just don't overdo it."
msgstr ""

msgid "13939    ### <a name=\"Rl-literals\"></a>NL.11: Make literals readable"
msgstr ""

msgid "13940    ##### Reason"
msgstr ""

msgid "13941    Readability."
msgstr ""

msgid "13942    ##### Example"
msgstr ""

msgid "13943    Use digit separators to avoid long strings of digits"
msgstr ""

msgid "13944        auto c = 299'792'458; // m/s2"
msgstr ""

msgid "13945        auto q2 = 0b0000'1111'0000'0000;"
msgstr ""

msgid "13946        auto ss_number = 123'456'7890;"
msgstr ""

msgid "13947    ##### Example"
msgstr ""

msgid "13948    Use literal suffixes where clarification is needed"
msgstr ""

msgid "13949        auto hello = \"Hello!\"s; // a std::string"
msgstr ""

msgid "13950        auto world = \"world\";   // a C-style string"
msgstr ""

msgid "13951        auto interval = 100ms;  // using <chrono>"
msgstr ""

msgid "13952    ##### Note"
msgstr ""

msgid ""
"13953    Literals should not be sprinkled all over the code as [\"magic "
"constants\"](#Res-magic),"
msgstr ""

msgid ""
"13954    but it is still a good idea to make them readable where they are "
"defined."
msgstr ""

msgid "13955    It is easy to make a typo in a long string of integers."
msgstr ""

msgid "13956    ##### Enforcement"
msgstr ""

msgid ""
"13957    Flag long digit sequences. The trouble is to define \"long\"; maybe "
"7."
msgstr ""

msgid ""
"13958    ### <a name=\"Rl-order\"></a>NL.16: Use a conventional class member "
"declaration order"
msgstr ""

msgid "13959    ##### Reason"
msgstr ""

msgid "13960    A conventional order of members improves readability."
msgstr ""

msgid "13961    When declaring a class use the following order"
msgstr ""

msgid "13962    * types: classes, enums, and aliases (`using`)"
msgstr ""

msgid "13963    * constructors, assignments, destructor"
msgstr ""

msgid "13964    * functions"
msgstr ""

msgid "13965    * data"
msgstr ""

msgid "13966    Use the `public` before `protected` before `private` order."
msgstr ""

msgid "13967    ##### Example"
msgstr ""

msgid "13968        class X {"
msgstr ""

msgid "13969        public:"
msgstr ""

msgid "13970            // interface"
msgstr ""

msgid "13971        protected:"
msgstr ""

msgid ""
"13972            // unchecked function for use by derived class "
"implementations"
msgstr ""

msgid "13973        private:"
msgstr ""

msgid "13974            // implementation details"
msgstr ""

msgid "13975        };"
msgstr ""

msgid "13976    ##### Example"
msgstr ""

msgid ""
"13977    Sometimes, the default order of members conflicts with a desire to "
"separate the public interface from implementation details."
msgstr ""

msgid ""
"13978    In such cases, private types and functions can be placed with "
"private data."
msgstr ""

msgid "13979        class X {"
msgstr ""

msgid "13980        public:"
msgstr ""

msgid "13981            // interface"
msgstr ""

msgid "13982        protected:"
msgstr ""

msgid ""
"13983            // unchecked function for use by derived class "
"implementations"
msgstr ""

msgid "13984        private:"
msgstr ""

msgid ""
"13985            // implementation details (types, functions, and data)"
msgstr ""

msgid "13986        };"
msgstr ""

msgid "13987    ##### Example, bad"
msgstr ""

msgid ""
"13988    Avoid multiple blocks of declarations of one access (e.g., "
"`public`) dispersed among blocks of declarations with different access (e.g. "
"`private`)."
msgstr ""

msgid "13989        class X {   // bad"
msgstr ""

msgid "13990        public:"
msgstr ""

msgid "13991            void f();"
msgstr ""

msgid "13992        public:"
msgstr ""

msgid "13993            int g();"
msgstr ""

msgid "13994            // ..."
msgstr ""

msgid "13995        };"
msgstr ""

msgid ""
"13996    The use of macros to declare groups of members often leads to "
"violation of any ordering rules."
msgstr ""

msgid "13997    However, macros obscures what is being expressed anyway."
msgstr ""

msgid "13998    ##### Enforcement"
msgstr ""

msgid ""
"13999    Flag departures from the suggested order. There will be a lot of "
"old code that doesn't follow this rule."
msgstr ""

msgid "14000    ### <a name=\"Rl-knr\"></a>NL.17: Use K&R-derived layout"
msgstr ""

msgid "14001    ##### Reason"
msgstr ""

msgid ""
"14002    This is the original C and C++ layout. It preserves vertical space "
"well. It distinguishes different language constructs (such as functions and "
"classes) well."
msgstr ""

msgid "14003    ##### Note"
msgstr ""

msgid ""
"14004    In the context of C++, this style is often called \"Stroustrup\"."
msgstr ""

msgid "14005    ##### Example"
msgstr ""

msgid "14006        struct Cable {"
msgstr ""

msgid "14007            int x;"
msgstr ""

msgid "14008            // ..."
msgstr ""

msgid "14009        };"
msgstr ""

msgid "14010        double foo(int x)"
msgstr ""

msgid "14011        {"
msgstr ""

msgid "14012            if (0 < x) {"
msgstr ""

msgid "14013                // ..."
msgstr ""

msgid "14014            }"
msgstr ""

msgid "14015            switch (x) {"
msgstr ""

msgid "14016            case 0:"
msgstr ""

msgid "14017                // ..."
msgstr ""

msgid "14018                break;"
msgstr ""

msgid "14019            case amazing:"
msgstr ""

msgid "14020                // ..."
msgstr ""

msgid "14021                break;"
msgstr ""

msgid "14022            default:"
msgstr ""

msgid "14023                // ..."
msgstr ""

msgid "14024                break;"
msgstr ""

msgid "14025            }"
msgstr ""

msgid "14026            if (0 < x)"
msgstr ""

msgid "14027                ++x;"
msgstr ""

msgid "14028            if (x < 0)"
msgstr ""

msgid "14029                something();"
msgstr ""

msgid "14030            else"
msgstr ""

msgid "14031                something_else();"
msgstr ""

msgid "14032            return some_value;"
msgstr ""

msgid "14033        }"
msgstr ""

msgid "14034    Note the space between `if` and `(`"
msgstr ""

msgid "14035    ##### Note"
msgstr ""

msgid ""
"14036    Use separate lines for each statement, the branches of an `if`, and "
"the body of a `for`."
msgstr ""

msgid "14037    ##### Note"
msgstr ""

msgid ""
"14038    The `{` for a `class` and a `struct` is *not* on a separate line, "
"but the `{` for a function is."
msgstr ""

msgid "14039    ##### Note"
msgstr ""

msgid ""
"14040    Capitalize the names of your user-defined types to distinguish them "
"from standards-library types."
msgstr ""

msgid "14041    ##### Note"
msgstr ""

msgid "14042    Do not capitalize function names."
msgstr ""

msgid "14043    ##### Enforcement"
msgstr ""

msgid "14044    If you want enforcement, use an IDE to reformat."
msgstr ""

msgid ""
"14045    ### <a name=\"Rl-ptr\"></a>NL.18: Use C++-style declarator layout"
msgstr ""

msgid "14046    ##### Reason"
msgstr ""

msgid ""
"14047    The C-style layout emphasizes use in expressions and grammar, "
"whereas the C++-style emphasizes types."
msgstr ""

msgid "14048    The use in expressions argument doesn't hold for references."
msgstr ""

msgid "14049    ##### Example"
msgstr ""

msgid "14050        T& operator[](size_t);   // OK"
msgstr ""

msgid "14051        T &operator[](size_t);   // just strange"
msgstr ""

msgid "14052        T & operator[](size_t);   // undecided"
msgstr ""

msgid "14053    ##### Enforcement"
msgstr ""

msgid "14054    Impossible in the face of history."
msgstr ""

msgid ""
"14055    ### <a name=\"Rl-misread\"></a>NL.19: Avoid names that are easily "
"misread"
msgstr ""

msgid "14056    ##### Reason"
msgstr ""

msgid "14057    Readability."
msgstr ""

msgid ""
"14058    Not everyone has screens and printers that make it easy to "
"distinguish all characters."
msgstr ""

msgid ""
"14059    We easily confuse similarly spelled and slightly misspelled words."
msgstr ""

msgid "14060    ##### Example"
msgstr ""

msgid "14061        int oO01lL = 6; // bad"
msgstr ""

msgid "14062        int splunk = 7;"
msgstr ""

msgid ""
"14063        int splonk = 8; // bad: splunk and splonk are easily confused"
msgstr ""

msgid "14064    ##### Enforcement"
msgstr ""

msgid "14065    ???"
msgstr ""

msgid ""
"14066    ### <a name=\"Rl-stmt\"></a>NL.20: Don't place two statements on "
"the same line"
msgstr ""

msgid "14067    ##### Reason"
msgstr ""

msgid "14068    Readability."
msgstr ""

msgid ""
"14069    It is really easy to overlook a statement when there is more on a "
"line."
msgstr ""

msgid "14070    ##### Example"
msgstr ""

msgid "14071        int x = 7; char* p = 29;    // don't"
msgstr ""

msgid "14072        int x = 7; f(x);  ++x;      // don't"
msgstr ""

msgid "14073    ##### Enforcement"
msgstr ""

msgid "14074    Easy."
msgstr ""

msgid ""
"14075    ### <a name=\"Rl-dcl\"></a>NL.21: Declare one name (only) per "
"declaration"
msgstr ""

msgid "14076    ##### Reason"
msgstr ""

msgid "14077    Readability."
msgstr ""

msgid "14078    Minimizing confusion with the declarator syntax."
msgstr ""

msgid "14079    ##### Note"
msgstr ""

msgid "14080    For details, see [ES.10](#Res-name-one)."
msgstr ""

msgid ""
"14081    ### <a name=\"Rl-void\"></a>NL.25: Don't use `void` as an argument "
"type"
msgstr ""

msgid "14082    ##### Reason"
msgstr ""

msgid "14083    It's verbose and only needed where C compatibility matters."
msgstr ""

msgid "14084    ##### Example"
msgstr ""

msgid "14085        void f(void);   // bad"
msgstr ""

msgid "14086        void g();       // better"
msgstr ""

msgid "14087    ##### Note"
msgstr ""

msgid "14088    Even Dennis Ritchie deemed `void f(void)` an abomination."
msgstr ""

msgid ""
"14089    You can make an argument for that abomination in C when function "
"prototypes were rare so that banning:"
msgstr ""

msgid "14090        int f();"
msgstr ""

msgid ""
"14091        f(1, 2, \"weird but valid C89\");   // hope that f() is defined "
"int f(a, b, c) char* c; { /* ... */ }"
msgstr ""

msgid ""
"14092    would have caused major problems, but not in the 21st century and "
"in C++."
msgstr ""

msgid ""
"14093    ### <a name=\"Rl-const\"></a>NL.26: Use conventional `const` "
"notation"
msgstr ""

msgid "14094    ##### Reason"
msgstr ""

msgid "14095    Conventional notation is more familiar to more programmers."
msgstr ""

msgid "14096    Consistency in large code bases."
msgstr ""

msgid "14097    ##### Example"
msgstr ""

msgid "14098        const int x = 7;    // OK"
msgstr ""

msgid "14099        int const y = 9;    // bad"
msgstr ""

msgid ""
"14100        const int *const p = nullptr;   // OK, constant pointer to "
"constant int"
msgstr ""

msgid ""
"14101        int const *const p = nullptr;   // bad, constant pointer to "
"constant int"
msgstr ""

msgid "14102    ##### Note"
msgstr ""

msgid ""
"14103    We are well aware that you could claim the \"bad\" examples more "
"logical than the ones marked \"OK\","
msgstr ""

msgid ""
"14104    but they also confuse more people, especially novices relying on "
"teaching material using the far more common, conventional OK style."
msgstr ""

msgid ""
"14105    As ever, remember that the aim of these naming and layout rules is "
"consistency and that aesthetics vary immensely."
msgstr ""

msgid "14106    ##### Enforcement"
msgstr ""

msgid "14107    Flag `const` used as a suffix for a type."
msgstr ""

msgid ""
"14108    # <a name=\"S-faq\"></a>FAQ: Answers to frequently asked questions"
msgstr ""

msgid ""
"14109    This section covers answers to frequently asked questions about "
"these guidelines."
msgstr ""

msgid ""
"14110    ### <a name=\"Faq-aims\"></a>FAQ.1: What do these guidelines aim to "
"achieve?"
msgstr ""

msgid ""
"14111    See the <a href=\"#S-abstract\">top of this page</a>. This is an "
"open-source project to maintain modern authoritative guidelines for writing "
"C++ code using the current C++ Standard (as of this writing, C++14). The "
"guidelines are designed to be modern, machine-enforceable wherever possible, "
"and open to contributions and forking so that organizations can easily "
"incorporate them into their own corporate coding guidelines."
msgstr ""

msgid ""
"14112    ### <a name=\"Faq-announced\"></a>FAQ.2: When and where was this "
"work first announced?"
msgstr ""

msgid ""
"14113    It was announced by [Bjarne Stroustrup in his CppCon 2015 opening "
"keynote, \"Writing Good C++14\"](https://isocpp.org/blog/2015/09/stroustrup-"
"cppcon15-keynote). See also the [accompanying isocpp.org blog post](https://"
"isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines), "
"and for the rationale of the type and memory safety guidelines see [Herb "
"Sutter's follow-up CppCon 2015 talk, \"Writing Good C++14 ... By "
"Default\"](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary)."
msgstr ""

msgid ""
"14114    ### <a name=\"Faq-maintainers\"></a>FAQ.3: Who are the authors and "
"maintainers of these guidelines?"
msgstr ""

msgid ""
"14115    The initial primary authors and maintainers are Bjarne Stroustrup "
"and Herb Sutter, and the guidelines so far were developed with contributions "
"from experts at CERN, Microsoft, Morgan Stanley, and several other "
"organizations. At the time of their release, the guidelines are in a \"0.6\" "
"state, and contributions are welcome. As Stroustrup said in his announcement:"
" \"We need help!\""
msgstr ""

msgid "14116    ### <a name=\"Faq-contribute\"></a>FAQ.4: How can I contribute?"
msgstr ""

msgid ""
"14117    See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/"
"blob/master/CONTRIBUTING.md). We appreciate volunteer help!"
msgstr ""

msgid ""
"14118    ### <a name=\"Faq-maintainer\"></a>FAQ.5: How can I become an "
"editor/maintainer?"
msgstr ""

msgid ""
"14119    By contributing a lot first and having the consistent quality of "
"your contributions recognized. See [CONTRIBUTING.md](https://github.com/"
"isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate "
"volunteer help!"
msgstr ""

msgid ""
"14120    ### <a name=\"Faq-iso\"></a>FAQ.6: Have these guidelines been "
"approved by the ISO C++ standards committee? Do they represent the consensus "
"of the committee?"
msgstr ""

msgid ""
"14121    No. These guidelines are outside the standard. They are intended to "
"serve the standard, and be maintained as current guidelines about how to use "
"the current Standard C++ effectively. We aim to keep them in sync with the "
"standard as that is evolved by the committee."
msgstr ""

msgid ""
"14122    ### <a name=\"Faq-isocpp\"></a>FAQ.7: If these guidelines are not "
"approved by the committee, why are they under `github.com/isocpp`?"
msgstr ""

msgid ""
"14123    Because `isocpp` is the Standard C++ Foundation; the committee's "
"repositories are under [github.com/*cplusplus*](https://github.com/"
"cplusplus). Some neutral organization has to own the copyright and license "
"to make it clear this is not being dominated by any one person or vendor. "
"The natural entity is the Foundation, which exists to promote the use and up-"
"to-date understanding of modern Standard C++ and the work of the committee. "
"This follows the same pattern that isocpp.org did for the [C++ FAQ](https://"
"isocpp.org/faq), which was initially the work of Bjarne Stroustrup, Marshall "
"Cline, and Herb Sutter and contributed to the open project in the same way."
msgstr ""

msgid ""
"14124    ### <a name=\"Faq-cpp98\"></a>FAQ.8: Will there be a C++98 version "
"of these Guidelines? a C++11 version?"
msgstr ""

msgid ""
"14125    No. These guidelines are about how to best use Standard C++14 (and, "
"if you have an implementation available, the Concepts Technical "
"Specification) and write code assuming you have a modern conforming compiler."
""
msgstr ""

msgid ""
"14126    ### <a name=\"Faq-language-extensions\"></a>FAQ.9: Do these "
"guidelines propose new language features?"
msgstr ""

msgid ""
"14127    No. These guidelines are about how to best use Standard C++14 + the "
"Concepts Technical Specification, and they limit themselves to recommending "
"only those features."
msgstr ""

msgid ""
"14128    ### <a name=\"Faq-markdown\"></a>FAQ.10: What version of Markdown "
"do these guidelines use?"
msgstr ""

msgid ""
"14129    These coding standards are written using [CommonMark](http://"
"commonmark.org), and `<a>` HTML anchors."
msgstr ""

msgid ""
"14130    We are considering the following extensions from [GitHub Flavored "
"Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/):"
msgstr ""

msgid ""
"14131    * fenced code blocks (consistently using indented vs. fenced is "
"under discussion)"
msgstr ""

msgid ""
"14132    * tables (none yet but we'll likely need them, and this is a GFM "
"extension)"
msgstr ""

msgid "14133    Avoid other HTML tags and other extensions."
msgstr ""

msgid "14134    Note: We are not yet consistent with this style."
msgstr ""

msgid ""
"14135    ### <a name=\"Faq-gsl\"></a>FAQ.50: What is the GSL (guidelines "
"support library)?"
msgstr ""

msgid ""
"14136    The GSL is the small set of types and aliases specified in these "
"guidelines. As of this writing, their specification herein is too sparse; we "
"plan to add a WG21-style interface specification to ensure that different "
"implementations agree, and to propose as a contribution for possible "
"standardization, subject as usual to whatever the committee decides to "
"accept/improve/alter/reject."
msgstr ""

msgid ""
"14137    ### <a name=\"Faq-msgsl\"></a>FAQ.51: Is [github.com/Microsoft/"
"GSL](https://github.com/Microsoft/GSL) the GSL?"
msgstr ""

msgid ""
"14138    No. That is just a first implementation contributed by Microsoft. "
"Other implementations by other vendors are encouraged, as are forks of and "
"contributions to that implementation. As of this writing one week into the "
"public project, at least one GPLv3 open-source implementation already exists."
" We plan to produce a WG21-style interface specification to ensure that "
"different implementations agree."
msgstr ""

msgid ""
"14139    ### <a name=\"Faq-gsl-implementation\"></a>FAQ.52: Why not supply "
"an actual GSL implementation in/with these guidelines?"
msgstr ""

msgid ""
"14140    We are reluctant to bless one particular implementation because we "
"do not want to make people think there is only one, and inadvertently stifle "
"parallel implementations. And if these guidelines included an actual "
"implementation, then whoever contributed it could be mistakenly seen as too "
"influential. We prefer to follow the long-standing approach of the "
"committee, namely to specify interfaces, not implementations. But at the "
"same time we want at least one implementation available; we hope for many."
msgstr ""

msgid ""
"14141    ### <a name=\"Faq-boost\"></a>FAQ.53: Why weren't the GSL types "
"proposed through Boost?"
msgstr ""

msgid ""
"14142    Because we want to use them immediately, and because they are "
"temporary in that we want to retire them as soon as types that fill the same "
"needs exist in the standard library."
msgstr ""

msgid ""
"14143    ### <a name=\"Faq-gsl-iso\"></a>FAQ.54: Has the GSL (guidelines "
"support library) been approved by the ISO C++ standards committee?"
msgstr ""

msgid ""
"14144    No. The GSL exists only to supply a few types and aliases that are "
"not currently in the standard library. If the committee decides on "
"standardized versions (of these or other types that fill the same need) then "
"they can be removed from the GSL."
msgstr ""

msgid ""
"14145    ### <a name=\"Faq-gsl-string-view\"></a>FAQ.55: If you're using the "
"standard types where available, why is the GSL `string_span` different from "
"the `string_view` in the Library Fundamentals 1 Technical Specification and "
"C++17 Working Paper? Why not just use the committee-approved `string_view`?"
msgstr ""

msgid ""
"14146    The consensus on the taxonomy of views for the C++ Standard Library "
"was that \"view\" means \"read-only\", and \"span\" means \"read/write\". "
"The read-only `string_view` was the first such component to complete the "
"standardization process, while `span` and `string_span` are currently being "
"considered for standardization."
msgstr ""

msgid ""
"14147    ### <a name=\"Faq-gsl-owner\"></a>FAQ.56: Is `owner` the same as "
"the proposed `observer_ptr`?"
msgstr ""

msgid ""
"14148    No. `owner` owns, is an alias, and can be applied to any "
"indirection type. The main intent of `observer_ptr` is to signify a *non*-"
"owning pointer."
msgstr ""

msgid ""
"14149    ### <a name=\"Faq-gsl-stack-array\"></a>FAQ.57: Is `stack_array` "
"the same as the standard `array`?"
msgstr ""

msgid ""
"14150    No. `stack_array` is guaranteed to be allocated on the stack. "
"Although a `std::array` contains its storage directly inside itself, the "
"`array` object can be put anywhere, including the heap."
msgstr ""

msgid ""
"14151    ### <a name=\"Faq-gsl-dyn-array\"></a>FAQ.58: Is `dyn_array` the "
"same as `vector` or the proposed `dynarray`?"
msgstr ""

msgid ""
"14152    No. `dyn_array` is not resizable, and is a safe way to refer to a "
"heap-allocated fixed-size array. Unlike `vector`, it is intended to replace "
"array-`new[]`. Unlike the `dynarray` that has been proposed in the "
"committee, this does not anticipate compiler/language magic to somehow "
"allocate it on the stack when it is a member of an object that is allocated "
"on the stack; it simply refers to a \"dynamic\" or heap-based array."
msgstr ""

msgid ""
"14153    ### <a name=\"Faq-gsl-expects\"></a>FAQ.59: Is `Expects` the same "
"as `assert`?"
msgstr ""

msgid ""
"14154    No. It is a placeholder for language support for contract "
"preconditions."
msgstr ""

msgid ""
"14155    ### <a name=\"Faq-gsl-ensures\"></a>FAQ.60: Is `Ensures` the same "
"as `assert`?"
msgstr ""

msgid ""
"14156    No. It is a placeholder for language support for contract "
"postconditions."
msgstr ""

msgid "14157    # <a name=\"S-libraries\"></a>Appendix A: Libraries"
msgstr ""

msgid ""
"14158    This section lists recommended libraries, and explicitly recommends "
"a few."
msgstr ""

msgid "14159    ??? Suitable for the general guide? I think not ???"
msgstr ""

msgid "14160    # <a name=\"S-modernizing\"></a>Appendix B: Modernizing code"
msgstr ""

msgid "14161    Ideally, we follow all rules in all code."
msgstr ""

msgid "14162    Realistically, we have to deal with a lot of old code:"
msgstr ""

msgid ""
"14163    * application code written before the guidelines were formulated or "
"known"
msgstr ""

msgid "14164    * libraries written to older/different standards"
msgstr ""

msgid "14165    * code written under \"unusual\" constraints"
msgstr ""

msgid "14166    * code that we just haven't gotten around to modernizing"
msgstr ""

msgid ""
"14167    If we have a million lines of new code, the idea of \"just changing "
"it all at once\" is typically unrealistic."
msgstr ""

msgid "14168    Thus, we need a way of gradually modernizing a code base."
msgstr ""

msgid "14169    Upgrading older code to modern style can be a daunting task."
msgstr ""

msgid ""
"14170    Often, the old code is both a mess (hard to understand) and working "
"correctly (for the current range of uses)."
msgstr ""

msgid ""
"14171    Typically, the original programmer is not around and the test cases "
"incomplete."
msgstr ""

msgid ""
"14172    The fact that the code is a mess dramatically increases the effort "
"needed to make any change and the risk of introducing errors."
msgstr ""

msgid ""
"14173    Often, messy old code runs unnecessarily slowly because it requires "
"outdated compilers and cannot take advantage of modern hardware."
msgstr ""

msgid ""
"14174    In many cases, automated \"modernizer\"-style tool support would be "
"required for major upgrade efforts."
msgstr ""

msgid ""
"14175    The purpose of modernizing code is to simplify adding new "
"functionality, to ease maintenance, and to increase performance (throughput "
"or latency), and to better utilize modern hardware."
msgstr ""

msgid ""
"14176    Making code \"look pretty\" or \"follow modern style\" are not by "
"themselves reasons for change."
msgstr ""

msgid ""
"14177    There are risks implied by every change and costs (including the "
"cost of lost opportunities) implied by having an outdated code base."
msgstr ""

msgid "14178    The cost reductions must outweigh the risks."
msgstr ""

msgid "14179    But how?"
msgstr ""

msgid "14180    There is no one approach to modernizing code."
msgstr ""

msgid ""
"14181    How best to do it depends on the code, the pressure for updates, "
"the backgrounds of the developers, and the available tool."
msgstr ""

msgid "14182    Here are some (very general) ideas:"
msgstr ""

msgid ""
"14183    * The ideal is \"just upgrade everything.\" That gives the most "
"benefits for the shortest total time."
msgstr ""

msgid "14184      In most circumstances, it is also impossible."
msgstr ""

msgid ""
"14185    * We could convert a code base module for module, but any rules "
"that affects interfaces (especially ABIs), such as [use `span`](#SS-views), "
"cannot be done on a per-module basis."
msgstr ""

msgid ""
"14186    * We could convert code \"bottom up\" starting with the rules we "
"estimate will give the greatest benefits and/or the least trouble in a given "
"code base."
msgstr ""

msgid ""
"14187    * We could start by focusing on the interfaces, e.g., make sure "
"that no resources are lost and no pointer is misused."
msgstr ""

msgid ""
"14188      This would be a set of changes across the whole code base, but "
"would most likely have huge benefits."
msgstr ""

msgid ""
"14189      Afterwards, code hidden behind those interfaces can be gradually "
"modernized without affecting other code."
msgstr ""

msgid ""
"14190    Whichever way you choose, please note that the most advantages come "
"with the highest conformance to the guidelines."
msgstr ""

msgid ""
"14191    The guidelines are not a random set of unrelated rules where you "
"can randomly pick and choose with an expectation of success."
msgstr ""

msgid ""
"14192    We would dearly love to hear about experience and about tools used."
msgstr ""

msgid ""
"14193    Modernization can be much faster, simpler, and safer when supported "
"with analysis tools and even code transformation tools."
msgstr ""

msgid "14194    # <a name=\"S-discussion\"></a>Appendix C: Discussion"
msgstr ""

msgid ""
"14195    This section contains follow-up material on rules and sets of rules."
""
msgstr ""

msgid ""
"14196    In particular, here we present further rationale, longer examples, "
"and discussions of alternatives."
msgstr ""

msgid ""
"14197    ### <a name=\"Sd-order\"></a>Discussion: Define and initialize "
"member variables in the order of member declaration"
msgstr ""

msgid ""
"14198    Member variables are always initialized in the order they are "
"declared in the class definition, so write them in that order in the "
"constructor initialization list. Writing them in a different order just "
"makes the code confusing because it won't run in the order you see, and that "
"can make it hard to see order-dependent bugs."
msgstr ""

msgid "14199        class Employee {"
msgstr ""

msgid "14200            string email, first, last;"
msgstr ""

msgid "14201        public:"
msgstr ""

msgid ""
"14202            Employee(const char* firstName, const char* lastName);"
msgstr ""

msgid "14203            // ..."
msgstr ""

msgid "14204        };"
msgstr ""

msgid ""
"14205        Employee::Employee(const char* firstName, const char* lastName)"
msgstr ""

msgid "14206          : first(firstName),"
msgstr ""

msgid "14207            last(lastName),"
msgstr ""

msgid "14208            // BAD: first and last not yet constructed"
msgstr ""

msgid "14209            email(first + \".\" + last + \"@acme.com\")"
msgstr ""

msgid "14210        {}"
msgstr ""

msgid ""
"14211    In this example, `email` will be constructed before `first` and "
"`last` because it is declared first. That means its constructor will attempt "
"to use `first` and `last` too soon -- not just before they are set to the "
"desired values, but before they are constructed at all."
msgstr ""

msgid ""
"14212    If the class definition and the constructor body are in separate "
"files, the long-distance influence that the order of member variable "
"declarations has over the constructor's correctness will be even harder to "
"spot."
msgstr ""

msgid "14213    **References**:"
msgstr ""

msgid ""
"14214    [\\[Cline99\\]](#Cline99) §22.03-11, "
"[\\[Dewhurst03\\]](#Dewhurst03) §52-53, [\\[Koenig97\\]](#Koenig97) §4, "
"[\\[Lakos96\\]](#Lakos96) §10.3.5, [\\[Meyers97\\]](#Meyers97) §13, "
"[\\[Murray93\\]](#Murray93) §2.1.3, [\\[Sutter00\\]](#Sutter00) §47"
msgstr ""

msgid ""
"14215    ### <a name=\"Sd-init\"></a>Discussion: Use of `=`, `{}`, and `()` "
"as initializers"
msgstr ""

msgid "14216    ???"
msgstr ""

msgid ""
"14217    ### <a name=\"Sd-factory\"></a>Discussion: Use a factory function "
"if you need \"virtual behavior\" during initialization"
msgstr ""

msgid ""
"14218    If your design wants virtual dispatch into a derived class from a "
"base class constructor or destructor for functions like `f` and `g`, you "
"need other techniques, such as a post-constructor -- a separate member "
"function the caller must invoke to complete initialization, which can safely "
"call `f` and `g` because in member functions virtual calls behave normally. "
"Some techniques for this are shown in the References. Here's a non-"
"exhaustive list of options:"
msgstr ""

msgid ""
"14219    * *Pass the buck:* Just document that user code must call the post-"
"initialization function right after constructing an object."
msgstr ""

msgid ""
"14220    * *Post-initialize lazily:* Do it during the first call of a member "
"function. A Boolean flag in the base class tells whether or not post-"
"construction has taken place yet."
msgstr ""

msgid ""
"14221    * *Use virtual base class semantics:* Language rules dictate that "
"the constructor most-derived class decides which base constructor will be "
"invoked; you can use that to your advantage. (See "
"[\\[Taligent94\\]](#Taligent94).)"
msgstr ""

msgid ""
"14222    * *Use a factory function:* This way, you can easily force a "
"mandatory invocation of a post-constructor function."
msgstr ""

msgid "14223    Here is an example of the last option:"
msgstr ""

msgid "14224        class B {"
msgstr ""

msgid "14225        public:"
msgstr ""

msgid ""
"14226            B() { /* ... */ f(); /* ... */ }   // BAD: see Item 49.1"
msgstr ""

msgid "14227            virtual void f() = 0;"
msgstr ""

msgid "14228            // ..."
msgstr ""

msgid "14229        };"
msgstr ""

msgid "14230        class B {"
msgstr ""

msgid "14231        protected:"
msgstr ""

msgid "14232            B() { /* ... */ }"
msgstr ""

msgid ""
"14233            virtual void post_initialize()    // called right after "
"construction"
msgstr ""

msgid ""
"14234                { /* ... */ f(); /* ... */ }   // GOOD: virtual "
"dispatch is safe"
msgstr ""

msgid "14235        public:"
msgstr ""

msgid "14236            virtual void f() = 0;"
msgstr ""

msgid "14237            template<class T>"
msgstr ""

msgid ""
"14238            static shared_ptr<T> create()    // interface for creating "
"objects"
msgstr ""

msgid "14239            {"
msgstr ""

msgid "14240                auto p = make_shared<T>();"
msgstr ""

msgid "14241                p->post_initialize();"
msgstr ""

msgid "14242                return p;"
msgstr ""

msgid "14243            }"
msgstr ""

msgid "14244        };"
msgstr ""

msgid ""
"14245        class D : public B {                 // some derived class"
msgstr ""

msgid "14246        public:"
msgstr ""

msgid "14247            void f() override { /* ...  */ };"
msgstr ""

msgid "14248        protected:"
msgstr ""

msgid "14249            D() {}"
msgstr ""

msgid "14250            template<class T>"
msgstr ""

msgid "14251            friend shared_ptr<T> B::Create();"
msgstr ""

msgid "14252        };"
msgstr ""

msgid ""
"14253        shared_ptr<D> p = D::Create<D>();    // creating a D object"
msgstr ""

msgid "14254    This design requires the following discipline:"
msgstr ""

msgid ""
"14255    * Derived classes such as `D` must not expose a public constructor. "
"Otherwise, `D`'s users could create `D` objects that don't invoke "
"`PostInitialize`."
msgstr ""

msgid ""
"14256    * Allocation is limited to `operator new`. `B` can, however, "
"override `new` (see Items 45 and 46)."
msgstr ""

msgid ""
"14257    * `D` must define a constructor with the same parameters that `B` "
"selected. Defining several overloads of `Create` can assuage this problem, "
"however; and the overloads can even be templated on the argument types."
msgstr ""

msgid ""
"14258    If the requirements above are met, the design guarantees that "
"`PostInitialize` has been called for any fully constructed `B`-derived "
"object. `PostInitialize` doesn't need to be virtual; it can, however, invoke "
"virtual functions freely."
msgstr ""

msgid ""
"14259    In summary, no post-construction technique is perfect. The worst "
"techniques dodge the whole issue by simply asking the caller to invoke the "
"post-constructor manually. Even the best require a different syntax for "
"constructing objects (easy to check at compile time) and/or cooperation from "
"derived class authors (impossible to check at compile time)."
msgstr ""

msgid ""
"14260    **References**: [\\[Alexandrescu01\\]](#Alexandrescu01) §3, "
"[\\[Boost\\]](#Boost), [\\[Dewhurst03\\]](#Dewhurst03) §75, "
"[\\[Meyers97\\]](#Meyers97) §46, [\\[Stroustrup00\\]](#Stroustrup00) §15.4."
"3, [\\[Taligent94\\]](#Taligent94)"
msgstr ""

msgid ""
"14261    ### <a name=\"Sd-dtor\"></a>Discussion: Make base class destructors "
"public and virtual, or protected and nonvirtual"
msgstr ""

msgid ""
"14262    Should destruction behave virtually? That is, should destruction "
"through a pointer to a `base` class be allowed? If yes, then `base`'s "
"destructor must be public in order to be callable, and virtual otherwise "
"calling it results in undefined behavior. Otherwise, it should be protected "
"so that only derived classes can invoke it in their own destructors, and "
"nonvirtual since it doesn't need to behave virtually virtual."
msgstr ""

msgid "14263    ##### Example"
msgstr ""

msgid ""
"14264    The common case for a base class is that it's intended to have "
"publicly derived classes, and so calling code is just about sure to use "
"something like a `shared_ptr<base>`:"
msgstr ""

msgid "14265        class Base {"
msgstr ""

msgid "14266        public:"
msgstr ""

msgid "14267            ~Base();                   // BAD, not virtual"
msgstr ""

msgid "14268            virtual ~Base();           // GOOD"
msgstr ""

msgid "14269            // ..."
msgstr ""

msgid "14270        };"
msgstr ""

msgid "14271        class Derived : public Base { /* ... */ };"
msgstr ""

msgid "14272        {"
msgstr ""

msgid "14273            unique_ptr<Base> pb = make_unique<Derived>();"
msgstr ""

msgid "14274            // ..."
msgstr ""

msgid ""
"14275        } // ~pb invokes correct destructor only when ~Base is virtual"
msgstr ""

msgid ""
"14276    In rarer cases, such as policy classes, the class is used as a base "
"class for convenience, not for polymorphic behavior. It is recommended to "
"make those destructors protected and nonvirtual:"
msgstr ""

msgid "14277        class My_policy {"
msgstr ""

msgid "14278        public:"
msgstr ""

msgid "14279            virtual ~My_policy();      // BAD, public and virtual"
msgstr ""

msgid "14280        protected:"
msgstr ""

msgid "14281            ~My_policy();              // GOOD"
msgstr ""

msgid "14282            // ..."
msgstr ""

msgid "14283        };"
msgstr ""

msgid "14284        template<class Policy>"
msgstr ""

msgid ""
"14285        class customizable : Policy { /* ... */ }; // note: private "
"inheritance"
msgstr ""

msgid "14286    ##### Note"
msgstr ""

msgid ""
"14287    This simple guideline illustrates a subtle issue and reflects "
"modern uses of inheritance and object-oriented design principles."
msgstr ""

msgid ""
"14288    For a base class `Base`, calling code might try to destroy derived "
"objects through pointers to `Base`, such as when using a `unique_ptr<Base>`. "
"If `Base`'s destructor is public and nonvirtual (the default), it can be "
"accidentally called on a pointer that actually points to a derived object, "
"in which case the behavior of the attempted deletion is undefined. This "
"state of affairs has led older coding standards to impose a blanket "
"requirement that all base class destructors must be virtual. This is "
"overkill (even if it is the common case); instead, the rule should be to "
"make base class destructors virtual if and only if they are public."
msgstr ""

msgid ""
"14289    To write a base class is to define an abstraction (see Items 35 "
"through 37). Recall that for each member function participating in that "
"abstraction, you need to decide:"
msgstr ""

msgid "14290    * Whether it should behave virtually or not."
msgstr ""

msgid ""
"14291    * Whether it should be publicly available to all callers using a "
"pointer to `Base` or else be a hidden internal implementation detail."
msgstr ""

msgid ""
"14292    As described in Item 39, for a normal member function, the choice "
"is between allowing it to be called via a pointer to `Base` nonvirtually "
"(but possibly with virtual behavior if it invokes virtual functions, such as "
"in the NVI or Template Method patterns), virtually, or not at all. The NVI "
"pattern is a technique to avoid public virtual functions."
msgstr ""

msgid ""
"14293    Destruction can be viewed as just another operation, albeit with "
"special semantics that make nonvirtual calls dangerous or wrong. For a base "
"class destructor, therefore, the choice is between allowing it to be called "
"via a pointer to `Base` virtually or not at all; \"nonvirtually\" is not an "
"option. Hence, a base class destructor is virtual if it can be called (i.e., "
"is public), and nonvirtual otherwise."
msgstr ""

msgid ""
"14294    Note that the NVI pattern cannot be applied to the destructor "
"because constructors and destructors cannot make deep virtual calls. (See "
"Items 39 and 55.)"
msgstr ""

msgid ""
"14295    Corollary: When writing a base class, always write a destructor "
"explicitly, because the implicitly generated one is public and nonvirtual. "
"You can always `=default` the implementation if the default body is fine and "
"you're just writing the function to give it the proper visibility and "
"virtuality."
msgstr ""

msgid "14296    ##### Exception"
msgstr ""

msgid ""
"14297    Some component architectures (e.g., COM and CORBA) don't use a "
"standard deletion mechanism, and foster different protocols for object "
"disposal. Follow the local patterns and idioms, and adapt this guideline as "
"appropriate."
msgstr ""

msgid "14298    Consider also this rare case:"
msgstr ""

msgid ""
"14299    * `B` is both a base class and a concrete class that can be "
"instantiated by itself, and so the destructor must be public for `B` objects "
"to be created and destroyed."
msgstr ""

msgid ""
"14300    * Yet `B` also has no virtual functions and is not meant to be used "
"polymorphically, and so although the destructor is public it does not need "
"to be virtual."
msgstr ""

msgid ""
"14301    Then, even though the destructor has to be public, there can be "
"great pressure to not make it virtual because as the first virtual function "
"it would incur all the run-time type overhead when the added functionality "
"should never be needed."
msgstr ""

msgid ""
"14302    In this rare case, you could make the destructor public and "
"nonvirtual but clearly document that further-derived objects must not be "
"used polymorphically as `B`'s. This is what was done with `std::"
"unary_function`."
msgstr ""

msgid ""
"14303    In general, however, avoid concrete base classes (see Item 35). For "
"example, `unary_function` is a bundle-of-typedefs that was never intended to "
"be instantiated standalone. It really makes no sense to give it a public "
"destructor; a better design would be to follow this Item's advice and give "
"it a protected nonvirtual destructor."
msgstr ""

msgid ""
"14304    **References**: [\\[C++CS\\]](#CplusplusCS) Item 50, "
"[\\[Cargill92\\]](#Cargill92) pp. 77-79, 207, [\\[Cline99\\]](#Cline99) §21."
"06, 21.12-13, [\\[Henricson97\\]](#Henricson97) pp. 110-114, "
"[\\[Koenig97\\]](#Koenig97) Chapters 4, 11, [\\[Meyers97\\]](#Meyers97) §14, "
"[\\[Stroustrup00\\]](#Stroustrup00) §12.4.2, [\\[Sutter02\\]](#Sutter02) "
"§27, [\\[Sutter04\\]](#Sutter04) §18"
msgstr ""

msgid "14305    ### <a name=\"Sd-noexcept\"></a>Discussion: Usage of noexcept"
msgstr ""

msgid "14306    ???"
msgstr ""

msgid ""
"14307    ### <a name=\"Sd-never-fail\"></a>Discussion: Destructors, "
"deallocation, and swap must never fail"
msgstr ""

msgid ""
"14308    Never allow an error to be reported from a destructor, a resource "
"deallocation function (e.g., `operator delete`), or a `swap` function using "
"`throw`. It is nearly impossible to write useful code if these operations "
"can fail, and even if something does go wrong it nearly never makes any "
"sense to retry. Specifically, types whose destructors may throw an exception "
"are flatly forbidden from use with the C++ Standard Library. Most "
"destructors are now implicitly `noexcept` by default."
msgstr ""

msgid "14309    ##### Example"
msgstr ""

msgid "14310        class Nefarious {"
msgstr ""

msgid "14311        public:"
msgstr ""

msgid "14312            Nefarious()  { /* code that could throw */ }   // ok"
msgstr ""

msgid ""
"14313            ~Nefarious() { /* code that could throw */ }   // BAD, "
"should not throw"
msgstr ""

msgid "14314            // ..."
msgstr ""

msgid "14315        };"
msgstr ""

msgid ""
"14316    1. `Nefarious` objects are hard to use safely even as local "
"variables:"
msgstr ""

msgid "14317            void test(string& s)"
msgstr ""

msgid "14318            {"
msgstr ""

msgid "14319                Nefarious n;          // trouble brewing"
msgstr ""

msgid "14320                string copy = s;      // copy the string"
msgstr ""

msgid "14321            } // destroy copy and then n"
msgstr ""

msgid ""
"14322        Here, copying `s` could throw, and if that throws and if `n`'s "
"destructor then also throws, the program will exit via `std::terminate` "
"because two exceptions can't be propagated simultaneously."
msgstr ""

msgid ""
"14323    2. Classes with `Nefarious` members or bases are also hard to use "
"safely, because their destructors must invoke `Nefarious`' destructor, and "
"are similarly poisoned by its poor behavior:"
msgstr ""

msgid "14324            class Innocent_bystander {"
msgstr ""

msgid ""
"14325                Nefarious member;     // oops, poisons the enclosing "
"class's destructor"
msgstr ""

msgid "14326                // ..."
msgstr ""

msgid "14327            };"
msgstr ""

msgid "14328            void test(string& s)"
msgstr ""

msgid "14329            {"
msgstr ""

msgid "14330                Innocent_bystander i; // more trouble brewing"
msgstr ""

msgid "14331                string copy2 = s;      // copy the string"
msgstr ""

msgid "14332            } // destroy copy and then i"
msgstr ""

msgid ""
"14333        Here, if constructing `copy2` throws, we have the same problem "
"because `i`'s destructor now also can throw, and if so we'll invoke `std::"
"terminate`."
msgstr ""

msgid ""
"14334    3. You can't reliably create global or static `Nefarious` objects "
"either:"
msgstr ""

msgid ""
"14335            static Nefarious n;       // oops, any destructor exception "
"can't be caught"
msgstr ""

msgid "14336    4. You can't reliably create arrays of `Nefarious`:"
msgstr ""

msgid "14337            void test()"
msgstr ""

msgid "14338            {"
msgstr ""

msgid ""
"14339                std::array<Nefarious, 10> arr; // this line can std::"
"terminate(!)"
msgstr ""

msgid "14340            }"
msgstr ""

msgid ""
"14341        The behavior of arrays is undefined in the presence of "
"destructors that throw because there is no reasonable rollback behavior that "
"could ever be devised. Just think: What code can the compiler generate for "
"constructing an `arr` where, if the fourth object's constructor throws, the "
"code has to give up and in its cleanup mode tries to call the destructors of "
"the already-constructed objects ... and one or more of those destructors "
"throws? There is no satisfactory answer."
msgstr ""

msgid "14342    5. You can't use `Nefarious` objects in standard containers:"
msgstr ""

msgid ""
"14343            std::vector<Nefarious> vec(10);   // this line can std::"
"terminate()"
msgstr ""

msgid ""
"14344        The standard library forbids all destructors used with it from "
"throwing. You can't store `Nefarious` objects in standard containers or use "
"them with any other part of the standard library."
msgstr ""

msgid "14345    ##### Note"
msgstr ""

msgid ""
"14346    These are key functions that must not fail because they are "
"necessary for the two key operations in transactional programming: to back "
"out work if problems are encountered during processing, and to commit work "
"if no problems occur. If there's no way to safely back out using no-fail "
"operations, then no-fail rollback is impossible to implement. If there's no "
"way to safely commit state changes using a no-fail operation (notably, but "
"not limited to, `swap`), then no-fail commit is impossible to implement."
msgstr ""

msgid ""
"14347    Consider the following advice and requirements found in the C++ "
"Standard:"
msgstr ""

msgid ""
"14348    > If a destructor called during stack unwinding exits with an "
"exception, terminate is called (15.5.1). So destructors should generally "
"catch exceptions and not let them propagate out of the destructor. --"
"[\\[C++03\\]](#Cplusplus03) §15.2(3)"
msgstr ""

msgid "14349    >"
msgstr ""

msgid ""
"14350    > No destructor operation defined in the C++ Standard Library "
"(including the destructor of any type that is used to instantiate a standard-"
"library template) will throw an exception. --[\\[C++03\\]](#Cplusplus03) §17."
"4.4.8(3)"
msgstr ""

msgid ""
"14351    Deallocation functions, including specifically overloaded `operator "
"delete` and `operator delete[]`, fall into the same category, because they "
"too are used during cleanup in general, and during exception handling in "
"particular, to back out of partial work that needs to be undone."
msgstr ""

msgid ""
"14352    Besides destructors and deallocation functions, common error-safety "
"techniques rely also on `swap` operations never failing -- in this case, not "
"because they are used to implement a guaranteed rollback, but because they "
"are used to implement a guaranteed commit. For example, here is an idiomatic "
"implementation of `operator=` for a type `T` that performs copy construction "
"followed by a call to a no-fail `swap`:"
msgstr ""

msgid "14353        T& T::operator=(const T& other) {"
msgstr ""

msgid "14354            auto temp = other;"
msgstr ""

msgid "14355            swap(temp);"
msgstr ""

msgid "14356        }"
msgstr ""

msgid "14357    (See also Item 56. ???)"
msgstr ""

msgid ""
"14358    Fortunately, when releasing a resource, the scope for failure is "
"definitely smaller. If using exceptions as the error reporting mechanism, "
"make sure such functions handle all exceptions and other errors that their "
"internal processing might generate. (For exceptions, simply wrap everything "
"sensitive that your destructor does in a `try/catch(...)` block.) This is "
"particularly important because a destructor might be called in a crisis "
"situation, such as failure to allocate a system resource (e.g., memory, "
"files, locks, ports, windows, or other system objects)."
msgstr ""

msgid ""
"14359    When using exceptions as your error handling mechanism, always "
"document this behavior by declaring these functions `noexcept`. (See Item 75."
")"
msgstr ""

msgid ""
"14360    **References**: [\\[C++CS\\]](#CplusplusCS) Item 51; "
"[\\[C++03\\]](#Cplusplus03) §15.2(3), §17.4.4.8(3), "
"[\\[Meyers96\\]](#Meyers96) §11, [\\[Stroustrup00\\]](#Stroustrup00) §14.4."
"7, §E.2-4, [\\[Sutter00\\]](#Sutter00) §8, §16, [\\[Sutter02\\]](#Sutter02) "
"§18-19"
msgstr ""

msgid ""
"14361    ## <a name=\"Sd-consistent\"></a>Define Copy, move, and destroy "
"consistently"
msgstr ""

msgid "14362    ##### Reason"
msgstr ""

msgid "14363     ???"
msgstr ""

msgid "14364    ##### Note"
msgstr ""

msgid ""
"14365    If you define a copy constructor, you must also define a copy "
"assignment operator."
msgstr ""

msgid "14366    ##### Note"
msgstr ""

msgid ""
"14367    If you define a move constructor, you must also define a move "
"assignment operator."
msgstr ""

msgid "14368    ##### Example"
msgstr ""

msgid "14369        class X {"
msgstr ""

msgid "14370            // ..."
msgstr ""

msgid "14371        public:"
msgstr ""

msgid "14372            X(const X&) { /* stuff */ }"
msgstr ""

msgid ""
"14373            // BAD: failed to also define a copy assignment operator"
msgstr ""

msgid "14374            X(x&&) noexcept { /* stuff */ }"
msgstr ""

msgid ""
"14375            // BAD: failed to also define a move assignment operator"
msgstr ""

msgid "14376        };"
msgstr ""

msgid "14377        X x1;"
msgstr ""

msgid "14378        X x2 = x1; // ok"
msgstr ""

msgid ""
"14379        x2 = x1;   // pitfall: either fails to compile, or does "
"something suspicious"
msgstr ""

msgid ""
"14380    If you define a destructor, you should not use the compiler-"
"generated copy or move operation; you probably need to define or suppress "
"copy and/or move."
msgstr ""

msgid "14381        class X {"
msgstr ""

msgid "14382            HANDLE hnd;"
msgstr ""

msgid "14383            // ..."
msgstr ""

msgid "14384        public:"
msgstr ""

msgid "14385            ~X() { /* custom stuff, such as closing hnd */ }"
msgstr ""

msgid ""
"14386            // suspicious: no mention of copying or moving -- what "
"happens to hnd?"
msgstr ""

msgid "14387        };"
msgstr ""

msgid "14388        X x1;"
msgstr ""

msgid ""
"14389        X x2 = x1; // pitfall: either fails to compile, or does "
"something suspicious"
msgstr ""

msgid ""
"14390        x2 = x1;   // pitfall: either fails to compile, or does "
"something suspicious"
msgstr ""

msgid ""
"14391    If you define copying, and any base or member has a type that "
"defines a move operation, you should also define a move operation."
msgstr ""

msgid "14392        class X {"
msgstr ""

msgid "14393            string s; // defines more efficient move operations"
msgstr ""

msgid "14394            // ... other data members ..."
msgstr ""

msgid "14395        public:"
msgstr ""

msgid "14396            X(const X&) { /* stuff */ }"
msgstr ""

msgid "14397            X& operator=(const X&) { /* stuff */ }"
msgstr ""

msgid ""
"14398            // BAD: failed to also define a move construction and move "
"assignment"
msgstr ""

msgid "14399            // (why wasn't the custom \"stuff\" repeated here?)"
msgstr ""

msgid "14400        };"
msgstr ""

msgid "14401        X test()"
msgstr ""

msgid "14402        {"
msgstr ""

msgid "14403            X local;"
msgstr ""

msgid "14404            // ..."
msgstr ""

msgid ""
"14405            return local;  // pitfall: will be inefficient and/or do "
"the wrong thing"
msgstr ""

msgid "14406        }"
msgstr ""

msgid ""
"14407    If you define any of the copy constructor, copy assignment "
"operator, or destructor, you probably should define the others."
msgstr ""

msgid "14408    ##### Note"
msgstr ""

msgid ""
"14409    If you need to define any of these five functions, it means you "
"need it to do more than its default behavior -- and the five are "
"asymmetrically interrelated. Here's how:"
msgstr ""

msgid ""
"14410    * If you write/disable either of the copy constructor or the copy "
"assignment operator, you probably need to do the same for the other: If one "
"does \"special\" work, probably so should the other because the two "
"functions should have similar effects. (See Item 53, which expands on this "
"point in isolation.)"
msgstr ""

msgid ""
"14411    * If you explicitly write the copying functions, you probably need "
"to write the destructor: If the \"special\" work in the copy constructor is "
"to allocate or duplicate some resource (e.g., memory, file, socket), you "
"need to deallocate it in the destructor."
msgstr ""

msgid ""
"14412    * If you explicitly write the destructor, you probably need to "
"explicitly write or disable copying: If you have to write a non-trivial "
"destructor, it's often because you need to manually release a resource that "
"the object held. If so, it is likely that those resources require careful "
"duplication, and then you need to pay attention to the way objects are "
"copied and assigned, or disable copying completely."
msgstr ""

msgid ""
"14413    In many cases, holding properly encapsulated resources using RAII "
"\"owning\" objects can eliminate the need to write these operations yourself."
" (See Item 13.)"
msgstr ""

msgid ""
"14414    Prefer compiler-generated (including `=default`) special members; "
"only these can be classified as \"trivial\", and at least one major standard "
"library vendor heavily optimizes for classes having trivial special members. "
"This is likely to become common practice."
msgstr ""

msgid ""
"14415    **Exceptions**: When any of the special functions are declared only "
"to make them nonpublic or virtual, but without special semantics, it doesn't "
"imply that the others are needed."
msgstr ""

msgid ""
"14416    In rare cases, classes that have members of strange types (such as "
"reference members) are an exception because they have peculiar copy "
"semantics."
msgstr ""

msgid ""
"14417    In a class holding a reference, you likely need to write the copy "
"constructor and the assignment operator, but the default destructor already "
"does the right thing. (Note that using a reference member is almost always "
"wrong.)"
msgstr ""

msgid ""
"14418    **References**: [\\[C++CS\\]](#CplusplusCS) Item 52; "
"[\\[Cline99\\]](#Cline99) §30.01-14, [\\[Koenig97\\]](#Koenig97) §4, "
"[\\[Stroustrup00\\]](#Stroustrup00) §5.5, §10.4, "
"[\\[SuttHysl04b\\]](#SuttHysl04b)"
msgstr ""

msgid "14419    Resource management rule summary:"
msgstr ""

msgid ""
"14420    * [Provide strong resource safety; that is, never leak anything "
"that you think of as a resource](#Cr-safety)"
msgstr ""

msgid ""
"14421    * [Never throw while holding a resource not owned by a handle](#Cr-"
"never)"
msgstr ""

msgid ""
"14422    * [A \"raw\" pointer or reference is never a resource handle](#Cr-"
"raw)"
msgstr ""

msgid ""
"14423    * [Never let a pointer outlive the object it points to](#Cr-"
"outlive)"
msgstr ""

msgid ""
"14424    * [Use templates to express containers (and other resource "
"handles)](#Cr-templates)"
msgstr ""

msgid ""
"14425    * [Return containers by value (relying on move or copy elision for "
"efficiency)](#Cr-value-return)"
msgstr ""

msgid ""
"14426    * [If a class is a resource handle, it needs a constructor, a "
"destructor, and copy and/or move operations](#Cr-handle)"
msgstr ""

msgid ""
"14427    * [If a class is a container, give it an initializer-list "
"constructor](#Cr-list)"
msgstr ""

msgid ""
"14428    ### <a name=\"Cr-safety\"></a>Discussion: Provide strong resource "
"safety; that is, never leak anything that you think of as a resource"
msgstr ""

msgid "14429    ##### Reason"
msgstr ""

msgid ""
"14430    Prevent leaks. Leaks can lead to performance degradation, "
"mysterious error, system crashes, and security violations."
msgstr ""

msgid ""
"14431    **Alternative formulation**: Have every resource represented as an "
"object of some class managing its lifetime."
msgstr ""

msgid "14432    ##### Example"
msgstr ""

msgid "14433        template<class T>"
msgstr ""

msgid "14434        class Vector {"
msgstr ""

msgid "14435        // ..."
msgstr ""

msgid "14436        private:"
msgstr ""

msgid ""
"14437            T* elem;   // sz elements on the free store, owned by the "
"class object"
msgstr ""

msgid "14438            int sz;"
msgstr ""

msgid "14439        };"
msgstr ""

msgid ""
"14440    This class is a resource handle. It manages the lifetime of the "
"`T`s. To do so, `Vector` must define or delete [the set of special "
"operations](???) (constructors, a destructor, etc.)."
msgstr ""

msgid "14441    ##### Example"
msgstr ""

msgid "14442        ??? \"odd\" non-memory resource ???"
msgstr ""

msgid "14443    ##### Enforcement"
msgstr ""

msgid ""
"14444    The basic technique for preventing leaks is to have every resource "
"owned by a resource handle with a suitable destructor. A checker can find "
"\"naked `new`s\". Given a list of C-style allocation functions (e.g., "
"`fopen()`), a checker can also find uses that are not managed by a resource "
"handle. In general, \"naked pointers\" can be viewed with suspicion, "
"flagged, and/or analyzed. A complete list of resources cannot be generated "
"without human input (the definition of \"a resource\" is necessarily too "
"general), but a tool can be \"parameterized\" with a resource list."
msgstr ""

msgid ""
"14445    ### <a name=\"Cr-never\"></a>Discussion: Never throw while holding "
"a resource not owned by a handle"
msgstr ""

msgid "14446    ##### Reason"
msgstr ""

msgid "14447    That would be a leak."
msgstr ""

msgid "14448    ##### Example"
msgstr ""

msgid "14449        void f(int i)"
msgstr ""

msgid "14450        {"
msgstr ""

msgid "14451            FILE* f = fopen(\"a file\", \"r\");"
msgstr ""

msgid "14452            ifstream is { \"another file\" };"
msgstr ""

msgid "14453            // ..."
msgstr ""

msgid "14454            if (i == 0) return;"
msgstr ""

msgid "14455            // ..."
msgstr ""

msgid "14456            fclose(f);"
msgstr ""

msgid "14457        }"
msgstr ""

msgid ""
"14458    If `i == 0` the file handle for `a file` is leaked. On the other "
"hand, the `ifstream` for `another file` will correctly close its file (upon "
"destruction). If you must use an explicit pointer, rather than a resource "
"handle with specific semantics, use a `unique_ptr` or a `shared_ptr` with a "
"custom deleter:"
msgstr ""

msgid "14459        void f(int i)"
msgstr ""

msgid "14460        {"
msgstr ""

msgid ""
"14461            unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), "
"fclose);"
msgstr ""

msgid "14462            // ..."
msgstr ""

msgid "14463            if (i == 0) return;"
msgstr ""

msgid "14464            // ..."
msgstr ""

msgid "14465        }"
msgstr ""

msgid "14466    Better:"
msgstr ""

msgid "14467        void f(int i)"
msgstr ""

msgid "14468        {"
msgstr ""

msgid "14469            ifstream input {\"a file\"};"
msgstr ""

msgid "14470            // ..."
msgstr ""

msgid "14471            if (i == 0) return;"
msgstr ""

msgid "14472            // ..."
msgstr ""

msgid "14473        }"
msgstr ""

msgid "14474    ##### Enforcement"
msgstr ""

msgid "14475    A checker must consider all \"naked pointers\" suspicious."
msgstr ""

msgid ""
"14476    A checker probably must rely on a human-provided list of resources."
msgstr ""

msgid ""
"14477    For starters, we know about the standard-library containers, "
"`string`, and smart pointers."
msgstr ""

msgid ""
"14478    The use of `span` and `string_span` should help a lot (they are not "
"resource handles)."
msgstr ""

msgid ""
"14479    ### <a name=\"Cr-raw\"></a>Discussion: A \"raw\" pointer or "
"reference is never a resource handle"
msgstr ""

msgid "14480    ##### Reason"
msgstr ""

msgid "14481    To be able to distinguish owners from views."
msgstr ""

msgid "14482    ##### Note"
msgstr ""

msgid ""
"14483    This is independent of how you \"spell\" pointer: `T*`, `T&`, "
"`Ptr<T>` and `Range<T>` are not owners."
msgstr ""

msgid ""
"14484    ### <a name=\"Cr-outlive\"></a>Discussion: Never let a pointer "
"outlive the object it points to"
msgstr ""

msgid "14485    ##### Reason"
msgstr ""

msgid ""
"14486    To avoid extremely hard-to-find errors. Dereferencing such a "
"pointer is undefined behavior and could lead to violations of the type "
"system."
msgstr ""

msgid "14487    ##### Example"
msgstr ""

msgid "14488        string* bad()   // really bad"
msgstr ""

msgid "14489        {"
msgstr ""

msgid ""
"14490            vector<string> v = { \"This\", \"will\", \"cause\", "
"\"trouble\", \"!\" };"
msgstr ""

msgid ""
"14491            // leaking a pointer into a destroyed member of a destroyed "
"object (v)"
msgstr ""

msgid "14492            return &v[0];"
msgstr ""

msgid "14493        }"
msgstr ""

msgid "14494        void use()"
msgstr ""

msgid "14495        {"
msgstr ""

msgid "14496            string* p = bad();"
msgstr ""

msgid "14497            vector<int> xx = {7, 8, 9};"
msgstr ""

msgid "14498            // undefined behavior: x may not be the string \"This\""
msgstr ""

msgid "14499            string x = *p;"
msgstr ""

msgid ""
"14500            // undefined behavior: we don't know what (if anything) is "
"allocated a location p"
msgstr ""

msgid "14501            *p = \"Evil!\";"
msgstr ""

msgid "14502        }"
msgstr ""

msgid ""
"14503    The `string`s of `v` are destroyed upon exit from `bad()` and so is "
"`v` itself. The returned pointer points to unallocated memory on the free "
"store. This memory (pointed into by `p`) may have been reallocated by the "
"time `*p` is executed. There may be no `string` to read and a write through "
"`p` could easily corrupt objects of unrelated types."
msgstr ""

msgid "14504    ##### Enforcement"
msgstr ""

msgid ""
"14505    Most compilers already warn about simple cases and has the "
"information to do more. Consider any pointer returned from a function "
"suspect. Use containers, resource handles, and views (e.g., `span` known not "
"to be resource handles) to lower the number of cases to be examined. For "
"starters, consider every class with a destructor as resource handle."
msgstr ""

msgid ""
"14506    ### <a name=\"Cr-templates\"></a>Discussion: Use templates to "
"express containers (and other resource handles)"
msgstr ""

msgid "14507    ##### Reason"
msgstr ""

msgid "14508    To provide statically type-safe manipulation of elements."
msgstr ""

msgid "14509    ##### Example"
msgstr ""

msgid "14510        template<typename T> class Vector {"
msgstr ""

msgid "14511            // ..."
msgstr ""

msgid "14512            T* elem;   // point to sz elements of type T"
msgstr ""

msgid "14513            int sz;"
msgstr ""

msgid "14514        };"
msgstr ""

msgid ""
"14515    ### <a name=\"Cr-value-return\"></a>Discussion: Return containers "
"by value (relying on move or copy elision for efficiency)"
msgstr ""

msgid "14516    ##### Reason"
msgstr ""

msgid ""
"14517    To simplify code and eliminate a need for explicit memory "
"management. To bring an object into a surrounding scope, thereby extending "
"its lifetime."
msgstr ""

msgid ""
"14518    **See also**: [F.20, the general item about \"out\" output "
"values](#Rf-out)"
msgstr ""

msgid "14519    ##### Example"
msgstr ""

msgid "14520        vector<int> get_large_vector()"
msgstr ""

msgid "14521        {"
msgstr ""

msgid "14522            return ...;"
msgstr ""

msgid "14523        }"
msgstr ""

msgid ""
"14524        auto v = get_large_vector(); //  return by value is ok, most "
"modern compilers will do copy elision"
msgstr ""

msgid "14525    ##### Exception"
msgstr ""

msgid "14526    See the Exceptions in [F.20](#Rf-out)."
msgstr ""

msgid "14527    ##### Enforcement"
msgstr ""

msgid ""
"14528    Check for pointers and references returned from functions and see "
"if they are assigned to resource handles (e.g., to a `unique_ptr`)."
msgstr ""

msgid ""
"14529    ### <a name=\"Cr-handle\"></a>Discussion: If a class is a resource "
"handle, it needs a constructor, a destructor, and copy and/or move "
"operations"
msgstr ""

msgid "14530    ##### Reason"
msgstr ""

msgid ""
"14531    To provide complete control of the lifetime of the resource. To "
"provide a coherent set of operations on the resource."
msgstr ""

msgid "14532    ##### Example"
msgstr ""

msgid "14533        ??? Messing with pointers"
msgstr ""

msgid "14534    ##### Note"
msgstr ""

msgid ""
"14535    If all members are resource handles, rely on the default special "
"operations where possible."
msgstr ""

msgid "14536        template<typename T> struct Named {"
msgstr ""

msgid "14537            string name;"
msgstr ""

msgid "14538            T value;"
msgstr ""

msgid "14539        };"
msgstr ""

msgid ""
"14540    Now `Named` has a default constructor, a destructor, and efficient "
"copy and move operations, provided `T` has."
msgstr ""

msgid "14541    ##### Enforcement"
msgstr ""

msgid ""
"14542    In general, a tool cannot know if a class is a resource handle. "
"However, if a class has some of [the default operations](#SS-ctor), it "
"should have all, and if a class has a member that is a resource handle, it "
"should be considered as resource handle."
msgstr ""

msgid ""
"14543    ### <a name=\"Cr-list\"></a>Discussion: If a class is a container, "
"give it an initializer-list constructor"
msgstr ""

msgid "14544    ##### Reason"
msgstr ""

msgid "14545    It is common to need an initial set of elements."
msgstr ""

msgid "14546    ##### Example"
msgstr ""

msgid "14547        template<typename T> class Vector {"
msgstr ""

msgid "14548        public:"
msgstr ""

msgid "14549            Vector(std::initializer_list<T>);"
msgstr ""

msgid "14550            // ..."
msgstr ""

msgid "14551        };"
msgstr ""

msgid "14552        Vector<string> vs { \"Nygaard\", \"Ritchie\" };"
msgstr ""

msgid "14553    ##### Enforcement"
msgstr ""

msgid "14554    When is a class a container? ???"
msgstr ""

msgid "14555    # <a name=\"S-tools\"></a>Appendix D: Supporting tools"
msgstr ""

msgid ""
"14556    This section contains a list of tools that directly support "
"adoption of the C++ Core Guidelines. This list is not intended to be an "
"exhaustive list of tools"
msgstr ""

msgid ""
"14557    that are helpful in writing good C++ code. If a tool is designed "
"specifically to support and links to the C++ Core Guidelines it is a "
"candidate for inclusion."
msgstr ""

msgid ""
"14558    ### <a name=\"St-clangtidy\"></a>Tools: [Clang-tidy](http://clang."
"llvm.org/extra/clang-tidy/checks/list.html)"
msgstr ""

msgid ""
"14559    Clang-tidy has a set of rules that specifically enforce the C++ "
"Core Guidelines. These rules are named in the pattern `cppcoreguidelines-*`."
msgstr ""

msgid ""
"14560    ### <a name=\"St-cppcorecheck\"></a>Tools: [CppCoreCheck](https://"
"docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-"
"guidelines-checkers)"
msgstr ""

msgid ""
"14561    The Microsoft compiler's C++ code analysis contains a set of rules "
"specifically aimed at enforcement of the C++ Core Guidelines."
msgstr ""

msgid "14562    # <a name=\"S-glossary\"></a>Glossary"
msgstr ""

msgid ""
"14563    A relatively informal definition of terms used in the guidelines"
msgstr ""

msgid ""
"14564    (based of the glossary in [Programming: Principles and Practice "
"using C++](http://www.stroustrup.com/programming.html))"
msgstr ""

msgid ""
"14565    More information on many topics about C++ can be found on the "
"[Standard C++ Foundation](https://isocpp.org)'s site."
msgstr ""

msgid ""
"14566    * *ABI*: Application Binary Interface, a specification for a "
"specific hardware platform combined with the operating system. Contrast with "
"API."
msgstr ""

msgid ""
"14567    * *abstract class*: a class that cannot be directly used to create "
"objects; often used to define an interface to derived classes."
msgstr ""

msgid ""
"14568      A class is made abstract by having a pure virtual function or "
"only protected constructors."
msgstr ""

msgid ""
"14569    * *abstraction*: a description of something that selectively and "
"deliberately ignores (hides) details (e.g., implementation details); "
"selective ignorance."
msgstr ""

msgid ""
"14570    * *address*: a value that allows us to find an object in a "
"computer's memory."
msgstr ""

msgid ""
"14571    * *algorithm*: a procedure or formula for solving a problem; a "
"finite series of computational steps to produce a result."
msgstr ""

msgid ""
"14572    * *alias*: an alternative way of referring to an object; often a "
"name, pointer, or reference."
msgstr ""

msgid ""
"14573    * *API*: Application Programming Interface, a set of functions that "
"form the communication between various software components. Contrast with "
"ABI."
msgstr ""

msgid ""
"14574    * *application*: a program or a collection of programs that is "
"considered an entity by its users."
msgstr ""

msgid ""
"14575    * *approximation*: something (e.g., a value or a design) that is "
"close to the perfect or ideal (value or design)."
msgstr ""

msgid ""
"14576      Often an approximation is a result of trade-offs among ideals."
msgstr ""

msgid ""
"14577    * *argument*: a value passed to a function or a template, in which "
"it is accessed through a parameter."
msgstr ""

msgid ""
"14578    * *array*: a homogeneous sequence of elements, usually numbered, e."
"g., `[0:max)`."
msgstr ""

msgid ""
"14579    * *assertion*: a statement inserted into a program to state "
"(assert) that something must always be true at this point in the program."
msgstr ""

msgid ""
"14580    * *base class*: a class used as the base of a class hierarchy. "
"Typically a base class has one or more virtual functions."
msgstr ""

msgid ""
"14581    * *bit*: the basic unit of information in a computer. A bit can "
"have the value 0 or the value 1."
msgstr ""

msgid "14582    * *bug*: an error in a program."
msgstr ""

msgid ""
"14583    * *byte*: the basic unit of addressing in most computers. "
"Typically, a byte holds 8 bits."
msgstr ""

msgid ""
"14584    * *class*: a user-defined type that may contain data members, "
"function members, and member types."
msgstr ""

msgid ""
"14585    * *code*: a program or a part of a program; ambiguously used for "
"both source code and object code."
msgstr ""

msgid ""
"14586    * *compiler*: a program that turns source code into object code."
msgstr ""

msgid ""
"14587    * *complexity*: a hard-to-precisely-define notion or measure of the "
"difficulty of constructing a solution to a problem or of the solution itself."
""
msgstr ""

msgid ""
"14588      Sometimes complexity is used to (simply) mean an estimate of the "
"number of operations needed to execute an algorithm."
msgstr ""

msgid ""
"14589    * *computation*: the execution of some code, usually taking some "
"input and producing some output."
msgstr ""

msgid ""
"14590    * *concept*: (1) a notion, and idea; (2) a set of requirements, "
"usually for a template argument."
msgstr ""

msgid "14591    * *concrete class*: class for which objects can be created."
msgstr ""

msgid ""
"14592    * *constant*: a value that cannot be changed (in a given scope); "
"not mutable."
msgstr ""

msgid ""
"14593    * *constructor*: an operation that initializes (\"constructs\") an "
"object."
msgstr ""

msgid ""
"14594      Typically a constructor establishes an invariant and often "
"acquires resources needed for an object to be used (which are then typically "
"released by a destructor)."
msgstr ""

msgid "14595    * *container*: an object that holds elements (other objects)."
msgstr ""

msgid ""
"14596    * *copy*: an operation that makes two object have values that "
"compare equal. See also move."
msgstr ""

msgid ""
"14597    * *correctness*: a program or a piece of a program is correct if it "
"meets its specification."
msgstr ""

msgid ""
"14598      Unfortunately, a specification can be incomplete or inconsistent, "
"or can fail to meet users' reasonable expectations."
msgstr ""

msgid ""
"14599      Thus, to produce acceptable code, we sometimes have to do more "
"than just follow the formal specification."
msgstr ""

msgid ""
"14600    * *cost*: the expense (e.g., in programmer time, run time, or "
"space) of producing a program or of executing it."
msgstr ""

msgid "14601      Ideally, cost should be a function of complexity."
msgstr ""

msgid "14602    * *customization point*: ???"
msgstr ""

msgid "14603    * *data*: values used in a computation."
msgstr ""

msgid ""
"14604    * *debugging*: the act of searching for and removing errors from a "
"program; usually far less systematic than testing."
msgstr ""

msgid ""
"14605    * *declaration*: the specification of a name with its type in a "
"program."
msgstr ""

msgid ""
"14606    * *definition*: a declaration of an entity that supplies all "
"information necessary to complete a program using the entity."
msgstr ""

msgid "14607      Simplified definition: a declaration that allocates memory."
msgstr ""

msgid ""
"14608    * *derived class*: a class derived from one or more base classes."
msgstr ""

msgid ""
"14609    * *design*: an overall description of how a piece of software "
"should operate to meet its specification."
msgstr ""

msgid ""
"14610    * *destructor*: an operation that is implicitly invoked (called) "
"when an object is destroyed (e.g., at the end of a scope). Often, it "
"releases resources."
msgstr ""

msgid ""
"14611    * *encapsulation*: protecting something meant to be private (e.g., "
"implementation details) from unauthorized access."
msgstr ""

msgid ""
"14612    * *error*: a mismatch between reasonable expectations of program "
"behavior (often expressed as a requirement or a users' guide) and what a "
"program actually does."
msgstr ""

msgid ""
"14613    * *executable*: a program ready to be run (executed) on a computer."
msgstr ""

msgid ""
"14614    * *feature creep*: a tendency to add excess functionality to a "
"program \"just in case.\""
msgstr ""

msgid "14615    * *file*: a container of permanent information in a computer."
msgstr ""

msgid ""
"14616    * *floating-point number*: a computer's approximation of a real "
"number, such as 7.93 and 10.78e-3."
msgstr ""

msgid ""
"14617    * *function*: a named unit of code that can be invoked (called) "
"from different parts of a program; a logical unit of computation."
msgstr ""

msgid ""
"14618    * *generic programming*: a style of programming focused on the "
"design and efficient implementation of algorithms."
msgstr ""

msgid ""
"14619      A generic algorithm will work for all argument types that meet "
"its requirements. In C++, generic programming typically uses templates."
msgstr ""

msgid ""
"14620    * *global variable*: technically, a named object in namespace scope."
""
msgstr ""

msgid ""
"14621    * *handle*: a class that allows access to another through a member "
"pointer or reference. See also resource, copy, move."
msgstr ""

msgid ""
"14622    * *header*: a file containing declarations used to share interfaces "
"between parts of a program."
msgstr ""

msgid ""
"14623    * *hiding*: the act of preventing a piece of information from being "
"directly seen or accessed."
msgstr ""

msgid ""
"14624      For example, a name from a nested (inner) scope can prevent that "
"same name from an outer (enclosing) scope from being directly used."
msgstr ""

msgid ""
"14625    * *ideal*: the perfect version of something we are striving for. "
"Usually we have to make trade-offs and settle for an approximation."
msgstr ""

msgid ""
"14626    * *implementation*: (1) the act of writing and testing code; (2) "
"the code that implements a program."
msgstr ""

msgid ""
"14627    * *infinite loop*: a loop where the termination condition never "
"becomes true. See iteration."
msgstr ""

msgid ""
"14628    * *infinite recursion*: a recursion that doesn't end until the "
"machine runs out of memory to hold the calls."
msgstr ""

msgid ""
"14629      In reality, such recursion is never infinite but is terminated by "
"some hardware error."
msgstr ""

msgid ""
"14630    * *information hiding*: the act of separating interface and "
"implementation, thus hiding implementation details not meant for the user's "
"attention and providing an abstraction."
msgstr ""

msgid "14631    * *initialize*: giving an object its first (initial) value."
msgstr ""

msgid ""
"14632    * *input*: values used by a computation (e.g., function arguments "
"and characters typed on a keyboard)."
msgstr ""

msgid "14633    * *integer*: a whole number, such as 42 and -99."
msgstr ""

msgid ""
"14634    * *interface*: a declaration or a set of declarations specifying "
"how a piece of code (such as a function or a class) can be called."
msgstr ""

msgid ""
"14635    * *invariant*: something that must be always true at a given point "
"(or points) of a program; typically used to describe the state (set of "
"values) of an object or the state of a loop before entry into the repeated "
"statement."
msgstr ""

msgid ""
"14636    * *iteration*: the act of repeatedly executing a piece of code; see "
"recursion."
msgstr ""

msgid ""
"14637    * *iterator*: an object that identifies an element of a sequence."
msgstr ""

msgid ""
"14638    * *ISO*: International Organization for Standardization. The C++ "
"language is an ISO standard, ISO/IEC 14882. More information at [iso."
"org](http://iso.org)."
msgstr ""

msgid ""
"14639    * *library*: a collection of types, functions, classes, etc. "
"implementing a set of facilities (abstractions) meant to be potentially used "
"as part of more that one program."
msgstr ""

msgid ""
"14640    * *lifetime*: the time from the initialization of an object until "
"it becomes unusable (goes out of scope, is deleted, or the program "
"terminates)."
msgstr ""

msgid ""
"14641    * *linker*: a program that combines object code files and libraries "
"into an executable program."
msgstr ""

msgid ""
"14642    * *literal*: a notation that directly specifies a value, such as 12 "
"specifying the integer value \"twelve.\""
msgstr ""

msgid ""
"14643    * *loop*: a piece of code executed repeatedly; in C++, typically a "
"for-statement or a `while`-statement."
msgstr ""

msgid ""
"14644    * *move*: an operation that transfers a value from one object to "
"another leaving behind a value representing \"empty.\" See also copy."
msgstr ""

msgid ""
"14645    * *mutable*: changeable; the opposite of immutable, constant, and "
"invariable."
msgstr ""

msgid ""
"14646    * *object*: (1) an initialized region of memory of a known type "
"which holds a value of that type; (2) a region of memory."
msgstr ""

msgid ""
"14647    * *object code*: output from a compiler intended as input for a "
"linker (for the linker to produce executable code)."
msgstr ""

msgid "14648    * *object file*: a file containing object code."
msgstr ""

msgid ""
"14649    * *object-oriented programming*: (OOP) a style of programming "
"focused on the design and use of classes and class hierarchies."
msgstr ""

msgid ""
"14650    * *operation*: something that can perform some action, such as a "
"function and an operator."
msgstr ""

msgid ""
"14651    * *output*: values produced by a computation (e.g., a function "
"result or lines of characters written on a screen)."
msgstr ""

msgid ""
"14652    * *overflow*: producing a value that cannot be stored in its "
"intended target."
msgstr ""

msgid ""
"14653    * *overload*: defining two functions or operators with the same "
"name but different argument (operand) types."
msgstr ""

msgid ""
"14654    * *override*: defining a function in a derived class with the same "
"name and argument types as a virtual function in the base class, thus making "
"the function callable through the interface defined by the base class."
msgstr ""

msgid "14655    * *owner*: an object responsible for releasing a resource."
msgstr ""

msgid ""
"14656    * *paradigm*: a somewhat pretentious term for design or programming "
"style; often used with the (erroneous) implication that there exists a "
"paradigm that is superior to all others."
msgstr ""

msgid ""
"14657    * *parameter*: a declaration of an explicit input to a function or "
"a template. When called, a function can access the arguments passed through "
"the names of its parameters."
msgstr ""

msgid ""
"14658    * *pointer*: (1) a value used to identify a typed object in memory; "
"(2) a variable holding such a value."
msgstr ""

msgid ""
"14659    * *post-condition*: a condition that must hold upon exit from a "
"piece of code, such as a function or a loop."
msgstr ""

msgid ""
"14660    * *pre-condition*: a condition that must hold upon entry into a "
"piece of code, such as a function or a loop."
msgstr ""

msgid ""
"14661    * *program*: code (possibly with associated data) that is "
"sufficiently complete to be executed by a computer."
msgstr ""

msgid ""
"14662    * *programming*: the art of expressing solutions to problems as "
"code."
msgstr ""

msgid "14663    * *programming language*: a language for expressing programs."
msgstr ""

msgid ""
"14664    * *pseudo code*: a description of a computation written in an "
"informal notation rather than a programming language."
msgstr ""

msgid ""
"14665    * *pure virtual function*: a virtual function that must be "
"overridden in a derived class."
msgstr ""

msgid ""
"14666    * *RAII*: (\"Resource Acquisition Is Initialization\") a basic "
"technique for resource management based on scopes."
msgstr ""

msgid ""
"14667    * *range*: a sequence of values that can be described by a start "
"point and an end point. For example, `[0:5)` means the values 0, 1, 2, 3, "
"and 4."
msgstr ""

msgid ""
"14668    * *recursion*: the act of a function calling itself; see also "
"iteration."
msgstr ""

msgid ""
"14669    * *reference*: (1) a value describing the location of a typed value "
"in memory; (2) a variable holding such a value."
msgstr ""

msgid ""
"14670    * *regular expression*: a notation for patterns in character "
"strings."
msgstr ""

msgid ""
"14671    * *regular*: a type that behaves similarly to built-in types like "
"`int` and can be compared with `==`."
msgstr ""

msgid ""
"14672    In particular, an object of a regular type can be copied and the "
"result of a copy is a separate object that compares equal to the original. "
"See also *semiregular type*."
msgstr ""

msgid ""
"14673    * *requirement*: (1) a description of the desired behavior of a "
"program or part of a program; (2) a description of the assumptions a "
"function or template makes of its arguments."
msgstr ""

msgid ""
"14674    * *resource*: something that is acquired and must later be "
"released, such as a file handle, a lock, or memory. See also handle, owner."
msgstr ""

msgid ""
"14675    * *rounding*: conversion of a value to the mathematically nearest "
"value of a less precise type."
msgstr ""

msgid "14676    * *RTTI*: Run-Time Type Information. ???"
msgstr ""

msgid ""
"14677    * *scope*: the region of program text (source code) in which a name "
"can be referred to."
msgstr ""

msgid ""
"14678    * *semiregular*: a type that behaves roughly like an built-in type "
"like `int`, but possibly without a `==` operator. See also *regular type*."
msgstr ""

msgid "14679    * *sequence*: elements that can be visited in a linear order."
msgstr ""

msgid ""
"14680    * *software*: a collection of pieces of code and associated data; "
"often used interchangeably with program."
msgstr ""

msgid ""
"14681    * *source code*: code as produced by a programmer and (in "
"principle) readable by other programmers."
msgstr ""

msgid "14682    * *source file*: a file containing source code."
msgstr ""

msgid ""
"14683    * *specification*: a description of what a piece of code should do."
msgstr ""

msgid ""
"14684    * *standard*: an officially agreed upon definition of something, "
"such as a programming language."
msgstr ""

msgid "14685    * *state*: a set of values."
msgstr ""

msgid ""
"14686    * *STL*: the containers, iterators, and algorithms part of the "
"standard library."
msgstr ""

msgid "14687    * *string*: a sequence of characters."
msgstr ""

msgid ""
"14688    * *style*: a set of techniques for programming leading to a "
"consistent use of language features; sometimes used in a very restricted "
"sense to refer just to low-level rules for naming and appearance of code."
msgstr ""

msgid ""
"14689    * *subtype*: derived type; a type that has all the properties of a "
"type and possibly more."
msgstr ""

msgid ""
"14690    * *supertype*: base type; a type that has a subset of the "
"properties of a type."
msgstr ""

msgid ""
"14691    * *system*: (1) a program or a set of programs for performing a "
"task on a computer; (2) a shorthand for \"operating system\", that is, the "
"fundamental execution environment and tools for a computer."
msgstr ""

msgid ""
"14692    * *TS*: [Technical Specification](https://www.iso.org/deliverables-"
"all.html?type=ts), A Technical Specification addresses work still under "
"technical development, or where it is believed that there will be a future, "
"but not immediate, possibility of agreement on an International Standard. A "
"Technical Specification is published for immediate use, but it also provides "
"a means to obtain feedback. The aim is that it will eventually be "
"transformed and republished as an International Standard."
msgstr ""

msgid ""
"14693    * *template*: a class or a function parameterized by one or more "
"types or (compile-time) values; the basic C++ language construct supporting "
"generic programming."
msgstr ""

msgid "14694    * *testing*: a systematic search for errors in a program."
msgstr ""

msgid ""
"14695    * *trade-off*: the result of balancing several design and "
"implementation criteria."
msgstr ""

msgid ""
"14696    * *truncation*: loss of information in a conversion from a type "
"into another that cannot exactly represent the value to be converted."
msgstr ""

msgid ""
"14697    * *type*: something that defines a set of possible values and a set "
"of operations for an object."
msgstr ""

msgid ""
"14698    * *uninitialized*: the (undefined) state of an object before it is "
"initialized."
msgstr ""

msgid ""
"14699    * *unit*: (1) a standard measure that gives meaning to a value (e.g."
", km for a distance); (2) a distinguished (e.g., named) part of a larger "
"whole."
msgstr ""

msgid ""
"14700    * *use case*: a specific (typically simple) use of a program meant "
"to test its functionality and demonstrate its purpose."
msgstr ""

msgid ""
"14701    * *value*: a set of bits in memory interpreted according to a type."
msgstr ""

msgid ""
"14702    * *variable*: a named object of a given type; contains a value "
"unless uninitialized."
msgstr ""

msgid ""
"14703    * *virtual function*: a member function that can be overridden in a "
"derived class."
msgstr ""

msgid ""
"14704    * *word*: a basic unit of memory in a computer, often the unit used "
"to hold an integer."
msgstr ""

msgid ""
"14705    # <a name=\"S-unclassified\"></a>To-do: Unclassified proto-rules"
msgstr ""

msgid "14706    This is our to-do list."
msgstr ""

msgid "14707    Eventually, the entries will become rules or parts of rules."
msgstr ""

msgid ""
"14708    Alternatively, we will decide that no change is needed and delete "
"the entry."
msgstr ""

msgid "14709    * No long-distance friendship"
msgstr ""

msgid ""
"14710    * Should physical design (what's in a file) and large-scale design "
"(libraries, groups of libraries) be addressed?"
msgstr ""

msgid "14711    * Namespaces"
msgstr ""

msgid ""
"14712    * Avoid using directives in the global scope (except for std, and "
"other \"fundamental\" namespaces (e.g. experimental))"
msgstr ""

msgid ""
"14713    * How granular should namespaces be? All classes/functions designed "
"to work together and released together (as defined in Sutter/Alexandrescu) "
"or something narrower or wider?"
msgstr ""

msgid ""
"14714    * Should there be inline namespaces (à la `std::literals::"
"*_literals`)?"
msgstr ""

msgid "14715    * Avoid implicit conversions"
msgstr ""

msgid ""
"14716    * Const member functions should be thread safe ... aka, but I don't "
"really change the variable, just assign it a value the first time it's "
"called ... argh"
msgstr ""

msgid ""
"14717    * Always initialize variables, use initialization lists for member "
"variables."
msgstr ""

msgid ""
"14718    * Anyone writing a public interface which takes or returns `void*` "
"should have their toes set on fire. That one has been a personal favorite of "
"mine for a number of years. :)"
msgstr ""

msgid ""
"14719    * Use `const`-ness wherever possible: member functions, variables "
"and (yippee) `const_iterators`"
msgstr ""

msgid "14720    * Use `auto`"
msgstr ""

msgid "14721    * `(size)` vs. `{initializers}` vs. `{Extent{size}}`"
msgstr ""

msgid "14722    * Don't overabstract"
msgstr ""

msgid "14723    * Never pass a pointer down the call stack"
msgstr ""

msgid "14724    * falling through a function bottom"
msgstr ""

msgid ""
"14725    * Should there be guidelines to choose between polymorphisms? YES. "
"classic (virtual functions, reference semantics) vs. Sean Parent style "
"(value semantics, type-erased, kind of like `std::function`)  vs. CRTP/"
"static? YES Perhaps even vs. tag dispatch?"
msgstr ""

msgid ""
"14726    * should virtual calls be banned from ctors/dtors in your "
"guidelines? YES. A lot of people ban them, even though I think it's a big "
"strength of C++ that they are ??? -preserving (D disappointed me so much "
"when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE?"
msgstr ""

msgid ""
"14727    * Speaking of lambdas, what would weigh in on the decision between "
"lambdas and (local?) classes in algorithm calls and other callback "
"scenarios?"
msgstr ""

msgid ""
"14728    * And speaking of `std::bind`, Stephen T. Lavavej criticizes it so "
"much I'm starting to wonder if it is indeed going to fade away in future. "
"Should lambdas be recommended instead?"
msgstr ""

msgid ""
"14729    * What to do with leaks out of temporaries? : `p = (s1 + s2)."
"c_str();`"
msgstr ""

msgid "14730    * pointer/iterator invalidation leading to dangling pointers:"
msgstr ""

msgid "14731            void bad()"
msgstr ""

msgid "14732            {"
msgstr ""

msgid "14733                int* p = new int[700];"
msgstr ""

msgid "14734                int* q = &p[7];"
msgstr ""

msgid "14735                delete p;"
msgstr ""

msgid "14736                vector<int> v(700);"
msgstr ""

msgid "14737                int* q2 = &v[7];"
msgstr ""

msgid "14738                v.resize(900);"
msgstr ""

msgid "14739                // ... use q and q2 ..."
msgstr ""

msgid "14740            }"
msgstr ""

msgid "14741    * LSP"
msgstr ""

msgid "14742    * private inheritance vs/and membership"
msgstr ""

msgid ""
"14743    * avoid static class members variables (race conditions, almost-"
"global variables)"
msgstr ""

msgid ""
"14744    * Use RAII lock guards (`lock_guard`, `unique_lock`, "
"`shared_lock`), never call `mutex.lock` and `mutex.unlock` directly (RAII)"
msgstr ""

msgid ""
"14745    * Prefer non-recursive locks (often used to work around bad "
"reasoning, overhead)"
msgstr ""

msgid ""
"14746    * Join your threads! (because of `std::terminate` in destructor if "
"not joined or detached ... is there a good reason to detach threads?) -- ??? "
"could support library provide a RAII wrapper for `std::thread`?"
msgstr ""

msgid ""
"14747    * If two or more mutexes must be acquired at the same time, use "
"`std::lock` (or another deadlock avoidance algorithm?)"
msgstr ""

msgid ""
"14748    * When using a `condition_variable`, always protect the condition "
"by a mutex (atomic bool whose value is set outside of the mutex is wrong!), "
"and use the same mutex for the condition variable itself."
msgstr ""

msgid ""
"14749    * Never use `atomic_compare_exchange_strong` with `std::atomic<user-"
"defined-struct>` (differences in padding matter, while "
"`compare_exchange_weak` in a loop converges to stable padding)"
msgstr ""

msgid ""
"14750    * individual `shared_future` objects are not thread-safe: two "
"threads cannot wait on the same `shared_future` object (they can wait on "
"copies of a `shared_future` that refer to the same shared state)"
msgstr ""

msgid ""
"14751    * individual `shared_ptr` objects are not thread-safe: different "
"threads can call non-`const` member functions on *different* `shared_ptr`s "
"that refer to the same shared object, but one thread cannot call a non-"
"`const` member function of a `shared_ptr` object while another thread "
"accesses that same `shared_ptr` object (if you need that, consider "
"`atomic_shared_ptr` instead)"
msgstr ""

msgid "14752    * rules for arithmetic"
msgstr ""

msgid "14753    # Bibliography"
msgstr ""

msgid "14754    * <a name=\"Abrahams01\"></a>"
msgstr ""

msgid ""
"14755      \\[Abrahams01]:  D. Abrahams. [Exception-Safety in Generic "
"Components](http://www.boost.org/community/exception_safety.html)."
msgstr ""

msgid "14756    * <a name=\"Alexandrescu01\"></a>"
msgstr ""

msgid ""
"14757      \\[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-"
"Wesley, 2001)."
msgstr ""

msgid "14758    * <a name=\"Cplusplus03\"></a>"
msgstr ""

msgid ""
"14759      \\[C++03]:           ISO/IEC 14882:2003(E), Programming Languages "
"— C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) "
"plus errata corrections)."
msgstr ""

msgid "14760    * <a name=\"CplusplusCS\"></a>"
msgstr ""

msgid "14761      \\[C++CS]:           ???"
msgstr ""

msgid "14762    * <a name=\"Cargill92\"></a>"
msgstr ""

msgid ""
"14763      \\[Cargill92]:       T. Cargill. C++ Programming Style (Addison-"
"Wesley, 1992)."
msgstr ""

msgid "14764    * <a name=\"Cline99\"></a>"
msgstr ""

msgid ""
"14765      \\[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs "
"(2ndEdition) (Addison-Wesley, 1999)."
msgstr ""

msgid "14766    * <a name=\"Dewhurst03\"></a>"
msgstr ""

msgid ""
"14767      \\[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, "
"2003)."
msgstr ""

msgid "14768    * <a name=\"Henricson97\"></a>"
msgstr ""

msgid ""
"14769      \\[Henricson97]:     M. Henricson and E. Nyquist. Industrial "
"Strength C++ (Prentice Hall, 1997)."
msgstr ""

msgid "14770    * <a name=\"Koenig97\"></a>"
msgstr ""

msgid ""
"14771      \\[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ "
"(Addison-Wesley, 1997)."
msgstr ""

msgid "14772    * <a name=\"Lakos96\"></a>"
msgstr ""

msgid ""
"14773      \\[Lakos96]:         J. Lakos. Large-Scale C++ Software Design "
"(Addison-Wesley, 1996)."
msgstr ""

msgid "14774    * <a name=\"Meyers96\"></a>"
msgstr ""

msgid ""
"14775      \\[Meyers96]:        S. Meyers. More Effective C++ (Addison-"
"Wesley, 1996)."
msgstr ""

msgid "14776    * <a name=\"Meyers97\"></a>"
msgstr ""

msgid ""
"14777      \\[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) "
"(Addison-Wesley, 1997)."
msgstr ""

msgid "14778    * <a name=\"Meyers15\"></a>"
msgstr ""

msgid ""
"14779      \\[Meyers15]:        S. Meyers. Effective Modern C++ (O'Reilly, "
"2015)."
msgstr ""

msgid "14780    * <a name=\"Murray93\"></a>"
msgstr ""

msgid ""
"14781      \\[Murray93]:        R. Murray. C++ Strategies and Tactics "
"(Addison-Wesley, 1993)."
msgstr ""

msgid "14782    * <a name=\"Stroustrup94\"></a>"
msgstr ""

msgid ""
"14783      \\[Stroustrup94]:    B. Stroustrup. The Design and Evolution of "
"C++ (Addison-Wesley, 1994)."
msgstr ""

msgid "14784    * <a name=\"Stroustrup00\"></a>"
msgstr ""

msgid ""
"14785      \\[Stroustrup00]:    B. Stroustrup. The C++ Programming Language "
"(Special 3rdEdition) (Addison-Wesley, 2000)."
msgstr ""

msgid "14786    * <a name=\"Stroustrup05\"></a>"
msgstr ""

msgid ""
"14787      \\[Stroustrup05]:    B. Stroustrup. [A rationale for semantically "
"enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf)."
msgstr ""

msgid "14788    * <a name=\"Stroustrup13\"></a>"
msgstr ""

msgid ""
"14789      \\[Stroustrup13]:    B. Stroustrup. [The C++ Programming Language "
"(4th Edition)](http://www.stroustrup.com/4th.html). Addison Wesley 2013."
msgstr ""

msgid "14790    * <a name=\"Stroustrup14\"></a>"
msgstr ""

msgid ""
"14791      \\[Stroustrup14]:    B. Stroustrup. [A Tour of C++](http://www."
"stroustrup.com/Tour.html)."
msgstr ""

msgid "14792      Addison Wesley 2014."
msgstr ""

msgid "14793    * <a name=\"Stroustrup15\"></a>"
msgstr ""

msgid ""
"14794      \\[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: "
"[A brief introduction to C++'s model for type- and resource-safety](https://"
"github.com/isocpp/CppCoreGuidelines/blob/master/docs/"
"Introduction%20to%20type%20and%20resource%20safety.pdf)."
msgstr ""

msgid "14795    * <a name=\"SuttHysl04b\"></a>"
msgstr ""

msgid ""
"14796      \\[SuttHysl04b]:     H. Sutter and J. Hyslop. \"Collecting Shared "
"Objects\" (C/C++ Users Journal, 22(8), August 2004)."
msgstr ""

msgid "14797    * <a name=\"SuttAlex05\"></a>"
msgstr ""

msgid ""
"14798      \\[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding "
"Standards. Addison-Wesley 2005."
msgstr ""

msgid "14799    * <a name=\"Sutter00\"></a>"
msgstr ""

msgid ""
"14800      \\[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, "
"2000)."
msgstr ""

msgid "14801    * <a name=\"Sutter02\"></a>"
msgstr ""

msgid ""
"14802      \\[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-"
"Wesley, 2002)."
msgstr ""

msgid "14803    * <a name=\"Sutter04\"></a>"
msgstr ""

msgid ""
"14804      \\[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-"
"Wesley, 2004)."
msgstr ""

msgid "14805    * <a name=\"Taligent94\"></a>"
msgstr ""

msgid ""
"14806      \\[Taligent94]: Taligent's Guide to Designing Programs (Addison-"
"Wesley, 1994)."
msgstr ""

