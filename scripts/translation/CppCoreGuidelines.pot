# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#charset=UTF-8
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-03-13 22:55+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
# CppCoreGuidelines.md:1
msgid "1    # <a name=\"main\"></a>C++ Core Guidelines"
msgstr""

       
# CppCoreGuidelines.md:2
msgid "2    August 13, 2018"
msgstr""

       
       
# CppCoreGuidelines.md:3
msgid "3    Editors:"
msgstr""

       
# CppCoreGuidelines.md:4
msgid "4    * [Bjarne Stroustrup](http://www.stroustrup.com)"
msgstr""

# CppCoreGuidelines.md:5
msgid "5    * [Herb Sutter](http://herbsutter.com/)"
msgstr""

       
# CppCoreGuidelines.md:6
msgid "6    This is a living document under continuous improvement."
msgstr""

# CppCoreGuidelines.md:7
msgid "7    Had it been an open-source (code) project, this would have been release 0.8."
msgstr""

# CppCoreGuidelines.md:8
msgid "8    Copying, use, modification, and creation of derivative works from this project is licensed under an MIT-style license."
msgstr""

# CppCoreGuidelines.md:9
msgid "9    Contributing to this project requires agreeing to a Contributor License. See the accompanying [LICENSE](LICENSE) file for details."
msgstr""

# CppCoreGuidelines.md:10
msgid "10    We make this project available to \"friendly users\" to use, copy, modify, and derive from, hoping for constructive input."
msgstr""

       
# CppCoreGuidelines.md:11
msgid "11    Comments and suggestions for improvements are most welcome."
msgstr""

# CppCoreGuidelines.md:12
msgid "12    We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve."
msgstr""

# CppCoreGuidelines.md:13
msgid "13    When commenting, please note [the introduction](#S-introduction) that outlines our aims and general approach."
msgstr""

# CppCoreGuidelines.md:14
msgid "14    The list of contributors is [here](#SS-ack)."
msgstr""

       
# CppCoreGuidelines.md:15
msgid "15    Problems:"
msgstr""

       
# CppCoreGuidelines.md:16
msgid "16    * The sets of rules have not been completely checked for completeness, consistency, or enforceability."
msgstr""

# CppCoreGuidelines.md:17
msgid "17    * Triple question marks (???) mark known missing information"
msgstr""

# CppCoreGuidelines.md:18
msgid "18    * Update reference sections; many pre-C++11 sources are too old."
msgstr""

# CppCoreGuidelines.md:19
msgid "19    * For a more-or-less up-to-date to-do list see: [To-do: Unclassified proto-rules](#S-unclassified)"
msgstr""

       
# CppCoreGuidelines.md:20
msgid "20    You can [read an explanation of the scope and structure of this Guide](#S-abstract) or just jump straight in:"
msgstr""

       
# CppCoreGuidelines.md:21
msgid "21    * [In: Introduction](#S-introduction)"
msgstr""

# CppCoreGuidelines.md:22
msgid "22    * [P: Philosophy](#S-philosophy)"
msgstr""

# CppCoreGuidelines.md:23
msgid "23    * [I: Interfaces](#S-interfaces)"
msgstr""

# CppCoreGuidelines.md:24
msgid "24    * [F: Functions](#S-functions)"
msgstr""

# CppCoreGuidelines.md:25
msgid "25    * [C: Classes and class hierarchies](#S-class)"
msgstr""

# CppCoreGuidelines.md:26
msgid "26    * [Enum: Enumerations](#S-enum)"
msgstr""

# CppCoreGuidelines.md:27
msgid "27    * [R: Resource management](#S-resource)"
msgstr""

# CppCoreGuidelines.md:28
msgid "28    * [ES: Expressions and statements](#S-expr)"
msgstr""

# CppCoreGuidelines.md:29
msgid "29    * [Per: Performance](#S-performance)"
msgstr""

# CppCoreGuidelines.md:30
msgid "30    * [CP: Concurrency and parallelism](#S-concurrency)"
msgstr""

# CppCoreGuidelines.md:31
msgid "31    * [E: Error handling](#S-errors)"
msgstr""

# CppCoreGuidelines.md:32
msgid "32    * [Con: Constants and immutability](#S-const)"
msgstr""

# CppCoreGuidelines.md:33
msgid "33    * [T: Templates and generic programming](#S-templates)"
msgstr""

# CppCoreGuidelines.md:34
msgid "34    * [CPL: C-style programming](#S-cpl)"
msgstr""

# CppCoreGuidelines.md:35
msgid "35    * [SF: Source files](#S-source)"
msgstr""

# CppCoreGuidelines.md:36
msgid "36    * [SL: The Standard Library](#S-stdlib)"
msgstr""

       
# CppCoreGuidelines.md:37
msgid "37    Supporting sections:"
msgstr""

       
# CppCoreGuidelines.md:38
msgid "38    * [A: Architectural ideas](#S-A)"
msgstr""

# CppCoreGuidelines.md:39
msgid "39    * [NR: Non-Rules and myths](#S-not)"
msgstr""

# CppCoreGuidelines.md:40
msgid "40    * [RF: References](#S-references)"
msgstr""

# CppCoreGuidelines.md:41
msgid "41    * [Pro: Profiles](#S-profile)"
msgstr""

# CppCoreGuidelines.md:42
msgid "42    * [GSL: Guidelines support library](#S-gsl)"
msgstr""

# CppCoreGuidelines.md:43
msgid "43    * [NL: Naming and layout rules](#S-naming)"
msgstr""

# CppCoreGuidelines.md:44
msgid "44    * [FAQ: Answers to frequently asked questions](#S-faq)"
msgstr""

# CppCoreGuidelines.md:45
msgid "45    * [Appendix A: Libraries](#S-libraries)"
msgstr""

# CppCoreGuidelines.md:46
msgid "46    * [Appendix B: Modernizing code](#S-modernizing)"
msgstr""

# CppCoreGuidelines.md:47
msgid "47    * [Appendix C: Discussion](#S-discussion)"
msgstr""

# CppCoreGuidelines.md:48
msgid "48    * [Appendix D: Supporting tools](#S-tools)"
msgstr""

# CppCoreGuidelines.md:49
msgid "49    * [Glossary](#S-glossary)"
msgstr""

# CppCoreGuidelines.md:50
msgid "50    * [To-do: Unclassified proto-rules](#S-unclassified)"
msgstr""

       
# CppCoreGuidelines.md:51
msgid "51    You can sample rules for specific language features:"
msgstr""

       
# CppCoreGuidelines.md:52
msgid "52    * assignment:"
msgstr""

# CppCoreGuidelines.md:53
msgid "53    [regular types](#Rc-regular) --"
msgstr""

# CppCoreGuidelines.md:54
msgid "54    [prefer initialization](#Rc-initialize) --"
msgstr""

# CppCoreGuidelines.md:55
msgid "55    [copy](#Rc-copy-semantic) --"
msgstr""

# CppCoreGuidelines.md:56
msgid "56    [move](#Rc-move-semantic) --"
msgstr""

# CppCoreGuidelines.md:57
msgid "57    [other operations](#Rc-matched) --"
msgstr""

# CppCoreGuidelines.md:58
msgid "58    [default](#Rc-eqdefault)"
msgstr""

# CppCoreGuidelines.md:59
msgid "59    * `class`:"
msgstr""

# CppCoreGuidelines.md:60
msgid "60    [data](#Rc-org) --"
msgstr""

# CppCoreGuidelines.md:61
msgid "61    [invariant](#Rc-struct) --"
msgstr""

# CppCoreGuidelines.md:62
msgid "62    [members](#Rc-member) --"
msgstr""

# CppCoreGuidelines.md:63
msgid "63    [helpers](#Rc-helper) --"
msgstr""

# CppCoreGuidelines.md:64
msgid "64    [concrete types](#SS-concrete) --"
msgstr""

# CppCoreGuidelines.md:65
msgid "65    [ctors, =, and dtors](#S-ctor) --"
msgstr""

# CppCoreGuidelines.md:66
msgid "66    [hierarchy](#SS-hier) --"
msgstr""

# CppCoreGuidelines.md:67
msgid "67    [operators](#SS-overload)"
msgstr""

# CppCoreGuidelines.md:68
msgid "68    * `concept`:"
msgstr""

# CppCoreGuidelines.md:69
msgid "69    [rules](#SS-concepts) --"
msgstr""

# CppCoreGuidelines.md:70
msgid "70    [in generic programming](#Rt-raise) --"
msgstr""

# CppCoreGuidelines.md:71
msgid "71    [template arguments](#Rt-concepts) --"
msgstr""

# CppCoreGuidelines.md:72
msgid "72    [semantics](#Rt-low)"
msgstr""

# CppCoreGuidelines.md:73
msgid "73    * constructor:"
msgstr""

# CppCoreGuidelines.md:74
msgid "74    [invariant](#Rc-struct) --"
msgstr""

# CppCoreGuidelines.md:75
msgid "75    [establish invariant](#Rc-ctor) --"
msgstr""

# CppCoreGuidelines.md:76
msgid "76    [`throw`](#Rc-throw) --"
msgstr""

# CppCoreGuidelines.md:77
msgid "77    [default](#Rc-default0) --"
msgstr""

# CppCoreGuidelines.md:78
msgid "78    [not needed](#Rc-default) --"
msgstr""

# CppCoreGuidelines.md:79
msgid "79    [`explicit`](#Rc-explicit) --"
msgstr""

# CppCoreGuidelines.md:80
msgid "80    [delegating](#Rc-delegating) --"
msgstr""

# CppCoreGuidelines.md:81
msgid "81    [`virtual`](#Rc-ctor-virtual)"
msgstr""

# CppCoreGuidelines.md:82
msgid "82    * derived `class`:"
msgstr""

# CppCoreGuidelines.md:83
msgid "83    [when to use](#Rh-domain) --"
msgstr""

# CppCoreGuidelines.md:84
msgid "84    [as interface](#Rh-abstract) --"
msgstr""

# CppCoreGuidelines.md:85
msgid "85    [destructors](#Rh-dtor) --"
msgstr""

# CppCoreGuidelines.md:86
msgid "86    [copy](#Rh-copy) --"
msgstr""

# CppCoreGuidelines.md:87
msgid "87    [getters and setters](#Rh-get) --"
msgstr""

# CppCoreGuidelines.md:88
msgid "88    [multiple inheritance](#Rh-mi-interface) --"
msgstr""

# CppCoreGuidelines.md:89
msgid "89    [overloading](#Rh-using) --"
msgstr""

# CppCoreGuidelines.md:90
msgid "90    [slicing](#Rc-copy-virtual) --"
msgstr""

# CppCoreGuidelines.md:91
msgid "91    [`dynamic_cast`](#Rh-dynamic_cast)"
msgstr""

# CppCoreGuidelines.md:92
msgid "92    * destructor:"
msgstr""

# CppCoreGuidelines.md:93
msgid "93    [and constructors](#Rc-matched) --"
msgstr""

# CppCoreGuidelines.md:94
msgid "94    [when needed?](#Rc-dtor) --"
msgstr""

# CppCoreGuidelines.md:95
msgid "95    [may not fail](#Rc-dtor-fail)"
msgstr""

# CppCoreGuidelines.md:96
msgid "96    * exception:"
msgstr""

# CppCoreGuidelines.md:97
msgid "97    [errors](#S-errors) --"
msgstr""

# CppCoreGuidelines.md:98
msgid "98    [`throw`](#Re-throw) --"
msgstr""

# CppCoreGuidelines.md:99
msgid "99    [for errors only](#Re-errors) --"
msgstr""

# CppCoreGuidelines.md:100
msgid "100    [`noexcept`](#Re-noexcept) --"
msgstr""

# CppCoreGuidelines.md:101
msgid "101    [minimize `try`](#Re-catch) --"
msgstr""

# CppCoreGuidelines.md:102
msgid "102    [what if no exceptions?](#Re-no-throw-codes)"
msgstr""

# CppCoreGuidelines.md:103
msgid "103    * `for`:"
msgstr""

# CppCoreGuidelines.md:104
msgid "104    [range-for and for](#Res-for-range) --"
msgstr""

# CppCoreGuidelines.md:105
msgid "105    [for and while](#Res-for-while) --"
msgstr""

# CppCoreGuidelines.md:106
msgid "106    [for-initializer](#Res-for-init) --"
msgstr""

# CppCoreGuidelines.md:107
msgid "107    [empty body](#Res-empty) --"
msgstr""

# CppCoreGuidelines.md:108
msgid "108    [loop variable](#Res-loop-counter) --"
msgstr""

# CppCoreGuidelines.md:109
msgid "109    [loop variable type ???](#Res-???)"
msgstr""

# CppCoreGuidelines.md:110
msgid "110    * function:"
msgstr""

# CppCoreGuidelines.md:111
msgid "111    [naming](#Rf-package) --"
msgstr""

# CppCoreGuidelines.md:112
msgid "112    [single operation](#Rf-logical) --"
msgstr""

# CppCoreGuidelines.md:113
msgid "113    [no throw](#Rf-noexcept) --"
msgstr""

# CppCoreGuidelines.md:114
msgid "114    [arguments](#Rf-smart) --"
msgstr""

# CppCoreGuidelines.md:115
msgid "115    [argument passing](#Rf-conventional) --"
msgstr""

# CppCoreGuidelines.md:116
msgid "116    [multiple return values](#Rf-out-multi) --"
msgstr""

# CppCoreGuidelines.md:117
msgid "117    [pointers](#Rf-return-ptr) --"
msgstr""

# CppCoreGuidelines.md:118
msgid "118    [lambdas](#Rf-capture-vs-overload)"
msgstr""

# CppCoreGuidelines.md:119
msgid "119    * `inline`:"
msgstr""

# CppCoreGuidelines.md:120
msgid "120    [small functions](#Rf-inline) --"
msgstr""

# CppCoreGuidelines.md:121
msgid "121    [in headers](#Rs-inline)"
msgstr""

# CppCoreGuidelines.md:122
msgid "122    * initialization:"
msgstr""

# CppCoreGuidelines.md:123
msgid "123    [always](#Res-always) --"
msgstr""

# CppCoreGuidelines.md:124
msgid "124    [prefer `{}`](#Res-list) --"
msgstr""

# CppCoreGuidelines.md:125
msgid "125    [lambdas](#Res-lambda-init) --"
msgstr""

# CppCoreGuidelines.md:126
msgid "126    [in-class initializers](#Rc-in-class-initializer) --"
msgstr""

# CppCoreGuidelines.md:127
msgid "127    [class members](#Rc-initialize) --"
msgstr""

# CppCoreGuidelines.md:128
msgid "128    [factory functions](#Rc-factory)"
msgstr""

# CppCoreGuidelines.md:129
msgid "129    * lambda expression:"
msgstr""

# CppCoreGuidelines.md:130
msgid "130    [when to use](#SS-lambdas)"
msgstr""

# CppCoreGuidelines.md:131
msgid "131    * operator:"
msgstr""

# CppCoreGuidelines.md:132
msgid "132    [conventional](#Ro-conventional) --"
msgstr""

# CppCoreGuidelines.md:133
msgid "133    [avoid conversion operators](#Ro-conversion) --"
msgstr""

# CppCoreGuidelines.md:134
msgid "134    [and lambdas](#Ro-lambda)"
msgstr""

# CppCoreGuidelines.md:135
msgid "135    * `public`, `private`, and `protected`:"
msgstr""

# CppCoreGuidelines.md:136
msgid "136    [information hiding](#Rc-private) --"
msgstr""

# CppCoreGuidelines.md:137
msgid "137    [consistency](#Rh-public) --"
msgstr""

# CppCoreGuidelines.md:138
msgid "138    [`protected`](#Rh-protected)"
msgstr""

# CppCoreGuidelines.md:139
msgid "139    * `static_assert`:"
msgstr""

# CppCoreGuidelines.md:140
msgid "140    [compile-time checking](#Rp-compile-time) --"
msgstr""

# CppCoreGuidelines.md:141
msgid "141    [and concepts](#Rt-check-class)"
msgstr""

# CppCoreGuidelines.md:142
msgid "142    * `struct`:"
msgstr""

# CppCoreGuidelines.md:143
msgid "143    [for organizing data](#Rc-org) --"
msgstr""

# CppCoreGuidelines.md:144
msgid "144    [use if no invariant](#Rc-struct) --"
msgstr""

# CppCoreGuidelines.md:145
msgid "145    [no private members](#Rc-class)"
msgstr""

# CppCoreGuidelines.md:146
msgid "146    * `template`:"
msgstr""

# CppCoreGuidelines.md:147
msgid "147    [abstraction](#Rt-raise) --"
msgstr""

# CppCoreGuidelines.md:148
msgid "148    [containers](#Rt-cont) --"
msgstr""

# CppCoreGuidelines.md:149
msgid "149    [concepts](#Rt-concepts)"
msgstr""

# CppCoreGuidelines.md:150
msgid "150    * `unsigned`:"
msgstr""

# CppCoreGuidelines.md:151
msgid "151    [and signed](#Res-mix) --"
msgstr""

# CppCoreGuidelines.md:152
msgid "152    [bit manipulation](#Res-unsigned)"
msgstr""

# CppCoreGuidelines.md:153
msgid "153    * `virtual`:"
msgstr""

# CppCoreGuidelines.md:154
msgid "154    [interfaces](#Ri-abstract) --"
msgstr""

# CppCoreGuidelines.md:155
msgid "155    [not `virtual`](#Rc-concrete) --"
msgstr""

# CppCoreGuidelines.md:156
msgid "156    [destructor](#Rc-dtor-virtual) --"
msgstr""

# CppCoreGuidelines.md:157
msgid "157    [never fail](#Rc-dtor-fail)"
msgstr""

       
# CppCoreGuidelines.md:158
msgid "158    You can look at design concepts used to express the rules:"
msgstr""

       
# CppCoreGuidelines.md:159
msgid "159    * assertion: ???"
msgstr""

# CppCoreGuidelines.md:160
msgid "160    * error: ???"
msgstr""

# CppCoreGuidelines.md:161
msgid "161    * exception: exception guarantee (???)"
msgstr""

# CppCoreGuidelines.md:162
msgid "162    * failure: ???"
msgstr""

# CppCoreGuidelines.md:163
msgid "163    * invariant: ???"
msgstr""

# CppCoreGuidelines.md:164
msgid "164    * leak: ???"
msgstr""

# CppCoreGuidelines.md:165
msgid "165    * library: ???"
msgstr""

# CppCoreGuidelines.md:166
msgid "166    * precondition: ???"
msgstr""

# CppCoreGuidelines.md:167
msgid "167    * postcondition: ???"
msgstr""

# CppCoreGuidelines.md:168
msgid "168    * resource: ???"
msgstr""

       
# CppCoreGuidelines.md:169
msgid "169    # <a name=\"S-abstract\"></a>Abstract"
msgstr""

       
# CppCoreGuidelines.md:170
msgid "170    This document is a set of guidelines for using C++ well."
msgstr""

# CppCoreGuidelines.md:171
msgid "171    The aim of this document is to help people to use modern C++ effectively."
msgstr""

# CppCoreGuidelines.md:172
msgid "172    By \"modern C++\" we mean C++17, C++14, and C++11."
msgstr""

# CppCoreGuidelines.md:173
msgid "173    In other words, what would you like your code to look like in 5 years' time, given that you can start now? In 10 years' time?"
msgstr""

       
# CppCoreGuidelines.md:174
msgid "174    The guidelines are focused on relatively high-level issues, such as interfaces, resource management, memory management, and concurrency."
msgstr""

# CppCoreGuidelines.md:175
msgid "175    Such rules affect application architecture and library design."
msgstr""

# CppCoreGuidelines.md:176
msgid "176    Following the rules will lead to code that is statically type safe, has no resource leaks, and catches many more programming logic errors than is common in code today."
msgstr""

# CppCoreGuidelines.md:177
msgid "177    And it will run fast -- you can afford to do things right."
msgstr""

       
# CppCoreGuidelines.md:178
msgid "178    We are less concerned with low-level issues, such as naming conventions and indentation style."
msgstr""

# CppCoreGuidelines.md:179
msgid "179    However, no topic that can help a programmer is out of bounds."
msgstr""

       
# CppCoreGuidelines.md:180
msgid "180    Our initial set of rules emphasizes safety (of various forms) and simplicity."
msgstr""

# CppCoreGuidelines.md:181
msgid "181    They may very well be too strict."
msgstr""

# CppCoreGuidelines.md:182
msgid "182    We expect to have to introduce more exceptions to better accommodate real-world needs."
msgstr""

# CppCoreGuidelines.md:183
msgid "183    We also need more rules."
msgstr""

       
# CppCoreGuidelines.md:184
msgid "184    You will find some of the rules contrary to your expectations or even contrary to your experience."
msgstr""

# CppCoreGuidelines.md:185
msgid "185    If we haven't suggested you change your coding style in any way, we have failed!"
msgstr""

# CppCoreGuidelines.md:186
msgid "186    Please try to verify or disprove rules!"
msgstr""

# CppCoreGuidelines.md:187
msgid "187    In particular, we'd really like to have some of our rules backed up with measurements or better examples."
msgstr""

       
# CppCoreGuidelines.md:188
msgid "188    You will find some of the rules obvious or even trivial."
msgstr""

# CppCoreGuidelines.md:189
msgid "189    Please remember that one purpose of a guideline is to help someone who is less experienced or coming from a different background or language to get up to speed."
msgstr""

       
# CppCoreGuidelines.md:190
msgid "190    Many of the rules are designed to be supported by an analysis tool."
msgstr""

# CppCoreGuidelines.md:191
msgid "191    Violations of rules will be flagged with references (or links) to the relevant rule."
msgstr""

# CppCoreGuidelines.md:192
msgid "192    We do not expect you to memorize all the rules before trying to write code."
msgstr""

# CppCoreGuidelines.md:193
msgid "193    One way of thinking about these guidelines is as a specification for tools that happens to be readable by humans."
msgstr""

       
# CppCoreGuidelines.md:194
msgid "194    The rules are meant for gradual introduction into a code base."
msgstr""

# CppCoreGuidelines.md:195
msgid "195    We plan to build tools for that and hope others will too."
msgstr""

       
# CppCoreGuidelines.md:196
msgid "196    Comments and suggestions for improvements are most welcome."
msgstr""

# CppCoreGuidelines.md:197
msgid "197    We plan to modify and extend this document as our understanding improves and the language and the set of available libraries improve."
msgstr""

       
# CppCoreGuidelines.md:198
msgid "198    # <a name=\"S-introduction\"></a>In: Introduction"
msgstr""

       
# CppCoreGuidelines.md:199
msgid "199    This is a set of core guidelines for modern C++, C++17, C++14, and C++11, taking likely future enhancements and ISO Technical Specifications (TSs) into account."
msgstr""

# CppCoreGuidelines.md:200
msgid "200    The aim is to help C++ programmers to write simpler, more efficient, more maintainable code."
msgstr""

       
# CppCoreGuidelines.md:201
msgid "201    Introduction summary:"
msgstr""

       
# CppCoreGuidelines.md:202
msgid "202    * [In.target: Target readership](#SS-readers)"
msgstr""

# CppCoreGuidelines.md:203
msgid "203    * [In.aims: Aims](#SS-aims)"
msgstr""

# CppCoreGuidelines.md:204
msgid "204    * [In.not: Non-aims](#SS-non)"
msgstr""

# CppCoreGuidelines.md:205
msgid "205    * [In.force: Enforcement](#SS-force)"
msgstr""

# CppCoreGuidelines.md:206
msgid "206    * [In.struct: The structure of this document](#SS-struct)"
msgstr""

# CppCoreGuidelines.md:207
msgid "207    * [In.sec: Major sections](#SS-sec)"
msgstr""

       
# CppCoreGuidelines.md:208
msgid "208    ## <a name=\"SS-readers\"></a>In.target: Target readership"
msgstr""

       
# CppCoreGuidelines.md:209
msgid "209    All C++ programmers. This includes [programmers who might consider C](#S-cpl)."
msgstr""

       
# CppCoreGuidelines.md:210
msgid "210    ## <a name=\"SS-aims\"></a>In.aims: Aims"
msgstr""

       
# CppCoreGuidelines.md:211
msgid "211    The purpose of this document is to help developers to adopt modern C++ (C++17, C++14, and C++11) and to achieve a more uniform style across code bases."
msgstr""

       
# CppCoreGuidelines.md:212
msgid "212    We do not suffer the delusion that every one of these rules can be effectively applied to every code base. Upgrading old systems is hard. However, we do believe that a program that uses a rule is less error-prone and more maintainable than one that does not. Often, rules also lead to faster/easier initial development."
msgstr""

# CppCoreGuidelines.md:213
msgid "213    As far as we can tell, these rules lead to code that performs as well or better than older, more conventional techniques; they are meant to follow the zero-overhead principle (\"what you don't use, you don't pay for\" or \"when you use an abstraction mechanism appropriately, you get at least as good performance as if you had handcoded using lower-level language constructs\")."
msgstr""

# CppCoreGuidelines.md:214
msgid "214    Consider these rules ideals for new code, opportunities to exploit when working on older code, and try to approximate these ideals as closely as feasible."
msgstr""

# CppCoreGuidelines.md:215
msgid "215    Remember:"
msgstr""

       
# CppCoreGuidelines.md:216
msgid "216    ### <a name=\"R0\"></a>In.0: Don't panic!"
msgstr""

       
# CppCoreGuidelines.md:217
msgid "217    Take the time to understand the implications of a guideline rule on your program."
msgstr""

       
# CppCoreGuidelines.md:218
msgid "218    These guidelines are designed according to the \"subset of superset\" principle ([Stroustrup05](#Stroustrup05))."
msgstr""

# CppCoreGuidelines.md:219
msgid "219    They do not simply define a subset of C++ to be used (for reliability, safety, performance, or whatever)."
msgstr""

# CppCoreGuidelines.md:220
msgid "220    Instead, they strongly recommend the use of a few simple \"extensions\" ([library components](#S-gsl))"
msgstr""

# CppCoreGuidelines.md:221
msgid "221    that make the use of the most error-prone features of C++ redundant, so that they can be banned (in our set of rules)."
msgstr""

       
# CppCoreGuidelines.md:222
msgid "222    The rules emphasize static type safety and resource safety."
msgstr""

# CppCoreGuidelines.md:223
msgid "223    For that reason, they emphasize possibilities for range checking, for avoiding dereferencing `nullptr`, for avoiding dangling pointers, and the systematic use of exceptions (via RAII)."
msgstr""

# CppCoreGuidelines.md:224
msgid "224    Partly to achieve that and partly to minimize obscure code as a source of errors, the rules also emphasize simplicity and the hiding of necessary complexity behind well-specified interfaces."
msgstr""

       
# CppCoreGuidelines.md:225
msgid "225    Many of the rules are prescriptive."
msgstr""

# CppCoreGuidelines.md:226
msgid "226    We are uncomfortable with rules that simply state \"don't do that!\" without offering an alternative."
msgstr""

# CppCoreGuidelines.md:227
msgid "227    One consequence of that is that some rules can be supported only by heuristics, rather than precise and mechanically verifiable checks."
msgstr""

# CppCoreGuidelines.md:228
msgid "228    Other rules articulate general principles. For these more general rules, more detailed and specific rules provide partial checking."
msgstr""

       
# CppCoreGuidelines.md:229
msgid "229    These guidelines address the core of C++ and its use."
msgstr""

# CppCoreGuidelines.md:230
msgid "230    We expect that most large organizations, specific application areas, and even large projects will need further rules, possibly further restrictions, and further library support."
msgstr""

# CppCoreGuidelines.md:231
msgid "231    For example, hard-real-time programmers typically can't use free store (dynamic memory) freely and will be restricted in their choice of libraries."
msgstr""

# CppCoreGuidelines.md:232
msgid "232    We encourage the development of such more specific rules as addenda to these core guidelines."
msgstr""

# CppCoreGuidelines.md:233
msgid "233    Build your ideal small foundation library and use that, rather than lowering your level of programming to glorified assembly code."
msgstr""

       
# CppCoreGuidelines.md:234
msgid "234    The rules are designed to allow [gradual adoption](#S-modernizing)."
msgstr""

       
# CppCoreGuidelines.md:235
msgid "235    Some rules aim to increase various forms of safety while others aim to reduce the likelihood of accidents, many do both."
msgstr""

# CppCoreGuidelines.md:236
msgid "236    The guidelines aimed at preventing accidents often ban perfectly legal C++."
msgstr""

# CppCoreGuidelines.md:237
msgid "237    However, when there are two ways of expressing an idea and one has shown itself a common source of errors and the other has not, we try to guide programmers towards the latter."
msgstr""

       
# CppCoreGuidelines.md:238
msgid "238    ## <a name=\"SS-non\"></a>In.not: Non-aims"
msgstr""

       
# CppCoreGuidelines.md:239
msgid "239    The rules are not intended to be minimal or orthogonal."
msgstr""

# CppCoreGuidelines.md:240
msgid "240    In particular, general rules can be simple, but unenforceable."
msgstr""

# CppCoreGuidelines.md:241
msgid "241    Also, it is often hard to understand the implications of a general rule."
msgstr""

# CppCoreGuidelines.md:242
msgid "242    More specialized rules are often easier to understand and to enforce, but without general rules, they would just be a long list of special cases."
msgstr""

# CppCoreGuidelines.md:243
msgid "243    We provide rules aimed at helping novices as well as rules supporting expert use."
msgstr""

# CppCoreGuidelines.md:244
msgid "244    Some rules can be completely enforced, but others are based on heuristics."
msgstr""

       
# CppCoreGuidelines.md:245
msgid "245    These rules are not meant to be read serially, like a book."
msgstr""

# CppCoreGuidelines.md:246
msgid "246    You can browse through them using the links."
msgstr""

# CppCoreGuidelines.md:247
msgid "247    However, their main intended use is to be targets for tools."
msgstr""

# CppCoreGuidelines.md:248
msgid "248    That is, a tool looks for violations and the tool returns links to violated rules."
msgstr""

# CppCoreGuidelines.md:249
msgid "249    The rules then provide reasons, examples of potential consequences of the violation, and suggested remedies."
msgstr""

       
# CppCoreGuidelines.md:250
msgid "250    These guidelines are not intended to be a substitute for a tutorial treatment of C++."
msgstr""

# CppCoreGuidelines.md:251
msgid "251    If you need a tutorial for some given level of experience, see [the references](#S-references)."
msgstr""

       
# CppCoreGuidelines.md:252
msgid "252    This is not a guide on how to convert old C++ code to more modern code."
msgstr""

# CppCoreGuidelines.md:253
msgid "253    It is meant to articulate ideas for new code in a concrete fashion."
msgstr""

# CppCoreGuidelines.md:254
msgid "254    However, see [the modernization section](#S-modernizing) for some possible approaches to modernizing/rejuvenating/upgrading."
msgstr""

# CppCoreGuidelines.md:255
msgid "255    Importantly, the rules support gradual adoption: It is typically infeasible to completely convert a large code base all at once."
msgstr""

       
# CppCoreGuidelines.md:256
msgid "256    These guidelines are not meant to be complete or exact in every language-technical detail."
msgstr""

# CppCoreGuidelines.md:257
msgid "257    For the final word on language definition issues, including every exception to general rules and every feature, see the ISO C++ standard."
msgstr""

       
# CppCoreGuidelines.md:258
msgid "258    The rules are not intended to force you to write in an impoverished subset of C++."
msgstr""

# CppCoreGuidelines.md:259
msgid "259    They are *emphatically* not meant to define a, say, Java-like subset of C++."
msgstr""

# CppCoreGuidelines.md:260
msgid "260    They are not meant to define a single \"one true C++\" language."
msgstr""

# CppCoreGuidelines.md:261
msgid "261    We value expressiveness and uncompromised performance."
msgstr""

       
# CppCoreGuidelines.md:262
msgid "262    The rules are not value-neutral."
msgstr""

# CppCoreGuidelines.md:263
msgid "263    They are meant to make code simpler and more correct/safer than most existing C++ code, without loss of performance."
msgstr""

# CppCoreGuidelines.md:264
msgid "264    They are meant to inhibit perfectly valid C++ code that correlates with errors, spurious complexity, and poor performance."
msgstr""

       
# CppCoreGuidelines.md:265
msgid "265    The rules are not perfect."
msgstr""

# CppCoreGuidelines.md:266
msgid "266    A rule can do harm by prohibiting something that is useful in a given situation."
msgstr""

# CppCoreGuidelines.md:267
msgid "267    A rule can do harm by failing to prohibit something that enables a serious error in a given situation."
msgstr""

# CppCoreGuidelines.md:268
msgid "268    A rule can do a lot of harm by being vague, ambiguous, unenforceable, or by enabling every solution to a problem."
msgstr""

# CppCoreGuidelines.md:269
msgid "269    It is impossible to completely meet the \"do no harm\" criteria."
msgstr""

# CppCoreGuidelines.md:270
msgid "270    Instead, our aim is the less ambitious: \"Do the most good for most programmers\";"
msgstr""

# CppCoreGuidelines.md:271
msgid "271    if you cannot live with a rule, object to it, ignore it, but don't water it down until it becomes meaningless."
msgstr""

# CppCoreGuidelines.md:272
msgid "272    Also, suggest an improvement."
msgstr""

       
# CppCoreGuidelines.md:273
msgid "273    ## <a name=\"SS-force\"></a>In.force: Enforcement"
msgstr""

       
# CppCoreGuidelines.md:274
msgid "274    Rules with no enforcement are unmanageable for large code bases."
msgstr""

# CppCoreGuidelines.md:275
msgid "275    Enforcement of all rules is possible only for a small weak set of rules or for a specific user community."
msgstr""

       
# CppCoreGuidelines.md:276
msgid "276    * But we want lots of rules, and we want rules that everybody can use."
msgstr""

# CppCoreGuidelines.md:277
msgid "277    * But different people have different needs."
msgstr""

# CppCoreGuidelines.md:278
msgid "278    * But people don't like to read lots of rules."
msgstr""

# CppCoreGuidelines.md:279
msgid "279    * But people can't remember many rules."
msgstr""

       
# CppCoreGuidelines.md:280
msgid "280    So, we need subsetting to meet a variety of needs."
msgstr""

       
# CppCoreGuidelines.md:281
msgid "281    * But arbitrary subsetting leads to chaos."
msgstr""

       
# CppCoreGuidelines.md:282
msgid "282    We want guidelines that help a lot of people, make code more uniform, and strongly encourage people to modernize their code."
msgstr""

# CppCoreGuidelines.md:283
msgid "283    We want to encourage best practices, rather than leave all to individual choices and management pressures."
msgstr""

# CppCoreGuidelines.md:284
msgid "284    The ideal is to use all rules; that gives the greatest benefits."
msgstr""

       
# CppCoreGuidelines.md:285
msgid "285    This adds up to quite a few dilemmas."
msgstr""

# CppCoreGuidelines.md:286
msgid "286    We try to resolve those using tools."
msgstr""

# CppCoreGuidelines.md:287
msgid "287    Each rule has an **Enforcement** section listing ideas for enforcement."
msgstr""

# CppCoreGuidelines.md:288
msgid "288    Enforcement might be done by code review, by static analysis, by compiler, or by run-time checks."
msgstr""

# CppCoreGuidelines.md:289
msgid "289    Wherever possible, we prefer \"mechanical\" checking (humans are slow, inaccurate, and bore easily) and static checking."
msgstr""

# CppCoreGuidelines.md:290
msgid "290    Run-time checks are suggested only rarely where no alternative exists; we do not want to introduce \"distributed fat\"."
msgstr""

# CppCoreGuidelines.md:291
msgid "291    Where appropriate, we label a rule (in the **Enforcement** sections) with the name of groups of related rules (called \"profiles\")."
msgstr""

# CppCoreGuidelines.md:292
msgid "292    A rule can be part of several profiles, or none."
msgstr""

# CppCoreGuidelines.md:293
msgid "293    For a start, we have a few profiles corresponding to common needs (desires, ideals):"
msgstr""

       
# CppCoreGuidelines.md:294
msgid "294    * **type**: No type violations (reinterpreting a `T` as a `U` through casts, unions, or varargs)"
msgstr""

# CppCoreGuidelines.md:295
msgid "295    * **bounds**: No bounds violations (accessing beyond the range of an array)"
msgstr""

# CppCoreGuidelines.md:296
msgid "296    * **lifetime**: No leaks (failing to `delete` or multiple `delete`) and no access to invalid objects (dereferencing `nullptr`, using a dangling reference)."
msgstr""

       
# CppCoreGuidelines.md:297
msgid "297    The profiles are intended to be used by tools, but also serve as an aid to the human reader."
msgstr""

# CppCoreGuidelines.md:298
msgid "298    We do not limit our comment in the **Enforcement** sections to things we know how to enforce; some comments are mere wishes that might inspire some tool builder."
msgstr""

       
# CppCoreGuidelines.md:299
msgid "299    Tools that implement these rules shall respect the following syntax to explicitly suppress a rule:"
msgstr""

       
# CppCoreGuidelines.md:300
msgid "300        [[gsl::suppress(tag)]]"
msgstr""

       
# CppCoreGuidelines.md:301
msgid "301    where \"tag\" is the anchor name of the item where the Enforcement rule appears (e.g., for [C.134](#Rh-public) it is \"Rh-public\"), the"
msgstr""

# CppCoreGuidelines.md:302
msgid "302    name of a profile group-of-rules (\"type\", \"bounds\", or \"lifetime\"),"
msgstr""

# CppCoreGuidelines.md:303
msgid "303    or a specific rule in a profile ([type.4](#Pro-type-cstylecast), or [bounds.2](#Pro-bounds-arrayindex))."
msgstr""

       
# CppCoreGuidelines.md:304
msgid "304    ## <a name=\"SS-struct\"></a>In.struct: The structure of this document"
msgstr""

       
# CppCoreGuidelines.md:305
msgid "305    Each rule (guideline, suggestion) can have several parts:"
msgstr""

       
# CppCoreGuidelines.md:306
msgid "306    * The rule itself -- e.g., **no naked `new`**"
msgstr""

# CppCoreGuidelines.md:307
msgid "307    * A rule reference number -- e.g., **C.7** (the 7th rule related to classes)."
msgstr""

# CppCoreGuidelines.md:308
msgid "308      Since the major sections are not inherently ordered, we use letters as the first part of a rule reference \"number\"."
msgstr""

# CppCoreGuidelines.md:309
msgid "309      We leave gaps in the numbering to minimize \"disruption\" when we add or remove rules."
msgstr""

# CppCoreGuidelines.md:310
msgid "310    * **Reason**s (rationales) -- because programmers find it hard to follow rules they don't understand"
msgstr""

# CppCoreGuidelines.md:311
msgid "311    * **Example**s -- because rules are hard to understand in the abstract; can be positive or negative"
msgstr""

# CppCoreGuidelines.md:312
msgid "312    * **Alternative**s -- for \"don't do this\" rules"
msgstr""

# CppCoreGuidelines.md:313
msgid "313    * **Exception**s -- we prefer simple general rules. However, many rules apply widely, but not universally, so exceptions must be listed"
msgstr""

# CppCoreGuidelines.md:314
msgid "314    * **Enforcement** -- ideas about how the rule might be checked \"mechanically\""
msgstr""

# CppCoreGuidelines.md:315
msgid "315    * **See also**s -- references to related rules and/or further discussion (in this document or elsewhere)"
msgstr""

# CppCoreGuidelines.md:316
msgid "316    * **Note**s (comments) -- something that needs saying that doesn't fit the other classifications"
msgstr""

# CppCoreGuidelines.md:317
msgid "317    * **Discussion** -- references to more extensive rationale and/or examples placed outside the main lists of rules"
msgstr""

       
# CppCoreGuidelines.md:318
msgid "318    Some rules are hard to check mechanically, but they all meet the minimal criteria that an expert programmer can spot many violations without too much trouble."
msgstr""

# CppCoreGuidelines.md:319
msgid "319    We hope that \"mechanical\" tools will improve with time to approximate what such an expert programmer notices."
msgstr""

# CppCoreGuidelines.md:320
msgid "320    Also, we assume that the rules will be refined over time to make them more precise and checkable."
msgstr""

       
# CppCoreGuidelines.md:321
msgid "321    A rule is aimed at being simple, rather than carefully phrased to mention every alternative and special case."
msgstr""

# CppCoreGuidelines.md:322
msgid "322    Such information is found in the **Alternative** paragraphs and the [Discussion](#S-discussion) sections."
msgstr""

# CppCoreGuidelines.md:323
msgid "323    If you don't understand a rule or disagree with it, please visit its **Discussion**."
msgstr""

# CppCoreGuidelines.md:324
msgid "324    If you feel that a discussion is missing or incomplete, enter an [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)"
msgstr""

# CppCoreGuidelines.md:325
msgid "325    explaining your concerns and possibly a corresponding PR."
msgstr""

       
# CppCoreGuidelines.md:326
msgid "326    This is not a language manual."
msgstr""

# CppCoreGuidelines.md:327
msgid "327    It is meant to be helpful, rather than complete, fully accurate on technical details, or a guide to existing code."
msgstr""

# CppCoreGuidelines.md:328
msgid "328    Recommended information sources can be found in [the references](#S-references)."
msgstr""

       
# CppCoreGuidelines.md:329
msgid "329    ## <a name=\"SS-sec\"></a>In.sec: Major sections"
msgstr""

       
# CppCoreGuidelines.md:330
msgid "330    * [In: Introduction](#S-introduction)"
msgstr""

# CppCoreGuidelines.md:331
msgid "331    * [P: Philosophy](#S-philosophy)"
msgstr""

# CppCoreGuidelines.md:332
msgid "332    * [I: Interfaces](#S-interfaces)"
msgstr""

# CppCoreGuidelines.md:333
msgid "333    * [F: Functions](#S-functions)"
msgstr""

# CppCoreGuidelines.md:334
msgid "334    * [C: Classes and class hierarchies](#S-class)"
msgstr""

# CppCoreGuidelines.md:335
msgid "335    * [Enum: Enumerations](#S-enum)"
msgstr""

# CppCoreGuidelines.md:336
msgid "336    * [R: Resource management](#S-resource)"
msgstr""

# CppCoreGuidelines.md:337
msgid "337    * [ES: Expressions and statements](#S-expr)"
msgstr""

# CppCoreGuidelines.md:338
msgid "338    * [Per: Performance](#S-performance)"
msgstr""

# CppCoreGuidelines.md:339
msgid "339    * [CP: Concurrency and parallelism](#S-concurrency)"
msgstr""

# CppCoreGuidelines.md:340
msgid "340    * [E: Error handling](#S-errors)"
msgstr""

# CppCoreGuidelines.md:341
msgid "341    * [Con: Constants and immutability](#S-const)"
msgstr""

# CppCoreGuidelines.md:342
msgid "342    * [T: Templates and generic programming](#S-templates)"
msgstr""

# CppCoreGuidelines.md:343
msgid "343    * [CPL: C-style programming](#S-cpl)"
msgstr""

# CppCoreGuidelines.md:344
msgid "344    * [SF: Source files](#S-source)"
msgstr""

# CppCoreGuidelines.md:345
msgid "345    * [SL: The Standard Library](#S-stdlib)"
msgstr""

       
# CppCoreGuidelines.md:346
msgid "346    Supporting sections:"
msgstr""

       
# CppCoreGuidelines.md:347
msgid "347    * [A: Architectural ideas](#S-A)"
msgstr""

# CppCoreGuidelines.md:348
msgid "348    * [NR: Non-Rules and myths](#S-not)"
msgstr""

# CppCoreGuidelines.md:349
msgid "349    * [RF: References](#S-references)"
msgstr""

# CppCoreGuidelines.md:350
msgid "350    * [Pro: Profiles](#S-profile)"
msgstr""

# CppCoreGuidelines.md:351
msgid "351    * [GSL: Guidelines support library](#S-gsl)"
msgstr""

# CppCoreGuidelines.md:352
msgid "352    * [NL: Naming and layout rules](#S-naming)"
msgstr""

# CppCoreGuidelines.md:353
msgid "353    * [FAQ: Answers to frequently asked questions](#S-faq)"
msgstr""

# CppCoreGuidelines.md:354
msgid "354    * [Appendix A: Libraries](#S-libraries)"
msgstr""

# CppCoreGuidelines.md:355
msgid "355    * [Appendix B: Modernizing code](#S-modernizing)"
msgstr""

# CppCoreGuidelines.md:356
msgid "356    * [Appendix C: Discussion](#S-discussion)"
msgstr""

# CppCoreGuidelines.md:357
msgid "357    * [Appendix D: Supporting tools](#S-tools)"
msgstr""

# CppCoreGuidelines.md:358
msgid "358    * [Glossary](#S-glossary)"
msgstr""

# CppCoreGuidelines.md:359
msgid "359    * [To-do: Unclassified proto-rules](#S-unclassified)"
msgstr""

       
# CppCoreGuidelines.md:360
msgid "360    These sections are not orthogonal."
msgstr""

       
# CppCoreGuidelines.md:361
msgid "361    Each section (e.g., \"P\" for \"Philosophy\") and each subsection (e.g., \"C.hier\" for \"Class Hierarchies (OOP)\") have an abbreviation for ease of searching and reference."
msgstr""

# CppCoreGuidelines.md:362
msgid "362    The main section abbreviations are also used in rule numbers (e.g., \"C.11\" for \"Make concrete types regular\")."
msgstr""

       
# CppCoreGuidelines.md:363
msgid "363    # <a name=\"S-philosophy\"></a>P: Philosophy"
msgstr""

       
# CppCoreGuidelines.md:364
msgid "364    The rules in this section are very general."
msgstr""

       
# CppCoreGuidelines.md:365
msgid "365    Philosophy rules summary:"
msgstr""

       
# CppCoreGuidelines.md:366
msgid "366    * [P.1: Express ideas directly in code](#Rp-direct)"
msgstr""

# CppCoreGuidelines.md:367
msgid "367    * [P.2: Write in ISO Standard C++](#Rp-Cplusplus)"
msgstr""

# CppCoreGuidelines.md:368
msgid "368    * [P.3: Express intent](#Rp-what)"
msgstr""

# CppCoreGuidelines.md:369
msgid "369    * [P.4: Ideally, a program should be statically type safe](#Rp-typesafe)"
msgstr""

# CppCoreGuidelines.md:370
msgid "370    * [P.5: Prefer compile-time checking to run-time checking](#Rp-compile-time)"
msgstr""

# CppCoreGuidelines.md:371
msgid "371    * [P.6: What cannot be checked at compile time should be checkable at run time](#Rp-run-time)"
msgstr""

# CppCoreGuidelines.md:372
msgid "372    * [P.7: Catch run-time errors early](#Rp-early)"
msgstr""

# CppCoreGuidelines.md:373
msgid "373    * [P.8: Don't leak any resources](#Rp-leak)"
msgstr""

# CppCoreGuidelines.md:374
msgid "374    * [P.9: Don't waste time or space](#Rp-waste)"
msgstr""

# CppCoreGuidelines.md:375
msgid "375    * [P.10: Prefer immutable data to mutable data](#Rp-mutable)"
msgstr""

# CppCoreGuidelines.md:376
msgid "376    * [P.11: Encapsulate messy constructs, rather than spreading through the code](#Rp-library)"
msgstr""

# CppCoreGuidelines.md:377
msgid "377    * [P.12: Use supporting tools as appropriate](#Rp-tools)"
msgstr""

# CppCoreGuidelines.md:378
msgid "378    * [P.13: Use support libraries as appropriate](#Rp-lib)"
msgstr""

       
# CppCoreGuidelines.md:379
msgid "379    Philosophical rules are generally not mechanically checkable."
msgstr""

# CppCoreGuidelines.md:380
msgid "380    However, individual rules reflecting these philosophical themes are."
msgstr""

# CppCoreGuidelines.md:381
msgid "381    Without a philosophical basis, the more concrete/specific/checkable rules lack rationale."
msgstr""

       
# CppCoreGuidelines.md:382
msgid "382    ### <a name=\"Rp-direct\"></a>P.1: Express ideas directly in code"
msgstr""

       
# CppCoreGuidelines.md:383
msgid "383    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:384
msgid "384    Compilers don't read comments (or design documents) and neither do many programmers (consistently)."
msgstr""

# CppCoreGuidelines.md:385
msgid "385    What is expressed in code has defined semantics and can (in principle) be checked by compilers and other tools."
msgstr""

       
# CppCoreGuidelines.md:386
msgid "386    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:387
msgid "387        class Date {"
msgstr""

# CppCoreGuidelines.md:388
msgid "388            // ..."
msgstr""

# CppCoreGuidelines.md:389
msgid "389        public:"
msgstr""

# CppCoreGuidelines.md:390
msgid "390            Month month() const;  // do"
msgstr""

# CppCoreGuidelines.md:391
msgid "391            int month();          // don't"
msgstr""

# CppCoreGuidelines.md:392
msgid "392            // ..."
msgstr""

# CppCoreGuidelines.md:393
msgid "393        };"
msgstr""

       
# CppCoreGuidelines.md:394
msgid "394    The first declaration of `month` is explicit about returning a `Month` and about not modifying the state of the `Date` object."
msgstr""

# CppCoreGuidelines.md:395
msgid "395    The second version leaves the reader guessing and opens more possibilities for uncaught bugs."
msgstr""

       
# CppCoreGuidelines.md:396
msgid "396    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:397
msgid "397    This loop is a restricted form of `std::find`:"
msgstr""

       
# CppCoreGuidelines.md:398
msgid "398        void f(vector<string>& v)"
msgstr""

# CppCoreGuidelines.md:399
msgid "399        {"
msgstr""

# CppCoreGuidelines.md:400
msgid "400            string val;"
msgstr""

# CppCoreGuidelines.md:401
msgid "401            cin >> val;"
msgstr""

# CppCoreGuidelines.md:402
msgid "402            // ..."
msgstr""

# CppCoreGuidelines.md:403
msgid "403            int index = -1;                    // bad, plus should use gsl::index"
msgstr""

# CppCoreGuidelines.md:404
msgid "404            for (int i = 0; i < v.size(); ++i) {"
msgstr""

# CppCoreGuidelines.md:405
msgid "405                if (v[i] == val) {"
msgstr""

# CppCoreGuidelines.md:406
msgid "406                    index = i;"
msgstr""

# CppCoreGuidelines.md:407
msgid "407                    break;"
msgstr""

# CppCoreGuidelines.md:408
msgid "408                }"
msgstr""

# CppCoreGuidelines.md:409
msgid "409            }"
msgstr""

# CppCoreGuidelines.md:410
msgid "410            // ..."
msgstr""

# CppCoreGuidelines.md:411
msgid "411        }"
msgstr""

       
# CppCoreGuidelines.md:412
msgid "412    ##### Example; good"
msgstr""

       
# CppCoreGuidelines.md:413
msgid "413    A much clearer expression of intent would be:"
msgstr""

       
# CppCoreGuidelines.md:414
msgid "414        void f(vector<string>& v)"
msgstr""

# CppCoreGuidelines.md:415
msgid "415        {"
msgstr""

# CppCoreGuidelines.md:416
msgid "416            string val;"
msgstr""

# CppCoreGuidelines.md:417
msgid "417            cin >> val;"
msgstr""

# CppCoreGuidelines.md:418
msgid "418            // ..."
msgstr""

# CppCoreGuidelines.md:419
msgid "419            auto p = find(begin(v), end(v), val);  // better"
msgstr""

# CppCoreGuidelines.md:420
msgid "420            // ..."
msgstr""

# CppCoreGuidelines.md:421
msgid "421        }"
msgstr""

       
# CppCoreGuidelines.md:422
msgid "422    A well-designed library expresses intent (what is to be done, rather than just how something is being done) far better than direct use of language features."
msgstr""

       
# CppCoreGuidelines.md:423
msgid "423    A C++ programmer should know the basics of the standard library, and use it where appropriate."
msgstr""

# CppCoreGuidelines.md:424
msgid "424    Any programmer should know the basics of the foundation libraries of the project being worked on, and use them appropriately."
msgstr""

# CppCoreGuidelines.md:425
msgid "425    Any programmer using these guidelines should know the [guidelines support library](#S-gsl), and use it appropriately."
msgstr""

       
# CppCoreGuidelines.md:426
msgid "426    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:427
msgid "427        change_speed(double s);   // bad: what does s signify?"
msgstr""

# CppCoreGuidelines.md:428
msgid "428        // ..."
msgstr""

# CppCoreGuidelines.md:429
msgid "429        change_speed(2.3);"
msgstr""

       
# CppCoreGuidelines.md:430
msgid "430    A better approach is to be explicit about the meaning of the double (new speed or delta on old speed?) and the unit used:"
msgstr""

       
# CppCoreGuidelines.md:431
msgid "431        change_speed(Speed s);    // better: the meaning of s is specified"
msgstr""

# CppCoreGuidelines.md:432
msgid "432        // ..."
msgstr""

# CppCoreGuidelines.md:433
msgid "433        change_speed(2.3);        // error: no unit"
msgstr""

# CppCoreGuidelines.md:434
msgid "434        change_speed(23m / 10s);  // meters per second"
msgstr""

       
# CppCoreGuidelines.md:435
msgid "435    We could have accepted a plain (unit-less) `double` as a delta, but that would have been error-prone."
msgstr""

# CppCoreGuidelines.md:436
msgid "436    If we wanted both absolute speed and deltas, we would have defined a `Delta` type."
msgstr""

       
# CppCoreGuidelines.md:437
msgid "437    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:438
msgid "438    Very hard in general."
msgstr""

       
# CppCoreGuidelines.md:439
msgid "439    * use `const` consistently (check if member functions modify their object; check if functions modify arguments passed by pointer or reference)"
msgstr""

# CppCoreGuidelines.md:440
msgid "440    * flag uses of casts (casts neuter the type system)"
msgstr""

# CppCoreGuidelines.md:441
msgid "441    * detect code that mimics the standard library (hard)"
msgstr""

       
# CppCoreGuidelines.md:442
msgid "442    ### <a name=\"Rp-Cplusplus\"></a>P.2: Write in ISO Standard C++"
msgstr""

       
# CppCoreGuidelines.md:443
msgid "443    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:444
msgid "444    This is a set of guidelines for writing ISO Standard C++."
msgstr""

       
# CppCoreGuidelines.md:445
msgid "445    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:446
msgid "446    There are environments where extensions are necessary, e.g., to access system resources."
msgstr""

# CppCoreGuidelines.md:447
msgid "447    In such cases, localize the use of necessary extensions and control their use with non-core Coding Guidelines.  If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions."
msgstr""

       
# CppCoreGuidelines.md:448
msgid "448    Extensions often do not have rigorously defined semantics.  Even extensions that"
msgstr""

# CppCoreGuidelines.md:449
msgid "449    are common and implemented by multiple compilers may have slightly different"
msgstr""

# CppCoreGuidelines.md:450
msgid "450    behaviors and edge case behavior as a direct result of *not* having a rigorous"
msgstr""

# CppCoreGuidelines.md:451
msgid "451    standard definition.  With sufficient use of any such extension, expected"
msgstr""

# CppCoreGuidelines.md:452
msgid "452    portability will be impacted."
msgstr""

       
# CppCoreGuidelines.md:453
msgid "453    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:454
msgid "454    Using valid ISO C++ does not guarantee portability (let alone correctness)."
msgstr""

# CppCoreGuidelines.md:455
msgid "455    Avoid dependence on undefined behavior (e.g., [undefined order of evaluation](#Res-order))"
msgstr""

# CppCoreGuidelines.md:456
msgid "456    and be aware of constructs with implementation defined meaning (e.g., `sizeof(int)`)."
msgstr""

       
# CppCoreGuidelines.md:457
msgid "457    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:458
msgid "458    There are environments where restrictions on use of standard C++ language or library features are necessary, e.g., to avoid dynamic memory allocation as required by aircraft control software standards."
msgstr""

# CppCoreGuidelines.md:459
msgid "459    In such cases, control their (dis)use with an extension of these Coding Guidelines customized to the specific environment."
msgstr""

       
# CppCoreGuidelines.md:460
msgid "460    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:461
msgid "461    Use an up-to-date C++ compiler (currently C++17, C++14, or C++11) with a set of options that do not accept extensions."
msgstr""

       
# CppCoreGuidelines.md:462
msgid "462    ### <a name=\"Rp-what\"></a>P.3: Express intent"
msgstr""

       
# CppCoreGuidelines.md:463
msgid "463    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:464
msgid "464    Unless the intent of some code is stated (e.g., in names or comments), it is impossible to tell whether the code does what it is supposed to do."
msgstr""

       
# CppCoreGuidelines.md:465
msgid "465    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:466
msgid "466        gsl::index i = 0;"
msgstr""

# CppCoreGuidelines.md:467
msgid "467        while (i < v.size()) {"
msgstr""

# CppCoreGuidelines.md:468
msgid "468            // ... do something with v[i] ..."
msgstr""

# CppCoreGuidelines.md:469
msgid "469        }"
msgstr""

       
# CppCoreGuidelines.md:470
msgid "470    The intent of \"just\" looping over the elements of `v` is not expressed here. The implementation detail of an index is exposed (so that it might be misused), and `i` outlives the scope of the loop, which may or may not be intended. The reader cannot know from just this section of code."
msgstr""

       
# CppCoreGuidelines.md:471
msgid "471    Better:"
msgstr""

       
# CppCoreGuidelines.md:472
msgid "472        for (const auto& x : v) { /* do something with the value of x */ }"
msgstr""

       
# CppCoreGuidelines.md:473
msgid "473    Now, there is no explicit mention of the iteration mechanism, and the loop operates on a reference to `const` elements so that accidental modification cannot happen. If modification is desired, say so:"
msgstr""

       
# CppCoreGuidelines.md:474
msgid "474        for (auto& x : v) { /* modify x */ }"
msgstr""

       
# CppCoreGuidelines.md:475
msgid "475    For more details about for-statements, see [ES.71](#Res-for-range)."
msgstr""

# CppCoreGuidelines.md:476
msgid "476    Sometimes better still, use a named algorithm:"
msgstr""

       
# CppCoreGuidelines.md:477
msgid "477        for_each(v, [](int x) { /* do something with the value of x */ });"
msgstr""

# CppCoreGuidelines.md:478
msgid "478        for_each(par, v, [](int x) { /* do something with the value of x */ });"
msgstr""

       
# CppCoreGuidelines.md:479
msgid "479    The last variant makes it clear that we are not interested in the order in which the elements of `v` are handled."
msgstr""

       
# CppCoreGuidelines.md:480
msgid "480    A programmer should be familiar with"
msgstr""

       
# CppCoreGuidelines.md:481
msgid "481    * [The guidelines support library](#S-gsl)"
msgstr""

# CppCoreGuidelines.md:482
msgid "482    * [The ISO C++ Standard Library](#S-stdlib)"
msgstr""

# CppCoreGuidelines.md:483
msgid "483    * Whatever foundation libraries are used for the current project(s)"
msgstr""

       
# CppCoreGuidelines.md:484
msgid "484    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:485
msgid "485    Alternative formulation: Say what should be done, rather than just how it should be done."
msgstr""

       
# CppCoreGuidelines.md:486
msgid "486    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:487
msgid "487    Some language constructs express intent better than others."
msgstr""

       
# CppCoreGuidelines.md:488
msgid "488    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:489
msgid "489    If two `int`s are meant to be the coordinates of a 2D point, say so:"
msgstr""

       
# CppCoreGuidelines.md:490
msgid "490        draw_line(int, int, int, int);  // obscure"
msgstr""

# CppCoreGuidelines.md:491
msgid "491        draw_line(Point, Point);        // clearer"
msgstr""

       
# CppCoreGuidelines.md:492
msgid "492    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:493
msgid "493    Look for common patterns for which there are better alternatives"
msgstr""

       
# CppCoreGuidelines.md:494
msgid "494    * simple `for` loops vs. range-`for` loops"
msgstr""

# CppCoreGuidelines.md:495
msgid "495    * `f(T*, int)` interfaces vs. `f(span<T>)` interfaces"
msgstr""

# CppCoreGuidelines.md:496
msgid "496    * loop variables in too large a scope"
msgstr""

# CppCoreGuidelines.md:497
msgid "497    * naked `new` and `delete`"
msgstr""

# CppCoreGuidelines.md:498
msgid "498    * functions with many parameters of built-in types"
msgstr""

       
# CppCoreGuidelines.md:499
msgid "499    There is a huge scope for cleverness and semi-automated program transformation."
msgstr""

       
# CppCoreGuidelines.md:500
msgid "500    ### <a name=\"Rp-typesafe\"></a>P.4: Ideally, a program should be statically type safe"
msgstr""

       
# CppCoreGuidelines.md:501
msgid "501    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:502
msgid "502    Ideally, a program would be completely statically (compile-time) type safe."
msgstr""

# CppCoreGuidelines.md:503
msgid "503    Unfortunately, that is not possible. Problem areas:"
msgstr""

       
# CppCoreGuidelines.md:504
msgid "504    * unions"
msgstr""

# CppCoreGuidelines.md:505
msgid "505    * casts"
msgstr""

# CppCoreGuidelines.md:506
msgid "506    * array decay"
msgstr""

# CppCoreGuidelines.md:507
msgid "507    * range errors"
msgstr""

# CppCoreGuidelines.md:508
msgid "508    * narrowing conversions"
msgstr""

       
# CppCoreGuidelines.md:509
msgid "509    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:510
msgid "510    These areas are sources of serious problems (e.g., crashes and security violations)."
msgstr""

# CppCoreGuidelines.md:511
msgid "511    We try to provide alternative techniques."
msgstr""

       
# CppCoreGuidelines.md:512
msgid "512    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:513
msgid "513    We can ban, restrain, or detect the individual problem categories separately, as required and feasible for individual programs."
msgstr""

# CppCoreGuidelines.md:514
msgid "514    Always suggest an alternative."
msgstr""

# CppCoreGuidelines.md:515
msgid "515    For example:"
msgstr""

       
# CppCoreGuidelines.md:516
msgid "516    * unions -- use `variant` (in C++17)"
msgstr""

# CppCoreGuidelines.md:517
msgid "517    * casts -- minimize their use; templates can help"
msgstr""

# CppCoreGuidelines.md:518
msgid "518    * array decay -- use `span` (from the GSL)"
msgstr""

# CppCoreGuidelines.md:519
msgid "519    * range errors -- use `span`"
msgstr""

# CppCoreGuidelines.md:520
msgid "520    * narrowing conversions -- minimize their use and use `narrow` or `narrow_cast` (from the GSL) where they are necessary"
msgstr""

       
# CppCoreGuidelines.md:521
msgid "521    ### <a name=\"Rp-compile-time\"></a>P.5: Prefer compile-time checking to run-time checking"
msgstr""

       
# CppCoreGuidelines.md:522
msgid "522    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:523
msgid "523    Code clarity and performance."
msgstr""

# CppCoreGuidelines.md:524
msgid "524    You don't need to write error handlers for errors caught at compile time."
msgstr""

       
# CppCoreGuidelines.md:525
msgid "525    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:526
msgid "526        // Int is an alias used for integers"
msgstr""

# CppCoreGuidelines.md:527
msgid "527        int bits = 0;         // don't: avoidable code"
msgstr""

# CppCoreGuidelines.md:528
msgid "528        for (Int i = 1; i; i <<= 1)"
msgstr""

# CppCoreGuidelines.md:529
msgid "529            ++bits;"
msgstr""

# CppCoreGuidelines.md:530
msgid "530        if (bits < 32)"
msgstr""

# CppCoreGuidelines.md:531
msgid "531            cerr << \"Int too small\\n\";"
msgstr""

       
# CppCoreGuidelines.md:532
msgid "532    This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple `static_assert`:"
msgstr""

       
# CppCoreGuidelines.md:533
msgid "533        // Int is an alias used for integers"
msgstr""

# CppCoreGuidelines.md:534
msgid "534        static_assert(sizeof(Int) >= 4);    // do: compile-time check"
msgstr""

       
# CppCoreGuidelines.md:535
msgid "535    Or better still just use the type system and replace `Int` with `int32_t`."
msgstr""

       
# CppCoreGuidelines.md:536
msgid "536    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:537
msgid "537        void read(int* p, int n);   // read max n integers into *p"
msgstr""

       
# CppCoreGuidelines.md:538
msgid "538        int a[100];"
msgstr""

# CppCoreGuidelines.md:539
msgid "539        read(a, 1000);    // bad, off the end"
msgstr""

       
# CppCoreGuidelines.md:540
msgid "540    better"
msgstr""

       
# CppCoreGuidelines.md:541
msgid "541        void read(span<int> r); // read into the range of integers r"
msgstr""

       
# CppCoreGuidelines.md:542
msgid "542        int a[100];"
msgstr""

# CppCoreGuidelines.md:543
msgid "543        read(a);        // better: let the compiler figure out the number of elements"
msgstr""

       
# CppCoreGuidelines.md:544
msgid "544    **Alternative formulation**: Don't postpone to run time what can be done well at compile time."
msgstr""

       
# CppCoreGuidelines.md:545
msgid "545    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:546
msgid "546    * Look for pointer arguments."
msgstr""

# CppCoreGuidelines.md:547
msgid "547    * Look for run-time checks for range violations."
msgstr""

       
# CppCoreGuidelines.md:548
msgid "548    ### <a name=\"Rp-run-time\"></a>P.6: What cannot be checked at compile time should be checkable at run time"
msgstr""

       
# CppCoreGuidelines.md:549
msgid "549    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:550
msgid "550    Leaving hard-to-detect errors in a program is asking for crashes and bad results."
msgstr""

       
# CppCoreGuidelines.md:551
msgid "551    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:552
msgid "552    Ideally, we catch all errors (that are not errors in the programmer's logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time)."
msgstr""

       
# CppCoreGuidelines.md:553
msgid "553    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:554
msgid "554        // separately compiled, possibly dynamically loaded"
msgstr""

# CppCoreGuidelines.md:555
msgid "555        extern void f(int* p);"
msgstr""

       
# CppCoreGuidelines.md:556
msgid "556        void g(int n)"
msgstr""

# CppCoreGuidelines.md:557
msgid "557        {"
msgstr""

# CppCoreGuidelines.md:558
msgid "558            // bad: the number of elements is not passed to f()"
msgstr""

# CppCoreGuidelines.md:559
msgid "559            f(new int[n]);"
msgstr""

# CppCoreGuidelines.md:560
msgid "560        }"
msgstr""

       
# CppCoreGuidelines.md:561
msgid "561    Here, a crucial bit of information (the number of elements) has been so thoroughly \"obscured\" that static analysis is probably rendered infeasible and dynamic checking can be very difficult when `f()` is part of an ABI so that we cannot \"instrument\" that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard."
msgstr""

       
# CppCoreGuidelines.md:562
msgid "562    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:563
msgid "563    We can of course pass the number of elements along with the pointer:"
msgstr""

       
# CppCoreGuidelines.md:564
msgid "564        // separately compiled, possibly dynamically loaded"
msgstr""

# CppCoreGuidelines.md:565
msgid "565        extern void f2(int* p, int n);"
msgstr""

       
# CppCoreGuidelines.md:566
msgid "566        void g2(int n)"
msgstr""

# CppCoreGuidelines.md:567
msgid "567        {"
msgstr""

# CppCoreGuidelines.md:568
msgid "568            f2(new int[n], m);  // bad: a wrong number of elements can be passed to f()"
msgstr""

# CppCoreGuidelines.md:569
msgid "569        }"
msgstr""

       
# CppCoreGuidelines.md:570
msgid "570    Passing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of `f2()` is conventional, rather than explicit."
msgstr""

       
# CppCoreGuidelines.md:571
msgid "571    Also, it is implicit that `f2()` is supposed to `delete` its argument (or did the caller make a second mistake?)."
msgstr""

       
# CppCoreGuidelines.md:572
msgid "572    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:573
msgid "573    The standard library resource management pointers fail to pass the size when they point to an object:"
msgstr""

       
# CppCoreGuidelines.md:574
msgid "574        // separately compiled, possibly dynamically loaded"
msgstr""

# CppCoreGuidelines.md:575
msgid "575        // NB: this assumes the calling code is ABI-compatible, using a"
msgstr""

# CppCoreGuidelines.md:576
msgid "576        // compatible C++ compiler and the same stdlib implementation"
msgstr""

# CppCoreGuidelines.md:577
msgid "577        extern void f3(unique_ptr<int[]>, int n);"
msgstr""

       
# CppCoreGuidelines.md:578
msgid "578        void g3(int n)"
msgstr""

# CppCoreGuidelines.md:579
msgid "579        {"
msgstr""

# CppCoreGuidelines.md:580
msgid "580            f3(make_unique<int[]>(n), m);    // bad: pass ownership and size separately"
msgstr""

# CppCoreGuidelines.md:581
msgid "581        }"
msgstr""

       
# CppCoreGuidelines.md:582
msgid "582    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:583
msgid "583    We need to pass the pointer and the number of elements as an integral object:"
msgstr""

       
# CppCoreGuidelines.md:584
msgid "584        extern void f4(vector<int>&);   // separately compiled, possibly dynamically loaded"
msgstr""

# CppCoreGuidelines.md:585
msgid "585        extern void f4(span<int>);      // separately compiled, possibly dynamically loaded"
msgstr""

# CppCoreGuidelines.md:586
msgid "586                                        // NB: this assumes the calling code is ABI-compatible, using a"
msgstr""

# CppCoreGuidelines.md:587
msgid "587                                        // compatible C++ compiler and the same stdlib implementation"
msgstr""

       
# CppCoreGuidelines.md:588
msgid "588        void g3(int n)"
msgstr""

# CppCoreGuidelines.md:589
msgid "589        {"
msgstr""

# CppCoreGuidelines.md:590
msgid "590            vector<int> v(n);"
msgstr""

# CppCoreGuidelines.md:591
msgid "591            f4(v);                     // pass a reference, retain ownership"
msgstr""

# CppCoreGuidelines.md:592
msgid "592            f4(span<int>{v});          // pass a view, retain ownership"
msgstr""

# CppCoreGuidelines.md:593
msgid "593        }"
msgstr""

       
# CppCoreGuidelines.md:594
msgid "594    This design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable."
msgstr""

       
# CppCoreGuidelines.md:595
msgid "595    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:596
msgid "596    How do we transfer both ownership and all information needed for validating use?"
msgstr""

       
# CppCoreGuidelines.md:597
msgid "597        vector<int> f5(int n)    // OK: move"
msgstr""

# CppCoreGuidelines.md:598
msgid "598        {"
msgstr""

# CppCoreGuidelines.md:599
msgid "599            vector<int> v(n);"
msgstr""

# CppCoreGuidelines.md:600
msgid "600            // ... initialize v ..."
msgstr""

# CppCoreGuidelines.md:601
msgid "601            return v;"
msgstr""

# CppCoreGuidelines.md:602
msgid "602        }"
msgstr""

       
# CppCoreGuidelines.md:603
msgid "603        unique_ptr<int[]> f6(int n)    // bad: loses n"
msgstr""

# CppCoreGuidelines.md:604
msgid "604        {"
msgstr""

# CppCoreGuidelines.md:605
msgid "605            auto p = make_unique<int[]>(n);"
msgstr""

# CppCoreGuidelines.md:606
msgid "606            // ... initialize *p ..."
msgstr""

# CppCoreGuidelines.md:607
msgid "607            return p;"
msgstr""

# CppCoreGuidelines.md:608
msgid "608        }"
msgstr""

       
# CppCoreGuidelines.md:609
msgid "609        owner<int*> f7(int n)    // bad: loses n and we might forget to delete"
msgstr""

# CppCoreGuidelines.md:610
msgid "610        {"
msgstr""

# CppCoreGuidelines.md:611
msgid "611            owner<int*> p = new int[n];"
msgstr""

# CppCoreGuidelines.md:612
msgid "612            // ... initialize *p ..."
msgstr""

# CppCoreGuidelines.md:613
msgid "613            return p;"
msgstr""

# CppCoreGuidelines.md:614
msgid "614        }"
msgstr""

       
# CppCoreGuidelines.md:615
msgid "615    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:616
msgid "616    * ???"
msgstr""

# CppCoreGuidelines.md:617
msgid "617    * show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need?"
msgstr""

# CppCoreGuidelines.md:618
msgid "618      Or strings as \"free-style\" options"
msgstr""

       
# CppCoreGuidelines.md:619
msgid "619    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:620
msgid "620    * Flag (pointer, count)-style interfaces (this will flag a lot of examples that can't be fixed for compatibility reasons)"
msgstr""

# CppCoreGuidelines.md:621
msgid "621    * ???"
msgstr""

       
# CppCoreGuidelines.md:622
msgid "622    ### <a name=\"Rp-early\"></a>P.7: Catch run-time errors early"
msgstr""

       
# CppCoreGuidelines.md:623
msgid "623    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:624
msgid "624    Avoid \"mysterious\" crashes."
msgstr""

# CppCoreGuidelines.md:625
msgid "625    Avoid errors leading to (possibly unrecognized) wrong results."
msgstr""

       
# CppCoreGuidelines.md:626
msgid "626    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:627
msgid "627        void increment1(int* p, int n)    // bad: error-prone"
msgstr""

# CppCoreGuidelines.md:628
msgid "628        {"
msgstr""

# CppCoreGuidelines.md:629
msgid "629            for (int i = 0; i < n; ++i) ++p[i];"
msgstr""

# CppCoreGuidelines.md:630
msgid "630        }"
msgstr""

       
# CppCoreGuidelines.md:631
msgid "631        void use1(int m)"
msgstr""

# CppCoreGuidelines.md:632
msgid "632        {"
msgstr""

# CppCoreGuidelines.md:633
msgid "633            const int n = 10;"
msgstr""

# CppCoreGuidelines.md:634
msgid "634            int a[n] = {};"
msgstr""

# CppCoreGuidelines.md:635
msgid "635            // ..."
msgstr""

# CppCoreGuidelines.md:636
msgid "636            increment1(a, m);   // maybe typo, maybe m <= n is supposed"
msgstr""

# CppCoreGuidelines.md:637
msgid "637                                // but assume that m == 20"
msgstr""

# CppCoreGuidelines.md:638
msgid "638            // ..."
msgstr""

# CppCoreGuidelines.md:639
msgid "639        }"
msgstr""

       
# CppCoreGuidelines.md:640
msgid "640    Here we made a small error in `use1` that will lead to corrupted data or a crash."
msgstr""

# CppCoreGuidelines.md:641
msgid "641    The (pointer, count)-style interface leaves `increment1()` with no realistic way of defending itself against out-of-range errors."
msgstr""

# CppCoreGuidelines.md:642
msgid "642    If we could check subscripts for out of range access, then the error would not be discovered until `p[10]` was accessed."
msgstr""

# CppCoreGuidelines.md:643
msgid "643    We could check earlier and improve the code:"
msgstr""

       
# CppCoreGuidelines.md:644
msgid "644        void increment2(span<int> p)"
msgstr""

# CppCoreGuidelines.md:645
msgid "645        {"
msgstr""

# CppCoreGuidelines.md:646
msgid "646            for (int& x : p) ++x;"
msgstr""

# CppCoreGuidelines.md:647
msgid "647        }"
msgstr""

       
# CppCoreGuidelines.md:648
msgid "648        void use2(int m)"
msgstr""

# CppCoreGuidelines.md:649
msgid "649        {"
msgstr""

# CppCoreGuidelines.md:650
msgid "650            const int n = 10;"
msgstr""

# CppCoreGuidelines.md:651
msgid "651            int a[n] = {};"
msgstr""

# CppCoreGuidelines.md:652
msgid "652            // ..."
msgstr""

# CppCoreGuidelines.md:653
msgid "653            increment2({a, m});    // maybe typo, maybe m <= n is supposed"
msgstr""

# CppCoreGuidelines.md:654
msgid "654            // ..."
msgstr""

# CppCoreGuidelines.md:655
msgid "655        }"
msgstr""

       
# CppCoreGuidelines.md:656
msgid "656    Now, `m <= n` can be checked at the point of call (early) rather than later."
msgstr""

# CppCoreGuidelines.md:657
msgid "657    If all we had was a typo so that we meant to use `n` as the bound, the code could be further simplified (eliminating the possibility of an error):"
msgstr""

       
# CppCoreGuidelines.md:658
msgid "658        void use3(int m)"
msgstr""

# CppCoreGuidelines.md:659
msgid "659        {"
msgstr""

# CppCoreGuidelines.md:660
msgid "660            const int n = 10;"
msgstr""

# CppCoreGuidelines.md:661
msgid "661            int a[n] = {};"
msgstr""

# CppCoreGuidelines.md:662
msgid "662            // ..."
msgstr""

# CppCoreGuidelines.md:663
msgid "663            increment2(a);   // the number of elements of a need not be repeated"
msgstr""

# CppCoreGuidelines.md:664
msgid "664            // ..."
msgstr""

# CppCoreGuidelines.md:665
msgid "665        }"
msgstr""

       
# CppCoreGuidelines.md:666
msgid "666    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:667
msgid "667    Don't repeatedly check the same value. Don't pass structured data as strings:"
msgstr""

       
# CppCoreGuidelines.md:668
msgid "668        Date read_date(istream& is);    // read date from istream"
msgstr""

       
# CppCoreGuidelines.md:669
msgid "669        Date extract_date(const string& s);    // extract date from string"
msgstr""

       
# CppCoreGuidelines.md:670
msgid "670        void user1(const string& date)    // manipulate date"
msgstr""

# CppCoreGuidelines.md:671
msgid "671        {"
msgstr""

# CppCoreGuidelines.md:672
msgid "672            auto d = extract_date(date);"
msgstr""

# CppCoreGuidelines.md:673
msgid "673            // ..."
msgstr""

# CppCoreGuidelines.md:674
msgid "674        }"
msgstr""

       
# CppCoreGuidelines.md:675
msgid "675        void user2()"
msgstr""

# CppCoreGuidelines.md:676
msgid "676        {"
msgstr""

# CppCoreGuidelines.md:677
msgid "677            Date d = read_date(cin);"
msgstr""

# CppCoreGuidelines.md:678
msgid "678            // ..."
msgstr""

# CppCoreGuidelines.md:679
msgid "679            user1(d.to_string());"
msgstr""

# CppCoreGuidelines.md:680
msgid "680            // ..."
msgstr""

# CppCoreGuidelines.md:681
msgid "681        }"
msgstr""

       
# CppCoreGuidelines.md:682
msgid "682    The date is validated twice (by the `Date` constructor) and passed as a character string (unstructured data)."
msgstr""

       
# CppCoreGuidelines.md:683
msgid "683    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:684
msgid "684    Excess checking can be costly."
msgstr""

# CppCoreGuidelines.md:685
msgid "685    There are cases where checking early is dumb because you may not ever need the value, or may only need part of the value that is more easily checked than the whole.  Similarly, don't add validity checks that change the asymptotic behavior of your interface (e.g., don't add a `O(n)` check to an interface with an average complexity of `O(1)`)."
msgstr""

       
# CppCoreGuidelines.md:686
msgid "686        class Jet {    // Physics says: e * e < x * x + y * y + z * z"
msgstr""

# CppCoreGuidelines.md:687
msgid "687            float x;"
msgstr""

# CppCoreGuidelines.md:688
msgid "688            float y;"
msgstr""

# CppCoreGuidelines.md:689
msgid "689            float z;"
msgstr""

# CppCoreGuidelines.md:690
msgid "690            float e;"
msgstr""

# CppCoreGuidelines.md:691
msgid "691        public:"
msgstr""

# CppCoreGuidelines.md:692
msgid "692            Jet(float x, float y, float z, float e)"
msgstr""

# CppCoreGuidelines.md:693
msgid "693                :x(x), y(y), z(z), e(e)"
msgstr""

# CppCoreGuidelines.md:694
msgid "694            {"
msgstr""

# CppCoreGuidelines.md:695
msgid "695                // Should I check here that the values are physically meaningful?"
msgstr""

# CppCoreGuidelines.md:696
msgid "696            }"
msgstr""

       
# CppCoreGuidelines.md:697
msgid "697            float m() const"
msgstr""

# CppCoreGuidelines.md:698
msgid "698            {"
msgstr""

# CppCoreGuidelines.md:699
msgid "699                // Should I handle the degenerate case here?"
msgstr""

# CppCoreGuidelines.md:700
msgid "700                return sqrt(x * x + y * y + z * z - e * e);"
msgstr""

# CppCoreGuidelines.md:701
msgid "701            }"
msgstr""

       
# CppCoreGuidelines.md:702
msgid "702            ???"
msgstr""

# CppCoreGuidelines.md:703
msgid "703        };"
msgstr""

       
# CppCoreGuidelines.md:704
msgid "704    The physical law for a jet (`e * e < x * x + y * y + z * z`) is not an invariant because of the possibility for measurement errors."
msgstr""

       
# CppCoreGuidelines.md:705
msgid "705    ???"
msgstr""

       
# CppCoreGuidelines.md:706
msgid "706    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:707
msgid "707    * Look at pointers and arrays: Do range-checking early and not repeatedly"
msgstr""

# CppCoreGuidelines.md:708
msgid "708    * Look at conversions: Eliminate or mark narrowing conversions"
msgstr""

# CppCoreGuidelines.md:709
msgid "709    * Look for unchecked values coming from input"
msgstr""

# CppCoreGuidelines.md:710
msgid "710    * Look for structured data (objects of classes with invariants) being converted into strings"
msgstr""

# CppCoreGuidelines.md:711
msgid "711    * ???"
msgstr""

       
# CppCoreGuidelines.md:712
msgid "712    ### <a name=\"Rp-leak\"></a>P.8: Don't leak any resources"
msgstr""

       
# CppCoreGuidelines.md:713
msgid "713    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:714
msgid "714    Even a slow growth in resources will, over time, exhaust the availability of those resources."
msgstr""

# CppCoreGuidelines.md:715
msgid "715    This is particularly important for long-running programs, but is an essential piece of responsible programming behavior."
msgstr""

       
# CppCoreGuidelines.md:716
msgid "716    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:717
msgid "717        void f(char* name)"
msgstr""

# CppCoreGuidelines.md:718
msgid "718        {"
msgstr""

# CppCoreGuidelines.md:719
msgid "719            FILE* input = fopen(name, \"r\");"
msgstr""

# CppCoreGuidelines.md:720
msgid "720            // ..."
msgstr""

# CppCoreGuidelines.md:721
msgid "721            if (something) return;   // bad: if something == true, a file handle is leaked"
msgstr""

# CppCoreGuidelines.md:722
msgid "722            // ..."
msgstr""

# CppCoreGuidelines.md:723
msgid "723            fclose(input);"
msgstr""

# CppCoreGuidelines.md:724
msgid "724        }"
msgstr""

       
# CppCoreGuidelines.md:725
msgid "725    Prefer [RAII](#Rr-raii):"
msgstr""

       
# CppCoreGuidelines.md:726
msgid "726        void f(char* name)"
msgstr""

# CppCoreGuidelines.md:727
msgid "727        {"
msgstr""

# CppCoreGuidelines.md:728
msgid "728            ifstream input {name};"
msgstr""

# CppCoreGuidelines.md:729
msgid "729            // ..."
msgstr""

# CppCoreGuidelines.md:730
msgid "730            if (something) return;   // OK: no leak"
msgstr""

# CppCoreGuidelines.md:731
msgid "731            // ..."
msgstr""

# CppCoreGuidelines.md:732
msgid "732        }"
msgstr""

       
# CppCoreGuidelines.md:733
msgid "733    **See also**: [The resource management section](#S-resource)"
msgstr""

       
# CppCoreGuidelines.md:734
msgid "734    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:735
msgid "735    A leak is colloquially \"anything that isn't cleaned up.\""
msgstr""

# CppCoreGuidelines.md:736
msgid "736    The more important classification is \"anything that can no longer be cleaned up.\""
msgstr""

# CppCoreGuidelines.md:737
msgid "737    For example, allocating an object on the heap and then losing the last pointer that points to that allocation."
msgstr""

# CppCoreGuidelines.md:738
msgid "738    This rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown."
msgstr""

# CppCoreGuidelines.md:739
msgid "739    For example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code."
msgstr""

# CppCoreGuidelines.md:740
msgid "740    However, relying on abstractions that implicitly clean up can be as simple, and often safer."
msgstr""

       
# CppCoreGuidelines.md:741
msgid "741    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:742
msgid "742    Enforcing [the lifetime safety profile](#SS-lifetime) eliminates leaks."
msgstr""

# CppCoreGuidelines.md:743
msgid "743    When combined with resource safety provided by [RAII](#Rr-raii), it eliminates the need for \"garbage collection\" (by generating no garbage)."
msgstr""

# CppCoreGuidelines.md:744
msgid "744    Combine this with enforcement of [the type and bounds profiles](#SS-force) and you get complete type- and resource-safety, guaranteed by tools."
msgstr""

       
# CppCoreGuidelines.md:745
msgid "745    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:746
msgid "746    * Look at pointers: Classify them into non-owners (the default) and owners."
msgstr""

# CppCoreGuidelines.md:747
msgid "747      Where feasible, replace owners with standard-library resource handles (as in the example above)."
msgstr""

# CppCoreGuidelines.md:748
msgid "748      Alternatively, mark an owner as such using `owner` from [the GSL](#S-gsl)."
msgstr""

# CppCoreGuidelines.md:749
msgid "749    * Look for naked `new` and `delete`"
msgstr""

# CppCoreGuidelines.md:750
msgid "750    * Look for known resource allocating functions returning raw pointers (such as `fopen`, `malloc`, and `strdup`)"
msgstr""

       
# CppCoreGuidelines.md:751
msgid "751    ### <a name=\"Rp-waste\"></a>P.9: Don't waste time or space"
msgstr""

       
# CppCoreGuidelines.md:752
msgid "752    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:753
msgid "753    This is C++."
msgstr""

       
# CppCoreGuidelines.md:754
msgid "754    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:755
msgid "755    Time and space that you spend well to achieve a goal (e.g., speed of development, resource safety, or simplification of testing) is not wasted."
msgstr""

# CppCoreGuidelines.md:756
msgid "756    \"Another benefit of striving for efficiency is that the process forces you to understand the problem in more depth.\" - Alex Stepanov"
msgstr""

       
# CppCoreGuidelines.md:757
msgid "757    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:758
msgid "758        struct X {"
msgstr""

# CppCoreGuidelines.md:759
msgid "759            char ch;"
msgstr""

# CppCoreGuidelines.md:760
msgid "760            int i;"
msgstr""

# CppCoreGuidelines.md:761
msgid "761            string s;"
msgstr""

# CppCoreGuidelines.md:762
msgid "762            char ch2;"
msgstr""

       
# CppCoreGuidelines.md:763
msgid "763            X& operator=(const X& a);"
msgstr""

# CppCoreGuidelines.md:764
msgid "764            X(const X&);"
msgstr""

# CppCoreGuidelines.md:765
msgid "765        };"
msgstr""

       
# CppCoreGuidelines.md:766
msgid "766        X waste(const char* p)"
msgstr""

# CppCoreGuidelines.md:767
msgid "767        {"
msgstr""

# CppCoreGuidelines.md:768
msgid "768            if (!p) throw Nullptr_error{};"
msgstr""

# CppCoreGuidelines.md:769
msgid "769            int n = strlen(p);"
msgstr""

# CppCoreGuidelines.md:770
msgid "770            auto buf = new char[n];"
msgstr""

# CppCoreGuidelines.md:771
msgid "771            if (!buf) throw Allocation_error{};"
msgstr""

# CppCoreGuidelines.md:772
msgid "772            for (int i = 0; i < n; ++i) buf[i] = p[i];"
msgstr""

# CppCoreGuidelines.md:773
msgid "773            // ... manipulate buffer ..."
msgstr""

# CppCoreGuidelines.md:774
msgid "774            X x;"
msgstr""

# CppCoreGuidelines.md:775
msgid "775            x.ch = 'a';"
msgstr""

# CppCoreGuidelines.md:776
msgid "776            x.s = string(n);    // give x.s space for *p"
msgstr""

# CppCoreGuidelines.md:777
msgid "777            for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // copy buf into x.s"
msgstr""

# CppCoreGuidelines.md:778
msgid "778            delete[] buf;"
msgstr""

# CppCoreGuidelines.md:779
msgid "779            return x;"
msgstr""

# CppCoreGuidelines.md:780
msgid "780        }"
msgstr""

       
# CppCoreGuidelines.md:781
msgid "781        void driver()"
msgstr""

# CppCoreGuidelines.md:782
msgid "782        {"
msgstr""

# CppCoreGuidelines.md:783
msgid "783            X x = waste(\"Typical argument\");"
msgstr""

# CppCoreGuidelines.md:784
msgid "784            // ..."
msgstr""

# CppCoreGuidelines.md:785
msgid "785        }"
msgstr""

       
# CppCoreGuidelines.md:786
msgid "786    Yes, this is a caricature, but we have seen every individual mistake in production code, and worse."
msgstr""

# CppCoreGuidelines.md:787
msgid "787    Note that the layout of `X` guarantees that at least 6 bytes (and most likely more) are wasted."
msgstr""

# CppCoreGuidelines.md:788
msgid "788    The spurious definition of copy operations disables move semantics so that the return operation is slow"
msgstr""

# CppCoreGuidelines.md:789
msgid "789    (please note that the Return Value Optimization, RVO, is not guaranteed here)."
msgstr""

# CppCoreGuidelines.md:790
msgid "790    The use of `new` and `delete` for `buf` is redundant; if we really needed a local string, we should use a local `string`."
msgstr""

# CppCoreGuidelines.md:791
msgid "791    There are several more performance bugs and gratuitous complication."
msgstr""

       
# CppCoreGuidelines.md:792
msgid "792    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:793
msgid "793        void lower(zstring s)"
msgstr""

# CppCoreGuidelines.md:794
msgid "794        {"
msgstr""

# CppCoreGuidelines.md:795
msgid "795            for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);"
msgstr""

# CppCoreGuidelines.md:796
msgid "796        }"
msgstr""

       
# CppCoreGuidelines.md:797
msgid "797    Yes, this is an example from production code."
msgstr""

# CppCoreGuidelines.md:798
msgid "798    We leave it to the reader to figure out what's wasted."
msgstr""

       
# CppCoreGuidelines.md:799
msgid "799    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:800
msgid "800    An individual example of waste is rarely significant, and where it is significant, it is typically easily eliminated by an expert."
msgstr""

# CppCoreGuidelines.md:801
msgid "801    However, waste spread liberally across a code base can easily be significant and experts are not always as available as we would like."
msgstr""

# CppCoreGuidelines.md:802
msgid "802    The aim of this rule (and the more specific rules that support it) is to eliminate most waste related to the use of C++ before it happens."
msgstr""

# CppCoreGuidelines.md:803
msgid "803    After that, we can look at waste related to algorithms and requirements, but that is beyond the scope of these guidelines."
msgstr""

       
# CppCoreGuidelines.md:804
msgid "804    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:805
msgid "805    Many more specific rules aim at the overall goals of simplicity and elimination of gratuitous waste."
msgstr""

       
# CppCoreGuidelines.md:806
msgid "806    ### <a name=\"Rp-mutable\"></a>P.10: Prefer immutable data to mutable data"
msgstr""

       
# CppCoreGuidelines.md:807
msgid "807    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:808
msgid "808    It is easier to reason about constants than about variables."
msgstr""

# CppCoreGuidelines.md:809
msgid "809    Something immutable cannot change unexpectedly."
msgstr""

# CppCoreGuidelines.md:810
msgid "810    Sometimes immutability enables better optimization."
msgstr""

# CppCoreGuidelines.md:811
msgid "811    You can't have a data race on a constant."
msgstr""

       
# CppCoreGuidelines.md:812
msgid "812    See [Con: Constants and immutability](#S-const)"
msgstr""

       
# CppCoreGuidelines.md:813
msgid "813    ### <a name=\"Rp-library\"></a>P.11: Encapsulate messy constructs, rather than spreading through the code"
msgstr""

       
# CppCoreGuidelines.md:814
msgid "814    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:815
msgid "815    Messy code is more likely to hide bugs and harder to write."
msgstr""

# CppCoreGuidelines.md:816
msgid "816    A good interface is easier and safer to use."
msgstr""

# CppCoreGuidelines.md:817
msgid "817    Messy, low-level code breeds more such code."
msgstr""

       
# CppCoreGuidelines.md:818
msgid "818    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:819
msgid "819        int sz = 100;"
msgstr""

# CppCoreGuidelines.md:820
msgid "820        int* p = (int*) malloc(sizeof(int) * sz);"
msgstr""

# CppCoreGuidelines.md:821
msgid "821        int count = 0;"
msgstr""

# CppCoreGuidelines.md:822
msgid "822        // ..."
msgstr""

# CppCoreGuidelines.md:823
msgid "823        for (;;) {"
msgstr""

# CppCoreGuidelines.md:824
msgid "824            // ... read an int into x, exit loop if end of file is reached ..."
msgstr""

# CppCoreGuidelines.md:825
msgid "825            // ... check that x is valid ..."
msgstr""

# CppCoreGuidelines.md:826
msgid "826            if (count == sz)"
msgstr""

# CppCoreGuidelines.md:827
msgid "827                p = (int*) realloc(p, sizeof(int) * sz * 2);"
msgstr""

# CppCoreGuidelines.md:828
msgid "828            p[count++] = x;"
msgstr""

# CppCoreGuidelines.md:829
msgid "829            // ..."
msgstr""

# CppCoreGuidelines.md:830
msgid "830        }"
msgstr""

       
# CppCoreGuidelines.md:831
msgid "831    This is low-level, verbose, and error-prone."
msgstr""

# CppCoreGuidelines.md:832
msgid "832    For example, we \"forgot\" to test for memory exhaustion."
msgstr""

# CppCoreGuidelines.md:833
msgid "833    Instead, we could use `vector`:"
msgstr""

       
# CppCoreGuidelines.md:834
msgid "834        vector<int> v;"
msgstr""

# CppCoreGuidelines.md:835
msgid "835        v.reserve(100);"
msgstr""

# CppCoreGuidelines.md:836
msgid "836        // ..."
msgstr""

# CppCoreGuidelines.md:837
msgid "837        for (int x; cin >> x; ) {"
msgstr""

# CppCoreGuidelines.md:838
msgid "838            // ... check that x is valid ..."
msgstr""

# CppCoreGuidelines.md:839
msgid "839            v.push_back(x);"
msgstr""

# CppCoreGuidelines.md:840
msgid "840        }"
msgstr""

       
# CppCoreGuidelines.md:841
msgid "841    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:842
msgid "842    The standards library and the GSL are examples of this philosophy."
msgstr""

# CppCoreGuidelines.md:843
msgid "843    For example, instead of messing with the arrays, unions, cast, tricky lifetime issues, `gsl::owner`, etc.,"
msgstr""

# CppCoreGuidelines.md:844
msgid "844    that are needed to implement key abstractions, such as `vector`, `span`, `lock_guard`, and `future`, we use the libraries"
msgstr""

# CppCoreGuidelines.md:845
msgid "845    designed and implemented by people with more time and expertise than we usually have."
msgstr""

# CppCoreGuidelines.md:846
msgid "846    Similarly, we can and should design and implement more specialized libraries, rather than leaving the users (often ourselves)"
msgstr""

# CppCoreGuidelines.md:847
msgid "847    with the challenge of repeatedly getting low-level code well."
msgstr""

# CppCoreGuidelines.md:848
msgid "848    This is a variant of the [subset of superset principle](#R0) that underlies these guidelines."
msgstr""

       
# CppCoreGuidelines.md:849
msgid "849    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:850
msgid "850    * Look for \"messy code\" such as complex pointer manipulation and casting outside the implementation of abstractions."
msgstr""

       
       
# CppCoreGuidelines.md:851
msgid "851    ### <a name=\"Rp-tools\"></a>P.12: Use supporting tools as appropriate"
msgstr""

       
# CppCoreGuidelines.md:852
msgid "852    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:853
msgid "853    There are many things that are done better \"by machine\"."
msgstr""

# CppCoreGuidelines.md:854
msgid "854    Computers don't tire or get bored by repetitive tasks."
msgstr""

# CppCoreGuidelines.md:855
msgid "855    We typically have better things to do than repeatedly do routine tasks."
msgstr""

       
# CppCoreGuidelines.md:856
msgid "856    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:857
msgid "857    Run a static analyzer to verify that your code follows the guidelines you want it to follow."
msgstr""

       
# CppCoreGuidelines.md:858
msgid "858    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:859
msgid "859    See"
msgstr""

       
# CppCoreGuidelines.md:860
msgid "860    * [Static analysis tools](???)"
msgstr""

# CppCoreGuidelines.md:861
msgid "861    * [Concurrency tools](#Rconc-tools)"
msgstr""

# CppCoreGuidelines.md:862
msgid "862    * [Testing tools](???)"
msgstr""

       
# CppCoreGuidelines.md:863
msgid "863    There are many other kinds of tools, such as source code repositories, build tools, etc.,"
msgstr""

# CppCoreGuidelines.md:864
msgid "864    but those are beyond the scope of these guidelines."
msgstr""

       
# CppCoreGuidelines.md:865
msgid "865    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:866
msgid "866    Be careful not to become dependent on over-elaborate or over-specialized tool chains."
msgstr""

# CppCoreGuidelines.md:867
msgid "867    Those can make your otherwise portable code non-portable."
msgstr""

       
       
# CppCoreGuidelines.md:868
msgid "868    ### <a name=\"Rp-lib\"></a>P.13: Use support libraries as appropriate"
msgstr""

       
# CppCoreGuidelines.md:869
msgid "869    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:870
msgid "870    Using a well-designed, well-documented, and well-supported library saves time and effort;"
msgstr""

# CppCoreGuidelines.md:871
msgid "871    its quality and documentation are likely to be greater than what you could do"
msgstr""

# CppCoreGuidelines.md:872
msgid "872    if the majority of your time must be spent on an implementation."
msgstr""

# CppCoreGuidelines.md:873
msgid "873    The cost (time, effort, money, etc.) of a library can be shared over many users."
msgstr""

# CppCoreGuidelines.md:874
msgid "874    A widely used library is more likely to be kept up-to-date and ported to new systems than an individual application."
msgstr""

# CppCoreGuidelines.md:875
msgid "875    Knowledge of a widely-used library can save time on other/future projects."
msgstr""

# CppCoreGuidelines.md:876
msgid "876    So, if a suitable library exists for your application domain, use it."
msgstr""

       
# CppCoreGuidelines.md:877
msgid "877    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:878
msgid "878        std::sort(begin(v), end(v), std::greater<>());"
msgstr""

       
# CppCoreGuidelines.md:879
msgid "879    Unless you are an expert in sorting algorithms and have plenty of time,"
msgstr""

# CppCoreGuidelines.md:880
msgid "880    this is more likely to be correct and to run faster than anything you write for a specific application."
msgstr""

# CppCoreGuidelines.md:881
msgid "881    You need a reason not to use the standard library (or whatever foundational libraries your application uses) rather than a reason to use it."
msgstr""

       
# CppCoreGuidelines.md:882
msgid "882    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:883
msgid "883    By default use"
msgstr""

       
# CppCoreGuidelines.md:884
msgid "884    * The [ISO C++ Standard Library](#S-stdlib)"
msgstr""

# CppCoreGuidelines.md:885
msgid "885    * The [Guidelines Support Library](#S-gsl)"
msgstr""

       
# CppCoreGuidelines.md:886
msgid "886    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:887
msgid "887    If no well-designed, well-documented, and well-supported library exists for an important domain,"
msgstr""

# CppCoreGuidelines.md:888
msgid "888    maybe you should design and implement it, and then use it."
msgstr""

       
       
# CppCoreGuidelines.md:889
msgid "889    # <a name=\"S-interfaces\"></a>I: Interfaces"
msgstr""

       
# CppCoreGuidelines.md:890
msgid "890    An interface is a contract between two parts of a program. Precisely stating what is expected of a supplier of a service and a user of that service is essential."
msgstr""

# CppCoreGuidelines.md:891
msgid "891    Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting testing, etc.) interfaces is probably the most important single aspect of code organization."
msgstr""

       
# CppCoreGuidelines.md:892
msgid "892    Interface rule summary:"
msgstr""

       
# CppCoreGuidelines.md:893
msgid "893    * [I.1: Make interfaces explicit](#Ri-explicit)"
msgstr""

# CppCoreGuidelines.md:894
msgid "894    * [I.2: Avoid non-`const` global variables](#Ri-global)"
msgstr""

# CppCoreGuidelines.md:895
msgid "895    * [I.3: Avoid singletons](#Ri-singleton)"
msgstr""

# CppCoreGuidelines.md:896
msgid "896    * [I.4: Make interfaces precisely and strongly typed](#Ri-typed)"
msgstr""

# CppCoreGuidelines.md:897
msgid "897    * [I.5: State preconditions (if any)](#Ri-pre)"
msgstr""

# CppCoreGuidelines.md:898
msgid "898    * [I.6: Prefer `Expects()` for expressing preconditions](#Ri-expects)"
msgstr""

# CppCoreGuidelines.md:899
msgid "899    * [I.7: State postconditions](#Ri-post)"
msgstr""

# CppCoreGuidelines.md:900
msgid "900    * [I.8: Prefer `Ensures()` for expressing postconditions](#Ri-ensures)"
msgstr""

# CppCoreGuidelines.md:901
msgid "901    * [I.9: If an interface is a template, document its parameters using concepts](#Ri-concepts)"
msgstr""

# CppCoreGuidelines.md:902
msgid "902    * [I.10: Use exceptions to signal a failure to perform a required task](#Ri-except)"
msgstr""

# CppCoreGuidelines.md:903
msgid "903    * [I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)](#Ri-raw)"
msgstr""

# CppCoreGuidelines.md:904
msgid "904    * [I.12: Declare a pointer that must not be null as `not_null`](#Ri-nullptr)"
msgstr""

# CppCoreGuidelines.md:905
msgid "905    * [I.13: Do not pass an array as a single pointer](#Ri-array)"
msgstr""

# CppCoreGuidelines.md:906
msgid "906    * [I.22: Avoid complex initialization of global objects](#Ri-global-init)"
msgstr""

# CppCoreGuidelines.md:907
msgid "907    * [I.23: Keep the number of function arguments low](#Ri-nargs)"
msgstr""

# CppCoreGuidelines.md:908
msgid "908    * [I.24: Avoid adjacent unrelated parameters of the same type](#Ri-unrelated)"
msgstr""

# CppCoreGuidelines.md:909
msgid "909    * [I.25: Prefer abstract classes as interfaces to class hierarchies](#Ri-abstract)"
msgstr""

# CppCoreGuidelines.md:910
msgid "910    * [I.26: If you want a cross-compiler ABI, use a C-style subset](#Ri-abi)"
msgstr""

# CppCoreGuidelines.md:911
msgid "911    * [I.27: For stable library ABI, consider the Pimpl idiom](#Ri-pimpl)"
msgstr""

# CppCoreGuidelines.md:912
msgid "912    * [I.30: Encapsulate rule violations](#Ri-encapsulate)"
msgstr""

       
# CppCoreGuidelines.md:913
msgid "913    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:914
msgid "914    * [F: Functions](#S-functions)"
msgstr""

# CppCoreGuidelines.md:915
msgid "915    * [C.concrete: Concrete types](#SS-concrete)"
msgstr""

# CppCoreGuidelines.md:916
msgid "916    * [C.hier: Class hierarchies](#SS-hier)"
msgstr""

# CppCoreGuidelines.md:917
msgid "917    * [C.over: Overloading and overloaded operators](#SS-overload)"
msgstr""

# CppCoreGuidelines.md:918
msgid "918    * [C.con: Containers and other resource handles](#SS-containers)"
msgstr""

# CppCoreGuidelines.md:919
msgid "919    * [E: Error handling](#S-errors)"
msgstr""

# CppCoreGuidelines.md:920
msgid "920    * [T: Templates and generic programming](#S-templates)"
msgstr""

       
# CppCoreGuidelines.md:921
msgid "921    ### <a name=\"Ri-explicit\"></a>I.1: Make interfaces explicit"
msgstr""

       
# CppCoreGuidelines.md:922
msgid "922    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:923
msgid "923    Correctness. Assumptions not stated in an interface are easily overlooked and hard to test."
msgstr""

       
# CppCoreGuidelines.md:924
msgid "924    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:925
msgid "925    Controlling the behavior of a function through a global (namespace scope) variable (a call mode) is implicit and potentially confusing. For example:"
msgstr""

       
# CppCoreGuidelines.md:926
msgid "926        int round(double d)"
msgstr""

# CppCoreGuidelines.md:927
msgid "927        {"
msgstr""

# CppCoreGuidelines.md:928
msgid "928            return (round_up) ? ceil(d) : d;    // don't: \"invisible\" dependency"
msgstr""

# CppCoreGuidelines.md:929
msgid "929        }"
msgstr""

       
# CppCoreGuidelines.md:930
msgid "930    It will not be obvious to a caller that the meaning of two calls of `round(7.2)` might give different results."
msgstr""

       
# CppCoreGuidelines.md:931
msgid "931    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:932
msgid "932    Sometimes we control the details of a set of operations by an environment variable, e.g., normal vs. verbose output or debug vs. optimized."
msgstr""

# CppCoreGuidelines.md:933
msgid "933    The use of a non-local control is potentially confusing, but controls only implementation details of otherwise fixed semantics."
msgstr""

       
# CppCoreGuidelines.md:934
msgid "934    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:935
msgid "935    Reporting through non-local variables (e.g., `errno`) is easily ignored. For example:"
msgstr""

       
# CppCoreGuidelines.md:936
msgid "936        // don't: no test of printf's return value"
msgstr""

# CppCoreGuidelines.md:937
msgid "937        fprintf(connection, \"logging: %d %d %d\\n\", x, y, s);"
msgstr""

       
# CppCoreGuidelines.md:938
msgid "938    What if the connection goes down so that no logging output is produced? See I.???."
msgstr""

       
# CppCoreGuidelines.md:939
msgid "939    **Alternative**: Throw an exception. An exception cannot be ignored."
msgstr""

       
# CppCoreGuidelines.md:940
msgid "940    **Alternative formulation**: Avoid passing information across an interface through non-local or implicit state."
msgstr""

# CppCoreGuidelines.md:941
msgid "941    Note that non-`const` member functions pass information to other member functions through their object's state."
msgstr""

       
# CppCoreGuidelines.md:942
msgid "942    **Alternative formulation**: An interface should be a function or a set of functions."
msgstr""

# CppCoreGuidelines.md:943
msgid "943    Functions can be template functions and sets of functions can be classes or class templates."
msgstr""

       
# CppCoreGuidelines.md:944
msgid "944    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:945
msgid "945    * (Simple) A function should not make control-flow decisions based on the values of variables declared at namespace scope."
msgstr""

# CppCoreGuidelines.md:946
msgid "946    * (Simple) A function should not write to variables declared at namespace scope."
msgstr""

       
# CppCoreGuidelines.md:947
msgid "947    ### <a name=\"Ri-global\"></a>I.2: Avoid non-`const` global variables"
msgstr""

       
# CppCoreGuidelines.md:948
msgid "948    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:949
msgid "949    Non-`const` global variables hide dependencies and make the dependencies subject to unpredictable changes."
msgstr""

       
# CppCoreGuidelines.md:950
msgid "950    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:951
msgid "951        struct Data {"
msgstr""

# CppCoreGuidelines.md:952
msgid "952            // ... lots of stuff ..."
msgstr""

# CppCoreGuidelines.md:953
msgid "953        } data;            // non-const data"
msgstr""

       
# CppCoreGuidelines.md:954
msgid "954        void compute()     // don't"
msgstr""

# CppCoreGuidelines.md:955
msgid "955        {"
msgstr""

# CppCoreGuidelines.md:956
msgid "956            // ... use data ..."
msgstr""

# CppCoreGuidelines.md:957
msgid "957        }"
msgstr""

       
# CppCoreGuidelines.md:958
msgid "958        void output()     // don't"
msgstr""

# CppCoreGuidelines.md:959
msgid "959        {"
msgstr""

# CppCoreGuidelines.md:960
msgid "960            // ... use data ..."
msgstr""

# CppCoreGuidelines.md:961
msgid "961        }"
msgstr""

       
# CppCoreGuidelines.md:962
msgid "962    Who else might modify `data`?"
msgstr""

       
# CppCoreGuidelines.md:963
msgid "963    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:964
msgid "964    Global constants are useful."
msgstr""

       
# CppCoreGuidelines.md:965
msgid "965    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:966
msgid "966    The rule against global variables applies to namespace scope variables as well."
msgstr""

       
# CppCoreGuidelines.md:967
msgid "967    **Alternative**: If you use global (more generally namespace scope) data to avoid copying, consider passing the data as an object by reference to `const`."
msgstr""

# CppCoreGuidelines.md:968
msgid "968    Another solution is to define the data as the state of some object and the operations as member functions."
msgstr""

       
# CppCoreGuidelines.md:969
msgid "969    **Warning**: Beware of data races: If one thread can access nonlocal data (or data passed by reference) while another thread executes the callee, we can have a data race."
msgstr""

# CppCoreGuidelines.md:970
msgid "970    Every pointer or reference to mutable data is a potential data race."
msgstr""

       
# CppCoreGuidelines.md:971
msgid "971    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:972
msgid "972    You cannot have a race condition on immutable data."
msgstr""

       
# CppCoreGuidelines.md:973
msgid "973    **References**: See the [rules for calling functions](#SS-call)."
msgstr""

       
# CppCoreGuidelines.md:974
msgid "974    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:975
msgid "975    The rule is \"avoid\", not \"don't use.\" Of course there will be (rare) exceptions, such as `cin`, `cout`, and `cerr`."
msgstr""

       
# CppCoreGuidelines.md:976
msgid "976    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:977
msgid "977    (Simple) Report all non-`const` variables declared at namespace scope."
msgstr""

       
# CppCoreGuidelines.md:978
msgid "978    ### <a name=\"Ri-singleton\"></a>I.3: Avoid singletons"
msgstr""

       
# CppCoreGuidelines.md:979
msgid "979    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:980
msgid "980    Singletons are basically complicated global objects in disguise."
msgstr""

       
# CppCoreGuidelines.md:981
msgid "981    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:982
msgid "982        class Singleton {"
msgstr""

# CppCoreGuidelines.md:983
msgid "983            // ... lots of stuff to ensure that only one Singleton object is created,"
msgstr""

# CppCoreGuidelines.md:984
msgid "984            // that it is initialized properly, etc."
msgstr""

# CppCoreGuidelines.md:985
msgid "985        };"
msgstr""

       
# CppCoreGuidelines.md:986
msgid "986    There are many variants of the singleton idea."
msgstr""

# CppCoreGuidelines.md:987
msgid "987    That's part of the problem."
msgstr""

       
# CppCoreGuidelines.md:988
msgid "988    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:989
msgid "989    If you don't want a global object to change, declare it `const` or `constexpr`."
msgstr""

       
# CppCoreGuidelines.md:990
msgid "990    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:991
msgid "991    You can use the simplest \"singleton\" (so simple that it is often not considered a singleton) to get initialization on first use, if any:"
msgstr""

       
# CppCoreGuidelines.md:992
msgid "992        X& myX()"
msgstr""

# CppCoreGuidelines.md:993
msgid "993        {"
msgstr""

# CppCoreGuidelines.md:994
msgid "994            static X my_x {3};"
msgstr""

# CppCoreGuidelines.md:995
msgid "995            return my_x;"
msgstr""

# CppCoreGuidelines.md:996
msgid "996        }"
msgstr""

       
# CppCoreGuidelines.md:997
msgid "997    This is one of the most effective solutions to problems related to initialization order."
msgstr""

# CppCoreGuidelines.md:998
msgid "998    In a multi-threaded environment, the initialization of the static object does not introduce a race condition"
msgstr""

# CppCoreGuidelines.md:999
msgid "999    (unless you carelessly access a shared object from within its constructor)."
msgstr""

       
# CppCoreGuidelines.md:1000
msgid "1000    Note that the initialization of a local `static` does not imply a race condition."
msgstr""

# CppCoreGuidelines.md:1001
msgid "1001    However, if the destruction of `X` involves an operation that needs to be synchronized we must use a less simple solution."
msgstr""

# CppCoreGuidelines.md:1002
msgid "1002    For example:"
msgstr""

       
# CppCoreGuidelines.md:1003
msgid "1003        X& myX()"
msgstr""

# CppCoreGuidelines.md:1004
msgid "1004        {"
msgstr""

# CppCoreGuidelines.md:1005
msgid "1005            static auto p = new X {3};"
msgstr""

# CppCoreGuidelines.md:1006
msgid "1006            return *p;  // potential leak"
msgstr""

# CppCoreGuidelines.md:1007
msgid "1007        }"
msgstr""

       
# CppCoreGuidelines.md:1008
msgid "1008    Now someone must `delete` that object in some suitably thread-safe way."
msgstr""

# CppCoreGuidelines.md:1009
msgid "1009    That's error-prone, so we don't use that technique unless"
msgstr""

       
# CppCoreGuidelines.md:1010
msgid "1010    * `myX` is in multi-threaded code,"
msgstr""

# CppCoreGuidelines.md:1011
msgid "1011    * that `X` object needs to be destroyed (e.g., because it releases a resource), and"
msgstr""

# CppCoreGuidelines.md:1012
msgid "1012    * `X`'s destructor's code needs to be synchronized."
msgstr""

       
# CppCoreGuidelines.md:1013
msgid "1013    If you, as many do, define a singleton as a class for which only one object is created, functions like `myX` are not singletons, and this useful technique is not an exception to the no-singleton rule."
msgstr""

       
# CppCoreGuidelines.md:1014
msgid "1014    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1015
msgid "1015    Very hard in general."
msgstr""

       
# CppCoreGuidelines.md:1016
msgid "1016    * Look for classes with names that include `singleton`."
msgstr""

# CppCoreGuidelines.md:1017
msgid "1017    * Look for classes for which only a single object is created (by counting objects or by examining constructors)."
msgstr""

# CppCoreGuidelines.md:1018
msgid "1018    * If a class X has a public static function that contains a function-local static of the class' type X and returns a pointer or reference to it, ban that."
msgstr""

       
# CppCoreGuidelines.md:1019
msgid "1019    ### <a name=\"Ri-typed\"></a>I.4: Make interfaces precisely and strongly typed"
msgstr""

       
# CppCoreGuidelines.md:1020
msgid "1020    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1021
msgid "1021    Types are the simplest and best documentation, have well-defined meaning, and are guaranteed to be checked at compile time."
msgstr""

# CppCoreGuidelines.md:1022
msgid "1022    Also, precisely typed code is often optimized better."
msgstr""

       
# CppCoreGuidelines.md:1023
msgid "1023    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:1024
msgid "1024    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1025
msgid "1025        void pass(void* data);    // void* is suspicious"
msgstr""

       
# CppCoreGuidelines.md:1026
msgid "1026    Now the callee must cast the data pointer (back) to a correct type to use it. That is error-prone and often verbose."
msgstr""

# CppCoreGuidelines.md:1027
msgid "1027    Avoid `void*`, especially in interfaces."
msgstr""

# CppCoreGuidelines.md:1028
msgid "1028    Consider using a `variant` or a pointer to base instead."
msgstr""

       
# CppCoreGuidelines.md:1029
msgid "1029    **Alternative**: Often, a template parameter can eliminate the `void*` turning it into a `T*` or `T&`."
msgstr""

# CppCoreGuidelines.md:1030
msgid "1030    For generic code these `T`s can be general or concept constrained template parameters."
msgstr""

       
# CppCoreGuidelines.md:1031
msgid "1031    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1032
msgid "1032    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1033
msgid "1033        void draw_rect(int, int, int, int);   // great opportunities for mistakes"
msgstr""

       
# CppCoreGuidelines.md:1034
msgid "1034        draw_rect(p.x, p.y, 10, 20);          // what does 10, 20 mean?"
msgstr""

       
# CppCoreGuidelines.md:1035
msgid "1035    An `int` can carry arbitrary forms of information, so we must guess about the meaning of the four `int`s."
msgstr""

# CppCoreGuidelines.md:1036
msgid "1036    Most likely, the first two are an `x`,`y` coordinate pair, but what are the last two?"
msgstr""

# CppCoreGuidelines.md:1037
msgid "1037    Comments and parameter names can help, but we could be explicit:"
msgstr""

       
# CppCoreGuidelines.md:1038
msgid "1038        void draw_rectangle(Point top_left, Point bottom_right);"
msgstr""

# CppCoreGuidelines.md:1039
msgid "1039        void draw_rectangle(Point top_left, Size height_width);"
msgstr""

       
# CppCoreGuidelines.md:1040
msgid "1040        draw_rectangle(p, Point{10, 20});  // two corners"
msgstr""

# CppCoreGuidelines.md:1041
msgid "1041        draw_rectangle(p, Size{10, 20});   // one corner and a (height, width) pair"
msgstr""

       
# CppCoreGuidelines.md:1042
msgid "1042    Obviously, we cannot catch all errors through the static type system"
msgstr""

# CppCoreGuidelines.md:1043
msgid "1043    (e.g., the fact that a first argument is supposed to be a top-left point is left to convention (naming and comments))."
msgstr""

       
# CppCoreGuidelines.md:1044
msgid "1044    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1045
msgid "1045    In the following example, it is not clear from the interface what `time_to_blink` means: Seconds? Milliseconds?"
msgstr""

       
# CppCoreGuidelines.md:1046
msgid "1046        void blink_led(int time_to_blink) // bad -- the unit is ambiguous"
msgstr""

# CppCoreGuidelines.md:1047
msgid "1047        {"
msgstr""

# CppCoreGuidelines.md:1048
msgid "1048            // ..."
msgstr""

# CppCoreGuidelines.md:1049
msgid "1049            // do something with time_to_blink"
msgstr""

# CppCoreGuidelines.md:1050
msgid "1050            // ..."
msgstr""

# CppCoreGuidelines.md:1051
msgid "1051        }"
msgstr""

       
# CppCoreGuidelines.md:1052
msgid "1052        void use()"
msgstr""

# CppCoreGuidelines.md:1053
msgid "1053        {"
msgstr""

# CppCoreGuidelines.md:1054
msgid "1054            blink_led(2);"
msgstr""

# CppCoreGuidelines.md:1055
msgid "1055        }"
msgstr""

       
# CppCoreGuidelines.md:1056
msgid "1056    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:1057
msgid "1057    `std::chrono::duration` types (C++11) helps making the unit of time duration explicit."
msgstr""

       
# CppCoreGuidelines.md:1058
msgid "1058        void blink_led(milliseconds time_to_blink) // good -- the unit is explicit"
msgstr""

# CppCoreGuidelines.md:1059
msgid "1059        {"
msgstr""

# CppCoreGuidelines.md:1060
msgid "1060            // ..."
msgstr""

# CppCoreGuidelines.md:1061
msgid "1061            // do something with time_to_blink"
msgstr""

# CppCoreGuidelines.md:1062
msgid "1062            // ..."
msgstr""

# CppCoreGuidelines.md:1063
msgid "1063        }"
msgstr""

       
# CppCoreGuidelines.md:1064
msgid "1064        void use()"
msgstr""

# CppCoreGuidelines.md:1065
msgid "1065        {"
msgstr""

# CppCoreGuidelines.md:1066
msgid "1066            blink_led(1500ms);"
msgstr""

# CppCoreGuidelines.md:1067
msgid "1067        }"
msgstr""

       
# CppCoreGuidelines.md:1068
msgid "1068    The function can also be written in such a way that it will accept any time duration unit."
msgstr""

       
# CppCoreGuidelines.md:1069
msgid "1069        template<class rep, class period>"
msgstr""

# CppCoreGuidelines.md:1070
msgid "1070        void blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit"
msgstr""

# CppCoreGuidelines.md:1071
msgid "1071        {"
msgstr""

# CppCoreGuidelines.md:1072
msgid "1072            // assuming that millisecond is the smallest relevant unit"
msgstr""

# CppCoreGuidelines.md:1073
msgid "1073            auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);"
msgstr""

# CppCoreGuidelines.md:1074
msgid "1074            // ..."
msgstr""

# CppCoreGuidelines.md:1075
msgid "1075            // do something with milliseconds_to_blink"
msgstr""

# CppCoreGuidelines.md:1076
msgid "1076            // ..."
msgstr""

# CppCoreGuidelines.md:1077
msgid "1077        }"
msgstr""

       
# CppCoreGuidelines.md:1078
msgid "1078        void use()"
msgstr""

# CppCoreGuidelines.md:1079
msgid "1079        {"
msgstr""

# CppCoreGuidelines.md:1080
msgid "1080            blink_led(2s);"
msgstr""

# CppCoreGuidelines.md:1081
msgid "1081            blink_led(1500ms);"
msgstr""

# CppCoreGuidelines.md:1082
msgid "1082        }"
msgstr""

       
# CppCoreGuidelines.md:1083
msgid "1083    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1084
msgid "1084    * (Simple) Report the use of `void*` as a parameter or return type."
msgstr""

# CppCoreGuidelines.md:1085
msgid "1085    * (Hard to do well) Look for member functions with many built-in type arguments."
msgstr""

       
# CppCoreGuidelines.md:1086
msgid "1086    ### <a name=\"Ri-pre\"></a>I.5: State preconditions (if any)"
msgstr""

       
# CppCoreGuidelines.md:1087
msgid "1087    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1088
msgid "1088    Arguments have meaning that may constrain their proper use in the callee."
msgstr""

       
# CppCoreGuidelines.md:1089
msgid "1089    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1090
msgid "1090    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1091
msgid "1091        double sqrt(double x);"
msgstr""

       
# CppCoreGuidelines.md:1092
msgid "1092    Here `x` must be nonnegative. The type system cannot (easily and naturally) express that, so we must use other means. For example:"
msgstr""

       
# CppCoreGuidelines.md:1093
msgid "1093        double sqrt(double x); // x must be nonnegative"
msgstr""

       
# CppCoreGuidelines.md:1094
msgid "1094    Some preconditions can be expressed as assertions. For example:"
msgstr""

       
# CppCoreGuidelines.md:1095
msgid "1095        double sqrt(double x) { Expects(x >= 0); /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:1096
msgid "1096    Ideally, that `Expects(x >= 0)` should be part of the interface of `sqrt()` but that's not easily done. For now, we place it in the definition (function body)."
msgstr""

       
# CppCoreGuidelines.md:1097
msgid "1097    **References**: `Expects()` is described in [GSL](#S-gsl)."
msgstr""

       
# CppCoreGuidelines.md:1098
msgid "1098    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1099
msgid "1099    Prefer a formal specification of requirements, such as `Expects(p);`."
msgstr""

# CppCoreGuidelines.md:1100
msgid "1100    If that is infeasible, use English text in comments, such as `// the sequence [p:q) is ordered using <`."
msgstr""

       
# CppCoreGuidelines.md:1101
msgid "1101    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1102
msgid "1102    Most member functions have as a precondition that some class invariant holds."
msgstr""

# CppCoreGuidelines.md:1103
msgid "1103    That invariant is established by a constructor and must be reestablished upon exit by every member function called from outside the class."
msgstr""

# CppCoreGuidelines.md:1104
msgid "1104    We don't need to mention it for each member function."
msgstr""

       
# CppCoreGuidelines.md:1105
msgid "1105    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1106
msgid "1106    (Not enforceable)"
msgstr""

       
# CppCoreGuidelines.md:1107
msgid "1107    **See also**: The rules for passing pointers. ???"
msgstr""

       
# CppCoreGuidelines.md:1108
msgid "1108    ### <a name=\"Ri-expects\"></a>I.6: Prefer `Expects()` for expressing preconditions"
msgstr""

       
# CppCoreGuidelines.md:1109
msgid "1109    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1110
msgid "1110    To make it clear that the condition is a precondition and to enable tool use."
msgstr""

       
# CppCoreGuidelines.md:1111
msgid "1111    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1112
msgid "1112        int area(int height, int width)"
msgstr""

# CppCoreGuidelines.md:1113
msgid "1113        {"
msgstr""

# CppCoreGuidelines.md:1114
msgid "1114            Expects(height > 0 && width > 0);            // good"
msgstr""

# CppCoreGuidelines.md:1115
msgid "1115            if (height <= 0 || width <= 0) my_error();   // obscure"
msgstr""

# CppCoreGuidelines.md:1116
msgid "1116            // ..."
msgstr""

# CppCoreGuidelines.md:1117
msgid "1117        }"
msgstr""

       
# CppCoreGuidelines.md:1118
msgid "1118    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1119
msgid "1119    Preconditions can be stated in many ways, including comments, `if`-statements, and `assert()`."
msgstr""

# CppCoreGuidelines.md:1120
msgid "1120    This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics (do you always want to abort in debug mode and check nothing in productions runs?)."
msgstr""

       
# CppCoreGuidelines.md:1121
msgid "1121    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1122
msgid "1122    Preconditions should be part of the interface rather than part of the implementation,"
msgstr""

# CppCoreGuidelines.md:1123
msgid "1123    but we don't yet have the language facilities to do that."
msgstr""

# CppCoreGuidelines.md:1124
msgid "1124    Once language support becomes available (e.g., see the [contract proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) we will adopt the standard version of preconditions, postconditions, and assertions."
msgstr""

       
# CppCoreGuidelines.md:1125
msgid "1125    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1126
msgid "1126    `Expects()` can also be used to check a condition in the middle of an algorithm."
msgstr""

       
# CppCoreGuidelines.md:1127
msgid "1127    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1128
msgid "1128    No, using `unsigned` is not a good way to sidestep the problem of [ensuring that a value is nonnegative](#Res-nonnegative)."
msgstr""

       
# CppCoreGuidelines.md:1129
msgid "1129    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1130
msgid "1130    (Not enforceable) Finding the variety of ways preconditions can be asserted is not feasible. Warning about those that can be easily identified (`assert()`) has questionable value in the absence of a language facility."
msgstr""

       
# CppCoreGuidelines.md:1131
msgid "1131    ### <a name=\"Ri-post\"></a>I.7: State postconditions"
msgstr""

       
# CppCoreGuidelines.md:1132
msgid "1132    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1133
msgid "1133    To detect misunderstandings about the result and possibly catch erroneous implementations."
msgstr""

       
# CppCoreGuidelines.md:1134
msgid "1134    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1135
msgid "1135    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1136
msgid "1136        int area(int height, int width) { return height * width; }  // bad"
msgstr""

       
# CppCoreGuidelines.md:1137
msgid "1137    Here, we (incautiously) left out the precondition specification, so it is not explicit that height and width must be positive."
msgstr""

# CppCoreGuidelines.md:1138
msgid "1138    We also left out the postcondition specification, so it is not obvious that the algorithm (`height * width`) is wrong for areas larger than the largest integer."
msgstr""

# CppCoreGuidelines.md:1139
msgid "1139    Overflow can happen."
msgstr""

# CppCoreGuidelines.md:1140
msgid "1140    Consider using:"
msgstr""

       
# CppCoreGuidelines.md:1141
msgid "1141        int area(int height, int width)"
msgstr""

# CppCoreGuidelines.md:1142
msgid "1142        {"
msgstr""

# CppCoreGuidelines.md:1143
msgid "1143            auto res = height * width;"
msgstr""

# CppCoreGuidelines.md:1144
msgid "1144            Ensures(res > 0);"
msgstr""

# CppCoreGuidelines.md:1145
msgid "1145            return res;"
msgstr""

# CppCoreGuidelines.md:1146
msgid "1146        }"
msgstr""

       
# CppCoreGuidelines.md:1147
msgid "1147    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1148
msgid "1148    Consider a famous security bug:"
msgstr""

       
# CppCoreGuidelines.md:1149
msgid "1149        void f()    // problematic"
msgstr""

# CppCoreGuidelines.md:1150
msgid "1150        {"
msgstr""

# CppCoreGuidelines.md:1151
msgid "1151            char buffer[MAX];"
msgstr""

# CppCoreGuidelines.md:1152
msgid "1152            // ..."
msgstr""

# CppCoreGuidelines.md:1153
msgid "1153            memset(buffer, 0, sizeof(buffer));"
msgstr""

# CppCoreGuidelines.md:1154
msgid "1154        }"
msgstr""

       
# CppCoreGuidelines.md:1155
msgid "1155    There was no postcondition stating that the buffer should be cleared and the optimizer eliminated the apparently redundant `memset()` call:"
msgstr""

       
# CppCoreGuidelines.md:1156
msgid "1156        void f()    // better"
msgstr""

# CppCoreGuidelines.md:1157
msgid "1157        {"
msgstr""

# CppCoreGuidelines.md:1158
msgid "1158            char buffer[MAX];"
msgstr""

# CppCoreGuidelines.md:1159
msgid "1159            // ..."
msgstr""

# CppCoreGuidelines.md:1160
msgid "1160            memset(buffer, 0, sizeof(buffer));"
msgstr""

# CppCoreGuidelines.md:1161
msgid "1161            Ensures(buffer[0] == 0);"
msgstr""

# CppCoreGuidelines.md:1162
msgid "1162        }"
msgstr""

       
# CppCoreGuidelines.md:1163
msgid "1163    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1164
msgid "1164    Postconditions are often informally stated in a comment that states the purpose of a function; `Ensures()` can be used to make this more systematic, visible, and checkable."
msgstr""

       
# CppCoreGuidelines.md:1165
msgid "1165    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1166
msgid "1166    Postconditions are especially important when they relate to something that is not directly reflected in a returned result, such as a state of a data structure used."
msgstr""

       
# CppCoreGuidelines.md:1167
msgid "1167    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1168
msgid "1168    Consider a function that manipulates a `Record`, using a `mutex` to avoid race conditions:"
msgstr""

       
# CppCoreGuidelines.md:1169
msgid "1169        mutex m;"
msgstr""

       
# CppCoreGuidelines.md:1170
msgid "1170        void manipulate(Record& r)    // don't"
msgstr""

# CppCoreGuidelines.md:1171
msgid "1171        {"
msgstr""

# CppCoreGuidelines.md:1172
msgid "1172            m.lock();"
msgstr""

# CppCoreGuidelines.md:1173
msgid "1173            // ... no m.unlock() ..."
msgstr""

# CppCoreGuidelines.md:1174
msgid "1174        }"
msgstr""

       
# CppCoreGuidelines.md:1175
msgid "1175    Here, we \"forgot\" to state that the `mutex` should be released, so we don't know if the failure to ensure release of the `mutex` was a bug or a feature."
msgstr""

# CppCoreGuidelines.md:1176
msgid "1176    Stating the postcondition would have made it clear:"
msgstr""

       
# CppCoreGuidelines.md:1177
msgid "1177        void manipulate(Record& r)    // postcondition: m is unlocked upon exit"
msgstr""

# CppCoreGuidelines.md:1178
msgid "1178        {"
msgstr""

# CppCoreGuidelines.md:1179
msgid "1179            m.lock();"
msgstr""

# CppCoreGuidelines.md:1180
msgid "1180            // ... no m.unlock() ..."
msgstr""

# CppCoreGuidelines.md:1181
msgid "1181        }"
msgstr""

       
# CppCoreGuidelines.md:1182
msgid "1182    The bug is now obvious (but only to a human reading comments)."
msgstr""

       
# CppCoreGuidelines.md:1183
msgid "1183    Better still, use [RAII](#Rr-raii) to ensure that the postcondition (\"the lock must be released\") is enforced in code:"
msgstr""

       
# CppCoreGuidelines.md:1184
msgid "1184        void manipulate(Record& r)    // best"
msgstr""

# CppCoreGuidelines.md:1185
msgid "1185        {"
msgstr""

# CppCoreGuidelines.md:1186
msgid "1186            lock_guard<mutex> _ {m};"
msgstr""

# CppCoreGuidelines.md:1187
msgid "1187            // ..."
msgstr""

# CppCoreGuidelines.md:1188
msgid "1188        }"
msgstr""

       
# CppCoreGuidelines.md:1189
msgid "1189    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1190
msgid "1190    Ideally, postconditions are stated in the interface/declaration so that users can easily see them."
msgstr""

# CppCoreGuidelines.md:1191
msgid "1191    Only postconditions related to the users can be stated in the interface."
msgstr""

# CppCoreGuidelines.md:1192
msgid "1192    Postconditions related only to internal state belongs in the definition/implementation."
msgstr""

       
# CppCoreGuidelines.md:1193
msgid "1193    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1194
msgid "1194    (Not enforceable) This is a philosophical guideline that is infeasible to check"
msgstr""

# CppCoreGuidelines.md:1195
msgid "1195    directly in the general case. Domain specific checkers (like lock-holding"
msgstr""

# CppCoreGuidelines.md:1196
msgid "1196    checkers) exist for many toolchains."
msgstr""

       
# CppCoreGuidelines.md:1197
msgid "1197    ### <a name=\"Ri-ensures\"></a>I.8: Prefer `Ensures()` for expressing postconditions"
msgstr""

       
# CppCoreGuidelines.md:1198
msgid "1198    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1199
msgid "1199    To make it clear that the condition is a postcondition and to enable tool use."
msgstr""

       
# CppCoreGuidelines.md:1200
msgid "1200    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1201
msgid "1201        void f()"
msgstr""

# CppCoreGuidelines.md:1202
msgid "1202        {"
msgstr""

# CppCoreGuidelines.md:1203
msgid "1203            char buffer[MAX];"
msgstr""

# CppCoreGuidelines.md:1204
msgid "1204            // ..."
msgstr""

# CppCoreGuidelines.md:1205
msgid "1205            memset(buffer, 0, MAX);"
msgstr""

# CppCoreGuidelines.md:1206
msgid "1206            Ensures(buffer[0] == 0);"
msgstr""

# CppCoreGuidelines.md:1207
msgid "1207        }"
msgstr""

       
# CppCoreGuidelines.md:1208
msgid "1208    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1209
msgid "1209    Postconditions can be stated in many ways, including comments, `if`-statements, and `assert()`."
msgstr""

# CppCoreGuidelines.md:1210
msgid "1210    This can make them hard to distinguish from ordinary code, hard to update, hard to manipulate by tools, and may have the wrong semantics."
msgstr""

       
# CppCoreGuidelines.md:1211
msgid "1211    **Alternative**: Postconditions of the form \"this resource must be released\" are best expressed by [RAII](#Rr-raii)."
msgstr""

       
# CppCoreGuidelines.md:1212
msgid "1212    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1213
msgid "1213    Ideally, that `Ensures` should be part of the interface, but that's not easily done."
msgstr""

# CppCoreGuidelines.md:1214
msgid "1214    For now, we place it in the definition (function body)."
msgstr""

# CppCoreGuidelines.md:1215
msgid "1215    Once language support becomes available (e.g., see the [contract proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) we will adopt the standard version of preconditions, postconditions, and assertions."
msgstr""

       
# CppCoreGuidelines.md:1216
msgid "1216    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1217
msgid "1217    (Not enforceable) Finding the variety of ways postconditions can be asserted is not feasible. Warning about those that can be easily identified (`assert()`) has questionable value in the absence of a language facility."
msgstr""

       
# CppCoreGuidelines.md:1218
msgid "1218    ### <a name=\"Ri-concepts\"></a>I.9: If an interface is a template, document its parameters using concepts"
msgstr""

       
# CppCoreGuidelines.md:1219
msgid "1219    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1220
msgid "1220    Make the interface precisely specified and compile-time checkable in the (not so distant) future."
msgstr""

       
# CppCoreGuidelines.md:1221
msgid "1221    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1222
msgid "1222    Use the ISO Concepts TS style of requirements specification. For example:"
msgstr""

       
# CppCoreGuidelines.md:1223
msgid "1223        template<typename Iter, typename Val>"
msgstr""

# CppCoreGuidelines.md:1224
msgid "1224        // requires InputIterator<Iter> && EqualityComparable<ValueType<Iter>>, Val>"
msgstr""

# CppCoreGuidelines.md:1225
msgid "1225        Iter find(Iter first, Iter last, Val v)"
msgstr""

# CppCoreGuidelines.md:1226
msgid "1226        {"
msgstr""

# CppCoreGuidelines.md:1227
msgid "1227            // ..."
msgstr""

# CppCoreGuidelines.md:1228
msgid "1228        }"
msgstr""

       
# CppCoreGuidelines.md:1229
msgid "1229    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1230
msgid "1230    Soon (maybe in 2018), most compilers will be able to check `requires` clauses once the `//` is removed."
msgstr""

# CppCoreGuidelines.md:1231
msgid "1231    Concepts are supported in GCC 6.1 and later."
msgstr""

       
# CppCoreGuidelines.md:1232
msgid "1232    **See also**: [Generic programming](#SS-GP) and [concepts](#SS-concepts)."
msgstr""

       
# CppCoreGuidelines.md:1233
msgid "1233    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1234
msgid "1234    (Not yet enforceable) A language facility is under specification. When the language facility is available, warn if any non-variadic template parameter is not constrained by a concept (in its declaration or mentioned in a `requires` clause)."
msgstr""

       
# CppCoreGuidelines.md:1235
msgid "1235    ### <a name=\"Ri-except\"></a>I.10: Use exceptions to signal a failure to perform a required task"
msgstr""

       
# CppCoreGuidelines.md:1236
msgid "1236    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1237
msgid "1237    It should not be possible to ignore an error because that could leave the system or a computation in an undefined (or unexpected) state."
msgstr""

# CppCoreGuidelines.md:1238
msgid "1238    This is a major source of errors."
msgstr""

       
# CppCoreGuidelines.md:1239
msgid "1239    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1240
msgid "1240        int printf(const char* ...);    // bad: return negative number if output fails"
msgstr""

       
# CppCoreGuidelines.md:1241
msgid "1241        template <class F, class ...Args>"
msgstr""

# CppCoreGuidelines.md:1242
msgid "1242        // good: throw system_error if unable to start the new thread"
msgstr""

# CppCoreGuidelines.md:1243
msgid "1243        explicit thread(F&& f, Args&&... args);"
msgstr""

       
# CppCoreGuidelines.md:1244
msgid "1244    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1245
msgid "1245    What is an error?"
msgstr""

       
# CppCoreGuidelines.md:1246
msgid "1246    An error means that the function cannot achieve its advertised purpose (including establishing postconditions)."
msgstr""

# CppCoreGuidelines.md:1247
msgid "1247    Calling code that ignores an error could lead to wrong results or undefined systems state."
msgstr""

# CppCoreGuidelines.md:1248
msgid "1248    For example, not being able to connect to a remote server is not by itself an error:"
msgstr""

# CppCoreGuidelines.md:1249
msgid "1249    the server can refuse a connection for all kinds of reasons, so the natural thing is to return a result that the caller should always check."
msgstr""

# CppCoreGuidelines.md:1250
msgid "1250    However, if failing to make a connection is considered an error, then a failure should throw an exception."
msgstr""

       
# CppCoreGuidelines.md:1251
msgid "1251    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1252
msgid "1252    Many traditional interface functions (e.g., UNIX signal handlers) use error codes (e.g., `errno`) to report what are really status codes, rather than errors. You don't have a good alternative to using such, so calling these does not violate the rule."
msgstr""

       
# CppCoreGuidelines.md:1253
msgid "1253    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:1254
msgid "1254    If you can't use exceptions (e.g., because your code is full of old-style raw-pointer use or because there are hard-real-time constraints), consider using a style that returns a pair of values:"
msgstr""

       
# CppCoreGuidelines.md:1255
msgid "1255        int val;"
msgstr""

# CppCoreGuidelines.md:1256
msgid "1256        int error_code;"
msgstr""

# CppCoreGuidelines.md:1257
msgid "1257        tie(val, error_code) = do_something();"
msgstr""

# CppCoreGuidelines.md:1258
msgid "1258        if (error_code) {"
msgstr""

# CppCoreGuidelines.md:1259
msgid "1259            // ... handle the error or exit ..."
msgstr""

# CppCoreGuidelines.md:1260
msgid "1260        }"
msgstr""

# CppCoreGuidelines.md:1261
msgid "1261        // ... use val ..."
msgstr""

       
# CppCoreGuidelines.md:1262
msgid "1262    This style unfortunately leads to uninitialized variables."
msgstr""

# CppCoreGuidelines.md:1263
msgid "1263    A facility [structured bindings](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0144r1.pdf) to deal with that will become available in C++17."
msgstr""

       
# CppCoreGuidelines.md:1264
msgid "1264        auto [val, error_code] = do_something();"
msgstr""

# CppCoreGuidelines.md:1265
msgid "1265        if (error_code) {"
msgstr""

# CppCoreGuidelines.md:1266
msgid "1266            // ... handle the error or exit ..."
msgstr""

# CppCoreGuidelines.md:1267
msgid "1267        }"
msgstr""

# CppCoreGuidelines.md:1268
msgid "1268        // ... use val ..."
msgstr""

       
# CppCoreGuidelines.md:1269
msgid "1269    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1270
msgid "1270    We don't consider \"performance\" a valid reason not to use exceptions."
msgstr""

       
# CppCoreGuidelines.md:1271
msgid "1271    * Often, explicit error checking and handling consume as much time and space as exception handling."
msgstr""

# CppCoreGuidelines.md:1272
msgid "1272    * Often, cleaner code yields better performance with exceptions (simplifying the tracing of paths through the program and their optimization)."
msgstr""

# CppCoreGuidelines.md:1273
msgid "1273    * A good rule for performance critical code is to move checking outside the critical part of the code ([checking](#Rper-checking))."
msgstr""

# CppCoreGuidelines.md:1274
msgid "1274    * In the longer term, more regular code gets better optimized."
msgstr""

# CppCoreGuidelines.md:1275
msgid "1275    * Always carefully [measure](#Rper-measure) before making performance claims."
msgstr""

       
# CppCoreGuidelines.md:1276
msgid "1276    **See also**: [I.5](#Ri-pre) and [I.7](#Ri-post) for reporting precondition and postcondition violations."
msgstr""

       
# CppCoreGuidelines.md:1277
msgid "1277    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1278
msgid "1278    * (Not enforceable) This is a philosophical guideline that is infeasible to check directly."
msgstr""

# CppCoreGuidelines.md:1279
msgid "1279    * Look for `errno`."
msgstr""

       
# CppCoreGuidelines.md:1280
msgid "1280    ### <a name=\"Ri-raw\"></a>I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)"
msgstr""

       
# CppCoreGuidelines.md:1281
msgid "1281    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1282
msgid "1282    If there is any doubt whether the caller or the callee owns an object, leaks or premature destruction will occur."
msgstr""

       
# CppCoreGuidelines.md:1283
msgid "1283    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1284
msgid "1284    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1285
msgid "1285        X* compute(args)    // don't"
msgstr""

# CppCoreGuidelines.md:1286
msgid "1286        {"
msgstr""

# CppCoreGuidelines.md:1287
msgid "1287            X* res = new X{};"
msgstr""

# CppCoreGuidelines.md:1288
msgid "1288            // ..."
msgstr""

# CppCoreGuidelines.md:1289
msgid "1289            return res;"
msgstr""

# CppCoreGuidelines.md:1290
msgid "1290        }"
msgstr""

       
# CppCoreGuidelines.md:1291
msgid "1291    Who deletes the returned `X`? The problem would be harder to spot if `compute` returned a reference."
msgstr""

# CppCoreGuidelines.md:1292
msgid "1292    Consider returning the result by value (use move semantics if the result is large):"
msgstr""

       
# CppCoreGuidelines.md:1293
msgid "1293        vector<double> compute(args)  // good"
msgstr""

# CppCoreGuidelines.md:1294
msgid "1294        {"
msgstr""

# CppCoreGuidelines.md:1295
msgid "1295            vector<double> res(10000);"
msgstr""

# CppCoreGuidelines.md:1296
msgid "1296            // ..."
msgstr""

# CppCoreGuidelines.md:1297
msgid "1297            return res;"
msgstr""

# CppCoreGuidelines.md:1298
msgid "1298        }"
msgstr""

       
# CppCoreGuidelines.md:1299
msgid "1299    **Alternative**: [Pass ownership](#Rr-smartptrparam) using a \"smart pointer\", such as `unique_ptr` (for exclusive ownership) and `shared_ptr` (for shared ownership)."
msgstr""

# CppCoreGuidelines.md:1300
msgid "1300    However, that is less elegant and often less efficient than returning the object itself,"
msgstr""

# CppCoreGuidelines.md:1301
msgid "1301    so use smart pointers only if reference semantics are needed."
msgstr""

       
# CppCoreGuidelines.md:1302
msgid "1302    **Alternative**: Sometimes older code can't be modified because of ABI compatibility requirements or lack of resources."
msgstr""

# CppCoreGuidelines.md:1303
msgid "1303    In that case, mark owning pointers using `owner` from the [guidelines support library](#S-gsl):"
msgstr""

       
# CppCoreGuidelines.md:1304
msgid "1304        owner<X*> compute(args)    // It is now clear that ownership is transferred"
msgstr""

# CppCoreGuidelines.md:1305
msgid "1305        {"
msgstr""

# CppCoreGuidelines.md:1306
msgid "1306            owner<X*> res = new X{};"
msgstr""

# CppCoreGuidelines.md:1307
msgid "1307            // ..."
msgstr""

# CppCoreGuidelines.md:1308
msgid "1308            return res;"
msgstr""

# CppCoreGuidelines.md:1309
msgid "1309        }"
msgstr""

       
# CppCoreGuidelines.md:1310
msgid "1310    This tells analysis tools that `res` is an owner."
msgstr""

# CppCoreGuidelines.md:1311
msgid "1311    That is, its value must be `delete`d or transferred to another owner, as is done here by the `return`."
msgstr""

       
# CppCoreGuidelines.md:1312
msgid "1312    `owner` is used similarly in the implementation of resource handles."
msgstr""

       
# CppCoreGuidelines.md:1313
msgid "1313    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1314
msgid "1314    Every object passed as a raw pointer (or iterator) is assumed to be owned by the"
msgstr""

# CppCoreGuidelines.md:1315
msgid "1315    caller, so that its lifetime is handled by the caller. Viewed another way:"
msgstr""

# CppCoreGuidelines.md:1316
msgid "1316    ownership transferring APIs are relatively rare compared to pointer-passing APIs,"
msgstr""

# CppCoreGuidelines.md:1317
msgid "1317    so the default is \"no ownership transfer.\""
msgstr""

       
# CppCoreGuidelines.md:1318
msgid "1318    **See also**: [Argument passing](#Rf-conventional), [use of smart pointer arguments](#Rr-smartptrparam), and [value return](#Rf-value-return)."
msgstr""

       
# CppCoreGuidelines.md:1319
msgid "1319    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1320
msgid "1320    * (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`. Suggest use of standard-library resource handle or use of `owner<T>`."
msgstr""

# CppCoreGuidelines.md:1321
msgid "1321    * (Simple) Warn on failure to either `reset` or explicitly `delete` an `owner` pointer on every code path."
msgstr""

# CppCoreGuidelines.md:1322
msgid "1322    * (Simple) Warn if the return value of `new` or a function call with an `owner` return value is assigned to a raw pointer or non-`owner` reference."
msgstr""

       
# CppCoreGuidelines.md:1323
msgid "1323    ### <a name=\"Ri-nullptr\"></a>I.12: Declare a pointer that must not be null as `not_null`"
msgstr""

       
# CppCoreGuidelines.md:1324
msgid "1324    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1325
msgid "1325    To help avoid dereferencing `nullptr` errors."
msgstr""

# CppCoreGuidelines.md:1326
msgid "1326    To improve performance by avoiding redundant checks for `nullptr`."
msgstr""

       
# CppCoreGuidelines.md:1327
msgid "1327    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1328
msgid "1328        int length(const char* p);            // it is not clear whether length(nullptr) is valid"
msgstr""

       
# CppCoreGuidelines.md:1329
msgid "1329        length(nullptr);                      // OK?"
msgstr""

       
# CppCoreGuidelines.md:1330
msgid "1330        int length(not_null<const char*> p);  // better: we can assume that p cannot be nullptr"
msgstr""

       
# CppCoreGuidelines.md:1331
msgid "1331        int length(const char* p);            // we must assume that p can be nullptr"
msgstr""

       
# CppCoreGuidelines.md:1332
msgid "1332    By stating the intent in source, implementers and tools can provide better diagnostics, such as finding some classes of errors through static analysis, and perform optimizations, such as removing branches and null tests."
msgstr""

       
# CppCoreGuidelines.md:1333
msgid "1333    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1334
msgid "1334    `not_null` is defined in the [guidelines support library](#S-gsl)."
msgstr""

       
# CppCoreGuidelines.md:1335
msgid "1335    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1336
msgid "1336    The assumption that the pointer to `char` pointed to a C-style string (a zero-terminated string of characters) was still implicit, and a potential source of confusion and errors. Use `czstring` in preference to `const char*`."
msgstr""

       
# CppCoreGuidelines.md:1337
msgid "1337        // we can assume that p cannot be nullptr"
msgstr""

# CppCoreGuidelines.md:1338
msgid "1338        // we can assume that p points to a zero-terminated array of characters"
msgstr""

# CppCoreGuidelines.md:1339
msgid "1339        int length(not_null<zstring> p);"
msgstr""

       
# CppCoreGuidelines.md:1340
msgid "1340    Note: `length()` is, of course, `std::strlen()` in disguise."
msgstr""

       
# CppCoreGuidelines.md:1341
msgid "1341    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1342
msgid "1342    * (Simple) ((Foundation)) If a function checks a pointer parameter against `nullptr` before access, on all control-flow paths, then warn it should be declared `not_null`."
msgstr""

# CppCoreGuidelines.md:1343
msgid "1343    * (Complex) If a function with pointer return value ensures it is not `nullptr` on all return paths, then warn the return type should be declared `not_null`."
msgstr""

       
# CppCoreGuidelines.md:1344
msgid "1344    ### <a name=\"Ri-array\"></a>I.13: Do not pass an array as a single pointer"
msgstr""

       
# CppCoreGuidelines.md:1345
msgid "1345    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1346
msgid "1346     (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to array) must rely on some convention to allow the callee to determine the size."
msgstr""

       
# CppCoreGuidelines.md:1347
msgid "1347    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1348
msgid "1348    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1349
msgid "1349        void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)"
msgstr""

       
# CppCoreGuidelines.md:1350
msgid "1350    What if there are fewer than `n` elements in the array pointed to by `q`? Then, we overwrite some probably unrelated memory."
msgstr""

# CppCoreGuidelines.md:1351
msgid "1351    What if there are fewer than `n` elements in the array pointed to by `p`? Then, we read some probably unrelated memory."
msgstr""

# CppCoreGuidelines.md:1352
msgid "1352    Either is undefined behavior and a potentially very nasty bug."
msgstr""

       
# CppCoreGuidelines.md:1353
msgid "1353    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:1354
msgid "1354    Consider using explicit spans:"
msgstr""

       
# CppCoreGuidelines.md:1355
msgid "1355        void copy(span<const T> r, span<T> r2); // copy r to r2"
msgstr""

       
# CppCoreGuidelines.md:1356
msgid "1356    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1357
msgid "1357    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1358
msgid "1358        void draw(Shape* p, int n);  // poor interface; poor code"
msgstr""

# CppCoreGuidelines.md:1359
msgid "1359        Circle arr[10];"
msgstr""

# CppCoreGuidelines.md:1360
msgid "1360        // ..."
msgstr""

# CppCoreGuidelines.md:1361
msgid "1361        draw(arr, 10);"
msgstr""

       
# CppCoreGuidelines.md:1362
msgid "1362    Passing `10` as the `n` argument may be a mistake: the most common convention is to assume `[0:n)` but that is nowhere stated. Worse is that the call of `draw()` compiled at all: there was an implicit conversion from array to pointer (array decay) and then another implicit conversion from `Circle` to `Shape`. There is no way that `draw()` can safely iterate through that array: it has no way of knowing the size of the elements."
msgstr""

       
# CppCoreGuidelines.md:1363
msgid "1363    **Alternative**: Use a support class that ensures that the number of elements is correct and prevents dangerous implicit conversions. For example:"
msgstr""

       
# CppCoreGuidelines.md:1364
msgid "1364        void draw2(span<Circle>);"
msgstr""

# CppCoreGuidelines.md:1365
msgid "1365        Circle arr[10];"
msgstr""

# CppCoreGuidelines.md:1366
msgid "1366        // ..."
msgstr""

# CppCoreGuidelines.md:1367
msgid "1367        draw2(span<Circle>(arr));  // deduce the number of elements"
msgstr""

# CppCoreGuidelines.md:1368
msgid "1368        draw2(arr);    // deduce the element type and array size"
msgstr""

       
# CppCoreGuidelines.md:1369
msgid "1369        void draw3(span<Shape>);"
msgstr""

# CppCoreGuidelines.md:1370
msgid "1370        draw3(arr);    // error: cannot convert Circle[10] to span<Shape>"
msgstr""

       
# CppCoreGuidelines.md:1371
msgid "1371    This `draw2()` passes the same amount of information to `draw()`, but makes the fact that it is supposed to be a range of `Circle`s explicit. See ???."
msgstr""

       
# CppCoreGuidelines.md:1372
msgid "1372    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1373
msgid "1373    Use `zstring` and `czstring` to represent a C-style, zero-terminated strings."
msgstr""

# CppCoreGuidelines.md:1374
msgid "1374    But when doing so, use `string_span` from the [GSL](#GSL) to prevent range errors."
msgstr""

       
# CppCoreGuidelines.md:1375
msgid "1375    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1376
msgid "1376    * (Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion of an array type to a pointer type. Allow exception for zstring/czstring pointer types."
msgstr""

# CppCoreGuidelines.md:1377
msgid "1377    * (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type. Allow exception for zstring/czstring pointer types."
msgstr""

       
# CppCoreGuidelines.md:1378
msgid "1378    ### <a name=\"Ri-global-init\"></a>I.22: Avoid complex initialization of global objects"
msgstr""

       
# CppCoreGuidelines.md:1379
msgid "1379    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1380
msgid "1380    Complex initialization can lead to undefined order of execution."
msgstr""

       
# CppCoreGuidelines.md:1381
msgid "1381    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1382
msgid "1382        // file1.c"
msgstr""

       
# CppCoreGuidelines.md:1383
msgid "1383        extern const X x;"
msgstr""

       
# CppCoreGuidelines.md:1384
msgid "1384        const Y y = f(x);   // read x; write y"
msgstr""

       
# CppCoreGuidelines.md:1385
msgid "1385        // file2.c"
msgstr""

       
# CppCoreGuidelines.md:1386
msgid "1386        extern const Y y;"
msgstr""

       
# CppCoreGuidelines.md:1387
msgid "1387        const X x = g(y);   // read y; write x"
msgstr""

       
# CppCoreGuidelines.md:1388
msgid "1388    Since `x` and `y` are in different translation units the order of calls to `f()` and `g()` is undefined;"
msgstr""

# CppCoreGuidelines.md:1389
msgid "1389    one will access an uninitialized `const`."
msgstr""

# CppCoreGuidelines.md:1390
msgid "1390    This shows that the order-of-initialization problem for global (namespace scope) objects is not limited to global *variables*."
msgstr""

       
# CppCoreGuidelines.md:1391
msgid "1391    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1392
msgid "1392    Order of initialization problems become particularly difficult to handle in concurrent code."
msgstr""

# CppCoreGuidelines.md:1393
msgid "1393    It is usually best to avoid global (namespace scope) objects altogether."
msgstr""

       
# CppCoreGuidelines.md:1394
msgid "1394    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1395
msgid "1395    * Flag initializers of globals that call non-`constexpr` functions"
msgstr""

# CppCoreGuidelines.md:1396
msgid "1396    * Flag initializers of globals that access `extern` objects"
msgstr""

       
# CppCoreGuidelines.md:1397
msgid "1397    ### <a name=\"Ri-nargs\"></a>I.23: Keep the number of function arguments low"
msgstr""

       
# CppCoreGuidelines.md:1398
msgid "1398    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1399
msgid "1399    Having many arguments opens opportunities for confusion. Passing lots of arguments is often costly compared to alternatives."
msgstr""

       
# CppCoreGuidelines.md:1400
msgid "1400    ##### Discussion"
msgstr""

       
# CppCoreGuidelines.md:1401
msgid "1401    The two most common reasons why functions have too many parameters are:"
msgstr""

       
# CppCoreGuidelines.md:1402
msgid "1402    1. *Missing an abstraction.*"
msgstr""

# CppCoreGuidelines.md:1403
msgid "1403       There is an abstraction missing, so that a compound value is being"
msgstr""

# CppCoreGuidelines.md:1404
msgid "1404       passed as individual elements instead of as a single object that enforces an invariant."
msgstr""

# CppCoreGuidelines.md:1405
msgid "1405       This not only expands the parameter list, but it leads to errors because the component values"
msgstr""

# CppCoreGuidelines.md:1406
msgid "1406       are no longer protected by an enforced invariant."
msgstr""

       
# CppCoreGuidelines.md:1407
msgid "1407    2. *Violating \"one function, one responsibility.\"*"
msgstr""

# CppCoreGuidelines.md:1408
msgid "1408       The function is trying to do more than one job and should probably be refactored."
msgstr""

       
# CppCoreGuidelines.md:1409
msgid "1409    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1410
msgid "1410    The standard-library `merge()` is at the limit of what we can comfortably handle:"
msgstr""

       
# CppCoreGuidelines.md:1411
msgid "1411        template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>"
msgstr""

# CppCoreGuidelines.md:1412
msgid "1412        OutputIterator merge(InputIterator1 first1, InputIterator1 last1,"
msgstr""

# CppCoreGuidelines.md:1413
msgid "1413                             InputIterator2 first2, InputIterator2 last2,"
msgstr""

# CppCoreGuidelines.md:1414
msgid "1414                             OutputIterator result, Compare comp);"
msgstr""

       
# CppCoreGuidelines.md:1415
msgid "1415    Note that this is because of problem 1 above -- missing abstraction. Instead of passing a range (abstraction), STL passed iterator pairs (unencapsulated component values)."
msgstr""

       
# CppCoreGuidelines.md:1416
msgid "1416    Here, we have four template arguments and six function arguments."
msgstr""

# CppCoreGuidelines.md:1417
msgid "1417    To simplify the most frequent and simplest uses, the comparison argument can be defaulted to `<`:"
msgstr""

       
# CppCoreGuidelines.md:1418
msgid "1418        template<class InputIterator1, class InputIterator2, class OutputIterator>"
msgstr""

# CppCoreGuidelines.md:1419
msgid "1419        OutputIterator merge(InputIterator1 first1, InputIterator1 last1,"
msgstr""

# CppCoreGuidelines.md:1420
msgid "1420                             InputIterator2 first2, InputIterator2 last2,"
msgstr""

# CppCoreGuidelines.md:1421
msgid "1421                             OutputIterator result);"
msgstr""

       
# CppCoreGuidelines.md:1422
msgid "1422    This doesn't reduce the total complexity, but it reduces the surface complexity presented to many users."
msgstr""

# CppCoreGuidelines.md:1423
msgid "1423    To really reduce the number of arguments, we need to bundle the arguments into higher-level abstractions:"
msgstr""

       
# CppCoreGuidelines.md:1424
msgid "1424        template<class InputRange1, class InputRange2, class OutputIterator>"
msgstr""

# CppCoreGuidelines.md:1425
msgid "1425        OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);"
msgstr""

       
# CppCoreGuidelines.md:1426
msgid "1426    Grouping arguments into \"bundles\" is a general technique to reduce the number of arguments and to increase the opportunities for checking."
msgstr""

       
# CppCoreGuidelines.md:1427
msgid "1427    Alternatively, we could use concepts (as defined by the ISO TS) to define the notion of three types that must be usable for merging:"
msgstr""

       
# CppCoreGuidelines.md:1428
msgid "1428        Mergeable{In1, In2, Out}"
msgstr""

# CppCoreGuidelines.md:1429
msgid "1429        OutputIterator merge(In1 r1, In2 r2, Out result);"
msgstr""

       
# CppCoreGuidelines.md:1430
msgid "1430    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1431
msgid "1431    The safety Profiles recommend replacing"
msgstr""

       
# CppCoreGuidelines.md:1432
msgid "1432        void f(int* some_ints, int some_ints_length);  // BAD: C style, unsafe"
msgstr""

       
# CppCoreGuidelines.md:1433
msgid "1433    with"
msgstr""

       
# CppCoreGuidelines.md:1434
msgid "1434        void f(gsl::span<int> some_ints);              // GOOD: safe, bounds-checked"
msgstr""

       
# CppCoreGuidelines.md:1435
msgid "1435    Here, using an abstraction has safety and robustness benefits, and naturally also reduces the number of parameters."
msgstr""

       
# CppCoreGuidelines.md:1436
msgid "1436    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1437
msgid "1437    How many parameters are too many? Try to use fewer than four (4) parameters."
msgstr""

# CppCoreGuidelines.md:1438
msgid "1438    There are functions that are best expressed with four individual parameters, but not many."
msgstr""

       
# CppCoreGuidelines.md:1439
msgid "1439    **Alternative**: Use better abstraction: Group arguments into meaningful objects and pass the objects (by value or by reference)."
msgstr""

       
# CppCoreGuidelines.md:1440
msgid "1440    **Alternative**: Use default arguments or overloads to allow the most common forms of calls to be done with fewer arguments."
msgstr""

       
# CppCoreGuidelines.md:1441
msgid "1441    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1442
msgid "1442    * Warn when a function declares two iterators (including pointers) of the same type instead of a range or a view."
msgstr""

# CppCoreGuidelines.md:1443
msgid "1443    * (Not enforceable) This is a philosophical guideline that is infeasible to check directly."
msgstr""

       
# CppCoreGuidelines.md:1444
msgid "1444    ### <a name=\"Ri-unrelated\"></a>I.24: Avoid adjacent unrelated parameters of the same type"
msgstr""

       
# CppCoreGuidelines.md:1445
msgid "1445    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1446
msgid "1446    Adjacent arguments of the same type are easily swapped by mistake."
msgstr""

       
# CppCoreGuidelines.md:1447
msgid "1447    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1448
msgid "1448    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1449
msgid "1449        void copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)"
msgstr""

       
# CppCoreGuidelines.md:1450
msgid "1450    This is a nasty variant of a K&R C-style interface. It is easy to reverse the \"to\" and \"from\" arguments."
msgstr""

       
# CppCoreGuidelines.md:1451
msgid "1451    Use `const` for the \"from\" argument:"
msgstr""

       
# CppCoreGuidelines.md:1452
msgid "1452        void copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n)"
msgstr""

       
# CppCoreGuidelines.md:1453
msgid "1453    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1454
msgid "1454    If the order of the parameters is not important, there is no problem:"
msgstr""

       
# CppCoreGuidelines.md:1455
msgid "1455        int max(int a, int b);"
msgstr""

       
# CppCoreGuidelines.md:1456
msgid "1456    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:1457
msgid "1457    Don't pass arrays as pointers, pass an object representing a range (e.g., a `span`):"
msgstr""

       
# CppCoreGuidelines.md:1458
msgid "1458        void copy_n(span<const T> p, span<T> q);  // copy from p to q"
msgstr""

       
# CppCoreGuidelines.md:1459
msgid "1459    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:1460
msgid "1460    Define a `struct` as the parameter type and name the fields for those parameters accordingly:"
msgstr""

       
# CppCoreGuidelines.md:1461
msgid "1461        struct SystemParams {"
msgstr""

# CppCoreGuidelines.md:1462
msgid "1462            string config_file;"
msgstr""

# CppCoreGuidelines.md:1463
msgid "1463            string output_path;"
msgstr""

# CppCoreGuidelines.md:1464
msgid "1464            seconds timeout;"
msgstr""

# CppCoreGuidelines.md:1465
msgid "1465        };"
msgstr""

# CppCoreGuidelines.md:1466
msgid "1466        void initialize(SystemParams p);"
msgstr""

       
# CppCoreGuidelines.md:1467
msgid "1467    This tends to make invocations of this clear to future readers, as the parameters"
msgstr""

# CppCoreGuidelines.md:1468
msgid "1468    are often filled in by name at the call site."
msgstr""

       
# CppCoreGuidelines.md:1469
msgid "1469    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1470
msgid "1470    (Simple) Warn if two consecutive parameters share the same type."
msgstr""

       
# CppCoreGuidelines.md:1471
msgid "1471    ### <a name=\"Ri-abstract\"></a>I.25: Prefer abstract classes as interfaces to class hierarchies"
msgstr""

       
# CppCoreGuidelines.md:1472
msgid "1472    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1473
msgid "1473    Abstract classes are more likely to be stable than base classes with state."
msgstr""

       
# CppCoreGuidelines.md:1474
msgid "1474    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1475
msgid "1475    You just knew that `Shape` would turn up somewhere :-)"
msgstr""

       
# CppCoreGuidelines.md:1476
msgid "1476        class Shape {  // bad: interface class loaded with data"
msgstr""

# CppCoreGuidelines.md:1477
msgid "1477        public:"
msgstr""

# CppCoreGuidelines.md:1478
msgid "1478            Point center() const { return c; }"
msgstr""

# CppCoreGuidelines.md:1479
msgid "1479            virtual void draw() const;"
msgstr""

# CppCoreGuidelines.md:1480
msgid "1480            virtual void rotate(int);"
msgstr""

# CppCoreGuidelines.md:1481
msgid "1481            // ..."
msgstr""

# CppCoreGuidelines.md:1482
msgid "1482        private:"
msgstr""

# CppCoreGuidelines.md:1483
msgid "1483            Point c;"
msgstr""

# CppCoreGuidelines.md:1484
msgid "1484            vector<Point> outline;"
msgstr""

# CppCoreGuidelines.md:1485
msgid "1485            Color col;"
msgstr""

# CppCoreGuidelines.md:1486
msgid "1486        };"
msgstr""

       
# CppCoreGuidelines.md:1487
msgid "1487    This will force every derived class to compute a center -- even if that's non-trivial and the center is never used. Similarly, not every `Shape` has a `Color`, and many `Shape`s are best represented without an outline defined as a sequence of `Point`s. Abstract classes were invented to discourage users from writing such classes:"
msgstr""

       
# CppCoreGuidelines.md:1488
msgid "1488        class Shape {    // better: Shape is a pure interface"
msgstr""

# CppCoreGuidelines.md:1489
msgid "1489        public:"
msgstr""

# CppCoreGuidelines.md:1490
msgid "1490            virtual Point center() const = 0;   // pure virtual functions"
msgstr""

# CppCoreGuidelines.md:1491
msgid "1491            virtual void draw() const = 0;"
msgstr""

# CppCoreGuidelines.md:1492
msgid "1492            virtual void rotate(int) = 0;"
msgstr""

# CppCoreGuidelines.md:1493
msgid "1493            // ..."
msgstr""

# CppCoreGuidelines.md:1494
msgid "1494            // ... no data members ..."
msgstr""

# CppCoreGuidelines.md:1495
msgid "1495            // ..."
msgstr""

# CppCoreGuidelines.md:1496
msgid "1496            virtual ~Shape() = default;"
msgstr""

# CppCoreGuidelines.md:1497
msgid "1497        };"
msgstr""

       
# CppCoreGuidelines.md:1498
msgid "1498    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1499
msgid "1499    (Simple) Warn if a pointer/reference to a class `C` is assigned to a pointer/reference to a base of `C` and the base class contains data members."
msgstr""

       
# CppCoreGuidelines.md:1500
msgid "1500    ### <a name=\"Ri-abi\"></a>I.26: If you want a cross-compiler ABI, use a C-style subset"
msgstr""

       
# CppCoreGuidelines.md:1501
msgid "1501    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1502
msgid "1502    Different compilers implement different binary layouts for classes, exception handling, function names, and other implementation details."
msgstr""

       
# CppCoreGuidelines.md:1503
msgid "1503    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1504
msgid "1504    You can carefully craft an interface using a few carefully selected higher-level C++ types. See ???."
msgstr""

       
# CppCoreGuidelines.md:1505
msgid "1505    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1506
msgid "1506    Common ABIs are emerging on some platforms freeing you from the more draconian restrictions."
msgstr""

       
# CppCoreGuidelines.md:1507
msgid "1507    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1508
msgid "1508    If you use a single compiler, you can use full C++ in interfaces. That may require recompilation after an upgrade to a new compiler version."
msgstr""

       
# CppCoreGuidelines.md:1509
msgid "1509    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1510
msgid "1510    (Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI."
msgstr""

       
# CppCoreGuidelines.md:1511
msgid "1511    ### <a name=\"Ri-pimpl\"></a>I.27: For stable library ABI, consider the Pimpl idiom"
msgstr""

       
# CppCoreGuidelines.md:1512
msgid "1512    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1513
msgid "1513    Because private data members participate in class layout and private member functions participate in overload resolution, changes to those"
msgstr""

# CppCoreGuidelines.md:1514
msgid "1514    implementation details require recompilation of all users of a class that uses them. A non-polymorphic interface class holding a pointer to"
msgstr""

# CppCoreGuidelines.md:1515
msgid "1515    implementation (Pimpl) can isolate the users of a class from changes in its implementation at the cost of an indirection."
msgstr""

       
# CppCoreGuidelines.md:1516
msgid "1516    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1517
msgid "1517    interface (widget.h)"
msgstr""

       
# CppCoreGuidelines.md:1518
msgid "1518        class widget {"
msgstr""

# CppCoreGuidelines.md:1519
msgid "1519            class impl;"
msgstr""

# CppCoreGuidelines.md:1520
msgid "1520            std::unique_ptr<impl> pimpl;"
msgstr""

# CppCoreGuidelines.md:1521
msgid "1521        public:"
msgstr""

# CppCoreGuidelines.md:1522
msgid "1522            void draw(); // public API that will be forwarded to the implementation"
msgstr""

# CppCoreGuidelines.md:1523
msgid "1523            widget(int); // defined in the implementation file"
msgstr""

# CppCoreGuidelines.md:1524
msgid "1524            ~widget();   // defined in the implementation file, where impl is a complete type"
msgstr""

# CppCoreGuidelines.md:1525
msgid "1525            widget(widget&&) = default;"
msgstr""

# CppCoreGuidelines.md:1526
msgid "1526            widget(const widget&) = delete;"
msgstr""

# CppCoreGuidelines.md:1527
msgid "1527            widget& operator=(widget&&); // defined in the implementation file"
msgstr""

# CppCoreGuidelines.md:1528
msgid "1528            widget& operator=(const widget&) = delete;"
msgstr""

# CppCoreGuidelines.md:1529
msgid "1529        };"
msgstr""

       
       
# CppCoreGuidelines.md:1530
msgid "1530    implementation (widget.cpp)"
msgstr""

       
# CppCoreGuidelines.md:1531
msgid "1531        class widget::impl {"
msgstr""

# CppCoreGuidelines.md:1532
msgid "1532            int n; // private data"
msgstr""

# CppCoreGuidelines.md:1533
msgid "1533        public:"
msgstr""

# CppCoreGuidelines.md:1534
msgid "1534            void draw(const widget& w) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:1535
msgid "1535            impl(int n) : n(n) {}"
msgstr""

# CppCoreGuidelines.md:1536
msgid "1536        };"
msgstr""

# CppCoreGuidelines.md:1537
msgid "1537        void widget::draw() { pimpl->draw(*this); }"
msgstr""

# CppCoreGuidelines.md:1538
msgid "1538        widget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}"
msgstr""

# CppCoreGuidelines.md:1539
msgid "1539        widget::~widget() = default;"
msgstr""

# CppCoreGuidelines.md:1540
msgid "1540        widget& widget::operator=(widget&&) = default;"
msgstr""

       
# CppCoreGuidelines.md:1541
msgid "1541    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:1542
msgid "1542    See [GOTW #100](https://herbsutter.com/gotw/_100/) and [cppreference](http://en.cppreference.com/w/cpp/language/pimpl) for the trade-offs and additional implementation details associated with this idiom."
msgstr""

       
# CppCoreGuidelines.md:1543
msgid "1543    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1544
msgid "1544    (Not enforceable) It is difficult to reliably identify where an interface forms part of an ABI."
msgstr""

       
# CppCoreGuidelines.md:1545
msgid "1545    ### <a name=\"Ri-encapsulate\"></a>I.30: Encapsulate rule violations"
msgstr""

       
# CppCoreGuidelines.md:1546
msgid "1546    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1547
msgid "1547    To keep code simple and safe."
msgstr""

# CppCoreGuidelines.md:1548
msgid "1548    Sometimes, ugly, unsafe, or error-prone techniques are necessary for logical or performance reasons."
msgstr""

# CppCoreGuidelines.md:1549
msgid "1549    If so, keep them local, rather than \"infecting\" interfaces so that larger groups of programmers have to be aware of the"
msgstr""

# CppCoreGuidelines.md:1550
msgid "1550    subtleties."
msgstr""

# CppCoreGuidelines.md:1551
msgid "1551    Implementation complexity should, if at all possible, not leak through interfaces into user code."
msgstr""

       
# CppCoreGuidelines.md:1552
msgid "1552    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1553
msgid "1553    Consider a program that, depending on some form of input (e.g., arguments to `main`), should consume input"
msgstr""

# CppCoreGuidelines.md:1554
msgid "1554    from a file, from the command line, or from standard input."
msgstr""

# CppCoreGuidelines.md:1555
msgid "1555    We might write"
msgstr""

       
# CppCoreGuidelines.md:1556
msgid "1556        bool owned;"
msgstr""

# CppCoreGuidelines.md:1557
msgid "1557        owner<istream*> inp;"
msgstr""

# CppCoreGuidelines.md:1558
msgid "1558        switch (source) {"
msgstr""

# CppCoreGuidelines.md:1559
msgid "1559        case std_in:        owned = false; inp = &cin;                       break;"
msgstr""

# CppCoreGuidelines.md:1560
msgid "1560        case command_line:  owned = true;  inp = new istringstream{argv[2]}; break;"
msgstr""

# CppCoreGuidelines.md:1561
msgid "1561        case file:          owned = true;  inp = new ifstream{argv[2]};      break;"
msgstr""

# CppCoreGuidelines.md:1562
msgid "1562        }"
msgstr""

# CppCoreGuidelines.md:1563
msgid "1563        istream& in = *inp;"
msgstr""

       
# CppCoreGuidelines.md:1564
msgid "1564    This violated the rule [against uninitialized variables](#Res-always),"
msgstr""

# CppCoreGuidelines.md:1565
msgid "1565    the rule against [ignoring ownership](#Ri-raw),"
msgstr""

# CppCoreGuidelines.md:1566
msgid "1566    and the rule [against magic constants](#Res-magic)."
msgstr""

# CppCoreGuidelines.md:1567
msgid "1567    In particular, someone has to remember to somewhere write"
msgstr""

       
# CppCoreGuidelines.md:1568
msgid "1568        if (owned) delete inp;"
msgstr""

       
# CppCoreGuidelines.md:1569
msgid "1569    We could handle this particular example by using `unique_ptr` with a special deleter that does nothing for `cin`,"
msgstr""

# CppCoreGuidelines.md:1570
msgid "1570    but that's complicated for novices (who can easily encounter this problem) and the example is an example of a more general"
msgstr""

# CppCoreGuidelines.md:1571
msgid "1571    problem where a property that we would like to consider static (here, ownership) needs infrequently be addressed"
msgstr""

# CppCoreGuidelines.md:1572
msgid "1572    at run time."
msgstr""

# CppCoreGuidelines.md:1573
msgid "1573    The common, most frequent, and safest examples can be handled statically, so we don't want to add cost and complexity to those."
msgstr""

# CppCoreGuidelines.md:1574
msgid "1574    But we must also cope with the uncommon, less-safe, and necessarily more expensive cases."
msgstr""

# CppCoreGuidelines.md:1575
msgid "1575    Such examples are discussed in [[Str15]](http://www.stroustrup.com/resource-model.pdf)."
msgstr""

       
# CppCoreGuidelines.md:1576
msgid "1576    So, we write a class"
msgstr""

       
# CppCoreGuidelines.md:1577
msgid "1577        class Istream { [[gsl::suppress(lifetime)]]"
msgstr""

# CppCoreGuidelines.md:1578
msgid "1578        public:"
msgstr""

# CppCoreGuidelines.md:1579
msgid "1579            enum Opt { from_line = 1 };"
msgstr""

# CppCoreGuidelines.md:1580
msgid "1580            Istream() { }"
msgstr""

# CppCoreGuidelines.md:1581
msgid "1581            Istream(zstring p) :owned{true}, inp{new ifstream{p}} {}            // read from file"
msgstr""

# CppCoreGuidelines.md:1582
msgid "1582            Istream(zstring p, Opt) :owned{true}, inp{new istringstream{p}} {}  // read from command line"
msgstr""

# CppCoreGuidelines.md:1583
msgid "1583            ~Istream() { if (owned) delete inp; }"
msgstr""

# CppCoreGuidelines.md:1584
msgid "1584            operator istream& () { return *inp; }"
msgstr""

# CppCoreGuidelines.md:1585
msgid "1585        private:"
msgstr""

# CppCoreGuidelines.md:1586
msgid "1586            bool owned = false;"
msgstr""

# CppCoreGuidelines.md:1587
msgid "1587            istream* inp = &cin;"
msgstr""

# CppCoreGuidelines.md:1588
msgid "1588        };"
msgstr""

       
# CppCoreGuidelines.md:1589
msgid "1589    Now, the dynamic nature of `istream` ownership has been encapsulated."
msgstr""

# CppCoreGuidelines.md:1590
msgid "1590    Presumably, a bit of checking for potential errors would be added in real code."
msgstr""

       
# CppCoreGuidelines.md:1591
msgid "1591    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1592
msgid "1592    * Hard, it is hard to decide what rule-breaking code is essential"
msgstr""

# CppCoreGuidelines.md:1593
msgid "1593    * Flag rule suppression that enable rule-violations to cross interfaces"
msgstr""

       
# CppCoreGuidelines.md:1594
msgid "1594    # <a name=\"S-functions\"></a>F: Functions"
msgstr""

       
# CppCoreGuidelines.md:1595
msgid "1595    A function specifies an action or a computation that takes the system from one consistent state to the next. It is the fundamental building block of programs."
msgstr""

       
# CppCoreGuidelines.md:1596
msgid "1596    It should be possible to name a function meaningfully, to specify the requirements of its argument, and clearly state the relationship between the arguments and the result. An implementation is not a specification. Try to think about what a function does as well as about how it does it."
msgstr""

# CppCoreGuidelines.md:1597
msgid "1597    Functions are the most critical part in most interfaces, so see the interface rules."
msgstr""

       
# CppCoreGuidelines.md:1598
msgid "1598    Function rule summary:"
msgstr""

       
# CppCoreGuidelines.md:1599
msgid "1599    Function definition rules:"
msgstr""

       
# CppCoreGuidelines.md:1600
msgid "1600    * [F.1: \"Package\" meaningful operations as carefully named functions](#Rf-package)"
msgstr""

# CppCoreGuidelines.md:1601
msgid "1601    * [F.2: A function should perform a single logical operation](#Rf-logical)"
msgstr""

# CppCoreGuidelines.md:1602
msgid "1602    * [F.3: Keep functions short and simple](#Rf-single)"
msgstr""

# CppCoreGuidelines.md:1603
msgid "1603    * [F.4: If a function may have to be evaluated at compile time, declare it `constexpr`](#Rf-constexpr)"
msgstr""

# CppCoreGuidelines.md:1604
msgid "1604    * [F.5: If a function is very small and time-critical, declare it inline](#Rf-inline)"
msgstr""

# CppCoreGuidelines.md:1605
msgid "1605    * [F.6: If your function may not throw, declare it `noexcept`](#Rf-noexcept)"
msgstr""

# CppCoreGuidelines.md:1606
msgid "1606    * [F.7: For general use, take `T*` or `T&` arguments rather than smart pointers](#Rf-smart)"
msgstr""

# CppCoreGuidelines.md:1607
msgid "1607    * [F.8: Prefer pure functions](#Rf-pure)"
msgstr""

# CppCoreGuidelines.md:1608
msgid "1608    * [F.9: Unused parameters should be unnamed](#Rf-unused)"
msgstr""

       
# CppCoreGuidelines.md:1609
msgid "1609    Parameter passing expression rules:"
msgstr""

       
# CppCoreGuidelines.md:1610
msgid "1610    * [F.15: Prefer simple and conventional ways of passing information](#Rf-conventional)"
msgstr""

# CppCoreGuidelines.md:1611
msgid "1611    * [F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to `const`](#Rf-in)"
msgstr""

# CppCoreGuidelines.md:1612
msgid "1612    * [F.17: For \"in-out\" parameters, pass by reference to non-`const`](#Rf-inout)"
msgstr""

# CppCoreGuidelines.md:1613
msgid "1613    * [F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::move` the parameter](#Rf-consume)"
msgstr""

# CppCoreGuidelines.md:1614
msgid "1614    * [F.19: For \"forward\" parameters, pass by `TP&&` and only `std::forward` the parameter](#Rf-forward)"
msgstr""

# CppCoreGuidelines.md:1615
msgid "1615    * [F.20: For \"out\" output values, prefer return values to output parameters](#Rf-out)"
msgstr""

# CppCoreGuidelines.md:1616
msgid "1616    * [F.21: To return multiple \"out\" values, prefer returning a struct or tuple](#Rf-out-multi)"
msgstr""

# CppCoreGuidelines.md:1617
msgid "1617    * [F.60: Prefer `T*` over `T&` when \"no argument\" is a valid option](#Rf-ptr-ref)"
msgstr""

       
# CppCoreGuidelines.md:1618
msgid "1618    Parameter passing semantic rules:"
msgstr""

       
# CppCoreGuidelines.md:1619
msgid "1619    * [F.22: Use `T*` or `owner<T*>` to designate a single object](#Rf-ptr)"
msgstr""

# CppCoreGuidelines.md:1620
msgid "1620    * [F.23: Use a `not_null<T>` to indicate that \"null\" is not a valid value](#Rf-nullptr)"
msgstr""

# CppCoreGuidelines.md:1621
msgid "1621    * [F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence](#Rf-range)"
msgstr""

# CppCoreGuidelines.md:1622
msgid "1622    * [F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string](#Rf-zstring)"
msgstr""

# CppCoreGuidelines.md:1623
msgid "1623    * [F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed](#Rf-unique_ptr)"
msgstr""

# CppCoreGuidelines.md:1624
msgid "1624    * [F.27: Use a `shared_ptr<T>` to share ownership](#Rf-shared_ptr)"
msgstr""

       
# CppCoreGuidelines.md:1625
msgid "1625    <a name=\"Rf-value-return\"></a>Value return semantic rules:"
msgstr""

       
# CppCoreGuidelines.md:1626
msgid "1626    * [F.42: Return a `T*` to indicate a position (only)](#Rf-return-ptr)"
msgstr""

# CppCoreGuidelines.md:1627
msgid "1627    * [F.43: Never (directly or indirectly) return a pointer or a reference to a local object](#Rf-dangle)"
msgstr""

# CppCoreGuidelines.md:1628
msgid "1628    * [F.44: Return a `T&` when copy is undesirable and \"returning no object\" isn't needed](#Rf-return-ref)"
msgstr""

# CppCoreGuidelines.md:1629
msgid "1629    * [F.45: Don't return a `T&&`](#Rf-return-ref-ref)"
msgstr""

# CppCoreGuidelines.md:1630
msgid "1630    * [F.46: `int` is the return type for `main()`](#Rf-main)"
msgstr""

# CppCoreGuidelines.md:1631
msgid "1631    * [F.47: Return `T&` from assignment operators](#Rf-assignment-op)"
msgstr""

# CppCoreGuidelines.md:1632
msgid "1632    * [F.48: Don't `return std::move(local)`](#Rf-return-move-local)"
msgstr""

       
# CppCoreGuidelines.md:1633
msgid "1633    Other function rules:"
msgstr""

       
# CppCoreGuidelines.md:1634
msgid "1634    * [F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)](#Rf-capture-vs-overload)"
msgstr""

# CppCoreGuidelines.md:1635
msgid "1635    * [F.51: Where there is a choice, prefer default arguments over overloading](#Rf-default-args)"
msgstr""

# CppCoreGuidelines.md:1636
msgid "1636    * [F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms](#Rf-reference-capture)"
msgstr""

# CppCoreGuidelines.md:1637
msgid "1637    * [F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread](#Rf-value-capture)"
msgstr""

# CppCoreGuidelines.md:1638
msgid "1638    * [F.54: If you capture `this`, capture all variables explicitly (no default capture)](#Rf-this-capture)"
msgstr""

# CppCoreGuidelines.md:1639
msgid "1639    * [F.55: Don't use `va_arg` arguments](#F-varargs)"
msgstr""

       
# CppCoreGuidelines.md:1640
msgid "1640    Functions have strong similarities to lambdas and function objects."
msgstr""

       
# CppCoreGuidelines.md:1641
msgid "1641    **See also**: [C.lambdas: Function objects and lambdas](#SS-lambdas)"
msgstr""

       
# CppCoreGuidelines.md:1642
msgid "1642    ## <a name=\"SS-fct-def\"></a>F.def: Function definitions"
msgstr""

       
# CppCoreGuidelines.md:1643
msgid "1643    A function definition is a function declaration that also specifies the function's implementation, the function body."
msgstr""

       
# CppCoreGuidelines.md:1644
msgid "1644    ### <a name=\"Rf-package\"></a>F.1: \"Package\" meaningful operations as carefully named functions"
msgstr""

       
# CppCoreGuidelines.md:1645
msgid "1645    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1646
msgid "1646    Factoring out common code makes code more readable, more likely to be reused, and limit errors from complex code."
msgstr""

# CppCoreGuidelines.md:1647
msgid "1647    If something is a well-specified action, separate it out from its surrounding code and give it a name."
msgstr""

       
# CppCoreGuidelines.md:1648
msgid "1648    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:1649
msgid "1649        void read_and_print(istream& is)    // read and print an int"
msgstr""

# CppCoreGuidelines.md:1650
msgid "1650        {"
msgstr""

# CppCoreGuidelines.md:1651
msgid "1651            int x;"
msgstr""

# CppCoreGuidelines.md:1652
msgid "1652            if (is >> x)"
msgstr""

# CppCoreGuidelines.md:1653
msgid "1653                cout << \"the int is \" << x << '\\n';"
msgstr""

# CppCoreGuidelines.md:1654
msgid "1654            else"
msgstr""

# CppCoreGuidelines.md:1655
msgid "1655                cerr << \"no int on input\\n\";"
msgstr""

# CppCoreGuidelines.md:1656
msgid "1656        }"
msgstr""

       
# CppCoreGuidelines.md:1657
msgid "1657    Almost everything is wrong with `read_and_print`."
msgstr""

# CppCoreGuidelines.md:1658
msgid "1658    It reads, it writes (to a fixed `ostream`), it writes error messages (to a fixed `ostream`), it handles only `int`s."
msgstr""

# CppCoreGuidelines.md:1659
msgid "1659    There is nothing to reuse, logically separate operations are intermingled and local variables are in scope after the end of their logical use."
msgstr""

# CppCoreGuidelines.md:1660
msgid "1660    For a tiny example, this looks OK, but if the input operation, the output operation, and the error handling had been more complicated the tangled"
msgstr""

# CppCoreGuidelines.md:1661
msgid "1661    mess could become hard to understand."
msgstr""

       
# CppCoreGuidelines.md:1662
msgid "1662    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1663
msgid "1663    If you write a non-trivial lambda that potentially can be used in more than one place, give it a name by assigning it to a (usually non-local) variable."
msgstr""

       
# CppCoreGuidelines.md:1664
msgid "1664    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1665
msgid "1665        sort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); });"
msgstr""

       
# CppCoreGuidelines.md:1666
msgid "1666    Naming that lambda breaks up the expression into its logical parts and provides a strong hint to the meaning of the lambda."
msgstr""

       
# CppCoreGuidelines.md:1667
msgid "1667        auto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };"
msgstr""

       
# CppCoreGuidelines.md:1668
msgid "1668        sort(a, b, lessT);"
msgstr""

# CppCoreGuidelines.md:1669
msgid "1669        find_if(a, b, lessT);"
msgstr""

       
# CppCoreGuidelines.md:1670
msgid "1670    The shortest code is not always the best for performance or maintainability."
msgstr""

       
# CppCoreGuidelines.md:1671
msgid "1671    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1672
msgid "1672    Loop bodies, including lambdas used as loop bodies, rarely need to be named."
msgstr""

# CppCoreGuidelines.md:1673
msgid "1673    However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a problem."
msgstr""

# CppCoreGuidelines.md:1674
msgid "1674    The rule [Keep functions short and simple](#Rf-single) implies \"Keep loop bodies short.\""
msgstr""

# CppCoreGuidelines.md:1675
msgid "1675    Similarly, lambdas used as callback arguments are sometimes non-trivial, yet unlikely to be reusable."
msgstr""

       
# CppCoreGuidelines.md:1676
msgid "1676    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1677
msgid "1677    * See [Keep functions short and simple](#Rf-single)"
msgstr""

# CppCoreGuidelines.md:1678
msgid "1678    * Flag identical and very similar lambdas used in different places."
msgstr""

       
# CppCoreGuidelines.md:1679
msgid "1679    ### <a name=\"Rf-logical\"></a>F.2: A function should perform a single logical operation"
msgstr""

       
# CppCoreGuidelines.md:1680
msgid "1680    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1681
msgid "1681    A function that performs a single operation is simpler to understand, test, and reuse."
msgstr""

       
# CppCoreGuidelines.md:1682
msgid "1682    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1683
msgid "1683    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1684
msgid "1684        void read_and_print()    // bad"
msgstr""

# CppCoreGuidelines.md:1685
msgid "1685        {"
msgstr""

# CppCoreGuidelines.md:1686
msgid "1686            int x;"
msgstr""

# CppCoreGuidelines.md:1687
msgid "1687            cin >> x;"
msgstr""

# CppCoreGuidelines.md:1688
msgid "1688            // check for errors"
msgstr""

# CppCoreGuidelines.md:1689
msgid "1689            cout << x << \"\\n\";"
msgstr""

# CppCoreGuidelines.md:1690
msgid "1690        }"
msgstr""

       
# CppCoreGuidelines.md:1691
msgid "1691    This is a monolith that is tied to a specific input and will never find another (different) use. Instead, break functions up into suitable logical parts and parameterize:"
msgstr""

       
# CppCoreGuidelines.md:1692
msgid "1692        int read(istream& is)    // better"
msgstr""

# CppCoreGuidelines.md:1693
msgid "1693        {"
msgstr""

# CppCoreGuidelines.md:1694
msgid "1694            int x;"
msgstr""

# CppCoreGuidelines.md:1695
msgid "1695            is >> x;"
msgstr""

# CppCoreGuidelines.md:1696
msgid "1696            // check for errors"
msgstr""

# CppCoreGuidelines.md:1697
msgid "1697            return x;"
msgstr""

# CppCoreGuidelines.md:1698
msgid "1698        }"
msgstr""

       
# CppCoreGuidelines.md:1699
msgid "1699        void print(ostream& os, int x)"
msgstr""

# CppCoreGuidelines.md:1700
msgid "1700        {"
msgstr""

# CppCoreGuidelines.md:1701
msgid "1701            os << x << \"\\n\";"
msgstr""

# CppCoreGuidelines.md:1702
msgid "1702        }"
msgstr""

       
# CppCoreGuidelines.md:1703
msgid "1703    These can now be combined where needed:"
msgstr""

       
# CppCoreGuidelines.md:1704
msgid "1704        void read_and_print()"
msgstr""

# CppCoreGuidelines.md:1705
msgid "1705        {"
msgstr""

# CppCoreGuidelines.md:1706
msgid "1706            auto x = read(cin);"
msgstr""

# CppCoreGuidelines.md:1707
msgid "1707            print(cout, x);"
msgstr""

# CppCoreGuidelines.md:1708
msgid "1708        }"
msgstr""

       
# CppCoreGuidelines.md:1709
msgid "1709    If there was a need, we could further templatize `read()` and `print()` on the data type, the I/O mechanism, the response to errors, etc. Example:"
msgstr""

       
# CppCoreGuidelines.md:1710
msgid "1710        auto read = [](auto& input, auto& value)    // better"
msgstr""

# CppCoreGuidelines.md:1711
msgid "1711        {"
msgstr""

# CppCoreGuidelines.md:1712
msgid "1712            input >> value;"
msgstr""

# CppCoreGuidelines.md:1713
msgid "1713            // check for errors"
msgstr""

# CppCoreGuidelines.md:1714
msgid "1714        };"
msgstr""

       
# CppCoreGuidelines.md:1715
msgid "1715        auto print(auto& output, const auto& value)"
msgstr""

# CppCoreGuidelines.md:1716
msgid "1716        {"
msgstr""

# CppCoreGuidelines.md:1717
msgid "1717            output << value << \"\\n\";"
msgstr""

# CppCoreGuidelines.md:1718
msgid "1718        }"
msgstr""

       
# CppCoreGuidelines.md:1719
msgid "1719    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1720
msgid "1720    * Consider functions with more than one \"out\" parameter suspicious. Use return values instead, including `tuple` for multiple return values."
msgstr""

# CppCoreGuidelines.md:1721
msgid "1721    * Consider \"large\" functions that don't fit on one editor screen suspicious. Consider factoring such a function into smaller well-named suboperations."
msgstr""

# CppCoreGuidelines.md:1722
msgid "1722    * Consider functions with 7 or more parameters suspicious."
msgstr""

       
# CppCoreGuidelines.md:1723
msgid "1723    ### <a name=\"Rf-single\"></a>F.3: Keep functions short and simple"
msgstr""

       
# CppCoreGuidelines.md:1724
msgid "1724    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1725
msgid "1725    Large functions are hard to read, more likely to contain complex code, and more likely to have variables in larger than minimal scopes."
msgstr""

# CppCoreGuidelines.md:1726
msgid "1726    Functions with complex control structures are more likely to be long and more likely to hide logical errors"
msgstr""

       
# CppCoreGuidelines.md:1727
msgid "1727    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1728
msgid "1728    Consider:"
msgstr""

       
# CppCoreGuidelines.md:1729
msgid "1729        double simple_func(double val, int flag1, int flag2)"
msgstr""

# CppCoreGuidelines.md:1730
msgid "1730            // simple_func: takes a value and calculates the expected ASIC output,"
msgstr""

# CppCoreGuidelines.md:1731
msgid "1731            // given the two mode flags."
msgstr""

# CppCoreGuidelines.md:1732
msgid "1732        {"
msgstr""

# CppCoreGuidelines.md:1733
msgid "1733            double intermediate;"
msgstr""

# CppCoreGuidelines.md:1734
msgid "1734            if (flag1 > 0) {"
msgstr""

# CppCoreGuidelines.md:1735
msgid "1735                intermediate = func1(val);"
msgstr""

# CppCoreGuidelines.md:1736
msgid "1736                if (flag2 % 2)"
msgstr""

# CppCoreGuidelines.md:1737
msgid "1737                     intermediate = sqrt(intermediate);"
msgstr""

# CppCoreGuidelines.md:1738
msgid "1738            }"
msgstr""

# CppCoreGuidelines.md:1739
msgid "1739            else if (flag1 == -1) {"
msgstr""

# CppCoreGuidelines.md:1740
msgid "1740                intermediate = func1(-val);"
msgstr""

# CppCoreGuidelines.md:1741
msgid "1741                if (flag2 % 2)"
msgstr""

# CppCoreGuidelines.md:1742
msgid "1742                     intermediate = sqrt(-intermediate);"
msgstr""

# CppCoreGuidelines.md:1743
msgid "1743                flag1 = -flag1;"
msgstr""

# CppCoreGuidelines.md:1744
msgid "1744            }"
msgstr""

# CppCoreGuidelines.md:1745
msgid "1745            if (abs(flag2) > 10) {"
msgstr""

# CppCoreGuidelines.md:1746
msgid "1746                intermediate = func2(intermediate);"
msgstr""

# CppCoreGuidelines.md:1747
msgid "1747            }"
msgstr""

# CppCoreGuidelines.md:1748
msgid "1748            switch (flag2 / 10) {"
msgstr""

# CppCoreGuidelines.md:1749
msgid "1749            case 1: if (flag1 == -1) return finalize(intermediate, 1.171);"
msgstr""

# CppCoreGuidelines.md:1750
msgid "1750                    break;"
msgstr""

# CppCoreGuidelines.md:1751
msgid "1751            case 2: return finalize(intermediate, 13.1);"
msgstr""

# CppCoreGuidelines.md:1752
msgid "1752            default: break;"
msgstr""

# CppCoreGuidelines.md:1753
msgid "1753            }"
msgstr""

# CppCoreGuidelines.md:1754
msgid "1754            return finalize(intermediate, 0.);"
msgstr""

# CppCoreGuidelines.md:1755
msgid "1755        }"
msgstr""

       
# CppCoreGuidelines.md:1756
msgid "1756    This is too complex (and long)."
msgstr""

# CppCoreGuidelines.md:1757
msgid "1757    How would you know if all possible alternatives have been correctly handled?"
msgstr""

# CppCoreGuidelines.md:1758
msgid "1758    Yes, it breaks other rules also."
msgstr""

       
# CppCoreGuidelines.md:1759
msgid "1759    We can refactor:"
msgstr""

       
# CppCoreGuidelines.md:1760
msgid "1760        double func1_muon(double val, int flag)"
msgstr""

# CppCoreGuidelines.md:1761
msgid "1761        {"
msgstr""

# CppCoreGuidelines.md:1762
msgid "1762            // ???"
msgstr""

# CppCoreGuidelines.md:1763
msgid "1763        }"
msgstr""

       
# CppCoreGuidelines.md:1764
msgid "1764        double funct1_tau(double val, int flag1, int flag2)"
msgstr""

# CppCoreGuidelines.md:1765
msgid "1765        {"
msgstr""

# CppCoreGuidelines.md:1766
msgid "1766            // ???"
msgstr""

# CppCoreGuidelines.md:1767
msgid "1767        }"
msgstr""

       
# CppCoreGuidelines.md:1768
msgid "1768        double simple_func(double val, int flag1, int flag2)"
msgstr""

# CppCoreGuidelines.md:1769
msgid "1769            // simple_func: takes a value and calculates the expected ASIC output,"
msgstr""

# CppCoreGuidelines.md:1770
msgid "1770            // given the two mode flags."
msgstr""

# CppCoreGuidelines.md:1771
msgid "1771        {"
msgstr""

# CppCoreGuidelines.md:1772
msgid "1772            if (flag1 > 0)"
msgstr""

# CppCoreGuidelines.md:1773
msgid "1773                return func1_muon(val, flag2);"
msgstr""

# CppCoreGuidelines.md:1774
msgid "1774            if (flag1 == -1)"
msgstr""

# CppCoreGuidelines.md:1775
msgid "1775                // handled by func1_tau: flag1 = -flag1;"
msgstr""

# CppCoreGuidelines.md:1776
msgid "1776                return func1_tau(-val, flag1, flag2);"
msgstr""

# CppCoreGuidelines.md:1777
msgid "1777            return 0.;"
msgstr""

# CppCoreGuidelines.md:1778
msgid "1778        }"
msgstr""

       
# CppCoreGuidelines.md:1779
msgid "1779    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1780
msgid "1780    \"It doesn't fit on a screen\" is often a good practical definition of \"far too large.\""
msgstr""

# CppCoreGuidelines.md:1781
msgid "1781    One-to-five-line functions should be considered normal."
msgstr""

       
# CppCoreGuidelines.md:1782
msgid "1782    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1783
msgid "1783    Break large functions up into smaller cohesive and named functions."
msgstr""

# CppCoreGuidelines.md:1784
msgid "1784    Small simple functions are easily inlined where the cost of a function call is significant."
msgstr""

       
# CppCoreGuidelines.md:1785
msgid "1785    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1786
msgid "1786    * Flag functions that do not \"fit on a screen.\""
msgstr""

# CppCoreGuidelines.md:1787
msgid "1787      How big is a screen? Try 60 lines by 140 characters; that's roughly the maximum that's comfortable for a book page."
msgstr""

# CppCoreGuidelines.md:1788
msgid "1788    * Flag functions that are too complex. How complex is too complex?"
msgstr""

# CppCoreGuidelines.md:1789
msgid "1789      You could use cyclomatic complexity. Try \"more than 10 logical path through.\" Count a simple switch as one path."
msgstr""

       
# CppCoreGuidelines.md:1790
msgid "1790    ### <a name=\"Rf-constexpr\"></a>F.4: If a function may have to be evaluated at compile time, declare it `constexpr`"
msgstr""

       
# CppCoreGuidelines.md:1791
msgid "1791    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1792
msgid "1792     `constexpr` is needed to tell the compiler to allow compile-time evaluation."
msgstr""

       
# CppCoreGuidelines.md:1793
msgid "1793    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1794
msgid "1794    The (in)famous factorial:"
msgstr""

       
# CppCoreGuidelines.md:1795
msgid "1795        constexpr int fac(int n)"
msgstr""

# CppCoreGuidelines.md:1796
msgid "1796        {"
msgstr""

# CppCoreGuidelines.md:1797
msgid "1797            constexpr int max_exp = 17;      // constexpr enables max_exp to be used in Expects"
msgstr""

# CppCoreGuidelines.md:1798
msgid "1798            Expects(0 <= n && n < max_exp);  // prevent silliness and overflow"
msgstr""

# CppCoreGuidelines.md:1799
msgid "1799            int x = 1;"
msgstr""

# CppCoreGuidelines.md:1800
msgid "1800            for (int i = 2; i <= n; ++i) x *= i;"
msgstr""

# CppCoreGuidelines.md:1801
msgid "1801            return x;"
msgstr""

# CppCoreGuidelines.md:1802
msgid "1802        }"
msgstr""

       
# CppCoreGuidelines.md:1803
msgid "1803    This is C++14."
msgstr""

# CppCoreGuidelines.md:1804
msgid "1804    For C++11, use a recursive formulation of `fac()`."
msgstr""

       
# CppCoreGuidelines.md:1805
msgid "1805    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1806
msgid "1806    `constexpr` does not guarantee compile-time evaluation;"
msgstr""

# CppCoreGuidelines.md:1807
msgid "1807    it just guarantees that the function can be evaluated at compile time for constant expression arguments if the programmer requires it or the compiler decides to do so to optimize."
msgstr""

       
# CppCoreGuidelines.md:1808
msgid "1808        constexpr int min(int x, int y) { return x < y ? x : y; }"
msgstr""

       
# CppCoreGuidelines.md:1809
msgid "1809        void test(int v)"
msgstr""

# CppCoreGuidelines.md:1810
msgid "1810        {"
msgstr""

# CppCoreGuidelines.md:1811
msgid "1811            int m1 = min(-1, 2);            // probably compile-time evaluation"
msgstr""

# CppCoreGuidelines.md:1812
msgid "1812            constexpr int m2 = min(-1, 2);  // compile-time evaluation"
msgstr""

# CppCoreGuidelines.md:1813
msgid "1813            int m3 = min(-1, v);            // run-time evaluation"
msgstr""

# CppCoreGuidelines.md:1814
msgid "1814            constexpr int m4 = min(-1, v);  // error: cannot evaluate at compile time"
msgstr""

# CppCoreGuidelines.md:1815
msgid "1815        }"
msgstr""

       
# CppCoreGuidelines.md:1816
msgid "1816    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1817
msgid "1817    `constexpr` functions are pure: they can have no side effects."
msgstr""

       
# CppCoreGuidelines.md:1818
msgid "1818        int dcount = 0;"
msgstr""

# CppCoreGuidelines.md:1819
msgid "1819        constexpr int double(int v)"
msgstr""

# CppCoreGuidelines.md:1820
msgid "1820        {"
msgstr""

# CppCoreGuidelines.md:1821
msgid "1821            ++dcount;   // error: attempted side effect from constexpr function"
msgstr""

# CppCoreGuidelines.md:1822
msgid "1822            return v + v;"
msgstr""

# CppCoreGuidelines.md:1823
msgid "1823        }"
msgstr""

       
# CppCoreGuidelines.md:1824
msgid "1824    This is usually a very good thing."
msgstr""

       
# CppCoreGuidelines.md:1825
msgid "1825    When given a non-constant argument, a `constexpr` function can throw."
msgstr""

# CppCoreGuidelines.md:1826
msgid "1826    If you consider exiting by throwing a side effect, a `constexpr` function isn't completely pure;"
msgstr""

# CppCoreGuidelines.md:1827
msgid "1827    if not, this is not an issue."
msgstr""

# CppCoreGuidelines.md:1828
msgid "1828    ??? A question for the committee: can a constructor for an exception thrown by a `constexpr` function modify state?"
msgstr""

# CppCoreGuidelines.md:1829
msgid "1829    \"No\" would be a nice answer that matches most practice."
msgstr""

       
# CppCoreGuidelines.md:1830
msgid "1830    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1831
msgid "1831    Don't try to make all functions `constexpr`."
msgstr""

# CppCoreGuidelines.md:1832
msgid "1832    Most computation is best done at run time."
msgstr""

       
# CppCoreGuidelines.md:1833
msgid "1833    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1834
msgid "1834    Any API that may eventually depend on high-level run-time configuration or"
msgstr""

# CppCoreGuidelines.md:1835
msgid "1835    business logic should not be made `constexpr`. Such customization can not be"
msgstr""

# CppCoreGuidelines.md:1836
msgid "1836    evaluated by the compiler, and any `constexpr` functions that depended upon"
msgstr""

# CppCoreGuidelines.md:1837
msgid "1837    that API would have to be refactored or drop `constexpr`."
msgstr""

       
# CppCoreGuidelines.md:1838
msgid "1838    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1839
msgid "1839    Impossible and unnecessary."
msgstr""

# CppCoreGuidelines.md:1840
msgid "1840    The compiler gives an error if a non-`constexpr` function is called where a constant is required."
msgstr""

       
# CppCoreGuidelines.md:1841
msgid "1841    ### <a name=\"Rf-inline\"></a>F.5: If a function is very small and time-critical, declare it `inline`"
msgstr""

       
# CppCoreGuidelines.md:1842
msgid "1842    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1843
msgid "1843    Some optimizers are good at inlining without hints from the programmer, but don't rely on it."
msgstr""

# CppCoreGuidelines.md:1844
msgid "1844    Measure! Over the last 40 years or so, we have been promised compilers that can inline better than humans without hints from humans."
msgstr""

# CppCoreGuidelines.md:1845
msgid "1845    We are still waiting."
msgstr""

# CppCoreGuidelines.md:1846
msgid "1846    Specifying `inline` encourages the compiler to do a better job."
msgstr""

       
# CppCoreGuidelines.md:1847
msgid "1847    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1848
msgid "1848        inline string cat(const string& s, const string& s2) { return s + s2; }"
msgstr""

       
# CppCoreGuidelines.md:1849
msgid "1849    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1850
msgid "1850    Do not put an `inline` function in what is meant to be a stable interface unless you are certain that it will not change."
msgstr""

# CppCoreGuidelines.md:1851
msgid "1851    An inline function is part of the ABI."
msgstr""

       
# CppCoreGuidelines.md:1852
msgid "1852    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1853
msgid "1853    `constexpr` implies `inline`."
msgstr""

       
# CppCoreGuidelines.md:1854
msgid "1854    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1855
msgid "1855    Member functions defined in-class are `inline` by default."
msgstr""

       
# CppCoreGuidelines.md:1856
msgid "1856    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:1857
msgid "1857    Template functions (incl. template member functions) are normally defined in headers and therefore inline."
msgstr""

       
# CppCoreGuidelines.md:1858
msgid "1858    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1859
msgid "1859    Flag `inline` functions that are more than three statements and could have been declared out of line (such as class member functions)."
msgstr""

       
# CppCoreGuidelines.md:1860
msgid "1860    ### <a name=\"Rf-noexcept\"></a>F.6: If your function may not throw, declare it `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:1861
msgid "1861    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1862
msgid "1862    If an exception is not supposed to be thrown, the program cannot be assumed to cope with the error and should be terminated as soon as possible. Declaring a function `noexcept` helps optimizers by reducing the number of alternative execution paths. It also speeds up the exit after failure."
msgstr""

       
# CppCoreGuidelines.md:1863
msgid "1863    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1864
msgid "1864    Put `noexcept` on every function written completely in C or in any other language without exceptions."
msgstr""

# CppCoreGuidelines.md:1865
msgid "1865    The C++ Standard Library does that implicitly for all functions in the C Standard Library."
msgstr""

       
# CppCoreGuidelines.md:1866
msgid "1866    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1867
msgid "1867    `constexpr` functions can throw when evaluated at run time, so you may need `noexcept` for some of those."
msgstr""

       
# CppCoreGuidelines.md:1868
msgid "1868    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1869
msgid "1869    You can use `noexcept` even on functions that can throw:"
msgstr""

       
# CppCoreGuidelines.md:1870
msgid "1870        vector<string> collect(istream& is) noexcept"
msgstr""

# CppCoreGuidelines.md:1871
msgid "1871        {"
msgstr""

# CppCoreGuidelines.md:1872
msgid "1872            vector<string> res;"
msgstr""

# CppCoreGuidelines.md:1873
msgid "1873            for (string s; is >> s;)"
msgstr""

# CppCoreGuidelines.md:1874
msgid "1874                res.push_back(s);"
msgstr""

# CppCoreGuidelines.md:1875
msgid "1875            return res;"
msgstr""

# CppCoreGuidelines.md:1876
msgid "1876        }"
msgstr""

       
# CppCoreGuidelines.md:1877
msgid "1877    If `collect()` runs out of memory, the program crashes."
msgstr""

# CppCoreGuidelines.md:1878
msgid "1878    Unless the program is crafted to survive memory exhaustion, that may be just the right thing to do;"
msgstr""

# CppCoreGuidelines.md:1879
msgid "1879    `terminate()` may generate suitable error log information (but after memory runs out it is hard to do anything clever)."
msgstr""

       
# CppCoreGuidelines.md:1880
msgid "1880    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1881
msgid "1881    You must be aware of the execution environment that your code is running when"
msgstr""

# CppCoreGuidelines.md:1882
msgid "1882    deciding whether to tag a function `noexcept`, especially because of the issue"
msgstr""

# CppCoreGuidelines.md:1883
msgid "1883    of throwing and allocation.  Code that is intended to be perfectly general (like"
msgstr""

# CppCoreGuidelines.md:1884
msgid "1884    the standard library and other utility code of that sort) needs to support"
msgstr""

# CppCoreGuidelines.md:1885
msgid "1885    environments where a `bad_alloc` exception may be handled meaningfully."
msgstr""

# CppCoreGuidelines.md:1886
msgid "1886    However, most programs and execution environments cannot meaningfully"
msgstr""

# CppCoreGuidelines.md:1887
msgid "1887    handle a failure to allocate, and aborting the program is the cleanest and"
msgstr""

# CppCoreGuidelines.md:1888
msgid "1888    simplest response to an allocation failure in those cases.  If you know that"
msgstr""

# CppCoreGuidelines.md:1889
msgid "1889    your application code cannot respond to an allocation failure, it may be"
msgstr""

# CppCoreGuidelines.md:1890
msgid "1890    appropriate to add `noexcept` even on functions that allocate."
msgstr""

       
# CppCoreGuidelines.md:1891
msgid "1891    Put another way: In most programs, most functions can throw (e.g., because they"
msgstr""

# CppCoreGuidelines.md:1892
msgid "1892    use `new`, call functions that do, or use library functions that reports failure"
msgstr""

# CppCoreGuidelines.md:1893
msgid "1893    by throwing), so don't just sprinkle `noexcept` all over the place without"
msgstr""

# CppCoreGuidelines.md:1894
msgid "1894    considering whether the possible exceptions can be handled."
msgstr""

       
# CppCoreGuidelines.md:1895
msgid "1895    `noexcept` is most useful (and most clearly correct) for frequently used,"
msgstr""

# CppCoreGuidelines.md:1896
msgid "1896    low-level functions."
msgstr""

       
# CppCoreGuidelines.md:1897
msgid "1897    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1898
msgid "1898    Destructors, `swap` functions, move operations, and default constructors should never throw."
msgstr""

       
# CppCoreGuidelines.md:1899
msgid "1899    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1900
msgid "1900    * Flag functions that are not `noexcept`, yet cannot throw."
msgstr""

# CppCoreGuidelines.md:1901
msgid "1901    * Flag throwing `swap`, `move`, destructors, and default constructors."
msgstr""

       
# CppCoreGuidelines.md:1902
msgid "1902    ### <a name=\"Rf-smart\"></a>F.7: For general use, take `T*` or `T&` arguments rather than smart pointers"
msgstr""

       
# CppCoreGuidelines.md:1903
msgid "1903    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1904
msgid "1904    Passing a smart pointer transfers or shares ownership and should only be used when ownership semantics are intended (see [R.30](#Rr-smartptrparam))."
msgstr""

# CppCoreGuidelines.md:1905
msgid "1905    Passing by smart pointer restricts the use of a function to callers that use smart pointers."
msgstr""

# CppCoreGuidelines.md:1906
msgid "1906    Passing a shared smart pointer (e.g., `std::shared_ptr`) implies a run-time cost."
msgstr""

       
# CppCoreGuidelines.md:1907
msgid "1907    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1908
msgid "1908        // accepts any int*"
msgstr""

# CppCoreGuidelines.md:1909
msgid "1909        void f(int*);"
msgstr""

       
# CppCoreGuidelines.md:1910
msgid "1910        // can only accept ints for which you want to transfer ownership"
msgstr""

# CppCoreGuidelines.md:1911
msgid "1911        void g(unique_ptr<int>);"
msgstr""

       
# CppCoreGuidelines.md:1912
msgid "1912        // can only accept ints for which you are willing to share ownership"
msgstr""

# CppCoreGuidelines.md:1913
msgid "1913        void g(shared_ptr<int>);"
msgstr""

       
# CppCoreGuidelines.md:1914
msgid "1914        // doesn't change ownership, but requires a particular ownership of the caller"
msgstr""

# CppCoreGuidelines.md:1915
msgid "1915        void h(const unique_ptr<int>&);"
msgstr""

       
# CppCoreGuidelines.md:1916
msgid "1916        // accepts any int"
msgstr""

# CppCoreGuidelines.md:1917
msgid "1917        void h(int&);"
msgstr""

       
# CppCoreGuidelines.md:1918
msgid "1918    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:1919
msgid "1919        // callee"
msgstr""

# CppCoreGuidelines.md:1920
msgid "1920        void f(shared_ptr<widget>& w)"
msgstr""

# CppCoreGuidelines.md:1921
msgid "1921        {"
msgstr""

# CppCoreGuidelines.md:1922
msgid "1922            // ..."
msgstr""

# CppCoreGuidelines.md:1923
msgid "1923            use(*w); // only use of w -- the lifetime is not used at all"
msgstr""

# CppCoreGuidelines.md:1924
msgid "1924            // ..."
msgstr""

# CppCoreGuidelines.md:1925
msgid "1925        };"
msgstr""

       
# CppCoreGuidelines.md:1926
msgid "1926    See further in [R.30](#Rr-smartptrparam)."
msgstr""

       
# CppCoreGuidelines.md:1927
msgid "1927    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1928
msgid "1928    We can catch dangling pointers statically, so we don't need to rely on resource management to avoid violations from dangling pointers."
msgstr""

       
# CppCoreGuidelines.md:1929
msgid "1929    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:1930
msgid "1930    * [Prefer `T*` over `T&` when \"no argument\" is a valid option](#Rf-ptr-ref)"
msgstr""

# CppCoreGuidelines.md:1931
msgid "1931    * [Smart pointer rule summary](#Rr-summary-smartptrs)"
msgstr""

       
# CppCoreGuidelines.md:1932
msgid "1932    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1933
msgid "1933    Flag a parameter of a smart pointer type (a type that overloads `operator->` or `operator*`) for which the ownership semantics are not used;"
msgstr""

# CppCoreGuidelines.md:1934
msgid "1934    that is"
msgstr""

       
# CppCoreGuidelines.md:1935
msgid "1935    * copyable but never copied/moved from or movable but never moved"
msgstr""

# CppCoreGuidelines.md:1936
msgid "1936    * and that is never modified or passed along to another function that could do so."
msgstr""

       
# CppCoreGuidelines.md:1937
msgid "1937    ### <a name=\"Rf-pure\"></a>F.8: Prefer pure functions"
msgstr""

       
# CppCoreGuidelines.md:1938
msgid "1938    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1939
msgid "1939    Pure functions are easier to reason about, sometimes easier to optimize (and even parallelize), and sometimes can be memoized."
msgstr""

       
# CppCoreGuidelines.md:1940
msgid "1940    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1941
msgid "1941        template<class T>"
msgstr""

# CppCoreGuidelines.md:1942
msgid "1942        auto square(T t) { return t * t; }"
msgstr""

       
# CppCoreGuidelines.md:1943
msgid "1943    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1944
msgid "1944    `constexpr` functions are pure."
msgstr""

       
# CppCoreGuidelines.md:1945
msgid "1945    When given a non-constant argument, a `constexpr` function can throw."
msgstr""

# CppCoreGuidelines.md:1946
msgid "1946    If you consider exiting by throwing a side effect, a `constexpr` function isn't completely pure;"
msgstr""

# CppCoreGuidelines.md:1947
msgid "1947    if not, this is not an issue."
msgstr""

# CppCoreGuidelines.md:1948
msgid "1948    ??? A question for the committee: can a constructor for an exception thrown by a `constexpr` function modify state?"
msgstr""

# CppCoreGuidelines.md:1949
msgid "1949    \"No\" would be a nice answer that matches most practice."
msgstr""

       
# CppCoreGuidelines.md:1950
msgid "1950    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1951
msgid "1951    Not possible."
msgstr""

       
# CppCoreGuidelines.md:1952
msgid "1952    ### <a name=\"Rf-unused\"></a>F.9: Unused parameters should be unnamed"
msgstr""

       
# CppCoreGuidelines.md:1953
msgid "1953    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1954
msgid "1954    Readability."
msgstr""

# CppCoreGuidelines.md:1955
msgid "1955    Suppression of unused parameter warnings."
msgstr""

       
# CppCoreGuidelines.md:1956
msgid "1956    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1957
msgid "1957        X* find(map<Blob>& m, const string& s, Hint);   // once upon a time, a hint was used"
msgstr""

       
# CppCoreGuidelines.md:1958
msgid "1958    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:1959
msgid "1959    Allowing parameters to be unnamed was introduced in the early 1980 to address this problem."
msgstr""

       
# CppCoreGuidelines.md:1960
msgid "1960    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:1961
msgid "1961    Flag named unused parameters."
msgstr""

       
# CppCoreGuidelines.md:1962
msgid "1962    ## <a name=\"SS-call\"></a>F.call: Parameter passing"
msgstr""

       
# CppCoreGuidelines.md:1963
msgid "1963    There are a variety of ways to pass parameters to a function and to return values."
msgstr""

       
# CppCoreGuidelines.md:1964
msgid "1964    ### <a name=\"Rf-conventional\"></a>F.15: Prefer simple and conventional ways of passing information"
msgstr""

       
# CppCoreGuidelines.md:1965
msgid "1965    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1966
msgid "1966    Using \"unusual and clever\" techniques causes surprises, slows understanding by other programmers, and encourages bugs."
msgstr""

# CppCoreGuidelines.md:1967
msgid "1967    If you really feel the need for an optimization beyond the common techniques, measure to ensure that it really is an improvement, and document/comment because the improvement may not be portable."
msgstr""

       
# CppCoreGuidelines.md:1968
msgid "1968    The following tables summarize the advice in the following Guidelines, F.16-21."
msgstr""

       
# CppCoreGuidelines.md:1969
msgid "1969    Normal parameter passing:"
msgstr""

       
# CppCoreGuidelines.md:1970
msgid "1970    ![Normal parameter passing table](./param-passing-normal.png \"Normal parameter passing\")"
msgstr""

       
# CppCoreGuidelines.md:1971
msgid "1971    Advanced parameter passing:"
msgstr""

       
# CppCoreGuidelines.md:1972
msgid "1972    ![Advanced parameter passing table](./param-passing-advanced.png \"Advanced parameter passing\")"
msgstr""

       
# CppCoreGuidelines.md:1973
msgid "1973    Use the advanced techniques only after demonstrating need, and document that need in a comment."
msgstr""

       
# CppCoreGuidelines.md:1974
msgid "1974    ### <a name=\"Rf-in\"></a>F.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to `const`"
msgstr""

       
# CppCoreGuidelines.md:1975
msgid "1975    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:1976
msgid "1976    Both let the caller know that a function will not modify the argument, and both allow initialization by rvalues."
msgstr""

       
# CppCoreGuidelines.md:1977
msgid "1977    What is \"cheap to copy\" depends on the machine architecture, but two or three words (doubles, pointers, references) are usually best passed by value."
msgstr""

# CppCoreGuidelines.md:1978
msgid "1978    When copying is cheap, nothing beats the simplicity and safety of copying, and for small objects (up to two or three words) it is also faster than passing by reference because it does not require an extra indirection to access from the function."
msgstr""

       
# CppCoreGuidelines.md:1979
msgid "1979    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1980
msgid "1980        void f1(const string& s);  // OK: pass by reference to const; always cheap"
msgstr""

       
# CppCoreGuidelines.md:1981
msgid "1981        void f2(string s);         // bad: potentially expensive"
msgstr""

       
# CppCoreGuidelines.md:1982
msgid "1982        void f3(int x);            // OK: Unbeatable"
msgstr""

       
# CppCoreGuidelines.md:1983
msgid "1983        void f4(const int& x);     // bad: overhead on access in f4()"
msgstr""

       
# CppCoreGuidelines.md:1984
msgid "1984    For advanced uses (only), where you really need to optimize for rvalues passed to \"input-only\" parameters:"
msgstr""

       
# CppCoreGuidelines.md:1985
msgid "1985    * If the function is going to unconditionally move from the argument, take it by `&&`. See [F.18](#Rf-consume)."
msgstr""

# CppCoreGuidelines.md:1986
msgid "1986    * If the function is going to keep a copy of the argument, in addition to passing by `const&` (for lvalues),"
msgstr""

# CppCoreGuidelines.md:1987
msgid "1987      add an overload that passes the parameter by `&&` (for rvalues) and in the body `std::move`s it to its destination. Essentially this overloads a \"will-move-from\"; see [F.18](#Rf-consume)."
msgstr""

# CppCoreGuidelines.md:1988
msgid "1988    * In special cases, such as multiple \"input + copy\" parameters, consider using perfect forwarding. See [F.19](#Rf-forward)."
msgstr""

       
# CppCoreGuidelines.md:1989
msgid "1989    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1990
msgid "1990        int multiply(int, int); // just input ints, pass by value"
msgstr""

       
# CppCoreGuidelines.md:1991
msgid "1991        // suffix is input-only but not as cheap as an int, pass by const&"
msgstr""

# CppCoreGuidelines.md:1992
msgid "1992        string& concatenate(string&, const string& suffix);"
msgstr""

       
# CppCoreGuidelines.md:1993
msgid "1993        void sink(unique_ptr<widget>);  // input only, and moves ownership of the widget"
msgstr""

       
# CppCoreGuidelines.md:1994
msgid "1994    Avoid \"esoteric techniques\" such as:"
msgstr""

       
# CppCoreGuidelines.md:1995
msgid "1995    * Passing arguments as `T&&` \"for efficiency\"."
msgstr""

# CppCoreGuidelines.md:1996
msgid "1996      Most rumors about performance advantages from passing by `&&` are false or brittle (but see [F.18](#Rf-consume) and [F.19](#Rf-forward))."
msgstr""

# CppCoreGuidelines.md:1997
msgid "1997    * Returning `const T&` from assignments and similar operations (see [F.47](#Rf-assignment-op).)"
msgstr""

       
# CppCoreGuidelines.md:1998
msgid "1998    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:1999
msgid "1999    Assuming that `Matrix` has move operations (possibly by keeping its elements in a `std::vector`):"
msgstr""

       
# CppCoreGuidelines.md:2000
msgid "2000        Matrix operator+(const Matrix& a, const Matrix& b)"
msgstr""

# CppCoreGuidelines.md:2001
msgid "2001        {"
msgstr""

# CppCoreGuidelines.md:2002
msgid "2002            Matrix res;"
msgstr""

# CppCoreGuidelines.md:2003
msgid "2003            // ... fill res with the sum ..."
msgstr""

# CppCoreGuidelines.md:2004
msgid "2004            return res;"
msgstr""

# CppCoreGuidelines.md:2005
msgid "2005        }"
msgstr""

       
# CppCoreGuidelines.md:2006
msgid "2006        Matrix x = m1 + m2;  // move constructor"
msgstr""

       
# CppCoreGuidelines.md:2007
msgid "2007        y = m3 + m3;         // move assignment"
msgstr""

       
# CppCoreGuidelines.md:2008
msgid "2008    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:2009
msgid "2009    The return value optimization doesn't handle the assignment case, but the move assignment does."
msgstr""

       
# CppCoreGuidelines.md:2010
msgid "2010    A reference may be assumed to refer to a valid object (language rule)."
msgstr""

# CppCoreGuidelines.md:2011
msgid "2011    There is no (legitimate) \"null reference.\""
msgstr""

# CppCoreGuidelines.md:2012
msgid "2012    If you need the notion of an optional value, use a pointer, `std::optional`, or a special value used to denote \"no value.\""
msgstr""

       
# CppCoreGuidelines.md:2013
msgid "2013    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2014
msgid "2014    * (Simple) ((Foundation)) Warn when a parameter being passed by value has a size greater than `4 * sizeof(int)`."
msgstr""

# CppCoreGuidelines.md:2015
msgid "2015      Suggest using a reference to `const` instead."
msgstr""

# CppCoreGuidelines.md:2016
msgid "2016    * (Simple) ((Foundation)) Warn when a `const` parameter being passed by reference has a size less than `3 * sizeof(int)`. Suggest passing by value instead."
msgstr""

# CppCoreGuidelines.md:2017
msgid "2017    * (Simple) ((Foundation)) Warn when a `const` parameter being passed by reference is `move`d."
msgstr""

       
# CppCoreGuidelines.md:2018
msgid "2018    ### <a name=\"Rf-inout\"></a>F.17: For \"in-out\" parameters, pass by reference to non-`const`"
msgstr""

       
# CppCoreGuidelines.md:2019
msgid "2019    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2020
msgid "2020    This makes it clear to callers that the object is assumed to be modified."
msgstr""

       
# CppCoreGuidelines.md:2021
msgid "2021    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2022
msgid "2022        void update(Record& r);  // assume that update writes to r"
msgstr""

       
# CppCoreGuidelines.md:2023
msgid "2023    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2024
msgid "2024    A `T&` argument can pass information into a function as well as out of it."
msgstr""

# CppCoreGuidelines.md:2025
msgid "2025    Thus `T&` could be an in-out-parameter. That can in itself be a problem and a source of errors:"
msgstr""

       
# CppCoreGuidelines.md:2026
msgid "2026        void f(string& s)"
msgstr""

# CppCoreGuidelines.md:2027
msgid "2027        {"
msgstr""

# CppCoreGuidelines.md:2028
msgid "2028            s = \"New York\";  // non-obvious error"
msgstr""

# CppCoreGuidelines.md:2029
msgid "2029        }"
msgstr""

       
# CppCoreGuidelines.md:2030
msgid "2030        void g()"
msgstr""

# CppCoreGuidelines.md:2031
msgid "2031        {"
msgstr""

# CppCoreGuidelines.md:2032
msgid "2032            string buffer = \".................................\";"
msgstr""

# CppCoreGuidelines.md:2033
msgid "2033            f(buffer);"
msgstr""

# CppCoreGuidelines.md:2034
msgid "2034            // ..."
msgstr""

# CppCoreGuidelines.md:2035
msgid "2035        }"
msgstr""

       
# CppCoreGuidelines.md:2036
msgid "2036    Here, the writer of `g()` is supplying a buffer for `f()` to fill, but `f()` simply replaces it (at a somewhat higher cost than a simple copy of the characters)."
msgstr""

# CppCoreGuidelines.md:2037
msgid "2037    A bad logic error can happen if the writer of `g()` incorrectly assumes the size of the `buffer`."
msgstr""

       
# CppCoreGuidelines.md:2038
msgid "2038    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2039
msgid "2039    * (Moderate) ((Foundation)) Warn about functions regarding reference to non-`const` parameters that do *not* write to them."
msgstr""

# CppCoreGuidelines.md:2040
msgid "2040    * (Simple) ((Foundation)) Warn when a non-`const` parameter being passed by reference is `move`d."
msgstr""

       
# CppCoreGuidelines.md:2041
msgid "2041    ### <a name=\"Rf-consume\"></a>F.18: For \"will-move-from\" parameters, pass by `X&&` and `std::move` the parameter"
msgstr""

       
# CppCoreGuidelines.md:2042
msgid "2042    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2043
msgid "2043    It's efficient and eliminates bugs at the call site: `X&&` binds to rvalues, which requires an explicit `std::move` at the call site if passing an lvalue."
msgstr""

       
# CppCoreGuidelines.md:2044
msgid "2044    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2045
msgid "2045        void sink(vector<int>&& v) {   // sink takes ownership of whatever the argument owned"
msgstr""

# CppCoreGuidelines.md:2046
msgid "2046            // usually there might be const accesses of v here"
msgstr""

# CppCoreGuidelines.md:2047
msgid "2047            store_somewhere(std::move(v));"
msgstr""

# CppCoreGuidelines.md:2048
msgid "2048            // usually no more use of v here; it is moved-from"
msgstr""

# CppCoreGuidelines.md:2049
msgid "2049        }"
msgstr""

       
# CppCoreGuidelines.md:2050
msgid "2050    Note that the `std::move(v)` makes it possible for `store_somewhere()` to leave `v` in a moved-from state."
msgstr""

# CppCoreGuidelines.md:2051
msgid "2051    [That could be dangerous](#Rc-move-semantic)."
msgstr""

       
       
# CppCoreGuidelines.md:2052
msgid "2052    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2053
msgid "2053    Unique owner types that are move-only and cheap-to-move, such as `unique_ptr`, can also be passed by value which is simpler to write and achieves the same effect. Passing by value does generate one extra (cheap) move operation, but prefer simplicity and clarity first."
msgstr""

       
# CppCoreGuidelines.md:2054
msgid "2054    For example:"
msgstr""

       
# CppCoreGuidelines.md:2055
msgid "2055        template <class T>"
msgstr""

# CppCoreGuidelines.md:2056
msgid "2056        void sink(std::unique_ptr<T> p) {"
msgstr""

# CppCoreGuidelines.md:2057
msgid "2057            // use p ... possibly std::move(p) onward somewhere else"
msgstr""

# CppCoreGuidelines.md:2058
msgid "2058        }   // p gets destroyed"
msgstr""

       
# CppCoreGuidelines.md:2059
msgid "2059    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2060
msgid "2060    * Flag all `X&&` parameters (where `X` is not a template type parameter name) where the function body uses them without `std::move`."
msgstr""

# CppCoreGuidelines.md:2061
msgid "2061    * Flag access to moved-from objects."
msgstr""

# CppCoreGuidelines.md:2062
msgid "2062    * Don't conditionally move from objects"
msgstr""

       
# CppCoreGuidelines.md:2063
msgid "2063    ### <a name=\"Rf-forward\"></a>F.19: For \"forward\" parameters, pass by `TP&&` and only `std::forward` the parameter"
msgstr""

       
# CppCoreGuidelines.md:2064
msgid "2064    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2065
msgid "2065    If the object is to be passed onward to other code and not directly used by this function, we want to make this function agnostic to the argument `const`-ness and rvalue-ness."
msgstr""

       
# CppCoreGuidelines.md:2066
msgid "2066    In that case, and only that case, make the parameter `TP&&` where `TP` is a template type parameter -- it both *ignores* and *preserves* `const`-ness and rvalue-ness. Therefore any code that uses a `TP&&` is implicitly declaring that it itself doesn't care about the variable's `const`-ness and rvalue-ness (because it is ignored), but that intends to pass the value onward to other code that does care about `const`-ness and rvalue-ness (because it is preserved). When used as a parameter `TP&&` is safe because any temporary objects passed from the caller will live for the duration of the function call. A parameter of type `TP&&` should essentially always be passed onward via `std::forward` in the body of the function."
msgstr""

       
# CppCoreGuidelines.md:2067
msgid "2067    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2068
msgid "2068        template <class F, class... Args>"
msgstr""

# CppCoreGuidelines.md:2069
msgid "2069        inline auto invoke(F f, Args&&... args) {"
msgstr""

# CppCoreGuidelines.md:2070
msgid "2070            return f(forward<Args>(args)...);"
msgstr""

# CppCoreGuidelines.md:2071
msgid "2071        }"
msgstr""

       
# CppCoreGuidelines.md:2072
msgid "2072        ??? calls ???"
msgstr""

       
# CppCoreGuidelines.md:2073
msgid "2073    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2074
msgid "2074    * Flag a function that takes a `TP&&` parameter (where `TP` is a template type parameter name) and does anything with it other than `std::forward`ing it exactly once on every static path."
msgstr""

       
# CppCoreGuidelines.md:2075
msgid "2075    ### <a name=\"Rf-out\"></a>F.20: For \"out\" output values, prefer return values to output parameters"
msgstr""

       
# CppCoreGuidelines.md:2076
msgid "2076    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2077
msgid "2077    A return value is self-documenting, whereas a `&` could be either in-out or out-only and is liable to be misused."
msgstr""

       
# CppCoreGuidelines.md:2078
msgid "2078    This includes large objects like standard containers that use implicit move operations for performance and to avoid explicit memory management."
msgstr""

       
# CppCoreGuidelines.md:2079
msgid "2079    If you have multiple values to return, [use a tuple](#Rf-out-multi) or similar multi-member type."
msgstr""

       
# CppCoreGuidelines.md:2080
msgid "2080    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2081
msgid "2081        // OK: return pointers to elements with the value x"
msgstr""

# CppCoreGuidelines.md:2082
msgid "2082        vector<const int*> find_all(const vector<int>&, int x);"
msgstr""

       
# CppCoreGuidelines.md:2083
msgid "2083        // Bad: place pointers to elements with value x in-out"
msgstr""

# CppCoreGuidelines.md:2084
msgid "2084        void find_all(const vector<int>&, vector<const int*>& out, int x);"
msgstr""

       
# CppCoreGuidelines.md:2085
msgid "2085    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2086
msgid "2086    A `struct` of many (individually cheap-to-move) elements may be in aggregate expensive to move."
msgstr""

       
# CppCoreGuidelines.md:2087
msgid "2087    It is not recommended to return a `const` value."
msgstr""

# CppCoreGuidelines.md:2088
msgid "2088    Such older advice is now obsolete; it does not add value, and it interferes with move semantics."
msgstr""

       
# CppCoreGuidelines.md:2089
msgid "2089        const vector<int> fct();    // bad: that \"const\" is more trouble than it is worth"
msgstr""

       
# CppCoreGuidelines.md:2090
msgid "2090        vector<int> g(const vector<int>& vx)"
msgstr""

# CppCoreGuidelines.md:2091
msgid "2091        {"
msgstr""

# CppCoreGuidelines.md:2092
msgid "2092            // ..."
msgstr""

# CppCoreGuidelines.md:2093
msgid "2093            fct() = vx;   // prevented by the \"const\""
msgstr""

# CppCoreGuidelines.md:2094
msgid "2094            // ..."
msgstr""

# CppCoreGuidelines.md:2095
msgid "2095            return fct(); // expensive copy: move semantics suppressed by the \"const\""
msgstr""

# CppCoreGuidelines.md:2096
msgid "2096        }"
msgstr""

       
# CppCoreGuidelines.md:2097
msgid "2097    The argument for adding `const` to a return value is that it prevents (very rare) accidental access to a temporary."
msgstr""

# CppCoreGuidelines.md:2098
msgid "2098    The argument against is prevents (very frequent) use of move semantics."
msgstr""

       
# CppCoreGuidelines.md:2099
msgid "2099    ##### Exceptions"
msgstr""

       
# CppCoreGuidelines.md:2100
msgid "2100    * For non-value types, such as types in an inheritance hierarchy, return the object by `unique_ptr` or `shared_ptr`."
msgstr""

# CppCoreGuidelines.md:2101
msgid "2101    * If a type is expensive to move (e.g., `array<BigPOD>`), consider allocating it on the free store and return a handle (e.g., `unique_ptr`), or passing it in a reference to non-`const` target object to fill (to be used as an out-parameter)."
msgstr""

# CppCoreGuidelines.md:2102
msgid "2102    * To reuse an object that carries capacity (e.g., `std::string`, `std::vector`) across multiple calls to the function in an inner loop: [treat it as an in/out parameter and pass by reference](#Rf-out-multi)."
msgstr""

       
# CppCoreGuidelines.md:2103
msgid "2103    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2104
msgid "2104        struct Package {      // exceptional case: expensive-to-move object"
msgstr""

# CppCoreGuidelines.md:2105
msgid "2105            char header[16];"
msgstr""

# CppCoreGuidelines.md:2106
msgid "2106            char load[2024 - 16];"
msgstr""

# CppCoreGuidelines.md:2107
msgid "2107        };"
msgstr""

       
# CppCoreGuidelines.md:2108
msgid "2108        Package fill();       // Bad: large return value"
msgstr""

# CppCoreGuidelines.md:2109
msgid "2109        void fill(Package&);  // OK"
msgstr""

       
# CppCoreGuidelines.md:2110
msgid "2110        int val();            // OK"
msgstr""

# CppCoreGuidelines.md:2111
msgid "2111        void val(int&);       // Bad: Is val reading its argument"
msgstr""

       
# CppCoreGuidelines.md:2112
msgid "2112    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2113
msgid "2113    * Flag reference to non-`const` parameters that are not read before being written to and are a type that could be cheaply returned; they should be \"out\" return values."
msgstr""

# CppCoreGuidelines.md:2114
msgid "2114    * Flag returning a `const` value. To fix: Remove `const` to return a non-`const` value instead."
msgstr""

       
# CppCoreGuidelines.md:2115
msgid "2115    ### <a name=\"Rf-out-multi\"></a>F.21: To return multiple \"out\" values, prefer returning a struct or tuple"
msgstr""

       
# CppCoreGuidelines.md:2116
msgid "2116    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2117
msgid "2117    A return value is self-documenting as an \"output-only\" value."
msgstr""

# CppCoreGuidelines.md:2118
msgid "2118    Note that C++ does have multiple return values, by convention of using a `tuple` (including `pair`),"
msgstr""

# CppCoreGuidelines.md:2119
msgid "2119    possibly with the extra convenience of `tie` at the call site."
msgstr""

# CppCoreGuidelines.md:2120
msgid "2120    Prefer using a named struct where there are semantics to the returned value. Otherwise, a nameless `tuple` is useful in generic code."
msgstr""

       
# CppCoreGuidelines.md:2121
msgid "2121    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2122
msgid "2122        // BAD: output-only parameter documented in a comment"
msgstr""

# CppCoreGuidelines.md:2123
msgid "2123        int f(const string& input, /*output only*/ string& output_data)"
msgstr""

# CppCoreGuidelines.md:2124
msgid "2124        {"
msgstr""

# CppCoreGuidelines.md:2125
msgid "2125            // ..."
msgstr""

# CppCoreGuidelines.md:2126
msgid "2126            output_data = something();"
msgstr""

# CppCoreGuidelines.md:2127
msgid "2127            return status;"
msgstr""

# CppCoreGuidelines.md:2128
msgid "2128        }"
msgstr""

       
# CppCoreGuidelines.md:2129
msgid "2129        // GOOD: self-documenting"
msgstr""

# CppCoreGuidelines.md:2130
msgid "2130        tuple<int, string> f(const string& input)"
msgstr""

# CppCoreGuidelines.md:2131
msgid "2131        {"
msgstr""

# CppCoreGuidelines.md:2132
msgid "2132            // ..."
msgstr""

# CppCoreGuidelines.md:2133
msgid "2133            return make_tuple(status, something());"
msgstr""

# CppCoreGuidelines.md:2134
msgid "2134        }"
msgstr""

       
# CppCoreGuidelines.md:2135
msgid "2135    C++98's standard library already used this style, because a `pair` is like a two-element `tuple`."
msgstr""

# CppCoreGuidelines.md:2136
msgid "2136    For example, given a `set<string> my_set`, consider:"
msgstr""

       
# CppCoreGuidelines.md:2137
msgid "2137        // C++98"
msgstr""

# CppCoreGuidelines.md:2138
msgid "2138        result = my_set.insert(\"Hello\");"
msgstr""

# CppCoreGuidelines.md:2139
msgid "2139        if (result.second) do_something_with(result.first);    // workaround"
msgstr""

       
# CppCoreGuidelines.md:2140
msgid "2140    With C++11 we can write this, putting the results directly in existing local variables:"
msgstr""

       
# CppCoreGuidelines.md:2141
msgid "2141        Sometype iter;                                // default initialize if we haven't already"
msgstr""

# CppCoreGuidelines.md:2142
msgid "2142        Someothertype success;                        // used these variables for some other purpose"
msgstr""

       
# CppCoreGuidelines.md:2143
msgid "2143        tie(iter, success) = my_set.insert(\"Hello\");   // normal return value"
msgstr""

# CppCoreGuidelines.md:2144
msgid "2144        if (success) do_something_with(iter);"
msgstr""

       
# CppCoreGuidelines.md:2145
msgid "2145    With C++17 we should be able to use \"structured bindings\" to declare and initialize the multiple variables:"
msgstr""

       
# CppCoreGuidelines.md:2146
msgid "2146        if (auto [ iter, success ] = my_set.insert(\"Hello\"); success) do_something_with(iter);"
msgstr""

       
# CppCoreGuidelines.md:2147
msgid "2147    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2148
msgid "2148    Sometimes, we need to pass an object to a function to manipulate its state."
msgstr""

# CppCoreGuidelines.md:2149
msgid "2149    In such cases, passing the object by reference [`T&`](#Rf-inout) is usually the right technique."
msgstr""

# CppCoreGuidelines.md:2150
msgid "2150    Explicitly passing an in-out parameter back out again as a return value is often not necessary."
msgstr""

# CppCoreGuidelines.md:2151
msgid "2151    For example:"
msgstr""

       
# CppCoreGuidelines.md:2152
msgid "2152        istream& operator>>(istream& is, string& s);    // much like std::operator>>()"
msgstr""

       
# CppCoreGuidelines.md:2153
msgid "2153        for (string s; cin >> s; ) {"
msgstr""

# CppCoreGuidelines.md:2154
msgid "2154            // do something with line"
msgstr""

# CppCoreGuidelines.md:2155
msgid "2155        }"
msgstr""

       
# CppCoreGuidelines.md:2156
msgid "2156    Here, both `s` and `cin` are used as in-out parameters."
msgstr""

# CppCoreGuidelines.md:2157
msgid "2157    We pass `cin` by (non-`const`) reference to be able to manipulate its state."
msgstr""

# CppCoreGuidelines.md:2158
msgid "2158    We pass `s` to avoid repeated allocations."
msgstr""

# CppCoreGuidelines.md:2159
msgid "2159    By reusing `s` (passed by reference), we allocate new memory only when we need to expand `s`'s capacity."
msgstr""

# CppCoreGuidelines.md:2160
msgid "2160    This technique is sometimes called the \"caller-allocated out\" pattern and is particularly useful for types,"
msgstr""

# CppCoreGuidelines.md:2161
msgid "2161    such as `string` and `vector`, that needs to do free store allocations."
msgstr""

       
# CppCoreGuidelines.md:2162
msgid "2162    To compare, if we passed out all values as return values, we would something like this:"
msgstr""

       
# CppCoreGuidelines.md:2163
msgid "2163        pair<istream&, string> get_string(istream& is);  // not recommended"
msgstr""

# CppCoreGuidelines.md:2164
msgid "2164        {"
msgstr""

# CppCoreGuidelines.md:2165
msgid "2165            string s;"
msgstr""

# CppCoreGuidelines.md:2166
msgid "2166            is >> s;"
msgstr""

# CppCoreGuidelines.md:2167
msgid "2167            return {is, s};"
msgstr""

# CppCoreGuidelines.md:2168
msgid "2168        }"
msgstr""

       
# CppCoreGuidelines.md:2169
msgid "2169        for (auto p = get_string(cin); p.first; ) {"
msgstr""

# CppCoreGuidelines.md:2170
msgid "2170            // do something with p.second"
msgstr""

# CppCoreGuidelines.md:2171
msgid "2171        }"
msgstr""

       
# CppCoreGuidelines.md:2172
msgid "2172    We consider that significantly less elegant with significantly less performance."
msgstr""

       
# CppCoreGuidelines.md:2173
msgid "2173    For a truly strict reading of this rule (F.21), the exception isn't really an exception because it relies on in-out parameters,"
msgstr""

# CppCoreGuidelines.md:2174
msgid "2174    rather than the plain out parameters mentioned in the rule."
msgstr""

# CppCoreGuidelines.md:2175
msgid "2175    However, we prefer to be explicit, rather than subtle."
msgstr""

       
# CppCoreGuidelines.md:2176
msgid "2176    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2177
msgid "2177    In many cases, it may be useful to return a specific, user-defined type."
msgstr""

# CppCoreGuidelines.md:2178
msgid "2178    For example:"
msgstr""

       
# CppCoreGuidelines.md:2179
msgid "2179        struct Distance {"
msgstr""

# CppCoreGuidelines.md:2180
msgid "2180            int value;"
msgstr""

# CppCoreGuidelines.md:2181
msgid "2181            int unit = 1;   // 1 means meters"
msgstr""

# CppCoreGuidelines.md:2182
msgid "2182        };"
msgstr""

       
# CppCoreGuidelines.md:2183
msgid "2183        Distance d1 = measure(obj1);        // access d1.value and d1.unit"
msgstr""

# CppCoreGuidelines.md:2184
msgid "2184        auto d2 = measure(obj2);            // access d2.value and d2.unit"
msgstr""

# CppCoreGuidelines.md:2185
msgid "2185        auto [value, unit] = measure(obj3); // access value and unit; somewhat redundant"
msgstr""

# CppCoreGuidelines.md:2186
msgid "2186                                            // to people who know measure()"
msgstr""

# CppCoreGuidelines.md:2187
msgid "2187        auto [x, y] = measure(obj4);        // don't; it's likely to be confusing"
msgstr""

       
# CppCoreGuidelines.md:2188
msgid "2188    The overly-generic `pair` and `tuple` should be used only when the value returned represents to independent entities rather than an abstraction."
msgstr""

       
# CppCoreGuidelines.md:2189
msgid "2189    Another example, use a specific type along the lines of `variant<T, error_code>`, rather than using the generic `tuple`."
msgstr""

       
# CppCoreGuidelines.md:2190
msgid "2190    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2191
msgid "2191    * Output parameters should be replaced by return values."
msgstr""

# CppCoreGuidelines.md:2192
msgid "2192      An output parameter is one that the function writes to, invokes a non-`const` member function, or passes on as a non-`const`."
msgstr""

       
# CppCoreGuidelines.md:2193
msgid "2193    ### <a name=\"Rf-ptr\"></a>F.22: Use `T*` or `owner<T*>` to designate a single object"
msgstr""

       
# CppCoreGuidelines.md:2194
msgid "2194    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2195
msgid "2195    Readability: it makes the meaning of a plain pointer clear."
msgstr""

# CppCoreGuidelines.md:2196
msgid "2196    Enables significant tool support."
msgstr""

       
# CppCoreGuidelines.md:2197
msgid "2197    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2198
msgid "2198    In traditional C and C++ code, plain `T*` is used for many weakly-related purposes, such as:"
msgstr""

       
# CppCoreGuidelines.md:2199
msgid "2199    * Identify a (single) object (not to be deleted by this function)"
msgstr""

# CppCoreGuidelines.md:2200
msgid "2200    * Point to an object allocated on the free store (and delete it later)"
msgstr""

# CppCoreGuidelines.md:2201
msgid "2201    * Hold the `nullptr`"
msgstr""

# CppCoreGuidelines.md:2202
msgid "2202    * Identify a C-style string (zero-terminated array of characters)"
msgstr""

# CppCoreGuidelines.md:2203
msgid "2203    * Identify an array with a length specified separately"
msgstr""

# CppCoreGuidelines.md:2204
msgid "2204    * Identify a location in an array"
msgstr""

       
# CppCoreGuidelines.md:2205
msgid "2205    This makes it hard to understand what the code does and is supposed to do."
msgstr""

# CppCoreGuidelines.md:2206
msgid "2206    It complicates checking and tool support."
msgstr""

       
# CppCoreGuidelines.md:2207
msgid "2207    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2208
msgid "2208        void use(int* p, int n, char* s, int* q)"
msgstr""

# CppCoreGuidelines.md:2209
msgid "2209        {"
msgstr""

# CppCoreGuidelines.md:2210
msgid "2210            p[n - 1] = 666; // Bad: we don't know if p points to n elements;"
msgstr""

# CppCoreGuidelines.md:2211
msgid "2211                            // assume it does not or use span<int>"
msgstr""

# CppCoreGuidelines.md:2212
msgid "2212            cout << s;      // Bad: we don't know if that s points to a zero-terminated array of char;"
msgstr""

# CppCoreGuidelines.md:2213
msgid "2213                            // assume it does not or use zstring"
msgstr""

# CppCoreGuidelines.md:2214
msgid "2214            delete q;       // Bad: we don't know if *q is allocated on the free store;"
msgstr""

# CppCoreGuidelines.md:2215
msgid "2215                            // assume it does not or use owner"
msgstr""

# CppCoreGuidelines.md:2216
msgid "2216        }"
msgstr""

       
# CppCoreGuidelines.md:2217
msgid "2217    better"
msgstr""

       
# CppCoreGuidelines.md:2218
msgid "2218        void use2(span<int> p, zstring s, owner<int*> q)"
msgstr""

# CppCoreGuidelines.md:2219
msgid "2219        {"
msgstr""

# CppCoreGuidelines.md:2220
msgid "2220            p[p.size() - 1] = 666; // OK, a range error can be caught"
msgstr""

# CppCoreGuidelines.md:2221
msgid "2221            cout << s; // OK"
msgstr""

# CppCoreGuidelines.md:2222
msgid "2222            delete q;  // OK"
msgstr""

# CppCoreGuidelines.md:2223
msgid "2223        }"
msgstr""

       
# CppCoreGuidelines.md:2224
msgid "2224    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2225
msgid "2225    `owner<T*>` represents ownership, `zstring` represents a C-style string."
msgstr""

       
# CppCoreGuidelines.md:2226
msgid "2226    **Also**: Assume that a `T*` obtained from a smart pointer to `T` (e.g., `unique_ptr<T>`) points to a single element."
msgstr""

       
# CppCoreGuidelines.md:2227
msgid "2227    **See also**: [Support library](#S-gsl)"
msgstr""

       
# CppCoreGuidelines.md:2228
msgid "2228    **See also**: [Do not pass an array as a single pointer](#Ri-array)"
msgstr""

       
# CppCoreGuidelines.md:2229
msgid "2229    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2230
msgid "2230    * (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer type that results in a value of pointer type."
msgstr""

       
# CppCoreGuidelines.md:2231
msgid "2231    ### <a name=\"Rf-nullptr\"></a>F.23: Use a `not_null<T>` to indicate that \"null\" is not a valid value"
msgstr""

       
# CppCoreGuidelines.md:2232
msgid "2232    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2233
msgid "2233    Clarity. A function with a `not_null<T>` parameter makes it clear that the caller of the function is responsible for any `nullptr` checks that may be necessary."
msgstr""

# CppCoreGuidelines.md:2234
msgid "2234    Similarly, a function with a return value of `not_null<T>` makes it clear that the caller of the function does not need to check for `nullptr`."
msgstr""

       
# CppCoreGuidelines.md:2235
msgid "2235    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2236
msgid "2236    `not_null<T*>` makes it obvious to a reader (human or machine) that a test for `nullptr` is not necessary before dereference."
msgstr""

# CppCoreGuidelines.md:2237
msgid "2237    Additionally, when debugging, `owner<T*>` and `not_null<T>` can be instrumented to check for correctness."
msgstr""

       
# CppCoreGuidelines.md:2238
msgid "2238    Consider:"
msgstr""

       
# CppCoreGuidelines.md:2239
msgid "2239        int length(Record* p);"
msgstr""

       
# CppCoreGuidelines.md:2240
msgid "2240    When I call `length(p)` should I check if `p` is `nullptr` first? Should the implementation of `length()` check if `p` is `nullptr`?"
msgstr""

       
# CppCoreGuidelines.md:2241
msgid "2241        // it is the caller's job to make sure p != nullptr"
msgstr""

# CppCoreGuidelines.md:2242
msgid "2242        int length(not_null<Record*> p);"
msgstr""

       
# CppCoreGuidelines.md:2243
msgid "2243        // the implementor of length() must assume that p == nullptr is possible"
msgstr""

# CppCoreGuidelines.md:2244
msgid "2244        int length(Record* p);"
msgstr""

       
# CppCoreGuidelines.md:2245
msgid "2245    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2246
msgid "2246    A `not_null<T*>` is assumed not to be the `nullptr`; a `T*` may be the `nullptr`; both can be represented in memory as a `T*` (so no run-time overhead is implied)."
msgstr""

       
# CppCoreGuidelines.md:2247
msgid "2247    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2248
msgid "2248    `not_null` is not just for built-in pointers. It works for `unique_ptr`, `shared_ptr`, and other pointer-like types."
msgstr""

       
# CppCoreGuidelines.md:2249
msgid "2249    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2250
msgid "2250    * (Simple) Warn if a raw pointer is dereferenced without being tested against `nullptr` (or equivalent) within a function, suggest it is declared `not_null` instead."
msgstr""

# CppCoreGuidelines.md:2251
msgid "2251    * (Simple) Error if a raw pointer is sometimes dereferenced after first being tested against `nullptr` (or equivalent) within the function and sometimes is not."
msgstr""

# CppCoreGuidelines.md:2252
msgid "2252    * (Simple) Warn if a `not_null` pointer is tested against `nullptr` within a function."
msgstr""

       
# CppCoreGuidelines.md:2253
msgid "2253    ### <a name=\"Rf-range\"></a>F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence"
msgstr""

       
# CppCoreGuidelines.md:2254
msgid "2254    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2255
msgid "2255    Informal/non-explicit ranges are a source of errors."
msgstr""

       
# CppCoreGuidelines.md:2256
msgid "2256    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2257
msgid "2257        X* find(span<X> r, const X& v);    // find v in r"
msgstr""

       
# CppCoreGuidelines.md:2258
msgid "2258        vector<X> vec;"
msgstr""

# CppCoreGuidelines.md:2259
msgid "2259        // ..."
msgstr""

# CppCoreGuidelines.md:2260
msgid "2260        auto p = find({vec.begin(), vec.end()}, X{});  // find X{} in vec"
msgstr""

       
# CppCoreGuidelines.md:2261
msgid "2261    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2262
msgid "2262    Ranges are extremely common in C++ code. Typically, they are implicit and their correct use is very hard to ensure."
msgstr""

# CppCoreGuidelines.md:2263
msgid "2263    In particular, given a pair of arguments `(p, n)` designating an array `[p:p+n)`,"
msgstr""

# CppCoreGuidelines.md:2264
msgid "2264    it is in general impossible to know if there really are `n` elements to access following `*p`."
msgstr""

# CppCoreGuidelines.md:2265
msgid "2265    `span<T>` and `span_p<T>` are simple helper classes designating a `[p:q)` range and a range starting with `p` and ending with the first element for which a predicate is true, respectively."
msgstr""

       
# CppCoreGuidelines.md:2266
msgid "2266    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2267
msgid "2267    A `span` represents a range of elements, but how do we manipulate elements of that range?"
msgstr""

       
# CppCoreGuidelines.md:2268
msgid "2268        void f(span<int> s)"
msgstr""

# CppCoreGuidelines.md:2269
msgid "2269        {"
msgstr""

# CppCoreGuidelines.md:2270
msgid "2270            // range traversal (guaranteed correct)"
msgstr""

# CppCoreGuidelines.md:2271
msgid "2271            for (int x : s) cout << x << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:2272
msgid "2272            // C-style traversal (potentially checked)"
msgstr""

# CppCoreGuidelines.md:2273
msgid "2273            for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:2274
msgid "2274            // random access (potentially checked)"
msgstr""

# CppCoreGuidelines.md:2275
msgid "2275            s[7] = 9;"
msgstr""

       
# CppCoreGuidelines.md:2276
msgid "2276            // extract pointers (potentially checked)"
msgstr""

# CppCoreGuidelines.md:2277
msgid "2277            std::sort(&s[0], &s[s.size() / 2]);"
msgstr""

# CppCoreGuidelines.md:2278
msgid "2278        }"
msgstr""

       
# CppCoreGuidelines.md:2279
msgid "2279    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2280
msgid "2280    A `span<T>` object does not own its elements and is so small that it can be passed by value."
msgstr""

       
# CppCoreGuidelines.md:2281
msgid "2281    Passing a `span` object as an argument is exactly as efficient as passing a pair of pointer arguments or passing a pointer and an integer count."
msgstr""

       
# CppCoreGuidelines.md:2282
msgid "2282    **See also**: [Support library](#S-gsl)"
msgstr""

       
# CppCoreGuidelines.md:2283
msgid "2283    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2284
msgid "2284    (Complex) Warn where accesses to pointer parameters are bounded by other parameters that are integral types and suggest they could use `span` instead."
msgstr""

       
# CppCoreGuidelines.md:2285
msgid "2285    ### <a name=\"Rf-zstring\"></a>F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string"
msgstr""

       
# CppCoreGuidelines.md:2286
msgid "2286    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2287
msgid "2287    C-style strings are ubiquitous. They are defined by convention: zero-terminated arrays of characters."
msgstr""

# CppCoreGuidelines.md:2288
msgid "2288    We must distinguish C-style strings from a pointer to a single character or an old-fashioned pointer to an array of characters."
msgstr""

       
# CppCoreGuidelines.md:2289
msgid "2289    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2290
msgid "2290    Consider:"
msgstr""

       
# CppCoreGuidelines.md:2291
msgid "2291        int length(const char* p);"
msgstr""

       
# CppCoreGuidelines.md:2292
msgid "2292    When I call `length(s)` should I check if `s` is `nullptr` first? Should the implementation of `length()` check if `p` is `nullptr`?"
msgstr""

       
# CppCoreGuidelines.md:2293
msgid "2293        // the implementor of length() must assume that p == nullptr is possible"
msgstr""

# CppCoreGuidelines.md:2294
msgid "2294        int length(zstring p);"
msgstr""

       
# CppCoreGuidelines.md:2295
msgid "2295        // it is the caller's job to make sure p != nullptr"
msgstr""

# CppCoreGuidelines.md:2296
msgid "2296        int length(not_null<zstring> p);"
msgstr""

       
# CppCoreGuidelines.md:2297
msgid "2297    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2298
msgid "2298    `zstring` do not represent ownership."
msgstr""

       
# CppCoreGuidelines.md:2299
msgid "2299    **See also**: [Support library](#S-gsl)"
msgstr""

       
# CppCoreGuidelines.md:2300
msgid "2300    ### <a name=\"Rf-unique_ptr\"></a>F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed"
msgstr""

       
# CppCoreGuidelines.md:2301
msgid "2301    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2302
msgid "2302    Using `unique_ptr` is the cheapest way to pass a pointer safely."
msgstr""

       
# CppCoreGuidelines.md:2303
msgid "2303    **See also**: [C.50](#Rc-factory) regarding when to return a `shared_ptr` from a factory."
msgstr""

       
# CppCoreGuidelines.md:2304
msgid "2304    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2305
msgid "2305        unique_ptr<Shape> get_shape(istream& is)  // assemble shape from input stream"
msgstr""

# CppCoreGuidelines.md:2306
msgid "2306        {"
msgstr""

# CppCoreGuidelines.md:2307
msgid "2307            auto kind = read_header(is); // read header and identify the next shape on input"
msgstr""

# CppCoreGuidelines.md:2308
msgid "2308            switch (kind) {"
msgstr""

# CppCoreGuidelines.md:2309
msgid "2309            case kCircle:"
msgstr""

# CppCoreGuidelines.md:2310
msgid "2310                return make_unique<Circle>(is);"
msgstr""

# CppCoreGuidelines.md:2311
msgid "2311            case kTriangle:"
msgstr""

# CppCoreGuidelines.md:2312
msgid "2312                return make_unique<Triangle>(is);"
msgstr""

# CppCoreGuidelines.md:2313
msgid "2313            // ..."
msgstr""

# CppCoreGuidelines.md:2314
msgid "2314            }"
msgstr""

# CppCoreGuidelines.md:2315
msgid "2315        }"
msgstr""

       
# CppCoreGuidelines.md:2316
msgid "2316    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2317
msgid "2317    You need to pass a pointer rather than an object if what you are transferring is an object from a class hierarchy that is to be used through an interface (base class)."
msgstr""

       
# CppCoreGuidelines.md:2318
msgid "2318    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2319
msgid "2319    (Simple) Warn if a function returns a locally allocated raw pointer. Suggest using either `unique_ptr` or `shared_ptr` instead."
msgstr""

       
# CppCoreGuidelines.md:2320
msgid "2320    ### <a name=\"Rf-shared_ptr\"></a>F.27: Use a `shared_ptr<T>` to share ownership"
msgstr""

       
# CppCoreGuidelines.md:2321
msgid "2321    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2322
msgid "2322    Using `std::shared_ptr` is the standard way to represent shared ownership. That is, the last owner deletes the object."
msgstr""

       
# CppCoreGuidelines.md:2323
msgid "2323    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2324
msgid "2324        shared_ptr<const Image> im { read_image(somewhere) };"
msgstr""

       
# CppCoreGuidelines.md:2325
msgid "2325        std::thread t0 {shade, args0, top_left, im};"
msgstr""

# CppCoreGuidelines.md:2326
msgid "2326        std::thread t1 {shade, args1, top_right, im};"
msgstr""

# CppCoreGuidelines.md:2327
msgid "2327        std::thread t2 {shade, args2, bottom_left, im};"
msgstr""

# CppCoreGuidelines.md:2328
msgid "2328        std::thread t3 {shade, args3, bottom_right, im};"
msgstr""

       
# CppCoreGuidelines.md:2329
msgid "2329        // detach threads"
msgstr""

# CppCoreGuidelines.md:2330
msgid "2330        // last thread to finish deletes the image"
msgstr""

       
# CppCoreGuidelines.md:2331
msgid "2331    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2332
msgid "2332    Prefer a `unique_ptr` over a `shared_ptr` if there is never more than one owner at a time."
msgstr""

# CppCoreGuidelines.md:2333
msgid "2333    `shared_ptr` is for shared ownership."
msgstr""

       
# CppCoreGuidelines.md:2334
msgid "2334    Note that pervasive use of `shared_ptr` has a cost (atomic operations on the `shared_ptr`'s reference count have a measurable aggregate cost)."
msgstr""

       
# CppCoreGuidelines.md:2335
msgid "2335    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:2336
msgid "2336    Have a single object own the shared object (e.g. a scoped object) and destroy that (preferably implicitly) when all users have completed."
msgstr""

       
# CppCoreGuidelines.md:2337
msgid "2337    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2338
msgid "2338    (Not enforceable) This is a too complex pattern to reliably detect."
msgstr""

       
# CppCoreGuidelines.md:2339
msgid "2339    ### <a name=\"Rf-ptr-ref\"></a>F.60: Prefer `T*` over `T&` when \"no argument\" is a valid option"
msgstr""

       
# CppCoreGuidelines.md:2340
msgid "2340    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2341
msgid "2341    A pointer (`T*`) can be a `nullptr` and a reference (`T&`) cannot, there is no valid \"null reference\"."
msgstr""

# CppCoreGuidelines.md:2342
msgid "2342    Sometimes having `nullptr` as an alternative to indicated \"no object\" is useful, but if it is not, a reference is notationally simpler and might yield better code."
msgstr""

       
# CppCoreGuidelines.md:2343
msgid "2343    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2344
msgid "2344        string zstring_to_string(zstring p) // zstring is a char*; that is a C-style string"
msgstr""

# CppCoreGuidelines.md:2345
msgid "2345        {"
msgstr""

# CppCoreGuidelines.md:2346
msgid "2346            if (!p) return string{};    // p might be nullptr; remember to check"
msgstr""

# CppCoreGuidelines.md:2347
msgid "2347            return string{p};"
msgstr""

# CppCoreGuidelines.md:2348
msgid "2348        }"
msgstr""

       
# CppCoreGuidelines.md:2349
msgid "2349        void print(const vector<int>& r)"
msgstr""

# CppCoreGuidelines.md:2350
msgid "2350        {"
msgstr""

# CppCoreGuidelines.md:2351
msgid "2351            // r refers to a vector<int>; no check needed"
msgstr""

# CppCoreGuidelines.md:2352
msgid "2352        }"
msgstr""

       
# CppCoreGuidelines.md:2353
msgid "2353    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2354
msgid "2354    It is possible, but not valid C++ to construct a reference that is essentially a `nullptr` (e.g., `T* p = nullptr; T& r = (T&)*p;`)."
msgstr""

# CppCoreGuidelines.md:2355
msgid "2355    That error is very uncommon."
msgstr""

       
# CppCoreGuidelines.md:2356
msgid "2356    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2357
msgid "2357    If you prefer the pointer notation (`->` and/or `*` vs. `.`), `not_null<T*>` provides the same guarantee as `T&`."
msgstr""

       
# CppCoreGuidelines.md:2358
msgid "2358    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2359
msgid "2359    * Flag ???"
msgstr""

       
# CppCoreGuidelines.md:2360
msgid "2360    ### <a name=\"Rf-return-ptr\"></a>F.42: Return a `T*` to indicate a position (only)"
msgstr""

       
# CppCoreGuidelines.md:2361
msgid "2361    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2362
msgid "2362    That's what pointers are good for."
msgstr""

# CppCoreGuidelines.md:2363
msgid "2363    Returning a `T*` to transfer ownership is a misuse."
msgstr""

       
# CppCoreGuidelines.md:2364
msgid "2364    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2365
msgid "2365        Node* find(Node* t, const string& s)  // find s in a binary tree of Nodes"
msgstr""

# CppCoreGuidelines.md:2366
msgid "2366        {"
msgstr""

# CppCoreGuidelines.md:2367
msgid "2367            if (!t || t->name == s) return t;"
msgstr""

# CppCoreGuidelines.md:2368
msgid "2368            if ((auto p = find(t->left, s))) return p;"
msgstr""

# CppCoreGuidelines.md:2369
msgid "2369            if ((auto p = find(t->right, s))) return p;"
msgstr""

# CppCoreGuidelines.md:2370
msgid "2370            return nullptr;"
msgstr""

# CppCoreGuidelines.md:2371
msgid "2371        }"
msgstr""

       
# CppCoreGuidelines.md:2372
msgid "2372    If it isn't the `nullptr`, the pointer returned by `find` indicates a `Node` holding `s`."
msgstr""

# CppCoreGuidelines.md:2373
msgid "2373    Importantly, that does not imply a transfer of ownership of the pointed-to object to the caller."
msgstr""

       
# CppCoreGuidelines.md:2374
msgid "2374    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2375
msgid "2375    Positions can also be transferred by iterators, indices, and references."
msgstr""

# CppCoreGuidelines.md:2376
msgid "2376    A reference is often a superior alternative to a pointer [if there is no need to use `nullptr`](#Rf-ptr-ref) or [if the object referred to should not change](???)."
msgstr""

       
# CppCoreGuidelines.md:2377
msgid "2377    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2378
msgid "2378    Do not return a pointer to something that is not in the caller's scope; see [F.43](#Rf-dangle)."
msgstr""

       
# CppCoreGuidelines.md:2379
msgid "2379    **See also**: [discussion of dangling pointer prevention](#???)"
msgstr""

       
# CppCoreGuidelines.md:2380
msgid "2380    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2381
msgid "2381    * Flag `delete`, `std::free()`, etc. applied to a plain `T*`."
msgstr""

# CppCoreGuidelines.md:2382
msgid "2382    Only owners should be deleted."
msgstr""

# CppCoreGuidelines.md:2383
msgid "2383    * Flag `new`, `malloc()`, etc. assigned to a plain `T*`."
msgstr""

# CppCoreGuidelines.md:2384
msgid "2384    Only owners should be responsible for deletion."
msgstr""

       
# CppCoreGuidelines.md:2385
msgid "2385    ### <a name=\"Rf-dangle\"></a>F.43: Never (directly or indirectly) return a pointer or a reference to a local object"
msgstr""

       
# CppCoreGuidelines.md:2386
msgid "2386    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2387
msgid "2387    To avoid the crashes and data corruption that can result from the use of such a dangling pointer."
msgstr""

       
# CppCoreGuidelines.md:2388
msgid "2388    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:2389
msgid "2389    After the return from a function its local objects no longer exist:"
msgstr""

       
# CppCoreGuidelines.md:2390
msgid "2390        int* f()"
msgstr""

# CppCoreGuidelines.md:2391
msgid "2391        {"
msgstr""

# CppCoreGuidelines.md:2392
msgid "2392            int fx = 9;"
msgstr""

# CppCoreGuidelines.md:2393
msgid "2393            return &fx;  // BAD"
msgstr""

# CppCoreGuidelines.md:2394
msgid "2394        }"
msgstr""

       
# CppCoreGuidelines.md:2395
msgid "2395        void g(int* p)   // looks innocent enough"
msgstr""

# CppCoreGuidelines.md:2396
msgid "2396        {"
msgstr""

# CppCoreGuidelines.md:2397
msgid "2397            int gx;"
msgstr""

# CppCoreGuidelines.md:2398
msgid "2398            cout << \"*p == \" << *p << '\\n';"
msgstr""

# CppCoreGuidelines.md:2399
msgid "2399            *p = 999;"
msgstr""

# CppCoreGuidelines.md:2400
msgid "2400            cout << \"gx == \" << gx << '\\n';"
msgstr""

# CppCoreGuidelines.md:2401
msgid "2401        }"
msgstr""

       
# CppCoreGuidelines.md:2402
msgid "2402        void h()"
msgstr""

# CppCoreGuidelines.md:2403
msgid "2403        {"
msgstr""

# CppCoreGuidelines.md:2404
msgid "2404            int* p = f();"
msgstr""

# CppCoreGuidelines.md:2405
msgid "2405            int z = *p;  // read from abandoned stack frame (bad)"
msgstr""

# CppCoreGuidelines.md:2406
msgid "2406            g(p);        // pass pointer to abandoned stack frame to function (bad)"
msgstr""

# CppCoreGuidelines.md:2407
msgid "2407        }"
msgstr""

       
# CppCoreGuidelines.md:2408
msgid "2408    Here on one popular implementation I got the output:"
msgstr""

       
# CppCoreGuidelines.md:2409
msgid "2409        *p == 999"
msgstr""

# CppCoreGuidelines.md:2410
msgid "2410        gx == 999"
msgstr""

       
# CppCoreGuidelines.md:2411
msgid "2411    I expected that because the call of `g()` reuses the stack space abandoned by the call of `f()` so `*p` refers to the space now occupied by `gx`."
msgstr""

       
# CppCoreGuidelines.md:2412
msgid "2412    * Imagine what would happen if `fx` and `gx` were of different types."
msgstr""

# CppCoreGuidelines.md:2413
msgid "2413    * Imagine what would happen if `fx` or `gx` was a type with an invariant."
msgstr""

# CppCoreGuidelines.md:2414
msgid "2414    * Imagine what would happen if more that dangling pointer was passed around among a larger set of functions."
msgstr""

# CppCoreGuidelines.md:2415
msgid "2415    * Imagine what a cracker could do with that dangling pointer."
msgstr""

       
# CppCoreGuidelines.md:2416
msgid "2416    Fortunately, most (all?) modern compilers catch and warn against this simple case."
msgstr""

       
# CppCoreGuidelines.md:2417
msgid "2417    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2418
msgid "2418    This applies to references as well:"
msgstr""

       
# CppCoreGuidelines.md:2419
msgid "2419        int& f()"
msgstr""

# CppCoreGuidelines.md:2420
msgid "2420        {"
msgstr""

# CppCoreGuidelines.md:2421
msgid "2421            int x = 7;"
msgstr""

# CppCoreGuidelines.md:2422
msgid "2422            // ..."
msgstr""

# CppCoreGuidelines.md:2423
msgid "2423            return x;  // Bad: returns reference to object that is about to be destroyed"
msgstr""

# CppCoreGuidelines.md:2424
msgid "2424        }"
msgstr""

       
# CppCoreGuidelines.md:2425
msgid "2425    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2426
msgid "2426    This applies only to non-`static` local variables."
msgstr""

# CppCoreGuidelines.md:2427
msgid "2427    All `static` variables are (as their name indicates) statically allocated, so that pointers to them cannot dangle."
msgstr""

       
# CppCoreGuidelines.md:2428
msgid "2428    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:2429
msgid "2429    Not all examples of leaking a pointer to a local variable are that obvious:"
msgstr""

       
# CppCoreGuidelines.md:2430
msgid "2430        int* glob;       // global variables are bad in so many ways"
msgstr""

       
# CppCoreGuidelines.md:2431
msgid "2431        template<class T>"
msgstr""

# CppCoreGuidelines.md:2432
msgid "2432        void steal(T x)"
msgstr""

# CppCoreGuidelines.md:2433
msgid "2433        {"
msgstr""

# CppCoreGuidelines.md:2434
msgid "2434            glob = x();  // BAD"
msgstr""

# CppCoreGuidelines.md:2435
msgid "2435        }"
msgstr""

       
# CppCoreGuidelines.md:2436
msgid "2436        void f()"
msgstr""

# CppCoreGuidelines.md:2437
msgid "2437        {"
msgstr""

# CppCoreGuidelines.md:2438
msgid "2438            int i = 99;"
msgstr""

# CppCoreGuidelines.md:2439
msgid "2439            steal([&] { return &i; });"
msgstr""

# CppCoreGuidelines.md:2440
msgid "2440        }"
msgstr""

       
# CppCoreGuidelines.md:2441
msgid "2441        int main()"
msgstr""

# CppCoreGuidelines.md:2442
msgid "2442        {"
msgstr""

# CppCoreGuidelines.md:2443
msgid "2443            f();"
msgstr""

# CppCoreGuidelines.md:2444
msgid "2444            cout << *glob << '\\n';"
msgstr""

# CppCoreGuidelines.md:2445
msgid "2445        }"
msgstr""

       
# CppCoreGuidelines.md:2446
msgid "2446    Here I managed to read the location abandoned by the call of `f`."
msgstr""

# CppCoreGuidelines.md:2447
msgid "2447    The pointer stored in `glob` could be used much later and cause trouble in unpredictable ways."
msgstr""

       
# CppCoreGuidelines.md:2448
msgid "2448    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2449
msgid "2449    The address of a local variable can be \"returned\"/leaked by a return statement, by a `T&` out-parameter, as a member of a returned object, as an element of a returned array, and more."
msgstr""

       
# CppCoreGuidelines.md:2450
msgid "2450    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2451
msgid "2451    Similar examples can be constructed \"leaking\" a pointer from an inner scope to an outer one;"
msgstr""

# CppCoreGuidelines.md:2452
msgid "2452    such examples are handled equivalently to leaks of pointers out of a function."
msgstr""

       
# CppCoreGuidelines.md:2453
msgid "2453    A slightly different variant of the problem is placing pointers in a container that outlives the objects pointed to."
msgstr""

       
# CppCoreGuidelines.md:2454
msgid "2454    **See also**: Another way of getting dangling pointers is [pointer invalidation](#???)."
msgstr""

# CppCoreGuidelines.md:2455
msgid "2455    It can be detected/prevented with similar techniques."
msgstr""

       
# CppCoreGuidelines.md:2456
msgid "2456    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2457
msgid "2457    * Compilers tend to catch return of reference to locals and could in many cases catch return of pointers to locals."
msgstr""

# CppCoreGuidelines.md:2458
msgid "2458    * Static analysis can catch many common patterns of the use of pointers indicating positions (thus eliminating dangling pointers)"
msgstr""

       
# CppCoreGuidelines.md:2459
msgid "2459    ### <a name=\"Rf-return-ref\"></a>F.44: Return a `T&` when copy is undesirable and \"returning no object\" isn't needed"
msgstr""

       
# CppCoreGuidelines.md:2460
msgid "2460    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2461
msgid "2461    The language guarantees that a `T&` refers to an object, so that testing for `nullptr` isn't necessary."
msgstr""

       
# CppCoreGuidelines.md:2462
msgid "2462    **See also**: The return of a reference must not imply transfer of ownership:"
msgstr""

# CppCoreGuidelines.md:2463
msgid "2463    [discussion of dangling pointer prevention](#???) and [discussion of ownership](#???)."
msgstr""

       
# CppCoreGuidelines.md:2464
msgid "2464    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2465
msgid "2465        class Car"
msgstr""

# CppCoreGuidelines.md:2466
msgid "2466        {"
msgstr""

# CppCoreGuidelines.md:2467
msgid "2467            array<wheel, 4> w;"
msgstr""

# CppCoreGuidelines.md:2468
msgid "2468            // ..."
msgstr""

# CppCoreGuidelines.md:2469
msgid "2469        public:"
msgstr""

# CppCoreGuidelines.md:2470
msgid "2470            wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }"
msgstr""

# CppCoreGuidelines.md:2471
msgid "2471            // ..."
msgstr""

# CppCoreGuidelines.md:2472
msgid "2472        };"
msgstr""

       
# CppCoreGuidelines.md:2473
msgid "2473        void use()"
msgstr""

# CppCoreGuidelines.md:2474
msgid "2474        {"
msgstr""

# CppCoreGuidelines.md:2475
msgid "2475            Car c;"
msgstr""

# CppCoreGuidelines.md:2476
msgid "2476            wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c"
msgstr""

# CppCoreGuidelines.md:2477
msgid "2477        }"
msgstr""

       
# CppCoreGuidelines.md:2478
msgid "2478    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2479
msgid "2479    Flag functions where no `return` expression could yield `nullptr`"
msgstr""

       
# CppCoreGuidelines.md:2480
msgid "2480    ### <a name=\"Rf-return-ref-ref\"></a>F.45: Don't return a `T&&`"
msgstr""

       
# CppCoreGuidelines.md:2481
msgid "2481    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2482
msgid "2482    It's asking to return a reference to a destroyed temporary object. A `&&` is a magnet for temporary objects. This is fine when the reference to the temporary is being passed \"downward\" to a callee, because the temporary is guaranteed to outlive the function call (see [F.18](#Rf-consume) and [F.19](#Rf-forward)). However, it's not fine when passing such a reference \"upward\" to a larger caller scope. See also ???."
msgstr""

       
# CppCoreGuidelines.md:2483
msgid "2483    For passthrough functions that pass in parameters (by ordinary reference or by perfect forwarding) and want to return values, use simple `auto` return type deduction (not `auto&&`)."
msgstr""

       
# CppCoreGuidelines.md:2484
msgid "2484    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:2485
msgid "2485    If `F` returns by value, this function returns a reference to a temporary."
msgstr""

       
# CppCoreGuidelines.md:2486
msgid "2486        template<class F>"
msgstr""

# CppCoreGuidelines.md:2487
msgid "2487        auto&& wrapper(F f)"
msgstr""

# CppCoreGuidelines.md:2488
msgid "2488        {"
msgstr""

# CppCoreGuidelines.md:2489
msgid "2489            log_call(typeid(f)); // or whatever instrumentation"
msgstr""

# CppCoreGuidelines.md:2490
msgid "2490            return f();"
msgstr""

# CppCoreGuidelines.md:2491
msgid "2491        }"
msgstr""

       
# CppCoreGuidelines.md:2492
msgid "2492    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:2493
msgid "2493    Better:"
msgstr""

       
# CppCoreGuidelines.md:2494
msgid "2494        template<class F>"
msgstr""

# CppCoreGuidelines.md:2495
msgid "2495        auto wrapper(F f)"
msgstr""

# CppCoreGuidelines.md:2496
msgid "2496        {"
msgstr""

# CppCoreGuidelines.md:2497
msgid "2497            log_call(typeid(f)); // or whatever instrumentation"
msgstr""

# CppCoreGuidelines.md:2498
msgid "2498            return f();"
msgstr""

# CppCoreGuidelines.md:2499
msgid "2499        }"
msgstr""

       
# CppCoreGuidelines.md:2500
msgid "2500    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2501
msgid "2501    `std::move` and `std::forward` do return `&&`, but they are just casts -- used by convention only in expression contexts where a reference to a temporary object is passed along within the same expression before the temporary is destroyed. We don't know of any other good examples of returning `&&`."
msgstr""

       
# CppCoreGuidelines.md:2502
msgid "2502    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2503
msgid "2503    Flag any use of `&&` as a return type, except in `std::move` and `std::forward`."
msgstr""

       
# CppCoreGuidelines.md:2504
msgid "2504    ### <a name=\"Rf-main\"></a>F.46: `int` is the return type for `main()`"
msgstr""

       
# CppCoreGuidelines.md:2505
msgid "2505    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2506
msgid "2506    It's a language rule, but violated through \"language extensions\" so often that it is worth mentioning."
msgstr""

# CppCoreGuidelines.md:2507
msgid "2507    Declaring `main` (the one global `main` of a program) `void` limits portability."
msgstr""

       
# CppCoreGuidelines.md:2508
msgid "2508    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2509
msgid "2509            void main() { /* ... */ };  // bad, not C++"
msgstr""

       
# CppCoreGuidelines.md:2510
msgid "2510            int main()"
msgstr""

# CppCoreGuidelines.md:2511
msgid "2511            {"
msgstr""

# CppCoreGuidelines.md:2512
msgid "2512                std::cout << \"This is the way to do it\\n\";"
msgstr""

# CppCoreGuidelines.md:2513
msgid "2513            }"
msgstr""

       
# CppCoreGuidelines.md:2514
msgid "2514    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2515
msgid "2515    We mention this only because of the persistence of this error in the community."
msgstr""

       
# CppCoreGuidelines.md:2516
msgid "2516    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2517
msgid "2517    * The compiler should do it"
msgstr""

# CppCoreGuidelines.md:2518
msgid "2518    * If the compiler doesn't do it, let tools flag it"
msgstr""

       
# CppCoreGuidelines.md:2519
msgid "2519    ### <a name=\"Rf-assignment-op\"></a>F.47: Return `T&` from assignment operators"
msgstr""

       
# CppCoreGuidelines.md:2520
msgid "2520    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2521
msgid "2521    The convention for operator overloads (especially on value types) is for"
msgstr""

# CppCoreGuidelines.md:2522
msgid "2522    `operator=(const T&)` to perform the assignment and then return (non-`const`)"
msgstr""

# CppCoreGuidelines.md:2523
msgid "2523    `*this`.  This ensures consistency with standard-library types and follows the"
msgstr""

# CppCoreGuidelines.md:2524
msgid "2524    principle of \"do as the ints do.\""
msgstr""

       
# CppCoreGuidelines.md:2525
msgid "2525    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2526
msgid "2526    Historically there was some guidance to make the assignment operator return `const T&`."
msgstr""

# CppCoreGuidelines.md:2527
msgid "2527    This was primarily to avoid code of the form `(a = b) = c` -- such code is not common enough to warrant violating consistency with standard types."
msgstr""

       
# CppCoreGuidelines.md:2528
msgid "2528    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2529
msgid "2529        class Foo"
msgstr""

# CppCoreGuidelines.md:2530
msgid "2530        {"
msgstr""

# CppCoreGuidelines.md:2531
msgid "2531         public:"
msgstr""

# CppCoreGuidelines.md:2532
msgid "2532            ..."
msgstr""

# CppCoreGuidelines.md:2533
msgid "2533            Foo& operator=(const Foo& rhs) {"
msgstr""

# CppCoreGuidelines.md:2534
msgid "2534              // Copy members."
msgstr""

# CppCoreGuidelines.md:2535
msgid "2535              ..."
msgstr""

# CppCoreGuidelines.md:2536
msgid "2536              return *this;"
msgstr""

# CppCoreGuidelines.md:2537
msgid "2537            }"
msgstr""

# CppCoreGuidelines.md:2538
msgid "2538        };"
msgstr""

       
# CppCoreGuidelines.md:2539
msgid "2539    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2540
msgid "2540    This should be enforced by tooling by checking the return type (and return"
msgstr""

# CppCoreGuidelines.md:2541
msgid "2541    value) of any assignment operator."
msgstr""

       
       
# CppCoreGuidelines.md:2542
msgid "2542    ### <a name=\"Rf-return-move-local\"></a>F.48: Don't `return std::move(local)`"
msgstr""

       
# CppCoreGuidelines.md:2543
msgid "2543    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2544
msgid "2544    With guaranteed copy elision, it is now almost always a pessimization to expressly use `std::move` in a return statement."
msgstr""

       
# CppCoreGuidelines.md:2545
msgid "2545    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:2546
msgid "2546        S f()"
msgstr""

# CppCoreGuidelines.md:2547
msgid "2547        {"
msgstr""

# CppCoreGuidelines.md:2548
msgid "2548          S result;"
msgstr""

# CppCoreGuidelines.md:2549
msgid "2549          return std::move(result);"
msgstr""

# CppCoreGuidelines.md:2550
msgid "2550        }"
msgstr""

       
# CppCoreGuidelines.md:2551
msgid "2551    ##### Example; good"
msgstr""

       
# CppCoreGuidelines.md:2552
msgid "2552        S f()"
msgstr""

# CppCoreGuidelines.md:2553
msgid "2553        {"
msgstr""

# CppCoreGuidelines.md:2554
msgid "2554          S result;"
msgstr""

# CppCoreGuidelines.md:2555
msgid "2555          return result;"
msgstr""

# CppCoreGuidelines.md:2556
msgid "2556        }"
msgstr""

       
# CppCoreGuidelines.md:2557
msgid "2557    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2558
msgid "2558    This should be enforced by tooling by checking the return expression ."
msgstr""

       
       
# CppCoreGuidelines.md:2559
msgid "2559    ### <a name=\"Rf-capture-vs-overload\"></a>F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)"
msgstr""

       
# CppCoreGuidelines.md:2560
msgid "2560    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2561
msgid "2561    Functions can't capture local variables or be declared at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don't overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary."
msgstr""

       
# CppCoreGuidelines.md:2562
msgid "2562    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2563
msgid "2563        // writing a function that should only take an int or a string"
msgstr""

# CppCoreGuidelines.md:2564
msgid "2564        // -- overloading is natural"
msgstr""

# CppCoreGuidelines.md:2565
msgid "2565        void f(int);"
msgstr""

# CppCoreGuidelines.md:2566
msgid "2566        void f(const string&);"
msgstr""

       
# CppCoreGuidelines.md:2567
msgid "2567        // writing a function object that needs to capture local state and appear"
msgstr""

# CppCoreGuidelines.md:2568
msgid "2568        // at statement or expression scope -- a lambda is natural"
msgstr""

# CppCoreGuidelines.md:2569
msgid "2569        vector<work> v = lots_of_work();"
msgstr""

# CppCoreGuidelines.md:2570
msgid "2570        for (int tasknum = 0; tasknum < max; ++tasknum) {"
msgstr""

# CppCoreGuidelines.md:2571
msgid "2571            pool.run([=, &v]{"
msgstr""

# CppCoreGuidelines.md:2572
msgid "2572                /*"
msgstr""

# CppCoreGuidelines.md:2573
msgid "2573                ..."
msgstr""

# CppCoreGuidelines.md:2574
msgid "2574                ... process 1 / max - th of v, the tasknum - th chunk"
msgstr""

# CppCoreGuidelines.md:2575
msgid "2575                ..."
msgstr""

# CppCoreGuidelines.md:2576
msgid "2576                */"
msgstr""

# CppCoreGuidelines.md:2577
msgid "2577            });"
msgstr""

# CppCoreGuidelines.md:2578
msgid "2578        }"
msgstr""

# CppCoreGuidelines.md:2579
msgid "2579        pool.join();"
msgstr""

       
# CppCoreGuidelines.md:2580
msgid "2580    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2581
msgid "2581    Generic lambdas offer a concise way to write function templates and so can be useful even when a normal function template would do equally well with a little more syntax. This advantage will probably disappear in the future once all functions gain the ability to have Concept parameters."
msgstr""

       
# CppCoreGuidelines.md:2582
msgid "2582    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2583
msgid "2583    * Warn on use of a named non-generic lambda (e.g., `auto x = [](int i){ /*...*/; };`) that captures nothing and appears at global scope. Write an ordinary function instead."
msgstr""

       
# CppCoreGuidelines.md:2584
msgid "2584    ### <a name=\"Rf-default-args\"></a>F.51: Where there is a choice, prefer default arguments over overloading"
msgstr""

       
# CppCoreGuidelines.md:2585
msgid "2585    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2586
msgid "2586    Default arguments simply provide alternative interfaces to a single implementation."
msgstr""

# CppCoreGuidelines.md:2587
msgid "2587    There is no guarantee that a set of overloaded functions all implement the same semantics."
msgstr""

# CppCoreGuidelines.md:2588
msgid "2588    The use of default arguments can avoid code replication."
msgstr""

       
# CppCoreGuidelines.md:2589
msgid "2589    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2590
msgid "2590    There is a choice between using default argument and overloading when the alternatives are from a set of arguments of the same types."
msgstr""

# CppCoreGuidelines.md:2591
msgid "2591    For example:"
msgstr""

       
# CppCoreGuidelines.md:2592
msgid "2592        void print(const string& s, format f = {});"
msgstr""

       
# CppCoreGuidelines.md:2593
msgid "2593    as opposed to"
msgstr""

       
# CppCoreGuidelines.md:2594
msgid "2594        void print(const string& s);  // use default format"
msgstr""

# CppCoreGuidelines.md:2595
msgid "2595        void print(const string& s, format f);"
msgstr""

       
# CppCoreGuidelines.md:2596
msgid "2596    There is not a choice when a set of functions are used to do a semantically equivalent operation to a set of types. For example:"
msgstr""

       
# CppCoreGuidelines.md:2597
msgid "2597        void print(const char&);"
msgstr""

# CppCoreGuidelines.md:2598
msgid "2598        void print(int);"
msgstr""

# CppCoreGuidelines.md:2599
msgid "2599        void print(zstring);"
msgstr""

       
# CppCoreGuidelines.md:2600
msgid "2600    ##### See also"
msgstr""

       
       
# CppCoreGuidelines.md:2601
msgid "2601    [Default arguments for virtual functions](#Rh-virtual-default-arg)"
msgstr""

       
# CppCoreGuidelines.md:2602
msgid "2602    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2603
msgid "2603        ???"
msgstr""

       
# CppCoreGuidelines.md:2604
msgid "2604    ### <a name=\"Rf-reference-capture\"></a>F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms"
msgstr""

       
# CppCoreGuidelines.md:2605
msgid "2605    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2606
msgid "2606    For efficiency and correctness, you nearly always want to capture by reference when using the lambda locally. This includes when writing or calling parallel algorithms that are local because they join before returning."
msgstr""

       
# CppCoreGuidelines.md:2607
msgid "2607    ##### Discussion"
msgstr""

       
# CppCoreGuidelines.md:2608
msgid "2608    The efficiency consideration is that most types are cheaper to pass by reference than by value."
msgstr""

       
# CppCoreGuidelines.md:2609
msgid "2609    The correctness consideration is that many calls want to perform side effects on the original object at the call site (see example below). Passing by value prevents this."
msgstr""

       
# CppCoreGuidelines.md:2610
msgid "2610    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2611
msgid "2611    Unfortunately, there is no simple way to capture by reference to `const` to get the efficiency for a local call but also prevent side effects."
msgstr""

       
# CppCoreGuidelines.md:2612
msgid "2612    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2613
msgid "2613    Here, a large object (a network message) is passed to an iterative algorithm, and is it not efficient or correct to copy the message (which may not be copyable):"
msgstr""

       
# CppCoreGuidelines.md:2614
msgid "2614        std::for_each(begin(sockets), end(sockets), [&message](auto& socket)"
msgstr""

# CppCoreGuidelines.md:2615
msgid "2615        {"
msgstr""

# CppCoreGuidelines.md:2616
msgid "2616            socket.send(message);"
msgstr""

# CppCoreGuidelines.md:2617
msgid "2617        });"
msgstr""

       
# CppCoreGuidelines.md:2618
msgid "2618    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2619
msgid "2619    This is a simple three-stage parallel pipeline. Each `stage` object encapsulates a worker thread and a queue, has a `process` function to enqueue work, and in its destructor automatically blocks waiting for the queue to empty before ending the thread."
msgstr""

       
# CppCoreGuidelines.md:2620
msgid "2620        void send_packets(buffers& bufs)"
msgstr""

# CppCoreGuidelines.md:2621
msgid "2621        {"
msgstr""

# CppCoreGuidelines.md:2622
msgid "2622            stage encryptor([] (buffer& b){ encrypt(b); });"
msgstr""

# CppCoreGuidelines.md:2623
msgid "2623            stage compressor([&](buffer& b){ compress(b); encryptor.process(b); });"
msgstr""

# CppCoreGuidelines.md:2624
msgid "2624            stage decorator([&](buffer& b){ decorate(b); compressor.process(b); });"
msgstr""

# CppCoreGuidelines.md:2625
msgid "2625            for (auto& b : bufs) { decorator.process(b); }"
msgstr""

# CppCoreGuidelines.md:2626
msgid "2626        }  // automatically blocks waiting for pipeline to finish"
msgstr""

       
# CppCoreGuidelines.md:2627
msgid "2627    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2628
msgid "2628    Flag a lambda that captures by reference, but is used other than locally within the function scope or passed to a function by reference. (Note: This rule is an approximation, but does flag passing by pointer as those are more likely to be stored by the callee, writing to a heap location accessed via a parameter, returning the lambda, etc. The Lifetime rules will also provide general rules that flag escaping pointers and references including via lambdas.)"
msgstr""

       
# CppCoreGuidelines.md:2629
msgid "2629    ### <a name=\"Rf-value-capture\"></a>F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread"
msgstr""

       
# CppCoreGuidelines.md:2630
msgid "2630    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2631
msgid "2631    Pointers and references to locals shouldn't outlive their scope. Lambdas that capture by reference are just another place to store a reference to a local object, and shouldn't do so if they (or a copy) outlive the scope."
msgstr""

       
# CppCoreGuidelines.md:2632
msgid "2632    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:2633
msgid "2633        int local = 42;"
msgstr""

       
# CppCoreGuidelines.md:2634
msgid "2634        // Want a reference to local."
msgstr""

# CppCoreGuidelines.md:2635
msgid "2635        // Note, that after program exits this scope,"
msgstr""

# CppCoreGuidelines.md:2636
msgid "2636        // local no longer exists, therefore"
msgstr""

# CppCoreGuidelines.md:2637
msgid "2637        // process() call will have undefined behavior!"
msgstr""

# CppCoreGuidelines.md:2638
msgid "2638        thread_pool.queue_work([&]{ process(local); });"
msgstr""

       
# CppCoreGuidelines.md:2639
msgid "2639    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:2640
msgid "2640        int local = 42;"
msgstr""

# CppCoreGuidelines.md:2641
msgid "2641        // Want a copy of local."
msgstr""

# CppCoreGuidelines.md:2642
msgid "2642        // Since a copy of local is made, it will"
msgstr""

# CppCoreGuidelines.md:2643
msgid "2643        // always be available for the call."
msgstr""

# CppCoreGuidelines.md:2644
msgid "2644        thread_pool.queue_work([=]{ process(local); });"
msgstr""

       
# CppCoreGuidelines.md:2645
msgid "2645    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2646
msgid "2646    * (Simple) Warn when capture-list contains a reference to a locally declared variable"
msgstr""

# CppCoreGuidelines.md:2647
msgid "2647    * (Complex) Flag when capture-list contains a reference to a locally declared variable and the lambda is passed to a non-`const` and non-local context"
msgstr""

       
# CppCoreGuidelines.md:2648
msgid "2648    ### <a name=\"Rf-this-capture\"></a>F.54: If you capture `this`, capture all variables explicitly (no default capture)"
msgstr""

       
# CppCoreGuidelines.md:2649
msgid "2649    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2650
msgid "2650    It's confusing. Writing `[=]` in a member function appears to capture by value, but actually captures data members by reference because it actually captures the invisible `this` pointer by value. If you meant to do that, write `this` explicitly."
msgstr""

       
# CppCoreGuidelines.md:2651
msgid "2651    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2652
msgid "2652        class My_class {"
msgstr""

# CppCoreGuidelines.md:2653
msgid "2653            int x = 0;"
msgstr""

# CppCoreGuidelines.md:2654
msgid "2654            // ..."
msgstr""

       
# CppCoreGuidelines.md:2655
msgid "2655            void f() {"
msgstr""

# CppCoreGuidelines.md:2656
msgid "2656                int i = 0;"
msgstr""

# CppCoreGuidelines.md:2657
msgid "2657                // ..."
msgstr""

       
# CppCoreGuidelines.md:2658
msgid "2658                auto lambda = [=]{ use(i, x); };   // BAD: \"looks like\" copy/value capture"
msgstr""

# CppCoreGuidelines.md:2659
msgid "2659                // [&] has identical semantics and copies the this pointer under the current rules"
msgstr""

# CppCoreGuidelines.md:2660
msgid "2660                // [=,this] and [&,this] are not much better, and confusing"
msgstr""

       
# CppCoreGuidelines.md:2661
msgid "2661                x = 42;"
msgstr""

# CppCoreGuidelines.md:2662
msgid "2662                lambda(); // calls use(0, 42);"
msgstr""

# CppCoreGuidelines.md:2663
msgid "2663                x = 43;"
msgstr""

# CppCoreGuidelines.md:2664
msgid "2664                lambda(); // calls use(0, 43);"
msgstr""

       
# CppCoreGuidelines.md:2665
msgid "2665                // ..."
msgstr""

       
# CppCoreGuidelines.md:2666
msgid "2666                auto lambda2 = [i, this]{ use(i, x); }; // ok, most explicit and least confusing"
msgstr""

       
# CppCoreGuidelines.md:2667
msgid "2667                // ..."
msgstr""

# CppCoreGuidelines.md:2668
msgid "2668            }"
msgstr""

# CppCoreGuidelines.md:2669
msgid "2669        };"
msgstr""

       
# CppCoreGuidelines.md:2670
msgid "2670    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2671
msgid "2671    This is under active discussion in standardization, and may be addressed in a future version of the standard by adding a new capture mode or possibly adjusting the meaning of `[=]`. For now, just be explicit."
msgstr""

       
# CppCoreGuidelines.md:2672
msgid "2672    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2673
msgid "2673    * Flag any lambda capture-list that specifies a default capture and also captures `this` (whether explicitly or via default capture)"
msgstr""

       
# CppCoreGuidelines.md:2674
msgid "2674    ### <a name=\"F-varargs\"></a>F.55: Don't use `va_arg` arguments"
msgstr""

       
# CppCoreGuidelines.md:2675
msgid "2675    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2676
msgid "2676    Reading from a `va_arg` assumes that the correct type was actually passed."
msgstr""

# CppCoreGuidelines.md:2677
msgid "2677    Passing to varargs assumes the correct type will be read."
msgstr""

# CppCoreGuidelines.md:2678
msgid "2678    This is fragile because it cannot generally be enforced to be safe in the language and so relies on programmer discipline to get it right."
msgstr""

       
# CppCoreGuidelines.md:2679
msgid "2679    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2680
msgid "2680        int sum(...) {"
msgstr""

# CppCoreGuidelines.md:2681
msgid "2681            // ..."
msgstr""

# CppCoreGuidelines.md:2682
msgid "2682            while (/*...*/)"
msgstr""

# CppCoreGuidelines.md:2683
msgid "2683                result += va_arg(list, int); // BAD, assumes it will be passed ints"
msgstr""

# CppCoreGuidelines.md:2684
msgid "2684            // ..."
msgstr""

# CppCoreGuidelines.md:2685
msgid "2685        }"
msgstr""

       
# CppCoreGuidelines.md:2686
msgid "2686        sum(3, 2); // ok"
msgstr""

# CppCoreGuidelines.md:2687
msgid "2687        sum(3.14159, 2.71828); // BAD, undefined"
msgstr""

       
# CppCoreGuidelines.md:2688
msgid "2688        template<class ...Args>"
msgstr""

# CppCoreGuidelines.md:2689
msgid "2689        auto sum(Args... args) { // GOOD, and much more flexible"
msgstr""

# CppCoreGuidelines.md:2690
msgid "2690            return (... + args); // note: C++17 \"fold expression\""
msgstr""

# CppCoreGuidelines.md:2691
msgid "2691        }"
msgstr""

       
# CppCoreGuidelines.md:2692
msgid "2692        sum(3, 2); // ok: 5"
msgstr""

# CppCoreGuidelines.md:2693
msgid "2693        sum(3.14159, 2.71828); // ok: ~5.85987"
msgstr""

       
# CppCoreGuidelines.md:2694
msgid "2694    ##### Alternatives"
msgstr""

       
# CppCoreGuidelines.md:2695
msgid "2695    * overloading"
msgstr""

# CppCoreGuidelines.md:2696
msgid "2696    * variadic templates"
msgstr""

# CppCoreGuidelines.md:2697
msgid "2697    * `variant` arguments"
msgstr""

# CppCoreGuidelines.md:2698
msgid "2698    * `initializer_list` (homogeneous)"
msgstr""

       
# CppCoreGuidelines.md:2699
msgid "2699    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2700
msgid "2700    Declaring a `...` parameter is sometimes useful for techniques that don't involve actual argument passing, notably to declare \"take-anything\" functions so as to disable \"everything else\" in an overload set or express a catchall case in a template metaprogram."
msgstr""

       
# CppCoreGuidelines.md:2701
msgid "2701    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2702
msgid "2702    * Issue a diagnostic for using `va_list`, `va_start`, or `va_arg`."
msgstr""

# CppCoreGuidelines.md:2703
msgid "2703    * Issue a diagnostic for passing an argument to a vararg parameter of a function that does not offer an overload for a more specific type in the position of the vararg. To fix: Use a different function, or `[[suppress(types)]]`."
msgstr""

       
# CppCoreGuidelines.md:2704
msgid "2704    # <a name=\"S-class\"></a>C: Classes and class hierarchies"
msgstr""

       
# CppCoreGuidelines.md:2705
msgid "2705    A class is a user-defined type, for which a programmer can define the representation, operations, and interfaces."
msgstr""

# CppCoreGuidelines.md:2706
msgid "2706    Class hierarchies are used to organize related classes into hierarchical structures."
msgstr""

       
# CppCoreGuidelines.md:2707
msgid "2707    Class rule summary:"
msgstr""

       
# CppCoreGuidelines.md:2708
msgid "2708    * [C.1: Organize related data into structures (`struct`s or `class`es)](#Rc-org)"
msgstr""

# CppCoreGuidelines.md:2709
msgid "2709    * [C.2: Use `class` if the class has an invariant; use `struct` if the data members can vary independently](#Rc-struct)"
msgstr""

# CppCoreGuidelines.md:2710
msgid "2710    * [C.3: Represent the distinction between an interface and an implementation using a class](#Rc-interface)"
msgstr""

# CppCoreGuidelines.md:2711
msgid "2711    * [C.4: Make a function a member only if it needs direct access to the representation of a class](#Rc-member)"
msgstr""

# CppCoreGuidelines.md:2712
msgid "2712    * [C.5: Place helper functions in the same namespace as the class they support](#Rc-helper)"
msgstr""

# CppCoreGuidelines.md:2713
msgid "2713    * [C.7: Don't define a class or enum and declare a variable of its type in the same statement](#Rc-standalone)"
msgstr""

# CppCoreGuidelines.md:2714
msgid "2714    * [C.8: Use `class` rather than `struct` if any member is non-public](#Rc-class)"
msgstr""

# CppCoreGuidelines.md:2715
msgid "2715    * [C.9: Minimize exposure of members](#Rc-private)"
msgstr""

       
# CppCoreGuidelines.md:2716
msgid "2716    Subsections:"
msgstr""

       
# CppCoreGuidelines.md:2717
msgid "2717    * [C.concrete: Concrete types](#SS-concrete)"
msgstr""

# CppCoreGuidelines.md:2718
msgid "2718    * [C.ctor: Constructors, assignments, and destructors](#S-ctor)"
msgstr""

# CppCoreGuidelines.md:2719
msgid "2719    * [C.con: Containers and other resource handles](#SS-containers)"
msgstr""

# CppCoreGuidelines.md:2720
msgid "2720    * [C.lambdas: Function objects and lambdas](#SS-lambdas)"
msgstr""

# CppCoreGuidelines.md:2721
msgid "2721    * [C.hier: Class hierarchies (OOP)](#SS-hier)"
msgstr""

# CppCoreGuidelines.md:2722
msgid "2722    * [C.over: Overloading and overloaded operators](#SS-overload)"
msgstr""

# CppCoreGuidelines.md:2723
msgid "2723    * [C.union: Unions](#SS-union)"
msgstr""

       
# CppCoreGuidelines.md:2724
msgid "2724    ### <a name=\"Rc-org\"></a>C.1: Organize related data into structures (`struct`s or `class`es)"
msgstr""

       
# CppCoreGuidelines.md:2725
msgid "2725    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2726
msgid "2726    Ease of comprehension."
msgstr""

# CppCoreGuidelines.md:2727
msgid "2727    If data is related (for fundamental reasons), that fact should be reflected in code."
msgstr""

       
# CppCoreGuidelines.md:2728
msgid "2728    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2729
msgid "2729        void draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships"
msgstr""

# CppCoreGuidelines.md:2730
msgid "2730        void draw(Point from, Point to);          // better"
msgstr""

       
# CppCoreGuidelines.md:2731
msgid "2731    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2732
msgid "2732    A simple class without virtual functions implies no space or time overhead."
msgstr""

       
# CppCoreGuidelines.md:2733
msgid "2733    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2734
msgid "2734    From a language perspective `class` and `struct` differ only in the default visibility of their members."
msgstr""

       
# CppCoreGuidelines.md:2735
msgid "2735    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2736
msgid "2736    Probably impossible. Maybe a heuristic looking for data items used together is possible."
msgstr""

       
# CppCoreGuidelines.md:2737
msgid "2737    ### <a name=\"Rc-struct\"></a>C.2: Use `class` if the class has an invariant; use `struct` if the data members can vary independently"
msgstr""

       
# CppCoreGuidelines.md:2738
msgid "2738    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2739
msgid "2739    Readability."
msgstr""

# CppCoreGuidelines.md:2740
msgid "2740    Ease of comprehension."
msgstr""

# CppCoreGuidelines.md:2741
msgid "2741    The use of `class` alerts the programmer to the need for an invariant."
msgstr""

# CppCoreGuidelines.md:2742
msgid "2742    This is a useful convention."
msgstr""

       
# CppCoreGuidelines.md:2743
msgid "2743    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2744
msgid "2744    An invariant is a logical condition for the members of an object that a constructor must establish for the public member functions to assume."
msgstr""

# CppCoreGuidelines.md:2745
msgid "2745    After the invariant is established (typically by a constructor) every member function can be called for the object."
msgstr""

# CppCoreGuidelines.md:2746
msgid "2746    An invariant can be stated informally (e.g., in a comment) or more formally using `Expects`."
msgstr""

       
# CppCoreGuidelines.md:2747
msgid "2747    If all data members can vary independently of each other, no invariant is possible."
msgstr""

       
# CppCoreGuidelines.md:2748
msgid "2748    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2749
msgid "2749        struct Pair {  // the members can vary independently"
msgstr""

# CppCoreGuidelines.md:2750
msgid "2750            string name;"
msgstr""

# CppCoreGuidelines.md:2751
msgid "2751            int volume;"
msgstr""

# CppCoreGuidelines.md:2752
msgid "2752        };"
msgstr""

       
# CppCoreGuidelines.md:2753
msgid "2753    but:"
msgstr""

       
# CppCoreGuidelines.md:2754
msgid "2754        class Date {"
msgstr""

# CppCoreGuidelines.md:2755
msgid "2755        public:"
msgstr""

# CppCoreGuidelines.md:2756
msgid "2756            // validate that {yy, mm, dd} is a valid date and initialize"
msgstr""

# CppCoreGuidelines.md:2757
msgid "2757            Date(int yy, Month mm, char dd);"
msgstr""

# CppCoreGuidelines.md:2758
msgid "2758            // ..."
msgstr""

# CppCoreGuidelines.md:2759
msgid "2759        private:"
msgstr""

# CppCoreGuidelines.md:2760
msgid "2760            int y;"
msgstr""

# CppCoreGuidelines.md:2761
msgid "2761            Month m;"
msgstr""

# CppCoreGuidelines.md:2762
msgid "2762            char d;    // day"
msgstr""

# CppCoreGuidelines.md:2763
msgid "2763        };"
msgstr""

       
# CppCoreGuidelines.md:2764
msgid "2764    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2765
msgid "2765    If a class has any `private` data, a user cannot completely initialize an object without the use of a constructor."
msgstr""

# CppCoreGuidelines.md:2766
msgid "2766    Hence, the class definer will provide a constructor and must specify its meaning."
msgstr""

# CppCoreGuidelines.md:2767
msgid "2767    This effectively means the definer need to define an invariant."
msgstr""

       
# CppCoreGuidelines.md:2768
msgid "2768    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:2769
msgid "2769    * [define a class with private data as `class`](#Rc-class)"
msgstr""

# CppCoreGuidelines.md:2770
msgid "2770    * [Prefer to place the interface first in a class](#Rl-order)"
msgstr""

# CppCoreGuidelines.md:2771
msgid "2771    * [minimize exposure of members](#Rc-private)"
msgstr""

# CppCoreGuidelines.md:2772
msgid "2772    * [Avoid `protected` data](#Rh-protected)"
msgstr""

       
# CppCoreGuidelines.md:2773
msgid "2773    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2774
msgid "2774    Look for `struct`s with all data private and `class`es with public members."
msgstr""

       
# CppCoreGuidelines.md:2775
msgid "2775    ### <a name=\"Rc-interface\"></a>C.3: Represent the distinction between an interface and an implementation using a class"
msgstr""

       
# CppCoreGuidelines.md:2776
msgid "2776    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2777
msgid "2777    An explicit distinction between interface and implementation improves readability and simplifies maintenance."
msgstr""

       
# CppCoreGuidelines.md:2778
msgid "2778    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2779
msgid "2779        class Date {"
msgstr""

# CppCoreGuidelines.md:2780
msgid "2780            // ... some representation ..."
msgstr""

# CppCoreGuidelines.md:2781
msgid "2781        public:"
msgstr""

# CppCoreGuidelines.md:2782
msgid "2782            Date();"
msgstr""

# CppCoreGuidelines.md:2783
msgid "2783            // validate that {yy, mm, dd} is a valid date and initialize"
msgstr""

# CppCoreGuidelines.md:2784
msgid "2784            Date(int yy, Month mm, char dd);"
msgstr""

       
# CppCoreGuidelines.md:2785
msgid "2785            int day() const;"
msgstr""

# CppCoreGuidelines.md:2786
msgid "2786            Month month() const;"
msgstr""

# CppCoreGuidelines.md:2787
msgid "2787            // ..."
msgstr""

# CppCoreGuidelines.md:2788
msgid "2788        };"
msgstr""

       
# CppCoreGuidelines.md:2789
msgid "2789    For example, we can now change the representation of a `Date` without affecting its users (recompilation is likely, though)."
msgstr""

       
# CppCoreGuidelines.md:2790
msgid "2790    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2791
msgid "2791    Using a class in this way to represent the distinction between interface and implementation is of course not the only way."
msgstr""

# CppCoreGuidelines.md:2792
msgid "2792    For example, we can use a set of declarations of freestanding functions in a namespace, an abstract base class, or a template function with concepts to represent an interface."
msgstr""

# CppCoreGuidelines.md:2793
msgid "2793    The most important issue is to explicitly distinguish between an interface and its implementation \"details.\""
msgstr""

# CppCoreGuidelines.md:2794
msgid "2794    Ideally, and typically, an interface is far more stable than its implementation(s)."
msgstr""

       
# CppCoreGuidelines.md:2795
msgid "2795    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2796
msgid "2796    ???"
msgstr""

       
# CppCoreGuidelines.md:2797
msgid "2797    ### <a name=\"Rc-member\"></a>C.4: Make a function a member only if it needs direct access to the representation of a class"
msgstr""

       
# CppCoreGuidelines.md:2798
msgid "2798    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2799
msgid "2799    Less coupling than with member functions, fewer functions that can cause trouble by modifying object state, reduces the number of functions that needs to be modified after a change in representation."
msgstr""

       
# CppCoreGuidelines.md:2800
msgid "2800    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2801
msgid "2801        class Date {"
msgstr""

# CppCoreGuidelines.md:2802
msgid "2802            // ... relatively small interface ..."
msgstr""

# CppCoreGuidelines.md:2803
msgid "2803        };"
msgstr""

       
# CppCoreGuidelines.md:2804
msgid "2804        // helper functions:"
msgstr""

# CppCoreGuidelines.md:2805
msgid "2805        Date next_weekday(Date);"
msgstr""

# CppCoreGuidelines.md:2806
msgid "2806        bool operator==(Date, Date);"
msgstr""

       
# CppCoreGuidelines.md:2807
msgid "2807    The \"helper functions\" have no need for direct access to the representation of a `Date`."
msgstr""

       
# CppCoreGuidelines.md:2808
msgid "2808    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2809
msgid "2809    This rule becomes even better if C++ gets [\"uniform function call\"](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf)."
msgstr""

       
# CppCoreGuidelines.md:2810
msgid "2810    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2811
msgid "2811    The language requires `virtual` functions to be members, and not all `virtual` functions directly access data."
msgstr""

# CppCoreGuidelines.md:2812
msgid "2812    In particular, members of an abstract class rarely do."
msgstr""

       
# CppCoreGuidelines.md:2813
msgid "2813    Note [multi-methods](https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf)."
msgstr""

       
# CppCoreGuidelines.md:2814
msgid "2814    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2815
msgid "2815    The language requires operators `=`, `()`, `[]`, and `->` to be members."
msgstr""

       
# CppCoreGuidelines.md:2816
msgid "2816    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:2817
msgid "2817    An overload set may have some members that do not directly access `private` data:"
msgstr""

       
# CppCoreGuidelines.md:2818
msgid "2818        class Foobar {"
msgstr""

# CppCoreGuidelines.md:2819
msgid "2819        public:"
msgstr""

# CppCoreGuidelines.md:2820
msgid "2820            void foo(long x)    { /* manipulate private data */ }"
msgstr""

# CppCoreGuidelines.md:2821
msgid "2821            void foo(double x) { foo(std::lround(x)); }"
msgstr""

# CppCoreGuidelines.md:2822
msgid "2822            // ..."
msgstr""

# CppCoreGuidelines.md:2823
msgid "2823        private:"
msgstr""

# CppCoreGuidelines.md:2824
msgid "2824            // ..."
msgstr""

# CppCoreGuidelines.md:2825
msgid "2825        };"
msgstr""

       
# CppCoreGuidelines.md:2826
msgid "2826    Similarly, a set of functions may be designed to be used in a chain:"
msgstr""

       
# CppCoreGuidelines.md:2827
msgid "2827        x.scale(0.5).rotate(45).set_color(Color::red);"
msgstr""

       
# CppCoreGuidelines.md:2828
msgid "2828    Typically, some but not all of such functions directly access `private` data."
msgstr""

       
# CppCoreGuidelines.md:2829
msgid "2829    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2830
msgid "2830    * Look for non-`virtual` member functions that do not touch data members directly."
msgstr""

# CppCoreGuidelines.md:2831
msgid "2831    The snag is that many member functions that do not need to touch data members directly do."
msgstr""

# CppCoreGuidelines.md:2832
msgid "2832    * Ignore `virtual` functions."
msgstr""

# CppCoreGuidelines.md:2833
msgid "2833    * Ignore functions that are part of an overload set out of which at least one function accesses `private` members."
msgstr""

# CppCoreGuidelines.md:2834
msgid "2834    * Ignore functions returning `this`."
msgstr""

       
# CppCoreGuidelines.md:2835
msgid "2835    ### <a name=\"Rc-helper\"></a>C.5: Place helper functions in the same namespace as the class they support"
msgstr""

       
# CppCoreGuidelines.md:2836
msgid "2836    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2837
msgid "2837    A helper function is a function (usually supplied by the writer of a class) that does not need direct access to the representation of the class, yet is seen as part of the useful interface to the class."
msgstr""

# CppCoreGuidelines.md:2838
msgid "2838    Placing them in the same namespace as the class makes their relationship to the class obvious and allows them to be found by argument dependent lookup."
msgstr""

       
# CppCoreGuidelines.md:2839
msgid "2839    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2840
msgid "2840        namespace Chrono { // here we keep time-related services"
msgstr""

       
# CppCoreGuidelines.md:2841
msgid "2841            class Time { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:2842
msgid "2842            class Date { /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:2843
msgid "2843            // helper functions:"
msgstr""

# CppCoreGuidelines.md:2844
msgid "2844            bool operator==(Date, Date);"
msgstr""

# CppCoreGuidelines.md:2845
msgid "2845            Date next_weekday(Date);"
msgstr""

# CppCoreGuidelines.md:2846
msgid "2846            // ..."
msgstr""

# CppCoreGuidelines.md:2847
msgid "2847        }"
msgstr""

       
# CppCoreGuidelines.md:2848
msgid "2848    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2849
msgid "2849    This is especially important for [overloaded operators](#Ro-namespace)."
msgstr""

       
# CppCoreGuidelines.md:2850
msgid "2850    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2851
msgid "2851    * Flag global functions taking argument types from a single namespace."
msgstr""

       
# CppCoreGuidelines.md:2852
msgid "2852    ### <a name=\"Rc-standalone\"></a>C.7: Don't define a class or enum and declare a variable of its type in the same statement"
msgstr""

       
# CppCoreGuidelines.md:2853
msgid "2853    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2854
msgid "2854    Mixing a type definition and the definition of another entity in the same declaration is confusing and unnecessary."
msgstr""

       
# CppCoreGuidelines.md:2855
msgid "2855    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:2856
msgid "2856        struct Data { /*...*/ } data{ /*...*/ };"
msgstr""

       
# CppCoreGuidelines.md:2857
msgid "2857    ##### Example; good"
msgstr""

       
# CppCoreGuidelines.md:2858
msgid "2858        struct Data { /*...*/ };"
msgstr""

# CppCoreGuidelines.md:2859
msgid "2859        Data data{ /*...*/ };"
msgstr""

       
# CppCoreGuidelines.md:2860
msgid "2860    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2861
msgid "2861    * Flag if the `}` of a class or enumeration definition is not followed by a `;`. The `;` is missing."
msgstr""

       
# CppCoreGuidelines.md:2862
msgid "2862    ### <a name=\"Rc-class\"></a>C.8: Use `class` rather than `struct` if any member is non-public"
msgstr""

       
# CppCoreGuidelines.md:2863
msgid "2863    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2864
msgid "2864    Readability."
msgstr""

# CppCoreGuidelines.md:2865
msgid "2865    To make it clear that something is being hidden/abstracted."
msgstr""

# CppCoreGuidelines.md:2866
msgid "2866    This is a useful convention."
msgstr""

       
# CppCoreGuidelines.md:2867
msgid "2867    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:2868
msgid "2868        struct Date {"
msgstr""

# CppCoreGuidelines.md:2869
msgid "2869            int d, m;"
msgstr""

       
# CppCoreGuidelines.md:2870
msgid "2870            Date(int i, Month m);"
msgstr""

# CppCoreGuidelines.md:2871
msgid "2871            // ... lots of functions ..."
msgstr""

# CppCoreGuidelines.md:2872
msgid "2872        private:"
msgstr""

# CppCoreGuidelines.md:2873
msgid "2873            int y;  // year"
msgstr""

# CppCoreGuidelines.md:2874
msgid "2874        };"
msgstr""

       
# CppCoreGuidelines.md:2875
msgid "2875    There is nothing wrong with this code as far as the C++ language rules are concerned,"
msgstr""

# CppCoreGuidelines.md:2876
msgid "2876    but nearly everything is wrong from a design perspective."
msgstr""

# CppCoreGuidelines.md:2877
msgid "2877    The private data is hidden far from the public data."
msgstr""

# CppCoreGuidelines.md:2878
msgid "2878    The data is split in different parts of the class declaration."
msgstr""

# CppCoreGuidelines.md:2879
msgid "2879    Different parts of the data have different access."
msgstr""

# CppCoreGuidelines.md:2880
msgid "2880    All of this decreases readability and complicates maintenance."
msgstr""

       
# CppCoreGuidelines.md:2881
msgid "2881    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2882
msgid "2882    Prefer to place the interface first in a class, [see NL.16](#Rl-order)."
msgstr""

       
# CppCoreGuidelines.md:2883
msgid "2883    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2884
msgid "2884    Flag classes declared with `struct` if there is a `private` or `protected` member."
msgstr""

       
# CppCoreGuidelines.md:2885
msgid "2885    ### <a name=\"Rc-private\"></a>C.9: Minimize exposure of members"
msgstr""

       
# CppCoreGuidelines.md:2886
msgid "2886    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2887
msgid "2887    Encapsulation."
msgstr""

# CppCoreGuidelines.md:2888
msgid "2888    Information hiding."
msgstr""

# CppCoreGuidelines.md:2889
msgid "2889    Minimize the chance of unintended access."
msgstr""

# CppCoreGuidelines.md:2890
msgid "2890    This simplifies maintenance."
msgstr""

       
# CppCoreGuidelines.md:2891
msgid "2891    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2892
msgid "2892        template<typename T, typename U>"
msgstr""

# CppCoreGuidelines.md:2893
msgid "2893        struct pair {"
msgstr""

# CppCoreGuidelines.md:2894
msgid "2894            T a;"
msgstr""

# CppCoreGuidelines.md:2895
msgid "2895            U b;"
msgstr""

# CppCoreGuidelines.md:2896
msgid "2896            // ..."
msgstr""

# CppCoreGuidelines.md:2897
msgid "2897        };"
msgstr""

       
# CppCoreGuidelines.md:2898
msgid "2898    Whatever we do in the `//`-part, an arbitrary user of a `pair` can arbitrarily and independently change its `a` and `b`."
msgstr""

# CppCoreGuidelines.md:2899
msgid "2899    In a large code base, we cannot easily find which code does what to the members of `pair`."
msgstr""

# CppCoreGuidelines.md:2900
msgid "2900    This may be exactly what we want, but if we want to enforce a relation among members, we need to make them `private`"
msgstr""

# CppCoreGuidelines.md:2901
msgid "2901    and enforce that relation (invariant) through constructors and member functions."
msgstr""

# CppCoreGuidelines.md:2902
msgid "2902    For example:"
msgstr""

       
# CppCoreGuidelines.md:2903
msgid "2903        class Distance {"
msgstr""

# CppCoreGuidelines.md:2904
msgid "2904        public:"
msgstr""

# CppCoreGuidelines.md:2905
msgid "2905            // ..."
msgstr""

# CppCoreGuidelines.md:2906
msgid "2906            double meters() const { return magnitude*unit; }"
msgstr""

# CppCoreGuidelines.md:2907
msgid "2907            void set_unit(double u)"
msgstr""

# CppCoreGuidelines.md:2908
msgid "2908            {"
msgstr""

# CppCoreGuidelines.md:2909
msgid "2909                    // ... check that u is a factor of 10 ..."
msgstr""

# CppCoreGuidelines.md:2910
msgid "2910                    // ... change magnitude appropriately ..."
msgstr""

# CppCoreGuidelines.md:2911
msgid "2911                    unit = u;"
msgstr""

# CppCoreGuidelines.md:2912
msgid "2912            }"
msgstr""

# CppCoreGuidelines.md:2913
msgid "2913            // ..."
msgstr""

# CppCoreGuidelines.md:2914
msgid "2914        private:"
msgstr""

# CppCoreGuidelines.md:2915
msgid "2915            double magnitude;"
msgstr""

# CppCoreGuidelines.md:2916
msgid "2916            double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc."
msgstr""

# CppCoreGuidelines.md:2917
msgid "2917        };"
msgstr""

       
# CppCoreGuidelines.md:2918
msgid "2918    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2919
msgid "2919    If the set of direct users of a set of variables cannot be easily determined, the type or usage of that set cannot be (easily) changed/improved."
msgstr""

# CppCoreGuidelines.md:2920
msgid "2920    For `public` and `protected` data, that's usually the case."
msgstr""

       
# CppCoreGuidelines.md:2921
msgid "2921    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2922
msgid "2922    A class can provide two interfaces to its users."
msgstr""

# CppCoreGuidelines.md:2923
msgid "2923    One for derived classes (`protected`) and one for general users (`public`)."
msgstr""

# CppCoreGuidelines.md:2924
msgid "2924    For example, a derived class might be allowed to skip a run-time check because it has already guaranteed correctness:"
msgstr""

       
# CppCoreGuidelines.md:2925
msgid "2925        class Foo {"
msgstr""

# CppCoreGuidelines.md:2926
msgid "2926        public:"
msgstr""

# CppCoreGuidelines.md:2927
msgid "2927            int bar(int x) { check(x); return do_bar(x); }"
msgstr""

# CppCoreGuidelines.md:2928
msgid "2928            // ..."
msgstr""

# CppCoreGuidelines.md:2929
msgid "2929        protected:"
msgstr""

# CppCoreGuidelines.md:2930
msgid "2930            int do_bar(int x); // do some operation on the data"
msgstr""

# CppCoreGuidelines.md:2931
msgid "2931            // ..."
msgstr""

# CppCoreGuidelines.md:2932
msgid "2932        private:"
msgstr""

# CppCoreGuidelines.md:2933
msgid "2933            // ... data ..."
msgstr""

# CppCoreGuidelines.md:2934
msgid "2934        };"
msgstr""

       
# CppCoreGuidelines.md:2935
msgid "2935        class Dir : public Foo {"
msgstr""

# CppCoreGuidelines.md:2936
msgid "2936            //..."
msgstr""

# CppCoreGuidelines.md:2937
msgid "2937            int mem(int x, int y)"
msgstr""

# CppCoreGuidelines.md:2938
msgid "2938            {"
msgstr""

# CppCoreGuidelines.md:2939
msgid "2939                /* ... do something ... */"
msgstr""

# CppCoreGuidelines.md:2940
msgid "2940                return do_bar(x + y); // OK: derived class can bypass check"
msgstr""

# CppCoreGuidelines.md:2941
msgid "2941            }"
msgstr""

# CppCoreGuidelines.md:2942
msgid "2942        };"
msgstr""

       
# CppCoreGuidelines.md:2943
msgid "2943        void user(Foo& x)"
msgstr""

# CppCoreGuidelines.md:2944
msgid "2944        {"
msgstr""

# CppCoreGuidelines.md:2945
msgid "2945            int r1 = x.bar(1);      // OK, will check"
msgstr""

# CppCoreGuidelines.md:2946
msgid "2946            int r2 = x.do_bar(2);   // error: would bypass check"
msgstr""

# CppCoreGuidelines.md:2947
msgid "2947            // ..."
msgstr""

# CppCoreGuidelines.md:2948
msgid "2948        }"
msgstr""

       
# CppCoreGuidelines.md:2949
msgid "2949    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2950
msgid "2950    [`protected` data is a bad idea](#Rh-protected)."
msgstr""

       
# CppCoreGuidelines.md:2951
msgid "2951    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2952
msgid "2952    Prefer the order `public` members before `protected` members before `private` members [see](#Rl-order)."
msgstr""

       
# CppCoreGuidelines.md:2953
msgid "2953    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:2954
msgid "2954    * [Flag protected data](#Rh-protected)."
msgstr""

# CppCoreGuidelines.md:2955
msgid "2955    * Flag mixtures of `public` and private `data`"
msgstr""

       
# CppCoreGuidelines.md:2956
msgid "2956    ## <a name=\"SS-concrete\"></a>C.concrete: Concrete types"
msgstr""

       
# CppCoreGuidelines.md:2957
msgid "2957    One ideal for a class is to be a regular type."
msgstr""

# CppCoreGuidelines.md:2958
msgid "2958    That means roughly \"behaves like an `int`.\" A concrete type is the simplest kind of class."
msgstr""

# CppCoreGuidelines.md:2959
msgid "2959    A value of regular type can be copied and the result of a copy is an independent object with the same value as the original."
msgstr""

# CppCoreGuidelines.md:2960
msgid "2960    If a concrete type has both `=` and `==`, `a = b` should result in `a == b` being `true`."
msgstr""

# CppCoreGuidelines.md:2961
msgid "2961    Concrete classes without assignment and equality can be defined, but they are (and should be) rare."
msgstr""

# CppCoreGuidelines.md:2962
msgid "2962    The C++ built-in types are regular, and so are standard-library classes, such as `string`, `vector`, and `map`."
msgstr""

# CppCoreGuidelines.md:2963
msgid "2963    Concrete types are also often referred to as value types to distinguish them from types used as part of a hierarchy."
msgstr""

       
# CppCoreGuidelines.md:2964
msgid "2964    Concrete type rule summary:"
msgstr""

       
# CppCoreGuidelines.md:2965
msgid "2965    * [C.10: Prefer concrete types over class hierarchies](#Rc-concrete)"
msgstr""

# CppCoreGuidelines.md:2966
msgid "2966    * [C.11: Make concrete types regular](#Rc-regular)"
msgstr""

       
# CppCoreGuidelines.md:2967
msgid "2967    ### <a name=\"Rc-concrete\"></a>C.10: Prefer concrete types over class hierarchies"
msgstr""

       
# CppCoreGuidelines.md:2968
msgid "2968    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:2969
msgid "2969    A concrete type is fundamentally simpler than a hierarchy:"
msgstr""

# CppCoreGuidelines.md:2970
msgid "2970    easier to design, easier to implement, easier to use, easier to reason about, smaller, and faster."
msgstr""

# CppCoreGuidelines.md:2971
msgid "2971    You need a reason (use cases) for using a hierarchy."
msgstr""

       
# CppCoreGuidelines.md:2972
msgid "2972    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:2973
msgid "2973        class Point1 {"
msgstr""

# CppCoreGuidelines.md:2974
msgid "2974            int x, y;"
msgstr""

# CppCoreGuidelines.md:2975
msgid "2975            // ... operations ..."
msgstr""

# CppCoreGuidelines.md:2976
msgid "2976            // ... no virtual functions ..."
msgstr""

# CppCoreGuidelines.md:2977
msgid "2977        };"
msgstr""

       
# CppCoreGuidelines.md:2978
msgid "2978        class Point2 {"
msgstr""

# CppCoreGuidelines.md:2979
msgid "2979            int x, y;"
msgstr""

# CppCoreGuidelines.md:2980
msgid "2980            // ... operations, some virtual ..."
msgstr""

# CppCoreGuidelines.md:2981
msgid "2981            virtual ~Point2();"
msgstr""

# CppCoreGuidelines.md:2982
msgid "2982        };"
msgstr""

       
# CppCoreGuidelines.md:2983
msgid "2983        void use()"
msgstr""

# CppCoreGuidelines.md:2984
msgid "2984        {"
msgstr""

# CppCoreGuidelines.md:2985
msgid "2985            Point1 p11 {1, 2};   // make an object on the stack"
msgstr""

# CppCoreGuidelines.md:2986
msgid "2986            Point1 p12 {p11};    // a copy"
msgstr""

       
# CppCoreGuidelines.md:2987
msgid "2987            auto p21 = make_unique<Point2>(1, 2);   // make an object on the free store"
msgstr""

# CppCoreGuidelines.md:2988
msgid "2988            auto p22 = p21.clone();                 // make a copy"
msgstr""

# CppCoreGuidelines.md:2989
msgid "2989            // ..."
msgstr""

# CppCoreGuidelines.md:2990
msgid "2990        }"
msgstr""

       
# CppCoreGuidelines.md:2991
msgid "2991    If a class can be part of a hierarchy, we (in real code if not necessarily in small examples) must manipulate its objects through pointers or references."
msgstr""

# CppCoreGuidelines.md:2992
msgid "2992    That implies more memory overhead, more allocations and deallocations, and more run-time overhead to perform the resulting indirections."
msgstr""

       
# CppCoreGuidelines.md:2993
msgid "2993    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2994
msgid "2994    Concrete types can be stack-allocated and be members of other classes."
msgstr""

       
# CppCoreGuidelines.md:2995
msgid "2995    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:2996
msgid "2996    The use of indirection is fundamental for run-time polymorphic interfaces."
msgstr""

# CppCoreGuidelines.md:2997
msgid "2997    The allocation/deallocation overhead is not (that's just the most common case)."
msgstr""

# CppCoreGuidelines.md:2998
msgid "2998    We can use a base class as the interface of a scoped object of a derived class."
msgstr""

# CppCoreGuidelines.md:2999
msgid "2999    This is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide a stable interface to some kinds of plug-ins."
msgstr""

       
# CppCoreGuidelines.md:3000
msgid "3000    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3001
msgid "3001    ???"
msgstr""

       
# CppCoreGuidelines.md:3002
msgid "3002    ### <a name=\"Rc-regular\"></a>C.11: Make concrete types regular"
msgstr""

       
# CppCoreGuidelines.md:3003
msgid "3003    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3004
msgid "3004    Regular types are easier to understand and reason about than types that are not regular (irregularities requires extra effort to understand and use)."
msgstr""

       
# CppCoreGuidelines.md:3005
msgid "3005    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3006
msgid "3006        struct Bundle {"
msgstr""

# CppCoreGuidelines.md:3007
msgid "3007            string name;"
msgstr""

# CppCoreGuidelines.md:3008
msgid "3008            vector<Record> vr;"
msgstr""

# CppCoreGuidelines.md:3009
msgid "3009        };"
msgstr""

       
# CppCoreGuidelines.md:3010
msgid "3010        bool operator==(const Bundle& a, const Bundle& b)"
msgstr""

# CppCoreGuidelines.md:3011
msgid "3011        {"
msgstr""

# CppCoreGuidelines.md:3012
msgid "3012            return a.name == b.name && a.vr == b.vr;"
msgstr""

# CppCoreGuidelines.md:3013
msgid "3013        }"
msgstr""

       
# CppCoreGuidelines.md:3014
msgid "3014        Bundle b1 { \"my bundle\", {r1, r2, r3}};"
msgstr""

# CppCoreGuidelines.md:3015
msgid "3015        Bundle b2 = b1;"
msgstr""

# CppCoreGuidelines.md:3016
msgid "3016        if (!(b1 == b2)) error(\"impossible!\");"
msgstr""

# CppCoreGuidelines.md:3017
msgid "3017        b2.name = \"the other bundle\";"
msgstr""

# CppCoreGuidelines.md:3018
msgid "3018        if (b1 == b2) error(\"No!\");"
msgstr""

       
# CppCoreGuidelines.md:3019
msgid "3019    In particular, if a concrete type has an assignment also give it an equals operator so that `a = b` implies `a == b`."
msgstr""

       
# CppCoreGuidelines.md:3020
msgid "3020    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3021
msgid "3021    ???"
msgstr""

       
# CppCoreGuidelines.md:3022
msgid "3022    ## <a name=\"S-ctor\"></a>C.ctor: Constructors, assignments, and destructors"
msgstr""

       
# CppCoreGuidelines.md:3023
msgid "3023    These functions control the lifecycle of objects: creation, copy, move, and destruction."
msgstr""

# CppCoreGuidelines.md:3024
msgid "3024    Define constructors to guarantee and simplify initialization of classes."
msgstr""

       
# CppCoreGuidelines.md:3025
msgid "3025    These are *default operations*:"
msgstr""

       
# CppCoreGuidelines.md:3026
msgid "3026    * a default constructor: `X()`"
msgstr""

# CppCoreGuidelines.md:3027
msgid "3027    * a copy constructor: `X(const X&)`"
msgstr""

# CppCoreGuidelines.md:3028
msgid "3028    * a copy assignment: `operator=(const X&)`"
msgstr""

# CppCoreGuidelines.md:3029
msgid "3029    * a move constructor: `X(X&&)`"
msgstr""

# CppCoreGuidelines.md:3030
msgid "3030    * a move assignment: `operator=(X&&)`"
msgstr""

# CppCoreGuidelines.md:3031
msgid "3031    * a destructor: `~X()`"
msgstr""

       
# CppCoreGuidelines.md:3032
msgid "3032    By default, the compiler defines each of these operations if it is used, but the default can be suppressed."
msgstr""

       
# CppCoreGuidelines.md:3033
msgid "3033    The default operations are a set of related operations that together implement the lifecycle semantics of an object."
msgstr""

# CppCoreGuidelines.md:3034
msgid "3034    By default, C++ treats classes as value-like types, but not all types are value-like."
msgstr""

       
# CppCoreGuidelines.md:3035
msgid "3035    Set of default operations rules:"
msgstr""

       
# CppCoreGuidelines.md:3036
msgid "3036    * [C.20: If you can avoid defining any default operations, do](#Rc-zero)"
msgstr""

# CppCoreGuidelines.md:3037
msgid "3037    * [C.21: If you define or `=delete` any default operation, define or `=delete` them all](#Rc-five)"
msgstr""

# CppCoreGuidelines.md:3038
msgid "3038    * [C.22: Make default operations consistent](#Rc-matched)"
msgstr""

       
# CppCoreGuidelines.md:3039
msgid "3039    Destructor rules:"
msgstr""

       
# CppCoreGuidelines.md:3040
msgid "3040    * [C.30: Define a destructor if a class needs an explicit action at object destruction](#Rc-dtor)"
msgstr""

# CppCoreGuidelines.md:3041
msgid "3041    * [C.31: All resources acquired by a class must be released by the class's destructor](#Rc-dtor-release)"
msgstr""

# CppCoreGuidelines.md:3042
msgid "3042    * [C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether it might be owning](#Rc-dtor-ptr)"
msgstr""

# CppCoreGuidelines.md:3043
msgid "3043    * [C.33: If a class has an owning pointer member, define or `=delete` a destructor](#Rc-dtor-ptr2)"
msgstr""

# CppCoreGuidelines.md:3044
msgid "3044    * [C.35: A base class with a virtual function needs a virtual destructor](#Rc-dtor-virtual)"
msgstr""

# CppCoreGuidelines.md:3045
msgid "3045    * [C.36: A destructor may not fail](#Rc-dtor-fail)"
msgstr""

# CppCoreGuidelines.md:3046
msgid "3046    * [C.37: Make destructors `noexcept`](#Rc-dtor-noexcept)"
msgstr""

       
# CppCoreGuidelines.md:3047
msgid "3047    Constructor rules:"
msgstr""

       
# CppCoreGuidelines.md:3048
msgid "3048    * [C.40: Define a constructor if a class has an invariant](#Rc-ctor)"
msgstr""

# CppCoreGuidelines.md:3049
msgid "3049    * [C.41: A constructor should create a fully initialized object](#Rc-complete)"
msgstr""

# CppCoreGuidelines.md:3050
msgid "3050    * [C.42: If a constructor cannot construct a valid object, throw an exception](#Rc-throw)"
msgstr""

# CppCoreGuidelines.md:3051
msgid "3051    * [C.43: Ensure that a copyable (value type) class has a default constructor](#Rc-default0)"
msgstr""

# CppCoreGuidelines.md:3052
msgid "3052    * [C.44: Prefer default constructors to be simple and non-throwing](#Rc-default00)"
msgstr""

# CppCoreGuidelines.md:3053
msgid "3053    * [C.45: Don't define a default constructor that only initializes data members; use member initializers instead](#Rc-default)"
msgstr""

# CppCoreGuidelines.md:3054
msgid "3054    * [C.46: By default, declare single-argument constructors `explicit`](#Rc-explicit)"
msgstr""

# CppCoreGuidelines.md:3055
msgid "3055    * [C.47: Define and initialize member variables in the order of member declaration](#Rc-order)"
msgstr""

# CppCoreGuidelines.md:3056
msgid "3056    * [C.48: Prefer in-class initializers to member initializers in constructors for constant initializers](#Rc-in-class-initializer)"
msgstr""

# CppCoreGuidelines.md:3057
msgid "3057    * [C.49: Prefer initialization to assignment in constructors](#Rc-initialize)"
msgstr""

# CppCoreGuidelines.md:3058
msgid "3058    * [C.50: Use a factory function if you need \"virtual behavior\" during initialization](#Rc-factory)"
msgstr""

# CppCoreGuidelines.md:3059
msgid "3059    * [C.51: Use delegating constructors to represent common actions for all constructors of a class](#Rc-delegating)"
msgstr""

# CppCoreGuidelines.md:3060
msgid "3060    * [C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization](#Rc-inheriting)"
msgstr""

       
# CppCoreGuidelines.md:3061
msgid "3061    Copy and move rules:"
msgstr""

       
# CppCoreGuidelines.md:3062
msgid "3062    * [C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and return by non-`const&`](#Rc-copy-assignment)"
msgstr""

# CppCoreGuidelines.md:3063
msgid "3063    * [C.61: A copy operation should copy](#Rc-copy-semantic)"
msgstr""

# CppCoreGuidelines.md:3064
msgid "3064    * [C.62: Make copy assignment safe for self-assignment](#Rc-copy-self)"
msgstr""

# CppCoreGuidelines.md:3065
msgid "3065    * [C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return by non-`const&`](#Rc-move-assignment)"
msgstr""

# CppCoreGuidelines.md:3066
msgid "3066    * [C.64: A move operation should move and leave its source in a valid state](#Rc-move-semantic)"
msgstr""

# CppCoreGuidelines.md:3067
msgid "3067    * [C.65: Make move assignment safe for self-assignment](#Rc-move-self)"
msgstr""

# CppCoreGuidelines.md:3068
msgid "3068    * [C.66: Make move operations `noexcept`](#Rc-move-noexcept)"
msgstr""

# CppCoreGuidelines.md:3069
msgid "3069    * [C.67: A polymorphic class should suppress copying](#Rc-copy-virtual)"
msgstr""

       
# CppCoreGuidelines.md:3070
msgid "3070    Other default operations rules:"
msgstr""

       
# CppCoreGuidelines.md:3071
msgid "3071    * [C.80: Use `=default` if you have to be explicit about using the default semantics](#Rc-eqdefault)"
msgstr""

# CppCoreGuidelines.md:3072
msgid "3072    * [C.81: Use `=delete` when you want to disable default behavior (without wanting an alternative)](#Rc-delete)"
msgstr""

# CppCoreGuidelines.md:3073
msgid "3073    * [C.82: Don't call virtual functions in constructors and destructors](#Rc-ctor-virtual)"
msgstr""

# CppCoreGuidelines.md:3074
msgid "3074    * [C.83: For value-like types, consider providing a `noexcept` swap function](#Rc-swap)"
msgstr""

# CppCoreGuidelines.md:3075
msgid "3075    * [C.84: A `swap` may not fail](#Rc-swap-fail)"
msgstr""

# CppCoreGuidelines.md:3076
msgid "3076    * [C.85: Make `swap` `noexcept`](#Rc-swap-noexcept)"
msgstr""

# CppCoreGuidelines.md:3077
msgid "3077    * [C.86: Make `==` symmetric with respect of operand types and `noexcept`](#Rc-eq)"
msgstr""

# CppCoreGuidelines.md:3078
msgid "3078    * [C.87: Beware of `==` on base classes](#Rc-eq-base)"
msgstr""

# CppCoreGuidelines.md:3079
msgid "3079    * [C.89: Make a `hash` `noexcept`](#Rc-hash)"
msgstr""

       
# CppCoreGuidelines.md:3080
msgid "3080    ## <a name=\"SS-defop\"></a>C.defop: Default Operations"
msgstr""

       
# CppCoreGuidelines.md:3081
msgid "3081    By default, the language supplies the default operations with their default semantics."
msgstr""

# CppCoreGuidelines.md:3082
msgid "3082    However, a programmer can disable or replace these defaults."
msgstr""

       
# CppCoreGuidelines.md:3083
msgid "3083    ### <a name=\"Rc-zero\"></a>C.20: If you can avoid defining default operations, do"
msgstr""

       
# CppCoreGuidelines.md:3084
msgid "3084    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3085
msgid "3085    It's the simplest and gives the cleanest semantics."
msgstr""

       
# CppCoreGuidelines.md:3086
msgid "3086    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3087
msgid "3087        struct Named_map {"
msgstr""

# CppCoreGuidelines.md:3088
msgid "3088        public:"
msgstr""

# CppCoreGuidelines.md:3089
msgid "3089            // ... no default operations declared ..."
msgstr""

# CppCoreGuidelines.md:3090
msgid "3090        private:"
msgstr""

# CppCoreGuidelines.md:3091
msgid "3091            string name;"
msgstr""

# CppCoreGuidelines.md:3092
msgid "3092            map<int, int> rep;"
msgstr""

# CppCoreGuidelines.md:3093
msgid "3093        };"
msgstr""

       
# CppCoreGuidelines.md:3094
msgid "3094        Named_map nm;        // default construct"
msgstr""

# CppCoreGuidelines.md:3095
msgid "3095        Named_map nm2 {nm};  // copy construct"
msgstr""

       
# CppCoreGuidelines.md:3096
msgid "3096    Since `std::map` and `string` have all the special functions, no further work is needed."
msgstr""

       
# CppCoreGuidelines.md:3097
msgid "3097    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3098
msgid "3098    This is known as \"the rule of zero\"."
msgstr""

       
# CppCoreGuidelines.md:3099
msgid "3099    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3100
msgid "3100    (Not enforceable) While not enforceable, a good static analyzer can detect patterns that indicate a possible improvement to meet this rule."
msgstr""

# CppCoreGuidelines.md:3101
msgid "3101    For example, a class with a (pointer, size) pair of member and a destructor that `delete`s the pointer could probably be converted to a `vector`."
msgstr""

       
# CppCoreGuidelines.md:3102
msgid "3102    ### <a name=\"Rc-five\"></a>C.21: If you define or `=delete` any default operation, define or `=delete` them all"
msgstr""

       
# CppCoreGuidelines.md:3103
msgid "3103    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3104
msgid "3104    The *special member functions* are the default constructor, copy constructor,"
msgstr""

# CppCoreGuidelines.md:3105
msgid "3105    copy assignment operator, move constructor, move assignment operator, and"
msgstr""

# CppCoreGuidelines.md:3106
msgid "3106    destructor."
msgstr""

       
# CppCoreGuidelines.md:3107
msgid "3107    The semantics of the special functions are closely related, so if one needs to be declared, the odds are that others need consideration too."
msgstr""

       
# CppCoreGuidelines.md:3108
msgid "3108    Declaring any special member function except a default constructor,"
msgstr""

# CppCoreGuidelines.md:3109
msgid "3109    even as `=default` or `=delete`, will suppress the implicit declaration"
msgstr""

# CppCoreGuidelines.md:3110
msgid "3110    of a move constructor and move assignment operator."
msgstr""

# CppCoreGuidelines.md:3111
msgid "3111    Declaring a move constructor or move assignment operator, even as"
msgstr""

# CppCoreGuidelines.md:3112
msgid "3112    `=default` or `=delete`, will cause an implicitly generated copy constructor"
msgstr""

# CppCoreGuidelines.md:3113
msgid "3113    or implicitly generated copy assignment operator to be defined as deleted."
msgstr""

# CppCoreGuidelines.md:3114
msgid "3114    So as soon as any of the special functions is declared, the others should"
msgstr""

# CppCoreGuidelines.md:3115
msgid "3115    all be declared to avoid unwanted effects like turning all potential moves"
msgstr""

# CppCoreGuidelines.md:3116
msgid "3116    into more expensive copies, or making a class move-only."
msgstr""

       
# CppCoreGuidelines.md:3117
msgid "3117    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3118
msgid "3118        struct M2 {   // bad: incomplete set of default operations"
msgstr""

# CppCoreGuidelines.md:3119
msgid "3119        public:"
msgstr""

# CppCoreGuidelines.md:3120
msgid "3120            // ..."
msgstr""

# CppCoreGuidelines.md:3121
msgid "3121            // ... no copy or move operations ..."
msgstr""

# CppCoreGuidelines.md:3122
msgid "3122            ~M2() { delete[] rep; }"
msgstr""

# CppCoreGuidelines.md:3123
msgid "3123        private:"
msgstr""

# CppCoreGuidelines.md:3124
msgid "3124            pair<int, int>* rep;  // zero-terminated set of pairs"
msgstr""

# CppCoreGuidelines.md:3125
msgid "3125        };"
msgstr""

       
# CppCoreGuidelines.md:3126
msgid "3126        void use()"
msgstr""

# CppCoreGuidelines.md:3127
msgid "3127        {"
msgstr""

# CppCoreGuidelines.md:3128
msgid "3128            M2 x;"
msgstr""

# CppCoreGuidelines.md:3129
msgid "3129            M2 y;"
msgstr""

# CppCoreGuidelines.md:3130
msgid "3130            // ..."
msgstr""

# CppCoreGuidelines.md:3131
msgid "3131            x = y;   // the default assignment"
msgstr""

# CppCoreGuidelines.md:3132
msgid "3132            // ..."
msgstr""

# CppCoreGuidelines.md:3133
msgid "3133        }"
msgstr""

       
# CppCoreGuidelines.md:3134
msgid "3134    Given that \"special attention\" was needed for the destructor (here, to deallocate), the likelihood that copy and move assignment (both will implicitly destroy an object) are correct is low (here, we would get double deletion)."
msgstr""

       
# CppCoreGuidelines.md:3135
msgid "3135    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3136
msgid "3136    This is known as \"the rule of five\" or \"the rule of six\", depending on whether you count the default constructor."
msgstr""

       
# CppCoreGuidelines.md:3137
msgid "3137    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3138
msgid "3138    If you want a default implementation of a default operation (while defining another), write `=default` to show you're doing so intentionally for that function."
msgstr""

# CppCoreGuidelines.md:3139
msgid "3139    If you don't want a default operation, suppress it with `=delete`."
msgstr""

       
# CppCoreGuidelines.md:3140
msgid "3140    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:3141
msgid "3141    When a destructor needs to be declared just to make it `virtual`, it can be"
msgstr""

# CppCoreGuidelines.md:3142
msgid "3142    defined as defaulted. To avoid suppressing the implicit move operations"
msgstr""

# CppCoreGuidelines.md:3143
msgid "3143    they must also be declared, and then to avoid the class becoming move-only"
msgstr""

# CppCoreGuidelines.md:3144
msgid "3144    (and not copyable) the copy operations must be declared:"
msgstr""

       
# CppCoreGuidelines.md:3145
msgid "3145        class AbstractBase {"
msgstr""

# CppCoreGuidelines.md:3146
msgid "3146        public:"
msgstr""

# CppCoreGuidelines.md:3147
msgid "3147          virtual ~AbstractBase() = default;"
msgstr""

# CppCoreGuidelines.md:3148
msgid "3148          AbstractBase(const AbstractBase&) = default;"
msgstr""

# CppCoreGuidelines.md:3149
msgid "3149          AbstractBase& operator=(const AbstractBase&) = default;"
msgstr""

# CppCoreGuidelines.md:3150
msgid "3150          AbstractBase(AbstractBase&&) = default;"
msgstr""

# CppCoreGuidelines.md:3151
msgid "3151          AbstractBase& operator=(AbstractBase&&) = default;"
msgstr""

# CppCoreGuidelines.md:3152
msgid "3152        };"
msgstr""

       
# CppCoreGuidelines.md:3153
msgid "3153    Alternatively to prevent slicing as per [C.67](#Rc-copy-virtual),"
msgstr""

# CppCoreGuidelines.md:3154
msgid "3154    the copy and move operations can all be deleted:"
msgstr""

       
# CppCoreGuidelines.md:3155
msgid "3155        class ClonableBase {"
msgstr""

# CppCoreGuidelines.md:3156
msgid "3156        public:"
msgstr""

# CppCoreGuidelines.md:3157
msgid "3157          virtual unique_ptr<ClonableBase> clone() const;"
msgstr""

# CppCoreGuidelines.md:3158
msgid "3158          virtual ~ClonableBase() = default;"
msgstr""

# CppCoreGuidelines.md:3159
msgid "3159          ClonableBase(const ClonableBase&) = delete;"
msgstr""

# CppCoreGuidelines.md:3160
msgid "3160          ClonableBase& operator=(const ClonableBase&) = delete;"
msgstr""

# CppCoreGuidelines.md:3161
msgid "3161          ClonableBase(ClonableBase&&) = delete;"
msgstr""

# CppCoreGuidelines.md:3162
msgid "3162          ClonableBase& operator=(ClonableBase&&) = delete;"
msgstr""

# CppCoreGuidelines.md:3163
msgid "3163        };"
msgstr""

       
# CppCoreGuidelines.md:3164
msgid "3164    Defining only the move operations or only the copy operations would have the"
msgstr""

# CppCoreGuidelines.md:3165
msgid "3165    same effect here, but stating the intent explicitly for each special member"
msgstr""

# CppCoreGuidelines.md:3166
msgid "3166    makes it more obvious to the reader."
msgstr""

       
# CppCoreGuidelines.md:3167
msgid "3167    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3168
msgid "3168    Compilers enforce much of this rule and ideally warn about any violation."
msgstr""

       
# CppCoreGuidelines.md:3169
msgid "3169    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3170
msgid "3170    Relying on an implicitly generated copy operation in a class with a destructor is deprecated."
msgstr""

       
# CppCoreGuidelines.md:3171
msgid "3171    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3172
msgid "3172    (Simple) A class should have a declaration (even a `=delete` one) for either all or none of the special functions."
msgstr""

       
# CppCoreGuidelines.md:3173
msgid "3173    ### <a name=\"Rc-matched\"></a>C.22: Make default operations consistent"
msgstr""

       
# CppCoreGuidelines.md:3174
msgid "3174    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3175
msgid "3175    The default operations are conceptually a matched set. Their semantics are interrelated."
msgstr""

# CppCoreGuidelines.md:3176
msgid "3176    Users will be surprised if copy/move construction and copy/move assignment do logically different things. Users will be surprised if constructors and destructors do not provide a consistent view of resource management. Users will be surprised if copy and move don't reflect the way constructors and destructors work."
msgstr""

       
# CppCoreGuidelines.md:3177
msgid "3177    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3178
msgid "3178        class Silly {   // BAD: Inconsistent copy operations"
msgstr""

# CppCoreGuidelines.md:3179
msgid "3179            class Impl {"
msgstr""

# CppCoreGuidelines.md:3180
msgid "3180                // ..."
msgstr""

# CppCoreGuidelines.md:3181
msgid "3181            };"
msgstr""

# CppCoreGuidelines.md:3182
msgid "3182            shared_ptr<Impl> p;"
msgstr""

# CppCoreGuidelines.md:3183
msgid "3183        public:"
msgstr""

# CppCoreGuidelines.md:3184
msgid "3184            Silly(const Silly& a) : p{a.p} { *p = *a.p; }   // deep copy"
msgstr""

# CppCoreGuidelines.md:3185
msgid "3185            Silly& operator=(const Silly& a) { p = a.p; }   // shallow copy"
msgstr""

# CppCoreGuidelines.md:3186
msgid "3186            // ..."
msgstr""

# CppCoreGuidelines.md:3187
msgid "3187        };"
msgstr""

       
# CppCoreGuidelines.md:3188
msgid "3188    These operations disagree about copy semantics. This will lead to confusion and bugs."
msgstr""

       
# CppCoreGuidelines.md:3189
msgid "3189    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3190
msgid "3190    * (Complex) A copy/move constructor and the corresponding copy/move assignment operator should write to the same member variables at the same level of dereference."
msgstr""

# CppCoreGuidelines.md:3191
msgid "3191    * (Complex) Any member variables written in a copy/move constructor should also be initialized by all other constructors."
msgstr""

# CppCoreGuidelines.md:3192
msgid "3192    * (Complex) If a copy/move constructor performs a deep copy of a member variable, then the destructor should modify the member variable."
msgstr""

# CppCoreGuidelines.md:3193
msgid "3193    * (Complex) If a destructor is modifying a member variable, that member variable should be written in any copy/move constructors or assignment operators."
msgstr""

       
# CppCoreGuidelines.md:3194
msgid "3194    ## <a name=\"SS-dtor\"></a>C.dtor: Destructors"
msgstr""

       
# CppCoreGuidelines.md:3195
msgid "3195    \"Does this class need a destructor?\" is a surprisingly powerful design question."
msgstr""

# CppCoreGuidelines.md:3196
msgid "3196    For most classes the answer is \"no\" either because the class holds no resources or because destruction is handled by [the rule of zero](#Rc-zero);"
msgstr""

# CppCoreGuidelines.md:3197
msgid "3197    that is, its members can take care of themselves as concerns destruction."
msgstr""

# CppCoreGuidelines.md:3198
msgid "3198    If the answer is \"yes\", much of the design of the class follows (see [the rule of five](#Rc-five))."
msgstr""

       
# CppCoreGuidelines.md:3199
msgid "3199    ### <a name=\"Rc-dtor\"></a>C.30: Define a destructor if a class needs an explicit action at object destruction"
msgstr""

       
# CppCoreGuidelines.md:3200
msgid "3200    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3201
msgid "3201    A destructor is implicitly invoked at the end of an object's lifetime."
msgstr""

# CppCoreGuidelines.md:3202
msgid "3202    If the default destructor is sufficient, use it."
msgstr""

# CppCoreGuidelines.md:3203
msgid "3203    Only define a non-default destructor if a class needs to execute code that is not already part of its members' destructors."
msgstr""

       
# CppCoreGuidelines.md:3204
msgid "3204    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3205
msgid "3205        template<typename A>"
msgstr""

# CppCoreGuidelines.md:3206
msgid "3206        struct final_action {   // slightly simplified"
msgstr""

# CppCoreGuidelines.md:3207
msgid "3207            A act;"
msgstr""

# CppCoreGuidelines.md:3208
msgid "3208            final_action(A a) :act{a} {}"
msgstr""

# CppCoreGuidelines.md:3209
msgid "3209            ~final_action() { act(); }"
msgstr""

# CppCoreGuidelines.md:3210
msgid "3210        };"
msgstr""

       
# CppCoreGuidelines.md:3211
msgid "3211        template<typename A>"
msgstr""

# CppCoreGuidelines.md:3212
msgid "3212        final_action<A> finally(A act)   // deduce action type"
msgstr""

# CppCoreGuidelines.md:3213
msgid "3213        {"
msgstr""

# CppCoreGuidelines.md:3214
msgid "3214            return final_action<A>{act};"
msgstr""

# CppCoreGuidelines.md:3215
msgid "3215        }"
msgstr""

       
# CppCoreGuidelines.md:3216
msgid "3216        void test()"
msgstr""

# CppCoreGuidelines.md:3217
msgid "3217        {"
msgstr""

# CppCoreGuidelines.md:3218
msgid "3218            auto act = finally([]{ cout << \"Exit test\\n\"; });  // establish exit action"
msgstr""

# CppCoreGuidelines.md:3219
msgid "3219            // ..."
msgstr""

# CppCoreGuidelines.md:3220
msgid "3220            if (something) return;   // act done here"
msgstr""

# CppCoreGuidelines.md:3221
msgid "3221            // ..."
msgstr""

# CppCoreGuidelines.md:3222
msgid "3222        } // act done here"
msgstr""

       
# CppCoreGuidelines.md:3223
msgid "3223    The whole purpose of `final_action` is to get a piece of code (usually a lambda) executed upon destruction."
msgstr""

       
# CppCoreGuidelines.md:3224
msgid "3224    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3225
msgid "3225    There are two general categories of classes that need a user-defined destructor:"
msgstr""

       
# CppCoreGuidelines.md:3226
msgid "3226    * A class with a resource that is not already represented as a class with a destructor, e.g., a `vector` or a transaction class."
msgstr""

# CppCoreGuidelines.md:3227
msgid "3227    * A class that exists primarily to execute an action upon destruction, such as a tracer or `final_action`."
msgstr""

       
# CppCoreGuidelines.md:3228
msgid "3228    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3229
msgid "3229        class Foo {   // bad; use the default destructor"
msgstr""

# CppCoreGuidelines.md:3230
msgid "3230        public:"
msgstr""

# CppCoreGuidelines.md:3231
msgid "3231            // ..."
msgstr""

# CppCoreGuidelines.md:3232
msgid "3232            ~Foo() { s = \"\"; i = 0; vi.clear(); }  // clean up"
msgstr""

# CppCoreGuidelines.md:3233
msgid "3233        private:"
msgstr""

# CppCoreGuidelines.md:3234
msgid "3234            string s;"
msgstr""

# CppCoreGuidelines.md:3235
msgid "3235            int i;"
msgstr""

# CppCoreGuidelines.md:3236
msgid "3236            vector<int> vi;"
msgstr""

# CppCoreGuidelines.md:3237
msgid "3237        };"
msgstr""

       
# CppCoreGuidelines.md:3238
msgid "3238    The default destructor does it better, more efficiently, and can't get it wrong."
msgstr""

       
# CppCoreGuidelines.md:3239
msgid "3239    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3240
msgid "3240    If the default destructor is needed, but its generation has been suppressed (e.g., by defining a move constructor), use `=default`."
msgstr""

       
# CppCoreGuidelines.md:3241
msgid "3241    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3242
msgid "3242    Look for likely \"implicit resources\", such as pointers and references. Look for classes with destructors even though all their data members have destructors."
msgstr""

       
# CppCoreGuidelines.md:3243
msgid "3243    ### <a name=\"Rc-dtor-release\"></a>C.31: All resources acquired by a class must be released by the class's destructor"
msgstr""

       
# CppCoreGuidelines.md:3244
msgid "3244    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3245
msgid "3245    Prevention of resource leaks, especially in error cases."
msgstr""

       
# CppCoreGuidelines.md:3246
msgid "3246    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3247
msgid "3247    For resources represented as classes with a complete set of default operations, this happens automatically."
msgstr""

       
# CppCoreGuidelines.md:3248
msgid "3248    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3249
msgid "3249        class X {"
msgstr""

# CppCoreGuidelines.md:3250
msgid "3250            ifstream f;   // may own a file"
msgstr""

# CppCoreGuidelines.md:3251
msgid "3251            // ... no default operations defined or =deleted ..."
msgstr""

# CppCoreGuidelines.md:3252
msgid "3252        };"
msgstr""

       
# CppCoreGuidelines.md:3253
msgid "3253    `X`'s `ifstream` implicitly closes any file it may have open upon destruction of its `X`."
msgstr""

       
# CppCoreGuidelines.md:3254
msgid "3254    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3255
msgid "3255        class X2 {     // bad"
msgstr""

# CppCoreGuidelines.md:3256
msgid "3256            FILE* f;   // may own a file"
msgstr""

# CppCoreGuidelines.md:3257
msgid "3257            // ... no default operations defined or =deleted ..."
msgstr""

# CppCoreGuidelines.md:3258
msgid "3258        };"
msgstr""

       
# CppCoreGuidelines.md:3259
msgid "3259    `X2` may leak a file handle."
msgstr""

       
# CppCoreGuidelines.md:3260
msgid "3260    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3261
msgid "3261    What about a sockets that won't close? A destructor, close, or cleanup operation [should never fail](#Rc-dtor-fail)."
msgstr""

# CppCoreGuidelines.md:3262
msgid "3262    If it does nevertheless, we have a problem that has no really good solution."
msgstr""

# CppCoreGuidelines.md:3263
msgid "3263    For starters, the writer of a destructor does not know why the destructor is called and cannot \"refuse to act\" by throwing an exception."
msgstr""

# CppCoreGuidelines.md:3264
msgid "3264    See [discussion](#Sd-never-fail)."
msgstr""

# CppCoreGuidelines.md:3265
msgid "3265    To make the problem worse, many \"close/release\" operations are not retryable."
msgstr""

# CppCoreGuidelines.md:3266
msgid "3266    Many have tried to solve this problem, but no general solution is known."
msgstr""

# CppCoreGuidelines.md:3267
msgid "3267    If at all possible, consider failure to close/cleanup a fundamental design error and terminate."
msgstr""

       
# CppCoreGuidelines.md:3268
msgid "3268    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3269
msgid "3269    A class can hold pointers and references to objects that it does not own."
msgstr""

# CppCoreGuidelines.md:3270
msgid "3270    Obviously, such objects should not be `delete`d by the class's destructor."
msgstr""

# CppCoreGuidelines.md:3271
msgid "3271    For example:"
msgstr""

       
# CppCoreGuidelines.md:3272
msgid "3272        Preprocessor pp { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:3273
msgid "3273        Parser p { pp, /* ... */ };"
msgstr""

# CppCoreGuidelines.md:3274
msgid "3274        Type_checker tc { p, /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:3275
msgid "3275    Here `p` refers to `pp` but does not own it."
msgstr""

       
# CppCoreGuidelines.md:3276
msgid "3276    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3277
msgid "3277    * (Simple) If a class has pointer or reference member variables that are owners"
msgstr""

# CppCoreGuidelines.md:3278
msgid "3278      (e.g., deemed owners by using `gsl::owner`), then they should be referenced in its destructor."
msgstr""

# CppCoreGuidelines.md:3279
msgid "3279    * (Hard) Determine if pointer or reference member variables are owners when there is no explicit statement of ownership"
msgstr""

# CppCoreGuidelines.md:3280
msgid "3280      (e.g., look into the constructors)."
msgstr""

       
# CppCoreGuidelines.md:3281
msgid "3281    ### <a name=\"Rc-dtor-ptr\"></a>C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether it might be owning"
msgstr""

       
# CppCoreGuidelines.md:3282
msgid "3282    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3283
msgid "3283    There is a lot of code that is non-specific about ownership."
msgstr""

       
# CppCoreGuidelines.md:3284
msgid "3284    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3285
msgid "3285        ???"
msgstr""

       
# CppCoreGuidelines.md:3286
msgid "3286    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3287
msgid "3287    If the `T*` or `T&` is owning, mark it `owning`. If the `T*` is not owning, consider marking it `ptr`."
msgstr""

# CppCoreGuidelines.md:3288
msgid "3288    This will aid documentation and analysis."
msgstr""

       
# CppCoreGuidelines.md:3289
msgid "3289    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3290
msgid "3290    Look at the initialization of raw member pointers and member references and see if an allocation is used."
msgstr""

       
# CppCoreGuidelines.md:3291
msgid "3291    ### <a name=\"Rc-dtor-ptr2\"></a>C.33: If a class has an owning pointer member, define a destructor"
msgstr""

       
# CppCoreGuidelines.md:3292
msgid "3292    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3293
msgid "3293    An owned object must be `deleted` upon destruction of the object that owns it."
msgstr""

       
# CppCoreGuidelines.md:3294
msgid "3294    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3295
msgid "3295    A pointer member may represent a resource."
msgstr""

# CppCoreGuidelines.md:3296
msgid "3296    [A `T*` should not do so](#Rr-ptr), but in older code, that's common."
msgstr""

# CppCoreGuidelines.md:3297
msgid "3297    Consider a `T*` a possible owner and therefore suspect."
msgstr""

       
# CppCoreGuidelines.md:3298
msgid "3298        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3299
msgid "3299        class Smart_ptr {"
msgstr""

# CppCoreGuidelines.md:3300
msgid "3300            T* p;   // BAD: vague about ownership of *p"
msgstr""

# CppCoreGuidelines.md:3301
msgid "3301            // ..."
msgstr""

# CppCoreGuidelines.md:3302
msgid "3302        public:"
msgstr""

# CppCoreGuidelines.md:3303
msgid "3303            // ... no user-defined default operations ..."
msgstr""

# CppCoreGuidelines.md:3304
msgid "3304        };"
msgstr""

       
# CppCoreGuidelines.md:3305
msgid "3305        void use(Smart_ptr<int> p1)"
msgstr""

# CppCoreGuidelines.md:3306
msgid "3306        {"
msgstr""

# CppCoreGuidelines.md:3307
msgid "3307            // error: p2.p leaked (if not nullptr and not owned by some other code)"
msgstr""

# CppCoreGuidelines.md:3308
msgid "3308            auto p2 = p1;"
msgstr""

# CppCoreGuidelines.md:3309
msgid "3309        }"
msgstr""

       
# CppCoreGuidelines.md:3310
msgid "3310    Note that if you define a destructor, you must define or delete [all default operations](#Rc-five):"
msgstr""

       
# CppCoreGuidelines.md:3311
msgid "3311        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3312
msgid "3312        class Smart_ptr2 {"
msgstr""

# CppCoreGuidelines.md:3313
msgid "3313            T* p;   // BAD: vague about ownership of *p"
msgstr""

# CppCoreGuidelines.md:3314
msgid "3314            // ..."
msgstr""

# CppCoreGuidelines.md:3315
msgid "3315        public:"
msgstr""

# CppCoreGuidelines.md:3316
msgid "3316            // ... no user-defined copy operations ..."
msgstr""

# CppCoreGuidelines.md:3317
msgid "3317            ~Smart_ptr2() { delete p; }  // p is an owner!"
msgstr""

# CppCoreGuidelines.md:3318
msgid "3318        };"
msgstr""

       
# CppCoreGuidelines.md:3319
msgid "3319        void use(Smart_ptr2<int> p1)"
msgstr""

# CppCoreGuidelines.md:3320
msgid "3320        {"
msgstr""

# CppCoreGuidelines.md:3321
msgid "3321            auto p2 = p1;   // error: double deletion"
msgstr""

# CppCoreGuidelines.md:3322
msgid "3322        }"
msgstr""

       
# CppCoreGuidelines.md:3323
msgid "3323    The default copy operation will just copy the `p1.p` into `p2.p` leading to a double destruction of `p1.p`. Be explicit about ownership:"
msgstr""

       
# CppCoreGuidelines.md:3324
msgid "3324        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3325
msgid "3325        class Smart_ptr3 {"
msgstr""

# CppCoreGuidelines.md:3326
msgid "3326            owner<T*> p;   // OK: explicit about ownership of *p"
msgstr""

# CppCoreGuidelines.md:3327
msgid "3327            // ..."
msgstr""

# CppCoreGuidelines.md:3328
msgid "3328        public:"
msgstr""

# CppCoreGuidelines.md:3329
msgid "3329            // ..."
msgstr""

# CppCoreGuidelines.md:3330
msgid "3330            // ... copy and move operations ..."
msgstr""

# CppCoreGuidelines.md:3331
msgid "3331            ~Smart_ptr3() { delete p; }"
msgstr""

# CppCoreGuidelines.md:3332
msgid "3332        };"
msgstr""

       
# CppCoreGuidelines.md:3333
msgid "3333        void use(Smart_ptr3<int> p1)"
msgstr""

# CppCoreGuidelines.md:3334
msgid "3334        {"
msgstr""

# CppCoreGuidelines.md:3335
msgid "3335            auto p2 = p1;   // error: double deletion"
msgstr""

# CppCoreGuidelines.md:3336
msgid "3336        }"
msgstr""

       
# CppCoreGuidelines.md:3337
msgid "3337    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3338
msgid "3338    Often the simplest way to get a destructor is to replace the pointer with a smart pointer (e.g., `std::unique_ptr`) and let the compiler arrange for proper destruction to be done implicitly."
msgstr""

       
# CppCoreGuidelines.md:3339
msgid "3339    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3340
msgid "3340    Why not just require all owning pointers to be \"smart pointers\"?"
msgstr""

# CppCoreGuidelines.md:3341
msgid "3341    That would sometimes require non-trivial code changes and may affect ABIs."
msgstr""

       
# CppCoreGuidelines.md:3342
msgid "3342    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3343
msgid "3343    * A class with a pointer data member is suspect."
msgstr""

# CppCoreGuidelines.md:3344
msgid "3344    * A class with an `owner<T>` should define its default operations."
msgstr""

       
       
# CppCoreGuidelines.md:3345
msgid "3345    ### <a name=\"Rc-dtor-virtual\"></a>C.35: A base class destructor should be either public and virtual, or protected and nonvirtual"
msgstr""

       
# CppCoreGuidelines.md:3346
msgid "3346    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3347
msgid "3347    To prevent undefined behavior."
msgstr""

# CppCoreGuidelines.md:3348
msgid "3348    If the destructor is public, then calling code can attempt to destroy a derived class object through a base class pointer, and the result is undefined if the base class's destructor is non-virtual."
msgstr""

# CppCoreGuidelines.md:3349
msgid "3349    If the destructor is protected, then calling code cannot destroy through a base class pointer and the destructor does not need to be virtual; it does need to be protected, not private, so that derived destructors can invoke it."
msgstr""

# CppCoreGuidelines.md:3350
msgid "3350    In general, the writer of a base class does not know the appropriate action to be done upon destruction."
msgstr""

       
# CppCoreGuidelines.md:3351
msgid "3351    ##### Discussion"
msgstr""

       
# CppCoreGuidelines.md:3352
msgid "3352    See [this in the Discussion section](#Sd-dtor)."
msgstr""

       
# CppCoreGuidelines.md:3353
msgid "3353    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3354
msgid "3354        struct Base {  // BAD: no virtual destructor"
msgstr""

# CppCoreGuidelines.md:3355
msgid "3355            virtual void f();"
msgstr""

# CppCoreGuidelines.md:3356
msgid "3356        };"
msgstr""

       
# CppCoreGuidelines.md:3357
msgid "3357        struct D : Base {"
msgstr""

# CppCoreGuidelines.md:3358
msgid "3358            string s {\"a resource needing cleanup\"};"
msgstr""

# CppCoreGuidelines.md:3359
msgid "3359            ~D() { /* ... do some cleanup ... */ }"
msgstr""

# CppCoreGuidelines.md:3360
msgid "3360            // ..."
msgstr""

# CppCoreGuidelines.md:3361
msgid "3361        };"
msgstr""

       
# CppCoreGuidelines.md:3362
msgid "3362        void use()"
msgstr""

# CppCoreGuidelines.md:3363
msgid "3363        {"
msgstr""

# CppCoreGuidelines.md:3364
msgid "3364            unique_ptr<Base> p = make_unique<D>();"
msgstr""

# CppCoreGuidelines.md:3365
msgid "3365            // ..."
msgstr""

# CppCoreGuidelines.md:3366
msgid "3366        } // p's destruction calls ~Base(), not ~D(), which leaks D::s and possibly more"
msgstr""

       
# CppCoreGuidelines.md:3367
msgid "3367    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3368
msgid "3368    A virtual function defines an interface to derived classes that can be used without looking at the derived classes."
msgstr""

# CppCoreGuidelines.md:3369
msgid "3369    If the interface allows destroying, it should be safe to do so."
msgstr""

       
# CppCoreGuidelines.md:3370
msgid "3370    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3371
msgid "3371    A destructor must be nonprivate or it will prevent using the type :"
msgstr""

       
# CppCoreGuidelines.md:3372
msgid "3372        class X {"
msgstr""

# CppCoreGuidelines.md:3373
msgid "3373            ~X();   // private destructor"
msgstr""

# CppCoreGuidelines.md:3374
msgid "3374            // ..."
msgstr""

# CppCoreGuidelines.md:3375
msgid "3375        };"
msgstr""

       
# CppCoreGuidelines.md:3376
msgid "3376        void use()"
msgstr""

# CppCoreGuidelines.md:3377
msgid "3377        {"
msgstr""

# CppCoreGuidelines.md:3378
msgid "3378            X a;                        // error: cannot destroy"
msgstr""

# CppCoreGuidelines.md:3379
msgid "3379            auto p = make_unique<X>();  // error: cannot destroy"
msgstr""

# CppCoreGuidelines.md:3380
msgid "3380        }"
msgstr""

       
# CppCoreGuidelines.md:3381
msgid "3381    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:3382
msgid "3382    We can imagine one case where you could want a protected virtual destructor: When an object of a derived type (and only of such a type) should be allowed to destroy *another* object (not itself) through a pointer to base. We haven't seen such a case in practice, though."
msgstr""

       
# CppCoreGuidelines.md:3383
msgid "3383    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3384
msgid "3384    * A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual."
msgstr""

       
# CppCoreGuidelines.md:3385
msgid "3385    ### <a name=\"Rc-dtor-fail\"></a>C.36: A destructor may not fail"
msgstr""

       
# CppCoreGuidelines.md:3386
msgid "3386    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3387
msgid "3387    In general we do not know how to write error-free code if a destructor should fail."
msgstr""

# CppCoreGuidelines.md:3388
msgid "3388    The standard library requires that all classes it deals with have destructors that do not exit by throwing."
msgstr""

       
# CppCoreGuidelines.md:3389
msgid "3389    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3390
msgid "3390        class X {"
msgstr""

# CppCoreGuidelines.md:3391
msgid "3391        public:"
msgstr""

# CppCoreGuidelines.md:3392
msgid "3392            ~X() noexcept;"
msgstr""

# CppCoreGuidelines.md:3393
msgid "3393            // ..."
msgstr""

# CppCoreGuidelines.md:3394
msgid "3394        };"
msgstr""

       
# CppCoreGuidelines.md:3395
msgid "3395        X::~X() noexcept"
msgstr""

# CppCoreGuidelines.md:3396
msgid "3396        {"
msgstr""

# CppCoreGuidelines.md:3397
msgid "3397            // ..."
msgstr""

# CppCoreGuidelines.md:3398
msgid "3398            if (cannot_release_a_resource) terminate();"
msgstr""

# CppCoreGuidelines.md:3399
msgid "3399            // ..."
msgstr""

# CppCoreGuidelines.md:3400
msgid "3400        }"
msgstr""

       
# CppCoreGuidelines.md:3401
msgid "3401    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3402
msgid "3402    Many have tried to devise a fool-proof scheme for dealing with failure in destructors."
msgstr""

# CppCoreGuidelines.md:3403
msgid "3403    None have succeeded to come up with a general scheme."
msgstr""

# CppCoreGuidelines.md:3404
msgid "3404    This can be a real practical problem: For example, what about a socket that won't close?"
msgstr""

# CppCoreGuidelines.md:3405
msgid "3405    The writer of a destructor does not know why the destructor is called and cannot \"refuse to act\" by throwing an exception."
msgstr""

# CppCoreGuidelines.md:3406
msgid "3406    See [discussion](#Sd-dtor)."
msgstr""

# CppCoreGuidelines.md:3407
msgid "3407    To make the problem worse, many \"close/release\" operations are not retryable."
msgstr""

# CppCoreGuidelines.md:3408
msgid "3408    If at all possible, consider failure to close/cleanup a fundamental design error and terminate."
msgstr""

       
# CppCoreGuidelines.md:3409
msgid "3409    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3410
msgid "3410    Declare a destructor `noexcept`. That will ensure that it either completes normally or terminate the program."
msgstr""

       
# CppCoreGuidelines.md:3411
msgid "3411    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3412
msgid "3412    If a resource cannot be released and the program may not fail, try to signal the failure to the rest of the system somehow"
msgstr""

# CppCoreGuidelines.md:3413
msgid "3413    (maybe even by modifying some global state and hope something will notice and be able to take care of the problem)."
msgstr""

# CppCoreGuidelines.md:3414
msgid "3414    Be fully aware that this technique is special-purpose and error-prone."
msgstr""

# CppCoreGuidelines.md:3415
msgid "3415    Consider the \"my connection will not close\" example."
msgstr""

# CppCoreGuidelines.md:3416
msgid "3416    Probably there is a problem at the other end of the connection and only a piece of code responsible for both ends of the connection can properly handle the problem."
msgstr""

# CppCoreGuidelines.md:3417
msgid "3417    The destructor could send a message (somehow) to the responsible part of the system, consider that to have closed the connection, and return normally."
msgstr""

       
# CppCoreGuidelines.md:3418
msgid "3418    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3419
msgid "3419    If a destructor uses operations that may fail, it can catch exceptions and in some cases still complete successfully"
msgstr""

# CppCoreGuidelines.md:3420
msgid "3420    (e.g., by using a different clean-up mechanism from the one that threw an exception)."
msgstr""

       
# CppCoreGuidelines.md:3421
msgid "3421    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3422
msgid "3422    (Simple) A destructor should be declared `noexcept` if it could throw."
msgstr""

       
# CppCoreGuidelines.md:3423
msgid "3423    ### <a name=\"Rc-dtor-noexcept\"></a>C.37: Make destructors `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:3424
msgid "3424    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3425
msgid "3425     [A destructor may not fail](#Rc-dtor-fail). If a destructor tries to exit with an exception, it's a bad design error and the program had better terminate."
msgstr""

       
# CppCoreGuidelines.md:3426
msgid "3426    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3427
msgid "3427    A destructor (either user-defined or compiler-generated) is implicitly declared `noexcept` (independently of what code is in its body) if all of the members of its class have `noexcept` destructors. By explicitly marking destructors `noexcept`, an author guards against the destructor becoming implicitly `noexcept(false)` through the addition or modification of a class member."
msgstr""

       
# CppCoreGuidelines.md:3428
msgid "3428    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3429
msgid "3429    (Simple) A destructor should be declared `noexcept` if it could throw."
msgstr""

       
# CppCoreGuidelines.md:3430
msgid "3430    ## <a name=\"SS-ctor\"></a>C.ctor: Constructors"
msgstr""

       
# CppCoreGuidelines.md:3431
msgid "3431    A constructor defines how an object is initialized (constructed)."
msgstr""

       
# CppCoreGuidelines.md:3432
msgid "3432    ### <a name=\"Rc-ctor\"></a>C.40: Define a constructor if a class has an invariant"
msgstr""

       
# CppCoreGuidelines.md:3433
msgid "3433    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3434
msgid "3434    That's what constructors are for."
msgstr""

       
# CppCoreGuidelines.md:3435
msgid "3435    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3436
msgid "3436        class Date {  // a Date represents a valid date"
msgstr""

# CppCoreGuidelines.md:3437
msgid "3437                      // in the January 1, 1900 to December 31, 2100 range"
msgstr""

# CppCoreGuidelines.md:3438
msgid "3438            Date(int dd, int mm, int yy)"
msgstr""

# CppCoreGuidelines.md:3439
msgid "3439                :d{dd}, m{mm}, y{yy}"
msgstr""

# CppCoreGuidelines.md:3440
msgid "3440            {"
msgstr""

# CppCoreGuidelines.md:3441
msgid "3441                if (!is_valid(d, m, y)) throw Bad_date{};  // enforce invariant"
msgstr""

# CppCoreGuidelines.md:3442
msgid "3442            }"
msgstr""

# CppCoreGuidelines.md:3443
msgid "3443            // ..."
msgstr""

# CppCoreGuidelines.md:3444
msgid "3444        private:"
msgstr""

# CppCoreGuidelines.md:3445
msgid "3445            int d, m, y;"
msgstr""

# CppCoreGuidelines.md:3446
msgid "3446        };"
msgstr""

       
# CppCoreGuidelines.md:3447
msgid "3447    It is often a good idea to express the invariant as an `Ensures` on the constructor."
msgstr""

       
# CppCoreGuidelines.md:3448
msgid "3448    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3449
msgid "3449    A constructor can be used for convenience even if a class does not have an invariant. For example:"
msgstr""

       
# CppCoreGuidelines.md:3450
msgid "3450        struct Rec {"
msgstr""

# CppCoreGuidelines.md:3451
msgid "3451            string s;"
msgstr""

# CppCoreGuidelines.md:3452
msgid "3452            int i {0};"
msgstr""

# CppCoreGuidelines.md:3453
msgid "3453            Rec(const string& ss) : s{ss} {}"
msgstr""

# CppCoreGuidelines.md:3454
msgid "3454            Rec(int ii) :i{ii} {}"
msgstr""

# CppCoreGuidelines.md:3455
msgid "3455        };"
msgstr""

       
# CppCoreGuidelines.md:3456
msgid "3456        Rec r1 {7};"
msgstr""

# CppCoreGuidelines.md:3457
msgid "3457        Rec r2 {\"Foo bar\"};"
msgstr""

       
# CppCoreGuidelines.md:3458
msgid "3458    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3459
msgid "3459    The C++11 initializer list rule eliminates the need for many constructors. For example:"
msgstr""

       
# CppCoreGuidelines.md:3460
msgid "3460        struct Rec2{"
msgstr""

# CppCoreGuidelines.md:3461
msgid "3461            string s;"
msgstr""

# CppCoreGuidelines.md:3462
msgid "3462            int i;"
msgstr""

# CppCoreGuidelines.md:3463
msgid "3463            Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // redundant"
msgstr""

# CppCoreGuidelines.md:3464
msgid "3464        };"
msgstr""

       
# CppCoreGuidelines.md:3465
msgid "3465        Rec2 r1 {\"Foo\", 7};"
msgstr""

# CppCoreGuidelines.md:3466
msgid "3466        Rec2 r2 {\"Bar\"};"
msgstr""

       
# CppCoreGuidelines.md:3467
msgid "3467    The `Rec2` constructor is redundant."
msgstr""

# CppCoreGuidelines.md:3468
msgid "3468    Also, the default for `int` would be better done as a [member initializer](#Rc-in-class-initializer)."
msgstr""

       
# CppCoreGuidelines.md:3469
msgid "3469    **See also**: [construct valid object](#Rc-complete) and [constructor throws](#Rc-throw)."
msgstr""

       
# CppCoreGuidelines.md:3470
msgid "3470    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3471
msgid "3471    * Flag classes with user-defined copy operations but no constructor (a user-defined copy is a good indicator that the class has an invariant)"
msgstr""

       
# CppCoreGuidelines.md:3472
msgid "3472    ### <a name=\"Rc-complete\"></a>C.41: A constructor should create a fully initialized object"
msgstr""

       
# CppCoreGuidelines.md:3473
msgid "3473    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3474
msgid "3474    A constructor establishes the invariant for a class. A user of a class should be able to assume that a constructed object is usable."
msgstr""

       
# CppCoreGuidelines.md:3475
msgid "3475    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3476
msgid "3476        class X1 {"
msgstr""

# CppCoreGuidelines.md:3477
msgid "3477            FILE* f;   // call init() before any other function"
msgstr""

# CppCoreGuidelines.md:3478
msgid "3478            // ..."
msgstr""

# CppCoreGuidelines.md:3479
msgid "3479        public:"
msgstr""

# CppCoreGuidelines.md:3480
msgid "3480            X1() {}"
msgstr""

# CppCoreGuidelines.md:3481
msgid "3481            void init();   // initialize f"
msgstr""

# CppCoreGuidelines.md:3482
msgid "3482            void read();   // read from f"
msgstr""

# CppCoreGuidelines.md:3483
msgid "3483            // ..."
msgstr""

# CppCoreGuidelines.md:3484
msgid "3484        };"
msgstr""

       
# CppCoreGuidelines.md:3485
msgid "3485        void f()"
msgstr""

# CppCoreGuidelines.md:3486
msgid "3486        {"
msgstr""

# CppCoreGuidelines.md:3487
msgid "3487            X1 file;"
msgstr""

# CppCoreGuidelines.md:3488
msgid "3488            file.read();   // crash or bad read!"
msgstr""

# CppCoreGuidelines.md:3489
msgid "3489            // ..."
msgstr""

# CppCoreGuidelines.md:3490
msgid "3490            file.init();   // too late"
msgstr""

# CppCoreGuidelines.md:3491
msgid "3491            // ..."
msgstr""

# CppCoreGuidelines.md:3492
msgid "3492        }"
msgstr""

       
# CppCoreGuidelines.md:3493
msgid "3493    Compilers do not read comments."
msgstr""

       
# CppCoreGuidelines.md:3494
msgid "3494    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:3495
msgid "3495    If a valid object cannot conveniently be constructed by a constructor, [use a factory function](#Rc-factory)."
msgstr""

       
# CppCoreGuidelines.md:3496
msgid "3496    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3497
msgid "3497    * (Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction)."
msgstr""

# CppCoreGuidelines.md:3498
msgid "3498    * (Unknown) If a constructor has an `Ensures` contract, try to see if it holds as a postcondition."
msgstr""

       
# CppCoreGuidelines.md:3499
msgid "3499    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3500
msgid "3500    If a constructor acquires a resource (to create a valid object), that resource should be [released by the destructor](#Rc-dtor-release)."
msgstr""

# CppCoreGuidelines.md:3501
msgid "3501    The idiom of having constructors acquire resources and destructors release them is called [RAII](#Rr-raii) (\"Resource Acquisition Is Initialization\")."
msgstr""

       
# CppCoreGuidelines.md:3502
msgid "3502    ### <a name=\"Rc-throw\"></a>C.42: If a constructor cannot construct a valid object, throw an exception"
msgstr""

       
# CppCoreGuidelines.md:3503
msgid "3503    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3504
msgid "3504    Leaving behind an invalid object is asking for trouble."
msgstr""

       
# CppCoreGuidelines.md:3505
msgid "3505    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3506
msgid "3506        class X2 {"
msgstr""

# CppCoreGuidelines.md:3507
msgid "3507            FILE* f;"
msgstr""

# CppCoreGuidelines.md:3508
msgid "3508            // ..."
msgstr""

# CppCoreGuidelines.md:3509
msgid "3509        public:"
msgstr""

# CppCoreGuidelines.md:3510
msgid "3510            X2(const string& name)"
msgstr""

# CppCoreGuidelines.md:3511
msgid "3511                :f{fopen(name.c_str(), \"r\")}"
msgstr""

# CppCoreGuidelines.md:3512
msgid "3512            {"
msgstr""

# CppCoreGuidelines.md:3513
msgid "3513                if (!f) throw runtime_error{\"could not open\" + name};"
msgstr""

# CppCoreGuidelines.md:3514
msgid "3514                // ..."
msgstr""

# CppCoreGuidelines.md:3515
msgid "3515            }"
msgstr""

       
# CppCoreGuidelines.md:3516
msgid "3516            void read();      // read from f"
msgstr""

# CppCoreGuidelines.md:3517
msgid "3517            // ..."
msgstr""

# CppCoreGuidelines.md:3518
msgid "3518        };"
msgstr""

       
# CppCoreGuidelines.md:3519
msgid "3519        void f()"
msgstr""

# CppCoreGuidelines.md:3520
msgid "3520        {"
msgstr""

# CppCoreGuidelines.md:3521
msgid "3521            X2 file {\"Zeno\"}; // throws if file isn't open"
msgstr""

# CppCoreGuidelines.md:3522
msgid "3522            file.read();      // fine"
msgstr""

# CppCoreGuidelines.md:3523
msgid "3523            // ..."
msgstr""

# CppCoreGuidelines.md:3524
msgid "3524        }"
msgstr""

       
# CppCoreGuidelines.md:3525
msgid "3525    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3526
msgid "3526        class X3 {     // bad: the constructor leaves a non-valid object behind"
msgstr""

# CppCoreGuidelines.md:3527
msgid "3527            FILE* f;   // call is_valid() before any other function"
msgstr""

# CppCoreGuidelines.md:3528
msgid "3528            bool valid;"
msgstr""

# CppCoreGuidelines.md:3529
msgid "3529            // ..."
msgstr""

# CppCoreGuidelines.md:3530
msgid "3530        public:"
msgstr""

# CppCoreGuidelines.md:3531
msgid "3531            X3(const string& name)"
msgstr""

# CppCoreGuidelines.md:3532
msgid "3532                :f{fopen(name.c_str(), \"r\")}, valid{false}"
msgstr""

# CppCoreGuidelines.md:3533
msgid "3533            {"
msgstr""

# CppCoreGuidelines.md:3534
msgid "3534                if (f) valid = true;"
msgstr""

# CppCoreGuidelines.md:3535
msgid "3535                // ..."
msgstr""

# CppCoreGuidelines.md:3536
msgid "3536            }"
msgstr""

       
# CppCoreGuidelines.md:3537
msgid "3537            bool is_valid() { return valid; }"
msgstr""

# CppCoreGuidelines.md:3538
msgid "3538            void read();   // read from f"
msgstr""

# CppCoreGuidelines.md:3539
msgid "3539            // ..."
msgstr""

# CppCoreGuidelines.md:3540
msgid "3540        };"
msgstr""

       
# CppCoreGuidelines.md:3541
msgid "3541        void f()"
msgstr""

# CppCoreGuidelines.md:3542
msgid "3542        {"
msgstr""

# CppCoreGuidelines.md:3543
msgid "3543            X3 file {\"Heraclides\"};"
msgstr""

# CppCoreGuidelines.md:3544
msgid "3544            file.read();   // crash or bad read!"
msgstr""

# CppCoreGuidelines.md:3545
msgid "3545            // ..."
msgstr""

# CppCoreGuidelines.md:3546
msgid "3546            if (file.is_valid()) {"
msgstr""

# CppCoreGuidelines.md:3547
msgid "3547                file.read();"
msgstr""

# CppCoreGuidelines.md:3548
msgid "3548                // ..."
msgstr""

# CppCoreGuidelines.md:3549
msgid "3549            }"
msgstr""

# CppCoreGuidelines.md:3550
msgid "3550            else {"
msgstr""

# CppCoreGuidelines.md:3551
msgid "3551                // ... handle error ..."
msgstr""

# CppCoreGuidelines.md:3552
msgid "3552            }"
msgstr""

# CppCoreGuidelines.md:3553
msgid "3553            // ..."
msgstr""

# CppCoreGuidelines.md:3554
msgid "3554        }"
msgstr""

       
# CppCoreGuidelines.md:3555
msgid "3555    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3556
msgid "3556    For a variable definition (e.g., on the stack or as a member of another object) there is no explicit function call from which an error code could be returned."
msgstr""

# CppCoreGuidelines.md:3557
msgid "3557    Leaving behind an invalid object and relying on users to consistently check an `is_valid()` function before use is tedious, error-prone, and inefficient."
msgstr""

       
# CppCoreGuidelines.md:3558
msgid "3558    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:3559
msgid "3559    There are domains, such as some hard-real-time systems (think airplane controls) where (without additional tool support) exception handling is not sufficiently predictable from a timing perspective."
msgstr""

# CppCoreGuidelines.md:3560
msgid "3560    There the `is_valid()` technique must be used. In such cases, check `is_valid()` consistently and immediately to simulate [RAII](#Rr-raii)."
msgstr""

       
# CppCoreGuidelines.md:3561
msgid "3561    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:3562
msgid "3562    If you feel tempted to use some \"post-constructor initialization\" or \"two-stage initialization\" idiom, try not to do that."
msgstr""

# CppCoreGuidelines.md:3563
msgid "3563    If you really have to, look at [factory functions](#Rc-factory)."
msgstr""

       
# CppCoreGuidelines.md:3564
msgid "3564    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3565
msgid "3565    One reason people have used `init()` functions rather than doing the initialization work in a constructor has been to avoid code replication."
msgstr""

# CppCoreGuidelines.md:3566
msgid "3566    [Delegating constructors](#Rc-delegating) and [default member initialization](#Rc-in-class-initializer) do that better."
msgstr""

# CppCoreGuidelines.md:3567
msgid "3567    Another reason has been to delay initialization until an object is needed; the solution to that is often [not to declare a variable until it can be properly initialized](#Res-init)"
msgstr""

       
# CppCoreGuidelines.md:3568
msgid "3568    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3569
msgid "3569    ???"
msgstr""

       
# CppCoreGuidelines.md:3570
msgid "3570    ### <a name=\"Rc-default0\"></a>C.43: Ensure that a copyable (value type) class has a default constructor"
msgstr""

       
# CppCoreGuidelines.md:3571
msgid "3571    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3572
msgid "3572    Many language and library facilities rely on default constructors to initialize their elements, e.g. `T a[10]` and `std::vector<T> v(10)`."
msgstr""

# CppCoreGuidelines.md:3573
msgid "3573    A default constructor often simplifies the task of defining a suitable [moved-from state](#???) for a type that is also copyable."
msgstr""

       
# CppCoreGuidelines.md:3574
msgid "3574    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3575
msgid "3575    A [value type](#SS-concrete) is a class that is copyable (and usually also comparable)."
msgstr""

# CppCoreGuidelines.md:3576
msgid "3576    It is closely related to the notion of Regular type from [EoP](http://elementsofprogramming.com/) and [the Palo Alto TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf)."
msgstr""

       
# CppCoreGuidelines.md:3577
msgid "3577    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3578
msgid "3578        class Date { // BAD: no default constructor"
msgstr""

# CppCoreGuidelines.md:3579
msgid "3579        public:"
msgstr""

# CppCoreGuidelines.md:3580
msgid "3580            Date(int dd, int mm, int yyyy);"
msgstr""

# CppCoreGuidelines.md:3581
msgid "3581            // ..."
msgstr""

# CppCoreGuidelines.md:3582
msgid "3582        };"
msgstr""

       
# CppCoreGuidelines.md:3583
msgid "3583        vector<Date> vd1(1000);   // default Date needed here"
msgstr""

# CppCoreGuidelines.md:3584
msgid "3584        vector<Date> vd2(1000, Date{Month::October, 7, 1885});   // alternative"
msgstr""

       
# CppCoreGuidelines.md:3585
msgid "3585    The default constructor is only auto-generated if there is no user-declared constructor, hence it's impossible to initialize the vector `vd1` in the example above."
msgstr""

# CppCoreGuidelines.md:3586
msgid "3586    The absence of a default value can cause surprises for users and complicate its use, so if one can be reasonably defined, it should be."
msgstr""

       
# CppCoreGuidelines.md:3587
msgid "3587    `Date` is chosen to encourage thought:"
msgstr""

# CppCoreGuidelines.md:3588
msgid "3588    There is no \"natural\" default date (the big bang is too far back in time to be useful for most people), so this example is non-trivial."
msgstr""

# CppCoreGuidelines.md:3589
msgid "3589    `{0, 0, 0}` is not a valid date in most calendar systems, so choosing that would be introducing something like floating-point's `NaN`."
msgstr""

# CppCoreGuidelines.md:3590
msgid "3590    However, most realistic `Date` classes have a \"first date\" (e.g. January 1, 1970 is popular), so making that the default is usually trivial."
msgstr""

       
# CppCoreGuidelines.md:3591
msgid "3591        class Date {"
msgstr""

# CppCoreGuidelines.md:3592
msgid "3592        public:"
msgstr""

# CppCoreGuidelines.md:3593
msgid "3593            Date(int dd, int mm, int yyyy);"
msgstr""

# CppCoreGuidelines.md:3594
msgid "3594            Date() = default; // [See also](#Rc-default)"
msgstr""

# CppCoreGuidelines.md:3595
msgid "3595            // ..."
msgstr""

# CppCoreGuidelines.md:3596
msgid "3596        private:"
msgstr""

# CppCoreGuidelines.md:3597
msgid "3597            int dd = 1;"
msgstr""

# CppCoreGuidelines.md:3598
msgid "3598            int mm = 1;"
msgstr""

# CppCoreGuidelines.md:3599
msgid "3599            int yyyy = 1970;"
msgstr""

# CppCoreGuidelines.md:3600
msgid "3600            // ..."
msgstr""

# CppCoreGuidelines.md:3601
msgid "3601        };"
msgstr""

       
# CppCoreGuidelines.md:3602
msgid "3602        vector<Date> vd1(1000);"
msgstr""

       
# CppCoreGuidelines.md:3603
msgid "3603    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3604
msgid "3604    A class with members that all have default constructors implicitly gets a default constructor:"
msgstr""

       
# CppCoreGuidelines.md:3605
msgid "3605        struct X {"
msgstr""

# CppCoreGuidelines.md:3606
msgid "3606            string s;"
msgstr""

# CppCoreGuidelines.md:3607
msgid "3607            vector<int> v;"
msgstr""

# CppCoreGuidelines.md:3608
msgid "3608        };"
msgstr""

       
# CppCoreGuidelines.md:3609
msgid "3609        X x; // means X{{}, {}}; that is the empty string and the empty vector"
msgstr""

       
# CppCoreGuidelines.md:3610
msgid "3610    Beware that built-in types are not properly default constructed:"
msgstr""

       
# CppCoreGuidelines.md:3611
msgid "3611        struct X {"
msgstr""

# CppCoreGuidelines.md:3612
msgid "3612            string s;"
msgstr""

# CppCoreGuidelines.md:3613
msgid "3613            int i;"
msgstr""

# CppCoreGuidelines.md:3614
msgid "3614        };"
msgstr""

       
# CppCoreGuidelines.md:3615
msgid "3615        void f()"
msgstr""

# CppCoreGuidelines.md:3616
msgid "3616        {"
msgstr""

# CppCoreGuidelines.md:3617
msgid "3617            X x;    // x.s is initialized to the empty string; x.i is uninitialized"
msgstr""

       
# CppCoreGuidelines.md:3618
msgid "3618            cout << x.s << ' ' << x.i << '\\n';"
msgstr""

# CppCoreGuidelines.md:3619
msgid "3619            ++x.i;"
msgstr""

# CppCoreGuidelines.md:3620
msgid "3620        }"
msgstr""

       
# CppCoreGuidelines.md:3621
msgid "3621    Statically allocated objects of built-in types are by default initialized to `0`, but local built-in variables are not."
msgstr""

# CppCoreGuidelines.md:3622
msgid "3622    Beware that your compiler may default initialize local built-in variables, whereas an optimized build will not."
msgstr""

# CppCoreGuidelines.md:3623
msgid "3623    Thus, code like the example above may appear to work, but it relies on undefined behavior."
msgstr""

# CppCoreGuidelines.md:3624
msgid "3624    Assuming that you want initialization, an explicit default initialization can help:"
msgstr""

       
# CppCoreGuidelines.md:3625
msgid "3625        struct X {"
msgstr""

# CppCoreGuidelines.md:3626
msgid "3626            string s;"
msgstr""

# CppCoreGuidelines.md:3627
msgid "3627            int i {};   // default initialize (to 0)"
msgstr""

# CppCoreGuidelines.md:3628
msgid "3628        };"
msgstr""

       
# CppCoreGuidelines.md:3629
msgid "3629    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:3630
msgid "3630    Classes that don't have a reasonable default construction are usually not copyable either, so they don't fall under this guideline."
msgstr""

       
# CppCoreGuidelines.md:3631
msgid "3631    For example, a base class is not a value type (base classes should not be copyable) and so does not necessarily need a default constructor:"
msgstr""

       
# CppCoreGuidelines.md:3632
msgid "3632        // Shape is an abstract base class, not a copyable value type."
msgstr""

# CppCoreGuidelines.md:3633
msgid "3633        // It may or may not need a default constructor."
msgstr""

# CppCoreGuidelines.md:3634
msgid "3634        struct Shape {"
msgstr""

# CppCoreGuidelines.md:3635
msgid "3635            virtual void draw() = 0;"
msgstr""

# CppCoreGuidelines.md:3636
msgid "3636            virtual void rotate(int) = 0;"
msgstr""

# CppCoreGuidelines.md:3637
msgid "3637            // =delete copy/move functions"
msgstr""

# CppCoreGuidelines.md:3638
msgid "3638            // ..."
msgstr""

# CppCoreGuidelines.md:3639
msgid "3639        };"
msgstr""

       
# CppCoreGuidelines.md:3640
msgid "3640    A class that must acquire a caller-provided resource during construction often cannot have a default constructor, but it does not fall under this guideline because such a class is usually not copyable anyway:"
msgstr""

       
# CppCoreGuidelines.md:3641
msgid "3641        // std::lock_guard is not a copyable value type."
msgstr""

# CppCoreGuidelines.md:3642
msgid "3642        // It does not have a default constructor."
msgstr""

# CppCoreGuidelines.md:3643
msgid "3643        lock_guard g {mx};  // guard the mutex mx"
msgstr""

# CppCoreGuidelines.md:3644
msgid "3644        lock_guard g2;      // error: guarding nothing"
msgstr""

       
# CppCoreGuidelines.md:3645
msgid "3645    A class that has a \"special state\" that must be handled separately from other states by member functions or users causes extra work"
msgstr""

# CppCoreGuidelines.md:3646
msgid "3646    (and most likely more errors). Such a type can naturally use the special state as a default constructed value, whether or not it is copyable:"
msgstr""

       
# CppCoreGuidelines.md:3647
msgid "3647        // std::ofstream is not a copyable value type."
msgstr""

# CppCoreGuidelines.md:3648
msgid "3648        // It does happen to have a default constructor"
msgstr""

# CppCoreGuidelines.md:3649
msgid "3649        // that goes along with a special \"not open\" state."
msgstr""

# CppCoreGuidelines.md:3650
msgid "3650        ofstream out {\"Foobar\"};"
msgstr""

# CppCoreGuidelines.md:3651
msgid "3651        // ..."
msgstr""

# CppCoreGuidelines.md:3652
msgid "3652        out << log(time, transaction);"
msgstr""

       
# CppCoreGuidelines.md:3653
msgid "3653    Similar special-state types that are copyable, such as copyable smart pointers that have the special state \"==nullptr\", should use the special state as their default constructed value."
msgstr""

       
# CppCoreGuidelines.md:3654
msgid "3654    However, it is preferable to have a default constructor default to a meaningful state such as `std::string`s `\"\"` and `std::vector`s `{}`."
msgstr""

       
# CppCoreGuidelines.md:3655
msgid "3655    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3656
msgid "3656    * Flag classes that are copyable by `=` without a default constructor"
msgstr""

# CppCoreGuidelines.md:3657
msgid "3657    * Flag classes that are comparable with `==` but not copyable"
msgstr""

       
       
# CppCoreGuidelines.md:3658
msgid "3658    ### <a name=\"Rc-default00\"></a>C.44: Prefer default constructors to be simple and non-throwing"
msgstr""

       
# CppCoreGuidelines.md:3659
msgid "3659    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3660
msgid "3660    Being able to set a value to \"the default\" without operations that might fail simplifies error handling and reasoning about move operations."
msgstr""

       
# CppCoreGuidelines.md:3661
msgid "3661    ##### Example, problematic"
msgstr""

       
# CppCoreGuidelines.md:3662
msgid "3662        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3663
msgid "3663        // elem points to space-elem element allocated using new"
msgstr""

# CppCoreGuidelines.md:3664
msgid "3664        class Vector0 {"
msgstr""

# CppCoreGuidelines.md:3665
msgid "3665        public:"
msgstr""

# CppCoreGuidelines.md:3666
msgid "3666            Vector0() :Vector0{0} {}"
msgstr""

# CppCoreGuidelines.md:3667
msgid "3667            Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}"
msgstr""

# CppCoreGuidelines.md:3668
msgid "3668            // ..."
msgstr""

# CppCoreGuidelines.md:3669
msgid "3669        private:"
msgstr""

# CppCoreGuidelines.md:3670
msgid "3670            own<T*> elem;"
msgstr""

# CppCoreGuidelines.md:3671
msgid "3671            T* space;"
msgstr""

# CppCoreGuidelines.md:3672
msgid "3672            T* last;"
msgstr""

# CppCoreGuidelines.md:3673
msgid "3673        };"
msgstr""

       
# CppCoreGuidelines.md:3674
msgid "3674    This is nice and general, but setting a `Vector0` to empty after an error involves an allocation, which may fail."
msgstr""

# CppCoreGuidelines.md:3675
msgid "3675    Also, having a default `Vector` represented as `{new T[0], 0, 0}` seems wasteful."
msgstr""

# CppCoreGuidelines.md:3676
msgid "3676    For example, `Vector0<int> v[100]` costs 100 allocations."
msgstr""

       
# CppCoreGuidelines.md:3677
msgid "3677    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3678
msgid "3678        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3679
msgid "3679        // elem is nullptr or elem points to space-elem element allocated using new"
msgstr""

# CppCoreGuidelines.md:3680
msgid "3680        class Vector1 {"
msgstr""

# CppCoreGuidelines.md:3681
msgid "3681        public:"
msgstr""

# CppCoreGuidelines.md:3682
msgid "3682            // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw"
msgstr""

# CppCoreGuidelines.md:3683
msgid "3683            Vector1() noexcept {}"
msgstr""

# CppCoreGuidelines.md:3684
msgid "3684            Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}"
msgstr""

# CppCoreGuidelines.md:3685
msgid "3685            // ..."
msgstr""

# CppCoreGuidelines.md:3686
msgid "3686        private:"
msgstr""

# CppCoreGuidelines.md:3687
msgid "3687            own<T*> elem = nullptr;"
msgstr""

# CppCoreGuidelines.md:3688
msgid "3688            T* space = nullptr;"
msgstr""

# CppCoreGuidelines.md:3689
msgid "3689            T* last = nullptr;"
msgstr""

# CppCoreGuidelines.md:3690
msgid "3690        };"
msgstr""

       
# CppCoreGuidelines.md:3691
msgid "3691    Using `{nullptr, nullptr, nullptr}` makes `Vector1{}` cheap, but a special case and implies run-time checks."
msgstr""

# CppCoreGuidelines.md:3692
msgid "3692    Setting a `Vector1` to empty after detecting an error is trivial."
msgstr""

       
# CppCoreGuidelines.md:3693
msgid "3693    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3694
msgid "3694    * Flag throwing default constructors"
msgstr""

       
# CppCoreGuidelines.md:3695
msgid "3695    ### <a name=\"Rc-default\"></a>C.45: Don't define a default constructor that only initializes data members; use in-class member initializers instead"
msgstr""

       
# CppCoreGuidelines.md:3696
msgid "3696    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3697
msgid "3697    Using in-class member initializers lets the compiler generate the function for you. The compiler-generated function can be more efficient."
msgstr""

       
# CppCoreGuidelines.md:3698
msgid "3698    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3699
msgid "3699        class X1 { // BAD: doesn't use member initializers"
msgstr""

# CppCoreGuidelines.md:3700
msgid "3700            string s;"
msgstr""

# CppCoreGuidelines.md:3701
msgid "3701            int i;"
msgstr""

# CppCoreGuidelines.md:3702
msgid "3702        public:"
msgstr""

# CppCoreGuidelines.md:3703
msgid "3703            X1() :s{\"default\"}, i{1} { }"
msgstr""

# CppCoreGuidelines.md:3704
msgid "3704            // ..."
msgstr""

# CppCoreGuidelines.md:3705
msgid "3705        };"
msgstr""

       
# CppCoreGuidelines.md:3706
msgid "3706    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3707
msgid "3707        class X2 {"
msgstr""

# CppCoreGuidelines.md:3708
msgid "3708            string s = \"default\";"
msgstr""

# CppCoreGuidelines.md:3709
msgid "3709            int i = 1;"
msgstr""

# CppCoreGuidelines.md:3710
msgid "3710        public:"
msgstr""

# CppCoreGuidelines.md:3711
msgid "3711            // use compiler-generated default constructor"
msgstr""

# CppCoreGuidelines.md:3712
msgid "3712            // ..."
msgstr""

# CppCoreGuidelines.md:3713
msgid "3713        };"
msgstr""

       
# CppCoreGuidelines.md:3714
msgid "3714    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3715
msgid "3715    (Simple) A default constructor should do more than just initialize member variables with constants."
msgstr""

       
# CppCoreGuidelines.md:3716
msgid "3716    ### <a name=\"Rc-explicit\"></a>C.46: By default, declare single-argument constructors explicit"
msgstr""

       
# CppCoreGuidelines.md:3717
msgid "3717    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3718
msgid "3718    To avoid unintended conversions."
msgstr""

       
# CppCoreGuidelines.md:3719
msgid "3719    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3720
msgid "3720        class String {"
msgstr""

# CppCoreGuidelines.md:3721
msgid "3721            // ..."
msgstr""

# CppCoreGuidelines.md:3722
msgid "3722        public:"
msgstr""

# CppCoreGuidelines.md:3723
msgid "3723            String(int);   // BAD"
msgstr""

# CppCoreGuidelines.md:3724
msgid "3724            // ..."
msgstr""

# CppCoreGuidelines.md:3725
msgid "3725        };"
msgstr""

       
# CppCoreGuidelines.md:3726
msgid "3726        String s = 10;   // surprise: string of size 10"
msgstr""

       
# CppCoreGuidelines.md:3727
msgid "3727    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:3728
msgid "3728    If you really want an implicit conversion from the constructor argument type to the class type, don't use `explicit`:"
msgstr""

       
# CppCoreGuidelines.md:3729
msgid "3729        class Complex {"
msgstr""

# CppCoreGuidelines.md:3730
msgid "3730            // ..."
msgstr""

# CppCoreGuidelines.md:3731
msgid "3731        public:"
msgstr""

# CppCoreGuidelines.md:3732
msgid "3732            Complex(double d);   // OK: we want a conversion from d to {d, 0}"
msgstr""

# CppCoreGuidelines.md:3733
msgid "3733            // ..."
msgstr""

# CppCoreGuidelines.md:3734
msgid "3734        };"
msgstr""

       
# CppCoreGuidelines.md:3735
msgid "3735        Complex z = 10.7;   // unsurprising conversion"
msgstr""

       
# CppCoreGuidelines.md:3736
msgid "3736    **See also**: [Discussion of implicit conversions](#Ro-conversion)"
msgstr""

       
# CppCoreGuidelines.md:3737
msgid "3737    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3738
msgid "3738    Copy and move constructors should not be made `explicit` because they do not perform conversions. Explicit copy/move constructors make passing and returning by value difficult."
msgstr""

       
# CppCoreGuidelines.md:3739
msgid "3739    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3740
msgid "3740    (Simple) Single-argument constructors should be declared `explicit`. Good single argument non-`explicit` constructors are rare in most code based. Warn for all that are not on a \"positive list\"."
msgstr""

       
# CppCoreGuidelines.md:3741
msgid "3741    ### <a name=\"Rc-order\"></a>C.47: Define and initialize member variables in the order of member declaration"
msgstr""

       
# CppCoreGuidelines.md:3742
msgid "3742    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3743
msgid "3743    To minimize confusion and errors. That is the order in which the initialization happens (independent of the order of member initializers)."
msgstr""

       
# CppCoreGuidelines.md:3744
msgid "3744    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3745
msgid "3745        class Foo {"
msgstr""

# CppCoreGuidelines.md:3746
msgid "3746            int m1;"
msgstr""

# CppCoreGuidelines.md:3747
msgid "3747            int m2;"
msgstr""

# CppCoreGuidelines.md:3748
msgid "3748        public:"
msgstr""

# CppCoreGuidelines.md:3749
msgid "3749            Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading initializer order"
msgstr""

# CppCoreGuidelines.md:3750
msgid "3750            // ..."
msgstr""

# CppCoreGuidelines.md:3751
msgid "3751        };"
msgstr""

       
# CppCoreGuidelines.md:3752
msgid "3752        Foo x(1); // surprise: x.m1 == x.m2 == 2"
msgstr""

       
# CppCoreGuidelines.md:3753
msgid "3753    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3754
msgid "3754    (Simple) A member initializer list should mention the members in the same order they are declared."
msgstr""

       
# CppCoreGuidelines.md:3755
msgid "3755    **See also**: [Discussion](#Sd-order)"
msgstr""

       
# CppCoreGuidelines.md:3756
msgid "3756    ### <a name=\"Rc-in-class-initializer\"></a>C.48: Prefer in-class initializers to member initializers in constructors for constant initializers"
msgstr""

       
# CppCoreGuidelines.md:3757
msgid "3757    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3758
msgid "3758    Makes it explicit that the same value is expected to be used in all constructors. Avoids repetition. Avoids maintenance problems. It leads to the shortest and most efficient code."
msgstr""

       
# CppCoreGuidelines.md:3759
msgid "3759    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3760
msgid "3760        class X {   // BAD"
msgstr""

# CppCoreGuidelines.md:3761
msgid "3761            int i;"
msgstr""

# CppCoreGuidelines.md:3762
msgid "3762            string s;"
msgstr""

# CppCoreGuidelines.md:3763
msgid "3763            int j;"
msgstr""

# CppCoreGuidelines.md:3764
msgid "3764        public:"
msgstr""

# CppCoreGuidelines.md:3765
msgid "3765            X() :i{666}, s{\"qqq\"} { }   // j is uninitialized"
msgstr""

# CppCoreGuidelines.md:3766
msgid "3766            X(int ii) :i{ii} {}         // s is \"\" and j is uninitialized"
msgstr""

# CppCoreGuidelines.md:3767
msgid "3767            // ..."
msgstr""

# CppCoreGuidelines.md:3768
msgid "3768        };"
msgstr""

       
# CppCoreGuidelines.md:3769
msgid "3769    How would a maintainer know whether `j` was deliberately uninitialized (probably a poor idea anyway) and whether it was intentional to give `s` the default value `\"\"` in one case and `qqq` in another (almost certainly a bug)? The problem with `j` (forgetting to initialize a member) often happens when a new member is added to an existing class."
msgstr""

       
# CppCoreGuidelines.md:3770
msgid "3770    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3771
msgid "3771        class X2 {"
msgstr""

# CppCoreGuidelines.md:3772
msgid "3772            int i {666};"
msgstr""

# CppCoreGuidelines.md:3773
msgid "3773            string s {\"qqq\"};"
msgstr""

# CppCoreGuidelines.md:3774
msgid "3774            int j {0};"
msgstr""

# CppCoreGuidelines.md:3775
msgid "3775        public:"
msgstr""

# CppCoreGuidelines.md:3776
msgid "3776            X2() = default;        // all members are initialized to their defaults"
msgstr""

# CppCoreGuidelines.md:3777
msgid "3777            X2(int ii) :i{ii} {}   // s and j initialized to their defaults"
msgstr""

# CppCoreGuidelines.md:3778
msgid "3778            // ..."
msgstr""

# CppCoreGuidelines.md:3779
msgid "3779        };"
msgstr""

       
# CppCoreGuidelines.md:3780
msgid "3780    **Alternative**: We can get part of the benefits from default arguments to constructors, and that is not uncommon in older code. However, that is less explicit, causes more arguments to be passed, and is repetitive when there is more than one constructor:"
msgstr""

       
# CppCoreGuidelines.md:3781
msgid "3781        class X3 {   // BAD: inexplicit, argument passing overhead"
msgstr""

# CppCoreGuidelines.md:3782
msgid "3782            int i;"
msgstr""

# CppCoreGuidelines.md:3783
msgid "3783            string s;"
msgstr""

# CppCoreGuidelines.md:3784
msgid "3784            int j;"
msgstr""

# CppCoreGuidelines.md:3785
msgid "3785        public:"
msgstr""

# CppCoreGuidelines.md:3786
msgid "3786            X3(int ii = 666, const string& ss = \"qqq\", int jj = 0)"
msgstr""

# CppCoreGuidelines.md:3787
msgid "3787                :i{ii}, s{ss}, j{jj} { }   // all members are initialized to their defaults"
msgstr""

# CppCoreGuidelines.md:3788
msgid "3788            // ..."
msgstr""

# CppCoreGuidelines.md:3789
msgid "3789        };"
msgstr""

       
# CppCoreGuidelines.md:3790
msgid "3790    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3791
msgid "3791    * (Simple) Every constructor should initialize every member variable (either explicitly, via a delegating ctor call or via default construction)."
msgstr""

# CppCoreGuidelines.md:3792
msgid "3792    * (Simple) Default arguments to constructors suggest an in-class initializer may be more appropriate."
msgstr""

       
# CppCoreGuidelines.md:3793
msgid "3793    ### <a name=\"Rc-initialize\"></a>C.49: Prefer initialization to assignment in constructors"
msgstr""

       
# CppCoreGuidelines.md:3794
msgid "3794    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3795
msgid "3795    An initialization explicitly states that initialization, rather than assignment, is done and can be more elegant and efficient. Prevents \"use before set\" errors."
msgstr""

       
# CppCoreGuidelines.md:3796
msgid "3796    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:3797
msgid "3797        class A {   // Good"
msgstr""

# CppCoreGuidelines.md:3798
msgid "3798            string s1;"
msgstr""

# CppCoreGuidelines.md:3799
msgid "3799        public:"
msgstr""

# CppCoreGuidelines.md:3800
msgid "3800            A() : s1{\"Hello, \"} { }    // GOOD: directly construct"
msgstr""

# CppCoreGuidelines.md:3801
msgid "3801            // ..."
msgstr""

# CppCoreGuidelines.md:3802
msgid "3802        };"
msgstr""

       
# CppCoreGuidelines.md:3803
msgid "3803    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3804
msgid "3804        class B {   // BAD"
msgstr""

# CppCoreGuidelines.md:3805
msgid "3805            string s1;"
msgstr""

# CppCoreGuidelines.md:3806
msgid "3806        public:"
msgstr""

# CppCoreGuidelines.md:3807
msgid "3807            B() { s1 = \"Hello, \"; }   // BAD: default constructor followed by assignment"
msgstr""

# CppCoreGuidelines.md:3808
msgid "3808            // ..."
msgstr""

# CppCoreGuidelines.md:3809
msgid "3809        };"
msgstr""

       
# CppCoreGuidelines.md:3810
msgid "3810        class C {   // UGLY, aka very bad"
msgstr""

# CppCoreGuidelines.md:3811
msgid "3811            int* p;"
msgstr""

# CppCoreGuidelines.md:3812
msgid "3812        public:"
msgstr""

# CppCoreGuidelines.md:3813
msgid "3813            C() { cout << *p; p = new int{10}; }   // accidental use before initialized"
msgstr""

# CppCoreGuidelines.md:3814
msgid "3814            // ..."
msgstr""

# CppCoreGuidelines.md:3815
msgid "3815        };"
msgstr""

       
# CppCoreGuidelines.md:3816
msgid "3816    ### <a name=\"Rc-factory\"></a>C.50: Use a factory function if you need \"virtual behavior\" during initialization"
msgstr""

       
# CppCoreGuidelines.md:3817
msgid "3817    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3818
msgid "3818    If the state of a base class object must depend on the state of a derived part of the object, we need to use a virtual function (or equivalent) while minimizing the window of opportunity to misuse an imperfectly constructed object."
msgstr""

       
# CppCoreGuidelines.md:3819
msgid "3819    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3820
msgid "3820    The return type of the factory should normally be `unique_ptr` by default; if some uses are shared, the caller can `move` the `unique_ptr` into a `shared_ptr`. However, if the factory author knows that all uses of the returned object will be shared uses, return `shared_ptr` and use `make_shared` in the body to save an allocation."
msgstr""

       
# CppCoreGuidelines.md:3821
msgid "3821    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3822
msgid "3822        class B {"
msgstr""

# CppCoreGuidelines.md:3823
msgid "3823        public:"
msgstr""

# CppCoreGuidelines.md:3824
msgid "3824            B()"
msgstr""

# CppCoreGuidelines.md:3825
msgid "3825            {"
msgstr""

# CppCoreGuidelines.md:3826
msgid "3826                // ..."
msgstr""

# CppCoreGuidelines.md:3827
msgid "3827                f();   // BAD: virtual call in constructor"
msgstr""

# CppCoreGuidelines.md:3828
msgid "3828                // ..."
msgstr""

# CppCoreGuidelines.md:3829
msgid "3829            }"
msgstr""

       
# CppCoreGuidelines.md:3830
msgid "3830            virtual void f() = 0;"
msgstr""

       
# CppCoreGuidelines.md:3831
msgid "3831            // ..."
msgstr""

# CppCoreGuidelines.md:3832
msgid "3832        };"
msgstr""

       
# CppCoreGuidelines.md:3833
msgid "3833    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3834
msgid "3834        class B {"
msgstr""

# CppCoreGuidelines.md:3835
msgid "3835        protected:"
msgstr""

# CppCoreGuidelines.md:3836
msgid "3836            B() { /* ... */ }              // create an imperfectly initialized object"
msgstr""

       
# CppCoreGuidelines.md:3837
msgid "3837            virtual void PostInitialize()  // to be called right after construction"
msgstr""

# CppCoreGuidelines.md:3838
msgid "3838            {"
msgstr""

# CppCoreGuidelines.md:3839
msgid "3839                // ..."
msgstr""

# CppCoreGuidelines.md:3840
msgid "3840                f();    // GOOD: virtual dispatch is safe"
msgstr""

# CppCoreGuidelines.md:3841
msgid "3841                // ..."
msgstr""

# CppCoreGuidelines.md:3842
msgid "3842            }"
msgstr""

       
# CppCoreGuidelines.md:3843
msgid "3843        public:"
msgstr""

# CppCoreGuidelines.md:3844
msgid "3844            virtual void f() = 0;"
msgstr""

       
# CppCoreGuidelines.md:3845
msgid "3845            template<class T>"
msgstr""

# CppCoreGuidelines.md:3846
msgid "3846            static shared_ptr<T> Create()  // interface for creating shared objects"
msgstr""

# CppCoreGuidelines.md:3847
msgid "3847            {"
msgstr""

# CppCoreGuidelines.md:3848
msgid "3848                auto p = make_shared<T>();"
msgstr""

# CppCoreGuidelines.md:3849
msgid "3849                p->PostInitialize();"
msgstr""

# CppCoreGuidelines.md:3850
msgid "3850                return p;"
msgstr""

# CppCoreGuidelines.md:3851
msgid "3851            }"
msgstr""

# CppCoreGuidelines.md:3852
msgid "3852        };"
msgstr""

       
# CppCoreGuidelines.md:3853
msgid "3853        class D : public B { /* ... */ };  // some derived class"
msgstr""

       
# CppCoreGuidelines.md:3854
msgid "3854        shared_ptr<D> p = D::Create<D>();  // creating a D object"
msgstr""

       
# CppCoreGuidelines.md:3855
msgid "3855    By making the constructor `protected` we avoid an incompletely constructed object escaping into the wild."
msgstr""

# CppCoreGuidelines.md:3856
msgid "3856    By providing the factory function `Create()`, we make construction (on the free store) convenient."
msgstr""

       
# CppCoreGuidelines.md:3857
msgid "3857    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3858
msgid "3858    Conventional factory functions allocate on the free store, rather than on the stack or in an enclosing object."
msgstr""

       
# CppCoreGuidelines.md:3859
msgid "3859    **See also**: [Discussion](#Sd-factory)"
msgstr""

       
# CppCoreGuidelines.md:3860
msgid "3860    ### <a name=\"Rc-delegating\"></a>C.51: Use delegating constructors to represent common actions for all constructors of a class"
msgstr""

       
# CppCoreGuidelines.md:3861
msgid "3861    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3862
msgid "3862    To avoid repetition and accidental differences."
msgstr""

       
# CppCoreGuidelines.md:3863
msgid "3863    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3864
msgid "3864        class Date {   // BAD: repetitive"
msgstr""

# CppCoreGuidelines.md:3865
msgid "3865            int d;"
msgstr""

# CppCoreGuidelines.md:3866
msgid "3866            Month m;"
msgstr""

# CppCoreGuidelines.md:3867
msgid "3867            int y;"
msgstr""

# CppCoreGuidelines.md:3868
msgid "3868        public:"
msgstr""

# CppCoreGuidelines.md:3869
msgid "3869            Date(int ii, Month mm, year yy)"
msgstr""

# CppCoreGuidelines.md:3870
msgid "3870                :i{ii}, m{mm}, y{yy}"
msgstr""

# CppCoreGuidelines.md:3871
msgid "3871                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr""

       
# CppCoreGuidelines.md:3872
msgid "3872            Date(int ii, Month mm)"
msgstr""

# CppCoreGuidelines.md:3873
msgid "3873                :i{ii}, m{mm} y{current_year()}"
msgstr""

# CppCoreGuidelines.md:3874
msgid "3874                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr""

# CppCoreGuidelines.md:3875
msgid "3875            // ..."
msgstr""

# CppCoreGuidelines.md:3876
msgid "3876        };"
msgstr""

       
# CppCoreGuidelines.md:3877
msgid "3877    The common action gets tedious to write and may accidentally not be common."
msgstr""

       
# CppCoreGuidelines.md:3878
msgid "3878    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3879
msgid "3879        class Date2 {"
msgstr""

# CppCoreGuidelines.md:3880
msgid "3880            int d;"
msgstr""

# CppCoreGuidelines.md:3881
msgid "3881            Month m;"
msgstr""

# CppCoreGuidelines.md:3882
msgid "3882            int y;"
msgstr""

# CppCoreGuidelines.md:3883
msgid "3883        public:"
msgstr""

# CppCoreGuidelines.md:3884
msgid "3884            Date2(int ii, Month mm, year yy)"
msgstr""

# CppCoreGuidelines.md:3885
msgid "3885                :i{ii}, m{mm}, y{yy}"
msgstr""

# CppCoreGuidelines.md:3886
msgid "3886                { if (!valid(i, m, y)) throw Bad_date{}; }"
msgstr""

       
# CppCoreGuidelines.md:3887
msgid "3887            Date2(int ii, Month mm)"
msgstr""

# CppCoreGuidelines.md:3888
msgid "3888                :Date2{ii, mm, current_year()} {}"
msgstr""

# CppCoreGuidelines.md:3889
msgid "3889            // ..."
msgstr""

# CppCoreGuidelines.md:3890
msgid "3890        };"
msgstr""

       
# CppCoreGuidelines.md:3891
msgid "3891    **See also**: If the \"repeated action\" is a simple initialization, consider [an in-class member initializer](#Rc-in-class-initializer)."
msgstr""

       
# CppCoreGuidelines.md:3892
msgid "3892    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3893
msgid "3893    (Moderate) Look for similar constructor bodies."
msgstr""

       
# CppCoreGuidelines.md:3894
msgid "3894    ### <a name=\"Rc-inheriting\"></a>C.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization"
msgstr""

       
# CppCoreGuidelines.md:3895
msgid "3895    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3896
msgid "3896    If you need those constructors for a derived class, re-implementing them is tedious and error-prone."
msgstr""

       
# CppCoreGuidelines.md:3897
msgid "3897    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3898
msgid "3898    `std::vector` has a lot of tricky constructors, so if I want my own `vector`, I don't want to reimplement them:"
msgstr""

       
# CppCoreGuidelines.md:3899
msgid "3899        class Rec {"
msgstr""

# CppCoreGuidelines.md:3900
msgid "3900            // ... data and lots of nice constructors ..."
msgstr""

# CppCoreGuidelines.md:3901
msgid "3901        };"
msgstr""

       
# CppCoreGuidelines.md:3902
msgid "3902        class Oper : public Rec {"
msgstr""

# CppCoreGuidelines.md:3903
msgid "3903            using Rec::Rec;"
msgstr""

# CppCoreGuidelines.md:3904
msgid "3904            // ... no data members ..."
msgstr""

# CppCoreGuidelines.md:3905
msgid "3905            // ... lots of nice utility functions ..."
msgstr""

# CppCoreGuidelines.md:3906
msgid "3906        };"
msgstr""

       
# CppCoreGuidelines.md:3907
msgid "3907    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:3908
msgid "3908        struct Rec2 : public Rec {"
msgstr""

# CppCoreGuidelines.md:3909
msgid "3909            int x;"
msgstr""

# CppCoreGuidelines.md:3910
msgid "3910            using Rec::Rec;"
msgstr""

# CppCoreGuidelines.md:3911
msgid "3911        };"
msgstr""

       
# CppCoreGuidelines.md:3912
msgid "3912        Rec2 r {\"foo\", 7};"
msgstr""

# CppCoreGuidelines.md:3913
msgid "3913        int val = r.x;   // uninitialized"
msgstr""

       
# CppCoreGuidelines.md:3914
msgid "3914    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3915
msgid "3915    Make sure that every member of the derived class is initialized."
msgstr""

       
# CppCoreGuidelines.md:3916
msgid "3916    ## <a name=\"SS-copy\"></a>C.copy: Copy and move"
msgstr""

       
# CppCoreGuidelines.md:3917
msgid "3917    Value types should generally be copyable, but interfaces in a class hierarchy should not."
msgstr""

# CppCoreGuidelines.md:3918
msgid "3918    Resource handles may or may not be copyable."
msgstr""

# CppCoreGuidelines.md:3919
msgid "3919    Types can be defined to move for logical as well as performance reasons."
msgstr""

       
# CppCoreGuidelines.md:3920
msgid "3920    ### <a name=\"Rc-copy-assignment\"></a>C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and return by non-`const&`"
msgstr""

       
# CppCoreGuidelines.md:3921
msgid "3921    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3922
msgid "3922    It is simple and efficient. If you want to optimize for rvalues, provide an overload that takes a `&&` (see [F.18](#Rf-consume))."
msgstr""

       
# CppCoreGuidelines.md:3923
msgid "3923    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3924
msgid "3924        class Foo {"
msgstr""

# CppCoreGuidelines.md:3925
msgid "3925        public:"
msgstr""

# CppCoreGuidelines.md:3926
msgid "3926            Foo& operator=(const Foo& x)"
msgstr""

# CppCoreGuidelines.md:3927
msgid "3927            {"
msgstr""

# CppCoreGuidelines.md:3928
msgid "3928                // GOOD: no need to check for self-assignment (other than performance)"
msgstr""

# CppCoreGuidelines.md:3929
msgid "3929                auto tmp = x;"
msgstr""

# CppCoreGuidelines.md:3930
msgid "3930                std::swap(*this, tmp);"
msgstr""

# CppCoreGuidelines.md:3931
msgid "3931                return *this;"
msgstr""

# CppCoreGuidelines.md:3932
msgid "3932            }"
msgstr""

# CppCoreGuidelines.md:3933
msgid "3933            // ..."
msgstr""

# CppCoreGuidelines.md:3934
msgid "3934        };"
msgstr""

       
# CppCoreGuidelines.md:3935
msgid "3935        Foo a;"
msgstr""

# CppCoreGuidelines.md:3936
msgid "3936        Foo b;"
msgstr""

# CppCoreGuidelines.md:3937
msgid "3937        Foo f();"
msgstr""

       
# CppCoreGuidelines.md:3938
msgid "3938        a = b;    // assign lvalue: copy"
msgstr""

# CppCoreGuidelines.md:3939
msgid "3939        a = f();  // assign rvalue: potentially move"
msgstr""

       
# CppCoreGuidelines.md:3940
msgid "3940    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:3941
msgid "3941    The `swap` implementation technique offers the [strong guarantee](#Abrahams01)."
msgstr""

       
# CppCoreGuidelines.md:3942
msgid "3942    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3943
msgid "3943    But what if you can get significantly better performance by not making a temporary copy? Consider a simple `Vector` intended for a domain where assignment of large, equal-sized `Vector`s is common. In this case, the copy of elements implied by the `swap` implementation technique could cause an order of magnitude increase in cost:"
msgstr""

       
# CppCoreGuidelines.md:3944
msgid "3944        template<typename T>"
msgstr""

# CppCoreGuidelines.md:3945
msgid "3945        class Vector {"
msgstr""

# CppCoreGuidelines.md:3946
msgid "3946        public:"
msgstr""

# CppCoreGuidelines.md:3947
msgid "3947            Vector& operator=(const Vector&);"
msgstr""

# CppCoreGuidelines.md:3948
msgid "3948            // ..."
msgstr""

# CppCoreGuidelines.md:3949
msgid "3949        private:"
msgstr""

# CppCoreGuidelines.md:3950
msgid "3950            T* elem;"
msgstr""

# CppCoreGuidelines.md:3951
msgid "3951            int sz;"
msgstr""

# CppCoreGuidelines.md:3952
msgid "3952        };"
msgstr""

       
# CppCoreGuidelines.md:3953
msgid "3953        Vector& Vector::operator=(const Vector& a)"
msgstr""

# CppCoreGuidelines.md:3954
msgid "3954        {"
msgstr""

# CppCoreGuidelines.md:3955
msgid "3955            if (a.sz > sz) {"
msgstr""

# CppCoreGuidelines.md:3956
msgid "3956                // ... use the swap technique, it can't be bettered ..."
msgstr""

# CppCoreGuidelines.md:3957
msgid "3957                return *this"
msgstr""

# CppCoreGuidelines.md:3958
msgid "3958            }"
msgstr""

# CppCoreGuidelines.md:3959
msgid "3959            // ... copy sz elements from *a.elem to elem ..."
msgstr""

# CppCoreGuidelines.md:3960
msgid "3960            if (a.sz < sz) {"
msgstr""

# CppCoreGuidelines.md:3961
msgid "3961                // ... destroy the surplus elements in *this* and adjust size ..."
msgstr""

# CppCoreGuidelines.md:3962
msgid "3962            }"
msgstr""

# CppCoreGuidelines.md:3963
msgid "3963            return *this;"
msgstr""

# CppCoreGuidelines.md:3964
msgid "3964        }"
msgstr""

       
# CppCoreGuidelines.md:3965
msgid "3965    By writing directly to the target elements, we will get only [the basic guarantee](#Abrahams01) rather than the strong guarantee offered by the `swap` technique. Beware of [self-assignment](#Rc-copy-self)."
msgstr""

       
# CppCoreGuidelines.md:3966
msgid "3966    **Alternatives**: If you think you need a `virtual` assignment operator, and understand why that's deeply problematic, don't call it `operator=`. Make it a named function like `virtual void assign(const Foo&)`."
msgstr""

# CppCoreGuidelines.md:3967
msgid "3967    See [copy constructor vs. `clone()`](#Rc-copy-virtual)."
msgstr""

       
# CppCoreGuidelines.md:3968
msgid "3968    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:3969
msgid "3969    * (Simple) An assignment operator should not be virtual. Here be dragons!"
msgstr""

# CppCoreGuidelines.md:3970
msgid "3970    * (Simple) An assignment operator should return `T&` to enable chaining, not alternatives like `const T&` which interfere with composability and putting objects in containers."
msgstr""

# CppCoreGuidelines.md:3971
msgid "3971    * (Moderate) An assignment operator should (implicitly or explicitly) invoke all base and member assignment operators."
msgstr""

# CppCoreGuidelines.md:3972
msgid "3972      Look at the destructor to determine if the type has pointer semantics or value semantics."
msgstr""

       
# CppCoreGuidelines.md:3973
msgid "3973    ### <a name=\"Rc-copy-semantic\"></a>C.61: A copy operation should copy"
msgstr""

       
# CppCoreGuidelines.md:3974
msgid "3974    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:3975
msgid "3975    That is the generally assumed semantics. After `x = y`, we should have `x == y`."
msgstr""

# CppCoreGuidelines.md:3976
msgid "3976    After a copy `x` and `y` can be independent objects (value semantics, the way non-pointer built-in types and the standard-library types work) or refer to a shared object (pointer semantics, the way pointers work)."
msgstr""

       
# CppCoreGuidelines.md:3977
msgid "3977    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:3978
msgid "3978        class X {   // OK: value semantics"
msgstr""

# CppCoreGuidelines.md:3979
msgid "3979        public:"
msgstr""

# CppCoreGuidelines.md:3980
msgid "3980            X();"
msgstr""

# CppCoreGuidelines.md:3981
msgid "3981            X(const X&);     // copy X"
msgstr""

# CppCoreGuidelines.md:3982
msgid "3982            void modify();   // change the value of X"
msgstr""

# CppCoreGuidelines.md:3983
msgid "3983            // ..."
msgstr""

# CppCoreGuidelines.md:3984
msgid "3984            ~X() { delete[] p; }"
msgstr""

# CppCoreGuidelines.md:3985
msgid "3985        private:"
msgstr""

# CppCoreGuidelines.md:3986
msgid "3986            T* p;"
msgstr""

# CppCoreGuidelines.md:3987
msgid "3987            int sz;"
msgstr""

# CppCoreGuidelines.md:3988
msgid "3988        };"
msgstr""

       
# CppCoreGuidelines.md:3989
msgid "3989        bool operator==(const X& a, const X& b)"
msgstr""

# CppCoreGuidelines.md:3990
msgid "3990        {"
msgstr""

# CppCoreGuidelines.md:3991
msgid "3991            return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);"
msgstr""

# CppCoreGuidelines.md:3992
msgid "3992        }"
msgstr""

       
# CppCoreGuidelines.md:3993
msgid "3993        X::X(const X& a)"
msgstr""

# CppCoreGuidelines.md:3994
msgid "3994            :p{new T[a.sz]}, sz{a.sz}"
msgstr""

# CppCoreGuidelines.md:3995
msgid "3995        {"
msgstr""

# CppCoreGuidelines.md:3996
msgid "3996            copy(a.p, a.p + sz, p);"
msgstr""

# CppCoreGuidelines.md:3997
msgid "3997        }"
msgstr""

       
# CppCoreGuidelines.md:3998
msgid "3998        X x;"
msgstr""

# CppCoreGuidelines.md:3999
msgid "3999        X y = x;"
msgstr""

# CppCoreGuidelines.md:4000
msgid "4000        if (x != y) throw Bad{};"
msgstr""

# CppCoreGuidelines.md:4001
msgid "4001        x.modify();"
msgstr""

# CppCoreGuidelines.md:4002
msgid "4002        if (x == y) throw Bad{};   // assume value semantics"
msgstr""

       
# CppCoreGuidelines.md:4003
msgid "4003    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4004
msgid "4004        class X2 {  // OK: pointer semantics"
msgstr""

# CppCoreGuidelines.md:4005
msgid "4005        public:"
msgstr""

# CppCoreGuidelines.md:4006
msgid "4006            X2();"
msgstr""

# CppCoreGuidelines.md:4007
msgid "4007            X2(const X2&) = default; // shallow copy"
msgstr""

# CppCoreGuidelines.md:4008
msgid "4008            ~X2() = default;"
msgstr""

# CppCoreGuidelines.md:4009
msgid "4009            void modify();          // change the pointed-to value"
msgstr""

# CppCoreGuidelines.md:4010
msgid "4010            // ..."
msgstr""

# CppCoreGuidelines.md:4011
msgid "4011        private:"
msgstr""

# CppCoreGuidelines.md:4012
msgid "4012            T* p;"
msgstr""

# CppCoreGuidelines.md:4013
msgid "4013            int sz;"
msgstr""

# CppCoreGuidelines.md:4014
msgid "4014        };"
msgstr""

       
# CppCoreGuidelines.md:4015
msgid "4015        bool operator==(const X2& a, const X2& b)"
msgstr""

# CppCoreGuidelines.md:4016
msgid "4016        {"
msgstr""

# CppCoreGuidelines.md:4017
msgid "4017            return a.sz == b.sz && a.p == b.p;"
msgstr""

# CppCoreGuidelines.md:4018
msgid "4018        }"
msgstr""

       
# CppCoreGuidelines.md:4019
msgid "4019        X2 x;"
msgstr""

# CppCoreGuidelines.md:4020
msgid "4020        X2 y = x;"
msgstr""

# CppCoreGuidelines.md:4021
msgid "4021        if (x != y) throw Bad{};"
msgstr""

# CppCoreGuidelines.md:4022
msgid "4022        x.modify();"
msgstr""

# CppCoreGuidelines.md:4023
msgid "4023        if (x != y) throw Bad{};  // assume pointer semantics"
msgstr""

       
# CppCoreGuidelines.md:4024
msgid "4024    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4025
msgid "4025    Prefer copy semantics unless you are building a \"smart pointer\". Value semantics is the simplest to reason about and what the standard-library facilities expect."
msgstr""

       
# CppCoreGuidelines.md:4026
msgid "4026    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4027
msgid "4027    (Not enforceable)"
msgstr""

       
# CppCoreGuidelines.md:4028
msgid "4028    ### <a name=\"Rc-copy-self\"></a>C.62: Make copy assignment safe for self-assignment"
msgstr""

       
# CppCoreGuidelines.md:4029
msgid "4029    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4030
msgid "4030    If `x = x` changes the value of `x`, people will be surprised and bad errors will occur (often including leaks)."
msgstr""

       
# CppCoreGuidelines.md:4031
msgid "4031    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4032
msgid "4032    The standard-library containers handle self-assignment elegantly and efficiently:"
msgstr""

       
# CppCoreGuidelines.md:4033
msgid "4033        std::vector<int> v = {3, 1, 4, 1, 5, 9};"
msgstr""

# CppCoreGuidelines.md:4034
msgid "4034        v = v;"
msgstr""

# CppCoreGuidelines.md:4035
msgid "4035        // the value of v is still {3, 1, 4, 1, 5, 9}"
msgstr""

       
# CppCoreGuidelines.md:4036
msgid "4036    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4037
msgid "4037    The default assignment generated from members that handle self-assignment correctly handles self-assignment."
msgstr""

       
# CppCoreGuidelines.md:4038
msgid "4038        struct Bar {"
msgstr""

# CppCoreGuidelines.md:4039
msgid "4039            vector<pair<int, int>> v;"
msgstr""

# CppCoreGuidelines.md:4040
msgid "4040            map<string, int> m;"
msgstr""

# CppCoreGuidelines.md:4041
msgid "4041            string s;"
msgstr""

# CppCoreGuidelines.md:4042
msgid "4042        };"
msgstr""

       
# CppCoreGuidelines.md:4043
msgid "4043        Bar b;"
msgstr""

# CppCoreGuidelines.md:4044
msgid "4044        // ..."
msgstr""

# CppCoreGuidelines.md:4045
msgid "4045        b = b;   // correct and efficient"
msgstr""

       
# CppCoreGuidelines.md:4046
msgid "4046    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4047
msgid "4047    You can handle self-assignment by explicitly testing for self-assignment, but often it is faster and more elegant to cope without such a test (e.g., [using `swap`](#Rc-swap))."
msgstr""

       
# CppCoreGuidelines.md:4048
msgid "4048        class Foo {"
msgstr""

# CppCoreGuidelines.md:4049
msgid "4049            string s;"
msgstr""

# CppCoreGuidelines.md:4050
msgid "4050            int i;"
msgstr""

# CppCoreGuidelines.md:4051
msgid "4051        public:"
msgstr""

# CppCoreGuidelines.md:4052
msgid "4052            Foo& operator=(const Foo& a);"
msgstr""

# CppCoreGuidelines.md:4053
msgid "4053            // ..."
msgstr""

# CppCoreGuidelines.md:4054
msgid "4054        };"
msgstr""

       
# CppCoreGuidelines.md:4055
msgid "4055        Foo& Foo::operator=(const Foo& a)   // OK, but there is a cost"
msgstr""

# CppCoreGuidelines.md:4056
msgid "4056        {"
msgstr""

# CppCoreGuidelines.md:4057
msgid "4057            if (this == &a) return *this;"
msgstr""

# CppCoreGuidelines.md:4058
msgid "4058            s = a.s;"
msgstr""

# CppCoreGuidelines.md:4059
msgid "4059            i = a.i;"
msgstr""

# CppCoreGuidelines.md:4060
msgid "4060            return *this;"
msgstr""

# CppCoreGuidelines.md:4061
msgid "4061        }"
msgstr""

       
# CppCoreGuidelines.md:4062
msgid "4062    This is obviously safe and apparently efficient."
msgstr""

# CppCoreGuidelines.md:4063
msgid "4063    However, what if we do one self-assignment per million assignments?"
msgstr""

# CppCoreGuidelines.md:4064
msgid "4064    That's about a million redundant tests (but since the answer is essentially always the same, the computer's branch predictor will guess right essentially every time)."
msgstr""

# CppCoreGuidelines.md:4065
msgid "4065    Consider:"
msgstr""

       
# CppCoreGuidelines.md:4066
msgid "4066        Foo& Foo::operator=(const Foo& a)   // simpler, and probably much better"
msgstr""

# CppCoreGuidelines.md:4067
msgid "4067        {"
msgstr""

# CppCoreGuidelines.md:4068
msgid "4068            s = a.s;"
msgstr""

# CppCoreGuidelines.md:4069
msgid "4069            i = a.i;"
msgstr""

# CppCoreGuidelines.md:4070
msgid "4070            return *this;"
msgstr""

# CppCoreGuidelines.md:4071
msgid "4071        }"
msgstr""

       
# CppCoreGuidelines.md:4072
msgid "4072    `std::string` is safe for self-assignment and so are `int`. All the cost is carried by the (rare) case of self-assignment."
msgstr""

       
# CppCoreGuidelines.md:4073
msgid "4073    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4074
msgid "4074    (Simple) Assignment operators should not contain the pattern `if (this == &a) return *this;` ???"
msgstr""

       
# CppCoreGuidelines.md:4075
msgid "4075    ### <a name=\"Rc-move-assignment\"></a>C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return by non-`const &`"
msgstr""

       
# CppCoreGuidelines.md:4076
msgid "4076    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4077
msgid "4077    It is simple and efficient."
msgstr""

       
# CppCoreGuidelines.md:4078
msgid "4078    **See**: [The rule for copy-assignment](#Rc-copy-assignment)."
msgstr""

       
# CppCoreGuidelines.md:4079
msgid "4079    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4080
msgid "4080    Equivalent to what is done for [copy-assignment](#Rc-copy-assignment)."
msgstr""

       
# CppCoreGuidelines.md:4081
msgid "4081    * (Simple) An assignment operator should not be virtual. Here be dragons!"
msgstr""

# CppCoreGuidelines.md:4082
msgid "4082    * (Simple) An assignment operator should return `T&` to enable chaining, not alternatives like `const T&` which interfere with composability and putting objects in containers."
msgstr""

# CppCoreGuidelines.md:4083
msgid "4083    * (Moderate) A move assignment operator should (implicitly or explicitly) invoke all base and member move assignment operators."
msgstr""

       
# CppCoreGuidelines.md:4084
msgid "4084    ### <a name=\"Rc-move-semantic\"></a>C.64: A move operation should move and leave its source in a valid state"
msgstr""

       
# CppCoreGuidelines.md:4085
msgid "4085    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4086
msgid "4086    That is the generally assumed semantics."
msgstr""

# CppCoreGuidelines.md:4087
msgid "4087    After `y = std::move(x)` the value of `y` should be the value `x` had and `x` should be in a valid state."
msgstr""

       
# CppCoreGuidelines.md:4088
msgid "4088    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4089
msgid "4089        template<typename T>"
msgstr""

# CppCoreGuidelines.md:4090
msgid "4090        class X {   // OK: value semantics"
msgstr""

# CppCoreGuidelines.md:4091
msgid "4091        public:"
msgstr""

# CppCoreGuidelines.md:4092
msgid "4092            X();"
msgstr""

# CppCoreGuidelines.md:4093
msgid "4093            X(X&& a) noexcept;  // move X"
msgstr""

# CppCoreGuidelines.md:4094
msgid "4094            void modify();     // change the value of X"
msgstr""

# CppCoreGuidelines.md:4095
msgid "4095            // ..."
msgstr""

# CppCoreGuidelines.md:4096
msgid "4096            ~X() { delete[] p; }"
msgstr""

# CppCoreGuidelines.md:4097
msgid "4097        private:"
msgstr""

# CppCoreGuidelines.md:4098
msgid "4098            T* p;"
msgstr""

# CppCoreGuidelines.md:4099
msgid "4099            int sz;"
msgstr""

# CppCoreGuidelines.md:4100
msgid "4100        };"
msgstr""

       
       
# CppCoreGuidelines.md:4101
msgid "4101        X::X(X&& a)"
msgstr""

# CppCoreGuidelines.md:4102
msgid "4102            :p{a.p}, sz{a.sz}  // steal representation"
msgstr""

# CppCoreGuidelines.md:4103
msgid "4103        {"
msgstr""

# CppCoreGuidelines.md:4104
msgid "4104            a.p = nullptr;     // set to \"empty\""
msgstr""

# CppCoreGuidelines.md:4105
msgid "4105            a.sz = 0;"
msgstr""

# CppCoreGuidelines.md:4106
msgid "4106        }"
msgstr""

       
# CppCoreGuidelines.md:4107
msgid "4107        void use()"
msgstr""

# CppCoreGuidelines.md:4108
msgid "4108        {"
msgstr""

# CppCoreGuidelines.md:4109
msgid "4109            X x{};"
msgstr""

# CppCoreGuidelines.md:4110
msgid "4110            // ..."
msgstr""

# CppCoreGuidelines.md:4111
msgid "4111            X y = std::move(x);"
msgstr""

# CppCoreGuidelines.md:4112
msgid "4112            x = X{};   // OK"
msgstr""

# CppCoreGuidelines.md:4113
msgid "4113        } // OK: x can be destroyed"
msgstr""

       
# CppCoreGuidelines.md:4114
msgid "4114    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4115
msgid "4115    Ideally, that moved-from should be the default value of the type."
msgstr""

# CppCoreGuidelines.md:4116
msgid "4116    Ensure that unless there is an exceptionally good reason not to."
msgstr""

# CppCoreGuidelines.md:4117
msgid "4117    However, not all types have a default value and for some types establishing the default value can be expensive."
msgstr""

# CppCoreGuidelines.md:4118
msgid "4118    The standard requires only that the moved-from object can be destroyed."
msgstr""

# CppCoreGuidelines.md:4119
msgid "4119    Often, we can easily and cheaply do better: The standard library assumes that it is possible to assign to a moved-from object."
msgstr""

# CppCoreGuidelines.md:4120
msgid "4120    Always leave the moved-from object in some (necessarily specified) valid state."
msgstr""

       
# CppCoreGuidelines.md:4121
msgid "4121    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4122
msgid "4122    Unless there is an exceptionally strong reason not to, make `x = std::move(y); y = z;` work with the conventional semantics."
msgstr""

       
# CppCoreGuidelines.md:4123
msgid "4123    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4124
msgid "4124    (Not enforceable) Look for assignments to members in the move operation. If there is a default constructor, compare those assignments to the initializations in the default constructor."
msgstr""

       
# CppCoreGuidelines.md:4125
msgid "4125    ### <a name=\"Rc-move-self\"></a>C.65: Make move assignment safe for self-assignment"
msgstr""

       
# CppCoreGuidelines.md:4126
msgid "4126    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4127
msgid "4127    If `x = x` changes the value of `x`, people will be surprised and bad errors may occur. However, people don't usually directly write a self-assignment that turn into a move, but it can occur. However, `std::swap` is implemented using move operations so if you accidentally do `swap(a, b)` where `a` and `b` refer to the same object, failing to handle self-move could be a serious and subtle error."
msgstr""

       
# CppCoreGuidelines.md:4128
msgid "4128    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4129
msgid "4129        class Foo {"
msgstr""

# CppCoreGuidelines.md:4130
msgid "4130            string s;"
msgstr""

# CppCoreGuidelines.md:4131
msgid "4131            int i;"
msgstr""

# CppCoreGuidelines.md:4132
msgid "4132        public:"
msgstr""

# CppCoreGuidelines.md:4133
msgid "4133            Foo& operator=(Foo&& a);"
msgstr""

# CppCoreGuidelines.md:4134
msgid "4134            // ..."
msgstr""

# CppCoreGuidelines.md:4135
msgid "4135        };"
msgstr""

       
# CppCoreGuidelines.md:4136
msgid "4136        Foo& Foo::operator=(Foo&& a) noexcept  // OK, but there is a cost"
msgstr""

# CppCoreGuidelines.md:4137
msgid "4137        {"
msgstr""

# CppCoreGuidelines.md:4138
msgid "4138            if (this == &a) return *this;  // this line is redundant"
msgstr""

# CppCoreGuidelines.md:4139
msgid "4139            s = std::move(a.s);"
msgstr""

# CppCoreGuidelines.md:4140
msgid "4140            i = a.i;"
msgstr""

# CppCoreGuidelines.md:4141
msgid "4141            return *this;"
msgstr""

# CppCoreGuidelines.md:4142
msgid "4142        }"
msgstr""

       
# CppCoreGuidelines.md:4143
msgid "4143    The one-in-a-million argument against `if (this == &a) return *this;` tests from the discussion of [self-assignment](#Rc-copy-self) is even more relevant for self-move."
msgstr""

       
# CppCoreGuidelines.md:4144
msgid "4144    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4145
msgid "4145    There is no known general way of avoiding a `if (this == &a) return *this;` test for a move assignment and still get a correct answer (i.e., after `x = x` the value of `x` is unchanged)."
msgstr""

       
# CppCoreGuidelines.md:4146
msgid "4146    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4147
msgid "4147    The ISO standard guarantees only a \"valid but unspecified\" state for the standard-library containers. Apparently this has not been a problem in about 10 years of experimental and production use. Please contact the editors if you find a counter example. The rule here is more caution and insists on complete safety."
msgstr""

       
# CppCoreGuidelines.md:4148
msgid "4148    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4149
msgid "4149    Here is a way to move a pointer without a test (imagine it as code in the implementation a move assignment):"
msgstr""

       
# CppCoreGuidelines.md:4150
msgid "4150        // move from other.ptr to this->ptr"
msgstr""

# CppCoreGuidelines.md:4151
msgid "4151        T* temp = other.ptr;"
msgstr""

# CppCoreGuidelines.md:4152
msgid "4152        other.ptr = nullptr;"
msgstr""

# CppCoreGuidelines.md:4153
msgid "4153        delete ptr;"
msgstr""

# CppCoreGuidelines.md:4154
msgid "4154        ptr = temp;"
msgstr""

       
# CppCoreGuidelines.md:4155
msgid "4155    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4156
msgid "4156    * (Moderate) In the case of self-assignment, a move assignment operator should not leave the object holding pointer members that have been `delete`d or set to `nullptr`."
msgstr""

# CppCoreGuidelines.md:4157
msgid "4157    * (Not enforceable) Look at the use of standard-library container types (incl. `string`) and consider them safe for ordinary (not life-critical) uses."
msgstr""

       
# CppCoreGuidelines.md:4158
msgid "4158    ### <a name=\"Rc-move-noexcept\"></a>C.66: Make move operations `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:4159
msgid "4159    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4160
msgid "4160    A throwing move violates most people's reasonably assumptions."
msgstr""

# CppCoreGuidelines.md:4161
msgid "4161    A non-throwing move will be used more efficiently by standard-library and language facilities."
msgstr""

       
# CppCoreGuidelines.md:4162
msgid "4162    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4163
msgid "4163        template<typename T>"
msgstr""

# CppCoreGuidelines.md:4164
msgid "4164        class Vector {"
msgstr""

# CppCoreGuidelines.md:4165
msgid "4165            // ..."
msgstr""

# CppCoreGuidelines.md:4166
msgid "4166            Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.sz = 0; a.elem = nullptr; }"
msgstr""

# CppCoreGuidelines.md:4167
msgid "4167            Vector& operator=(Vector&& a) noexcept { elem = a.elem; sz = a.sz; a.sz = 0; a.elem = nullptr; }"
msgstr""

# CppCoreGuidelines.md:4168
msgid "4168            // ..."
msgstr""

# CppCoreGuidelines.md:4169
msgid "4169        public:"
msgstr""

# CppCoreGuidelines.md:4170
msgid "4170            T* elem;"
msgstr""

# CppCoreGuidelines.md:4171
msgid "4171            int sz;"
msgstr""

# CppCoreGuidelines.md:4172
msgid "4172        };"
msgstr""

       
# CppCoreGuidelines.md:4173
msgid "4173    These operations do not throw."
msgstr""

       
# CppCoreGuidelines.md:4174
msgid "4174    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4175
msgid "4175        template<typename T>"
msgstr""

# CppCoreGuidelines.md:4176
msgid "4176        class Vector2 {"
msgstr""

# CppCoreGuidelines.md:4177
msgid "4177            // ..."
msgstr""

# CppCoreGuidelines.md:4178
msgid "4178            Vector2(Vector2&& a) { *this = a; }             // just use the copy"
msgstr""

# CppCoreGuidelines.md:4179
msgid "4179            Vector2& operator=(Vector2&& a) { *this = a; }  // just use the copy"
msgstr""

# CppCoreGuidelines.md:4180
msgid "4180            // ..."
msgstr""

# CppCoreGuidelines.md:4181
msgid "4181        public:"
msgstr""

# CppCoreGuidelines.md:4182
msgid "4182            T* elem;"
msgstr""

# CppCoreGuidelines.md:4183
msgid "4183            int sz;"
msgstr""

# CppCoreGuidelines.md:4184
msgid "4184        };"
msgstr""

       
# CppCoreGuidelines.md:4185
msgid "4185    This `Vector2` is not just inefficient, but since a vector copy requires allocation, it can throw."
msgstr""

       
# CppCoreGuidelines.md:4186
msgid "4186    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4187
msgid "4187    (Simple) A move operation should be marked `noexcept`."
msgstr""

       
# CppCoreGuidelines.md:4188
msgid "4188    ### <a name=\"Rc-copy-virtual\"></a>C.67: A polymorphic class should suppress copying"
msgstr""

       
# CppCoreGuidelines.md:4189
msgid "4189    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4190
msgid "4190    A *polymorphic class* is a class that defines or inherits at least one virtual function. It is likely that it will be used as a base class for other derived classes with polymorphic behavior. If it is accidentally passed by value, with the implicitly generated copy constructor and assignment, we risk slicing: only the base portion of a derived object will be copied, and the polymorphic behavior will be corrupted."
msgstr""

       
# CppCoreGuidelines.md:4191
msgid "4191    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4192
msgid "4192        class B { // BAD: polymorphic base class doesn't suppress copying"
msgstr""

# CppCoreGuidelines.md:4193
msgid "4193        public:"
msgstr""

# CppCoreGuidelines.md:4194
msgid "4194            virtual char m() { return 'B'; }"
msgstr""

# CppCoreGuidelines.md:4195
msgid "4195            // ... nothing about copy operations, so uses default ..."
msgstr""

# CppCoreGuidelines.md:4196
msgid "4196        };"
msgstr""

       
# CppCoreGuidelines.md:4197
msgid "4197        class D : public B {"
msgstr""

# CppCoreGuidelines.md:4198
msgid "4198        public:"
msgstr""

# CppCoreGuidelines.md:4199
msgid "4199            char m() override { return 'D'; }"
msgstr""

# CppCoreGuidelines.md:4200
msgid "4200            // ..."
msgstr""

# CppCoreGuidelines.md:4201
msgid "4201        };"
msgstr""

       
# CppCoreGuidelines.md:4202
msgid "4202        void f(B& b) {"
msgstr""

# CppCoreGuidelines.md:4203
msgid "4203            auto b2 = b; // oops, slices the object; b2.m() will return 'B'"
msgstr""

# CppCoreGuidelines.md:4204
msgid "4204        }"
msgstr""

       
# CppCoreGuidelines.md:4205
msgid "4205        D d;"
msgstr""

# CppCoreGuidelines.md:4206
msgid "4206        f(d);"
msgstr""

       
# CppCoreGuidelines.md:4207
msgid "4207    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4208
msgid "4208        class B { // GOOD: polymorphic class suppresses copying"
msgstr""

# CppCoreGuidelines.md:4209
msgid "4209        public:"
msgstr""

# CppCoreGuidelines.md:4210
msgid "4210            B(const B&) = delete;"
msgstr""

# CppCoreGuidelines.md:4211
msgid "4211            B& operator=(const B&) = delete;"
msgstr""

# CppCoreGuidelines.md:4212
msgid "4212            virtual char m() { return 'B'; }"
msgstr""

# CppCoreGuidelines.md:4213
msgid "4213            // ..."
msgstr""

# CppCoreGuidelines.md:4214
msgid "4214        };"
msgstr""

       
# CppCoreGuidelines.md:4215
msgid "4215        class D : public B {"
msgstr""

# CppCoreGuidelines.md:4216
msgid "4216        public:"
msgstr""

# CppCoreGuidelines.md:4217
msgid "4217            char m() override { return 'D'; }"
msgstr""

# CppCoreGuidelines.md:4218
msgid "4218            // ..."
msgstr""

# CppCoreGuidelines.md:4219
msgid "4219        };"
msgstr""

       
# CppCoreGuidelines.md:4220
msgid "4220        void f(B& b) {"
msgstr""

# CppCoreGuidelines.md:4221
msgid "4221            auto b2 = b; // ok, compiler will detect inadvertent copying, and protest"
msgstr""

# CppCoreGuidelines.md:4222
msgid "4222        }"
msgstr""

       
# CppCoreGuidelines.md:4223
msgid "4223        D d;"
msgstr""

# CppCoreGuidelines.md:4224
msgid "4224        f(d);"
msgstr""

       
# CppCoreGuidelines.md:4225
msgid "4225    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4226
msgid "4226    If you need to create deep copies of polymorphic objects, use `clone()` functions: see [C.130](#Rh-copy)."
msgstr""

       
# CppCoreGuidelines.md:4227
msgid "4227    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:4228
msgid "4228    Classes that represent exception objects need both to be polymorphic and copy-constructible."
msgstr""

       
# CppCoreGuidelines.md:4229
msgid "4229    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4230
msgid "4230    * Flag a polymorphic class with a non-deleted copy operation."
msgstr""

# CppCoreGuidelines.md:4231
msgid "4231    * Flag an assignment of polymorphic class objects."
msgstr""

       
# CppCoreGuidelines.md:4232
msgid "4232    ## C.other: Other default operation rules"
msgstr""

       
# CppCoreGuidelines.md:4233
msgid "4233    In addition to the operations for which the language offer default implementations,"
msgstr""

# CppCoreGuidelines.md:4234
msgid "4234    there are a few operations that are so foundational that it rules for their definition are needed:"
msgstr""

# CppCoreGuidelines.md:4235
msgid "4235    comparisons, `swap`, and `hash`."
msgstr""

       
# CppCoreGuidelines.md:4236
msgid "4236    ### <a name=\"Rc-eqdefault\"></a>C.80: Use `=default` if you have to be explicit about using the default semantics"
msgstr""

       
# CppCoreGuidelines.md:4237
msgid "4237    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4238
msgid "4238    The compiler is more likely to get the default semantics right and you cannot implement these functions better than the compiler."
msgstr""

       
# CppCoreGuidelines.md:4239
msgid "4239    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4240
msgid "4240        class Tracer {"
msgstr""

# CppCoreGuidelines.md:4241
msgid "4241            string message;"
msgstr""

# CppCoreGuidelines.md:4242
msgid "4242        public:"
msgstr""

# CppCoreGuidelines.md:4243
msgid "4243            Tracer(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }"
msgstr""

# CppCoreGuidelines.md:4244
msgid "4244            ~Tracer() { cerr << \"exiting \" << message << '\\n'; }"
msgstr""

       
# CppCoreGuidelines.md:4245
msgid "4245            Tracer(const Tracer&) = default;"
msgstr""

# CppCoreGuidelines.md:4246
msgid "4246            Tracer& operator=(const Tracer&) = default;"
msgstr""

# CppCoreGuidelines.md:4247
msgid "4247            Tracer(Tracer&&) = default;"
msgstr""

# CppCoreGuidelines.md:4248
msgid "4248            Tracer& operator=(Tracer&&) = default;"
msgstr""

# CppCoreGuidelines.md:4249
msgid "4249        };"
msgstr""

       
# CppCoreGuidelines.md:4250
msgid "4250    Because we defined the destructor, we must define the copy and move operations. The `= default` is the best and simplest way of doing that."
msgstr""

       
# CppCoreGuidelines.md:4251
msgid "4251    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4252
msgid "4252        class Tracer2 {"
msgstr""

# CppCoreGuidelines.md:4253
msgid "4253            string message;"
msgstr""

# CppCoreGuidelines.md:4254
msgid "4254        public:"
msgstr""

# CppCoreGuidelines.md:4255
msgid "4255            Tracer2(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }"
msgstr""

# CppCoreGuidelines.md:4256
msgid "4256            ~Tracer2() { cerr << \"exiting \" << message << '\\n'; }"
msgstr""

       
# CppCoreGuidelines.md:4257
msgid "4257            Tracer2(const Tracer2& a) : message{a.message} {}"
msgstr""

# CppCoreGuidelines.md:4258
msgid "4258            Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }"
msgstr""

# CppCoreGuidelines.md:4259
msgid "4259            Tracer2(Tracer2&& a) :message{a.message} {}"
msgstr""

# CppCoreGuidelines.md:4260
msgid "4260            Tracer2& operator=(Tracer2&& a) { message = a.message; return *this; }"
msgstr""

# CppCoreGuidelines.md:4261
msgid "4261        };"
msgstr""

       
# CppCoreGuidelines.md:4262
msgid "4262    Writing out the bodies of the copy and move operations is verbose, tedious, and error-prone. A compiler does it better."
msgstr""

       
# CppCoreGuidelines.md:4263
msgid "4263    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4264
msgid "4264    (Moderate) The body of a special operation should not have the same accessibility and semantics as the compiler-generated version, because that would be redundant"
msgstr""

       
# CppCoreGuidelines.md:4265
msgid "4265    ### <a name=\"Rc-delete\"></a>C.81: Use `=delete` when you want to disable default behavior (without wanting an alternative)"
msgstr""

       
# CppCoreGuidelines.md:4266
msgid "4266    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4267
msgid "4267    In a few cases, a default operation is not desirable."
msgstr""

       
# CppCoreGuidelines.md:4268
msgid "4268    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4269
msgid "4269        class Immortal {"
msgstr""

# CppCoreGuidelines.md:4270
msgid "4270        public:"
msgstr""

# CppCoreGuidelines.md:4271
msgid "4271            ~Immortal() = delete;   // do not allow destruction"
msgstr""

# CppCoreGuidelines.md:4272
msgid "4272            // ..."
msgstr""

# CppCoreGuidelines.md:4273
msgid "4273        };"
msgstr""

       
# CppCoreGuidelines.md:4274
msgid "4274        void use()"
msgstr""

# CppCoreGuidelines.md:4275
msgid "4275        {"
msgstr""

# CppCoreGuidelines.md:4276
msgid "4276            Immortal ugh;   // error: ugh cannot be destroyed"
msgstr""

# CppCoreGuidelines.md:4277
msgid "4277            Immortal* p = new Immortal{};"
msgstr""

# CppCoreGuidelines.md:4278
msgid "4278            delete p;       // error: cannot destroy *p"
msgstr""

# CppCoreGuidelines.md:4279
msgid "4279        }"
msgstr""

       
# CppCoreGuidelines.md:4280
msgid "4280    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4281
msgid "4281    A `unique_ptr` can be moved, but not copied. To achieve that its copy operations are deleted. To avoid copying it is necessary to `=delete` its copy operations from lvalues:"
msgstr""

       
# CppCoreGuidelines.md:4282
msgid "4282        template <class T, class D = default_delete<T>> class unique_ptr {"
msgstr""

# CppCoreGuidelines.md:4283
msgid "4283        public:"
msgstr""

# CppCoreGuidelines.md:4284
msgid "4284            // ..."
msgstr""

# CppCoreGuidelines.md:4285
msgid "4285            constexpr unique_ptr() noexcept;"
msgstr""

# CppCoreGuidelines.md:4286
msgid "4286            explicit unique_ptr(pointer p) noexcept;"
msgstr""

# CppCoreGuidelines.md:4287
msgid "4287            // ..."
msgstr""

# CppCoreGuidelines.md:4288
msgid "4288            unique_ptr(unique_ptr&& u) noexcept;   // move constructor"
msgstr""

# CppCoreGuidelines.md:4289
msgid "4289            // ..."
msgstr""

# CppCoreGuidelines.md:4290
msgid "4290            unique_ptr(const unique_ptr&) = delete; // disable copy from lvalue"
msgstr""

# CppCoreGuidelines.md:4291
msgid "4291            // ..."
msgstr""

# CppCoreGuidelines.md:4292
msgid "4292        };"
msgstr""

       
# CppCoreGuidelines.md:4293
msgid "4293        unique_ptr<int> make();   // make \"something\" and return it by moving"
msgstr""

       
# CppCoreGuidelines.md:4294
msgid "4294        void f()"
msgstr""

# CppCoreGuidelines.md:4295
msgid "4295        {"
msgstr""

# CppCoreGuidelines.md:4296
msgid "4296            unique_ptr<int> pi {};"
msgstr""

# CppCoreGuidelines.md:4297
msgid "4297            auto pi2 {pi};      // error: no move constructor from lvalue"
msgstr""

# CppCoreGuidelines.md:4298
msgid "4298            auto pi3 {make()};  // OK, move: the result of make() is an rvalue"
msgstr""

# CppCoreGuidelines.md:4299
msgid "4299        }"
msgstr""

       
# CppCoreGuidelines.md:4300
msgid "4300    Note that deleted functions should be public."
msgstr""

       
# CppCoreGuidelines.md:4301
msgid "4301    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4302
msgid "4302    The elimination of a default operation is (should be) based on the desired semantics of the class. Consider such classes suspect, but maintain a \"positive list\" of classes where a human has asserted that the semantics is correct."
msgstr""

       
# CppCoreGuidelines.md:4303
msgid "4303    ### <a name=\"Rc-ctor-virtual\"></a>C.82: Don't call virtual functions in constructors and destructors"
msgstr""

       
# CppCoreGuidelines.md:4304
msgid "4304    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4305
msgid "4305    The function called will be that of the object constructed so far, rather than a possibly overriding function in a derived class."
msgstr""

# CppCoreGuidelines.md:4306
msgid "4306    This can be most confusing."
msgstr""

# CppCoreGuidelines.md:4307
msgid "4307    Worse, a direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:4308
msgid "4308    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4309
msgid "4309        class Base {"
msgstr""

# CppCoreGuidelines.md:4310
msgid "4310        public:"
msgstr""

# CppCoreGuidelines.md:4311
msgid "4311            virtual void f() = 0;   // not implemented"
msgstr""

# CppCoreGuidelines.md:4312
msgid "4312            virtual void g();       // implemented with Base version"
msgstr""

# CppCoreGuidelines.md:4313
msgid "4313            virtual void h();       // implemented with Base version"
msgstr""

# CppCoreGuidelines.md:4314
msgid "4314        };"
msgstr""

       
# CppCoreGuidelines.md:4315
msgid "4315        class Derived : public Base {"
msgstr""

# CppCoreGuidelines.md:4316
msgid "4316        public:"
msgstr""

# CppCoreGuidelines.md:4317
msgid "4317            void g() override;   // provide Derived implementation"
msgstr""

# CppCoreGuidelines.md:4318
msgid "4318            void h() final;      // provide Derived implementation"
msgstr""

       
# CppCoreGuidelines.md:4319
msgid "4319            Derived()"
msgstr""

# CppCoreGuidelines.md:4320
msgid "4320            {"
msgstr""

# CppCoreGuidelines.md:4321
msgid "4321                // BAD: attempt to call an unimplemented virtual function"
msgstr""

# CppCoreGuidelines.md:4322
msgid "4322                f();"
msgstr""

       
# CppCoreGuidelines.md:4323
msgid "4323                // BAD: will call Derived::g, not dispatch further virtually"
msgstr""

# CppCoreGuidelines.md:4324
msgid "4324                g();"
msgstr""

       
# CppCoreGuidelines.md:4325
msgid "4325                // GOOD: explicitly state intent to call only the visible version"
msgstr""

# CppCoreGuidelines.md:4326
msgid "4326                Derived::g();"
msgstr""

       
# CppCoreGuidelines.md:4327
msgid "4327                // ok, no qualification needed, h is final"
msgstr""

# CppCoreGuidelines.md:4328
msgid "4328                h();"
msgstr""

# CppCoreGuidelines.md:4329
msgid "4329            }"
msgstr""

# CppCoreGuidelines.md:4330
msgid "4330        };"
msgstr""

       
# CppCoreGuidelines.md:4331
msgid "4331    Note that calling a specific explicitly qualified function is not a virtual call even if the function is `virtual`."
msgstr""

       
# CppCoreGuidelines.md:4332
msgid "4332    **See also** [factory functions](#Rc-factory) for how to achieve the effect of a call to a derived class function without risking undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:4333
msgid "4333    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4334
msgid "4334    There is nothing inherently wrong with calling virtual functions from constructors and destructors."
msgstr""

# CppCoreGuidelines.md:4335
msgid "4335    The semantics of such calls is type safe."
msgstr""

# CppCoreGuidelines.md:4336
msgid "4336    However, experience shows that such calls are rarely needed, easily confuse maintainers, and become a source of errors when used by novices."
msgstr""

       
# CppCoreGuidelines.md:4337
msgid "4337    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4338
msgid "4338    * Flag calls of virtual functions from constructors and destructors."
msgstr""

       
# CppCoreGuidelines.md:4339
msgid "4339    ### <a name=\"Rc-swap\"></a>C.83: For value-like types, consider providing a `noexcept` swap function"
msgstr""

       
# CppCoreGuidelines.md:4340
msgid "4340    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4341
msgid "4341    A `swap` can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. Consider using swap to implement copy assignment in terms of copy construction. See also [destructors, deallocation, and swap must never fail](#Re-never-fail)."
msgstr""

       
# CppCoreGuidelines.md:4342
msgid "4342    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:4343
msgid "4343        class Foo {"
msgstr""

# CppCoreGuidelines.md:4344
msgid "4344            // ..."
msgstr""

# CppCoreGuidelines.md:4345
msgid "4345        public:"
msgstr""

# CppCoreGuidelines.md:4346
msgid "4346            void swap(Foo& rhs) noexcept"
msgstr""

# CppCoreGuidelines.md:4347
msgid "4347            {"
msgstr""

# CppCoreGuidelines.md:4348
msgid "4348                m1.swap(rhs.m1);"
msgstr""

# CppCoreGuidelines.md:4349
msgid "4349                std::swap(m2, rhs.m2);"
msgstr""

# CppCoreGuidelines.md:4350
msgid "4350            }"
msgstr""

# CppCoreGuidelines.md:4351
msgid "4351        private:"
msgstr""

# CppCoreGuidelines.md:4352
msgid "4352            Bar m1;"
msgstr""

# CppCoreGuidelines.md:4353
msgid "4353            int m2;"
msgstr""

# CppCoreGuidelines.md:4354
msgid "4354        };"
msgstr""

       
# CppCoreGuidelines.md:4355
msgid "4355    Providing a nonmember `swap` function in the same namespace as your type for callers' convenience."
msgstr""

       
# CppCoreGuidelines.md:4356
msgid "4356        void swap(Foo& a, Foo& b)"
msgstr""

# CppCoreGuidelines.md:4357
msgid "4357        {"
msgstr""

# CppCoreGuidelines.md:4358
msgid "4358            a.swap(b);"
msgstr""

# CppCoreGuidelines.md:4359
msgid "4359        }"
msgstr""

       
# CppCoreGuidelines.md:4360
msgid "4360    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4361
msgid "4361    * (Simple) A class without virtual functions should have a `swap` member function declared."
msgstr""

# CppCoreGuidelines.md:4362
msgid "4362    * (Simple) When a class has a `swap` member function, it should be declared `noexcept`."
msgstr""

       
# CppCoreGuidelines.md:4363
msgid "4363    ### <a name=\"Rc-swap-fail\"></a>C.84: A `swap` function may not fail"
msgstr""

       
# CppCoreGuidelines.md:4364
msgid "4364    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4365
msgid "4365     `swap` is widely used in ways that are assumed never to fail and programs cannot easily be written to work correctly in the presence of a failing `swap`. The standard-library containers and algorithms will not work correctly if a swap of an element type fails."
msgstr""

       
# CppCoreGuidelines.md:4366
msgid "4366    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4367
msgid "4367        void swap(My_vector& x, My_vector& y)"
msgstr""

# CppCoreGuidelines.md:4368
msgid "4368        {"
msgstr""

# CppCoreGuidelines.md:4369
msgid "4369            auto tmp = x;   // copy elements"
msgstr""

# CppCoreGuidelines.md:4370
msgid "4370            x = y;"
msgstr""

# CppCoreGuidelines.md:4371
msgid "4371            y = tmp;"
msgstr""

# CppCoreGuidelines.md:4372
msgid "4372        }"
msgstr""

       
# CppCoreGuidelines.md:4373
msgid "4373    This is not just slow, but if a memory allocation occurs for the elements in `tmp`, this `swap` may throw and would make STL algorithms fail if used with them."
msgstr""

       
# CppCoreGuidelines.md:4374
msgid "4374    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4375
msgid "4375    (Simple) When a class has a `swap` member function, it should be declared `noexcept`."
msgstr""

       
# CppCoreGuidelines.md:4376
msgid "4376    ### <a name=\"Rc-swap-noexcept\"></a>C.85: Make `swap` `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:4377
msgid "4377    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4378
msgid "4378     [A `swap` may not fail](#Rc-swap-fail)."
msgstr""

# CppCoreGuidelines.md:4379
msgid "4379    If a `swap` tries to exit with an exception, it's a bad design error and the program had better terminate."
msgstr""

       
# CppCoreGuidelines.md:4380
msgid "4380    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4381
msgid "4381    (Simple) When a class has a `swap` member function, it should be declared `noexcept`."
msgstr""

       
# CppCoreGuidelines.md:4382
msgid "4382    ### <a name=\"Rc-eq\"></a>C.86: Make `==` symmetric with respect to operand types and `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:4383
msgid "4383    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4384
msgid "4384    Asymmetric treatment of operands is surprising and a source of errors where conversions are possible."
msgstr""

# CppCoreGuidelines.md:4385
msgid "4385    `==` is a fundamental operations and programmers should be able to use it without fear of failure."
msgstr""

       
# CppCoreGuidelines.md:4386
msgid "4386    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4387
msgid "4387        struct X {"
msgstr""

# CppCoreGuidelines.md:4388
msgid "4388            string name;"
msgstr""

# CppCoreGuidelines.md:4389
msgid "4389            int number;"
msgstr""

# CppCoreGuidelines.md:4390
msgid "4390        };"
msgstr""

       
# CppCoreGuidelines.md:4391
msgid "4391        bool operator==(const X& a, const X& b) noexcept {"
msgstr""

# CppCoreGuidelines.md:4392
msgid "4392            return a.name == b.name && a.number == b.number;"
msgstr""

# CppCoreGuidelines.md:4393
msgid "4393        }"
msgstr""

       
# CppCoreGuidelines.md:4394
msgid "4394    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4395
msgid "4395        class B {"
msgstr""

# CppCoreGuidelines.md:4396
msgid "4396            string name;"
msgstr""

# CppCoreGuidelines.md:4397
msgid "4397            int number;"
msgstr""

# CppCoreGuidelines.md:4398
msgid "4398            bool operator==(const B& a) const {"
msgstr""

# CppCoreGuidelines.md:4399
msgid "4399                return name == a.name && number == a.number;"
msgstr""

# CppCoreGuidelines.md:4400
msgid "4400            }"
msgstr""

# CppCoreGuidelines.md:4401
msgid "4401            // ..."
msgstr""

# CppCoreGuidelines.md:4402
msgid "4402        };"
msgstr""

       
# CppCoreGuidelines.md:4403
msgid "4403    `B`'s comparison accepts conversions for its second operand, but not its first."
msgstr""

       
# CppCoreGuidelines.md:4404
msgid "4404    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4405
msgid "4405    If a class has a failure state, like `double`'s `NaN`, there is a temptation to make a comparison against the failure state throw."
msgstr""

# CppCoreGuidelines.md:4406
msgid "4406    The alternative is to make two failure states compare equal and any valid state compare false against the failure state."
msgstr""

       
# CppCoreGuidelines.md:4407
msgid "4407    #### Note"
msgstr""

       
# CppCoreGuidelines.md:4408
msgid "4408    This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr""

       
# CppCoreGuidelines.md:4409
msgid "4409    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4410
msgid "4410    * Flag an `operator==()` for which the argument types differ; same for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr""

# CppCoreGuidelines.md:4411
msgid "4411    * Flag member `operator==()`s; same for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr""

       
# CppCoreGuidelines.md:4412
msgid "4412    ### <a name=\"Rc-eq-base\"></a>C.87: Beware of `==` on base classes"
msgstr""

       
# CppCoreGuidelines.md:4413
msgid "4413    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4414
msgid "4414    It is really hard to write a foolproof and useful `==` for a hierarchy."
msgstr""

       
# CppCoreGuidelines.md:4415
msgid "4415    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4416
msgid "4416        class B {"
msgstr""

# CppCoreGuidelines.md:4417
msgid "4417            string name;"
msgstr""

# CppCoreGuidelines.md:4418
msgid "4418            int number;"
msgstr""

# CppCoreGuidelines.md:4419
msgid "4419            virtual bool operator==(const B& a) const"
msgstr""

# CppCoreGuidelines.md:4420
msgid "4420            {"
msgstr""

# CppCoreGuidelines.md:4421
msgid "4421                 return name == a.name && number == a.number;"
msgstr""

# CppCoreGuidelines.md:4422
msgid "4422            }"
msgstr""

# CppCoreGuidelines.md:4423
msgid "4423            // ..."
msgstr""

# CppCoreGuidelines.md:4424
msgid "4424        };"
msgstr""

       
# CppCoreGuidelines.md:4425
msgid "4425    `B`'s comparison accepts conversions for its second operand, but not its first."
msgstr""

       
# CppCoreGuidelines.md:4426
msgid "4426        class D :B {"
msgstr""

# CppCoreGuidelines.md:4427
msgid "4427            char character;"
msgstr""

# CppCoreGuidelines.md:4428
msgid "4428            virtual bool operator==(const D& a) const"
msgstr""

# CppCoreGuidelines.md:4429
msgid "4429            {"
msgstr""

# CppCoreGuidelines.md:4430
msgid "4430                return name == a.name && number == a.number && character == a.character;"
msgstr""

# CppCoreGuidelines.md:4431
msgid "4431            }"
msgstr""

# CppCoreGuidelines.md:4432
msgid "4432            // ..."
msgstr""

# CppCoreGuidelines.md:4433
msgid "4433        };"
msgstr""

       
# CppCoreGuidelines.md:4434
msgid "4434        B b = ..."
msgstr""

# CppCoreGuidelines.md:4435
msgid "4435        D d = ..."
msgstr""

# CppCoreGuidelines.md:4436
msgid "4436        b == d;    // compares name and number, ignores d's character"
msgstr""

# CppCoreGuidelines.md:4437
msgid "4437        d == b;    // error: no == defined"
msgstr""

# CppCoreGuidelines.md:4438
msgid "4438        D d2;"
msgstr""

# CppCoreGuidelines.md:4439
msgid "4439        d == d2;   // compares name, number, and character"
msgstr""

# CppCoreGuidelines.md:4440
msgid "4440        B& b2 = d2;"
msgstr""

# CppCoreGuidelines.md:4441
msgid "4441        b2 == d;   // compares name and number, ignores d2's and d's character"
msgstr""

       
# CppCoreGuidelines.md:4442
msgid "4442    Of course there are ways of making `==` work in a hierarchy, but the naive approaches do not scale"
msgstr""

       
# CppCoreGuidelines.md:4443
msgid "4443    #### Note"
msgstr""

       
# CppCoreGuidelines.md:4444
msgid "4444    This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr""

       
# CppCoreGuidelines.md:4445
msgid "4445    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4446
msgid "4446    * Flag a virtual `operator==()`; same for other comparison operators: `!=`, `<`, `<=`, `>`, and `>=`."
msgstr""

       
# CppCoreGuidelines.md:4447
msgid "4447    ### <a name=\"Rc-hash\"></a>C.89: Make a `hash` `noexcept`"
msgstr""

       
# CppCoreGuidelines.md:4448
msgid "4448    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4449
msgid "4449    Users of hashed containers use hash indirectly and don't expect simple access to throw."
msgstr""

# CppCoreGuidelines.md:4450
msgid "4450    It's a standard-library requirement."
msgstr""

       
# CppCoreGuidelines.md:4451
msgid "4451    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4452
msgid "4452        template<>"
msgstr""

# CppCoreGuidelines.md:4453
msgid "4453        struct hash<My_type> {  // thoroughly bad hash specialization"
msgstr""

# CppCoreGuidelines.md:4454
msgid "4454            using result_type = size_t;"
msgstr""

# CppCoreGuidelines.md:4455
msgid "4455            using argument_type = My_type;"
msgstr""

       
# CppCoreGuidelines.md:4456
msgid "4456            size_t operator() (const My_type & x) const"
msgstr""

# CppCoreGuidelines.md:4457
msgid "4457            {"
msgstr""

# CppCoreGuidelines.md:4458
msgid "4458                size_t xs = x.s.size();"
msgstr""

# CppCoreGuidelines.md:4459
msgid "4459                if (xs < 4) throw Bad_My_type{};    // \"Nobody expects the Spanish inquisition!\""
msgstr""

# CppCoreGuidelines.md:4460
msgid "4460                return hash<size_t>()(x.s.size()) ^ trim(x.s);"
msgstr""

# CppCoreGuidelines.md:4461
msgid "4461            }"
msgstr""

# CppCoreGuidelines.md:4462
msgid "4462        };"
msgstr""

       
# CppCoreGuidelines.md:4463
msgid "4463        int main()"
msgstr""

# CppCoreGuidelines.md:4464
msgid "4464        {"
msgstr""

# CppCoreGuidelines.md:4465
msgid "4465            unordered_map<My_type, int> m;"
msgstr""

# CppCoreGuidelines.md:4466
msgid "4466            My_type mt{ \"asdfg\" };"
msgstr""

# CppCoreGuidelines.md:4467
msgid "4467            m[mt] = 7;"
msgstr""

# CppCoreGuidelines.md:4468
msgid "4468            cout << m[My_type{ \"asdfg\" }] << '\\n';"
msgstr""

# CppCoreGuidelines.md:4469
msgid "4469        }"
msgstr""

       
# CppCoreGuidelines.md:4470
msgid "4470    If you have to define a `hash` specialization, try simply to let it combine standard-library `hash` specializations with `^` (xor)."
msgstr""

# CppCoreGuidelines.md:4471
msgid "4471    That tends to work better than \"cleverness\" for non-specialists."
msgstr""

       
# CppCoreGuidelines.md:4472
msgid "4472    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4473
msgid "4473    * Flag throwing `hash`es."
msgstr""

       
# CppCoreGuidelines.md:4474
msgid "4474    ## <a name=\"SS-containers\"></a>C.con: Containers and other resource handles"
msgstr""

       
# CppCoreGuidelines.md:4475
msgid "4475    A container is an object holding a sequence of objects of some type; `std::vector` is the archetypical container."
msgstr""

# CppCoreGuidelines.md:4476
msgid "4476    A resource handle is a class that owns a resource; `std::vector` is the typical resource handle; its resource is its sequence of elements."
msgstr""

       
# CppCoreGuidelines.md:4477
msgid "4477    Summary of container rules:"
msgstr""

       
# CppCoreGuidelines.md:4478
msgid "4478    * [C.100: Follow the STL when defining a container](#Rcon-stl)"
msgstr""

# CppCoreGuidelines.md:4479
msgid "4479    * [C.101: Give a container value semantics](#Rcon-val)"
msgstr""

# CppCoreGuidelines.md:4480
msgid "4480    * [C.102: Give a container move operations](#Rcon-move)"
msgstr""

# CppCoreGuidelines.md:4481
msgid "4481    * [C.103: Give a container an initializer list constructor](#Rcon-init)"
msgstr""

# CppCoreGuidelines.md:4482
msgid "4482    * [C.104: Give a container a default constructor that sets it to empty](#Rcon-empty)"
msgstr""

# CppCoreGuidelines.md:4483
msgid "4483    * [C.105: Give a constructor and `Extent` constructor](#Rcon-val)"
msgstr""

# CppCoreGuidelines.md:4484
msgid "4484    * ???"
msgstr""

# CppCoreGuidelines.md:4485
msgid "4485    * [C.109: If a resource handle has pointer semantics, provide `*` and `->`](#rcon-ptr)"
msgstr""

       
# CppCoreGuidelines.md:4486
msgid "4486    **See also**: [Resources](#S-resource)"
msgstr""

       
# CppCoreGuidelines.md:4487
msgid "4487    ## <a name=\"SS-lambdas\"></a>C.lambdas: Function objects and lambdas"
msgstr""

       
# CppCoreGuidelines.md:4488
msgid "4488    A function object is an object supplying an overloaded `()` so that you can call it."
msgstr""

# CppCoreGuidelines.md:4489
msgid "4489    A lambda expression (colloquially often shortened to \"a lambda\") is a notation for generating a function object."
msgstr""

# CppCoreGuidelines.md:4490
msgid "4490    Function objects should be cheap to copy (and therefore [passed by value](#Rf-in))."
msgstr""

       
# CppCoreGuidelines.md:4491
msgid "4491    Summary:"
msgstr""

       
# CppCoreGuidelines.md:4492
msgid "4492    * [F.50: Use a lambda when a function won't do (to capture local variables, or to write a local function)](#Rf-capture-vs-overload)"
msgstr""

# CppCoreGuidelines.md:4493
msgid "4493    * [F.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms](#Rf-reference-capture)"
msgstr""

# CppCoreGuidelines.md:4494
msgid "4494    * [F.53: Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread](#Rf-value-capture)"
msgstr""

# CppCoreGuidelines.md:4495
msgid "4495    * [ES.28: Use lambdas for complex initialization, especially of `const` variables](#Res-lambda-init)"
msgstr""

       
# CppCoreGuidelines.md:4496
msgid "4496    ## <a name=\"SS-hier\"></a>C.hier: Class hierarchies (OOP)"
msgstr""

       
# CppCoreGuidelines.md:4497
msgid "4497    A class hierarchy is constructed to represent a set of hierarchically organized concepts (only)."
msgstr""

# CppCoreGuidelines.md:4498
msgid "4498    Typically base classes act as interfaces."
msgstr""

# CppCoreGuidelines.md:4499
msgid "4499    There are two major uses for hierarchies, often named implementation inheritance and interface inheritance."
msgstr""

       
# CppCoreGuidelines.md:4500
msgid "4500    Class hierarchy rule summary:"
msgstr""

       
# CppCoreGuidelines.md:4501
msgid "4501    * [C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)](#Rh-domain)"
msgstr""

# CppCoreGuidelines.md:4502
msgid "4502    * [C.121: If a base class is used as an interface, make it a pure abstract class](#Rh-abstract)"
msgstr""

# CppCoreGuidelines.md:4503
msgid "4503    * [C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed](#Rh-separation)"
msgstr""

       
# CppCoreGuidelines.md:4504
msgid "4504    Designing rules for classes in a hierarchy summary:"
msgstr""

       
# CppCoreGuidelines.md:4505
msgid "4505    * [C.126: An abstract class typically doesn't need a constructor](#Rh-abstract-ctor)"
msgstr""

# CppCoreGuidelines.md:4506
msgid "4506    * [C.127: A class with a virtual function should have a virtual or protected destructor](#Rh-dtor)"
msgstr""

# CppCoreGuidelines.md:4507
msgid "4507    * [C.128: Virtual functions should specify exactly one of `virtual`, `override`, or `final`](#Rh-override)"
msgstr""

# CppCoreGuidelines.md:4508
msgid "4508    * [C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance](#Rh-kind)"
msgstr""

# CppCoreGuidelines.md:4509
msgid "4509    * [C.130: For making deep copies of polymorphic classes prefer a virtual `clone` function instead of copy construction/assignment](#Rh-copy)"
msgstr""

# CppCoreGuidelines.md:4510
msgid "4510    * [C.131: Avoid trivial getters and setters](#Rh-get)"
msgstr""

# CppCoreGuidelines.md:4511
msgid "4511    * [C.132: Don't make a function `virtual` without reason](#Rh-virtual)"
msgstr""

# CppCoreGuidelines.md:4512
msgid "4512    * [C.133: Avoid `protected` data](#Rh-protected)"
msgstr""

# CppCoreGuidelines.md:4513
msgid "4513    * [C.134: Ensure all non-`const` data members have the same access level](#Rh-public)"
msgstr""

# CppCoreGuidelines.md:4514
msgid "4514    * [C.135: Use multiple inheritance to represent multiple distinct interfaces](#Rh-mi-interface)"
msgstr""

# CppCoreGuidelines.md:4515
msgid "4515    * [C.136: Use multiple inheritance to represent the union of implementation attributes](#Rh-mi-implementation)"
msgstr""

# CppCoreGuidelines.md:4516
msgid "4516    * [C.137: Use `virtual` bases to avoid overly general base classes](#Rh-vbase)"
msgstr""

# CppCoreGuidelines.md:4517
msgid "4517    * [C.138: Create an overload set for a derived class and its bases with `using`](#Rh-using)"
msgstr""

# CppCoreGuidelines.md:4518
msgid "4518    * [C.139: Use `final` sparingly](#Rh-final)"
msgstr""

# CppCoreGuidelines.md:4519
msgid "4519    * [C.140: Do not provide different default arguments for a virtual function and an overrider](#Rh-virtual-default-arg)"
msgstr""

       
# CppCoreGuidelines.md:4520
msgid "4520    Accessing objects in a hierarchy rule summary:"
msgstr""

       
# CppCoreGuidelines.md:4521
msgid "4521    * [C.145: Access polymorphic objects through pointers and references](#Rh-poly)"
msgstr""

# CppCoreGuidelines.md:4522
msgid "4522    * [C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable](#Rh-dynamic_cast)"
msgstr""

# CppCoreGuidelines.md:4523
msgid "4523    * [C.147: Use `dynamic_cast` to a reference type when failure to find the required class is considered an error](#Rh-ref-cast)"
msgstr""

# CppCoreGuidelines.md:4524
msgid "4524    * [C.148: Use `dynamic_cast` to a pointer type when failure to find the required class is considered a valid alternative](#Rh-ptr-cast)"
msgstr""

# CppCoreGuidelines.md:4525
msgid "4525    * [C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects created using `new`](#Rh-smart)"
msgstr""

# CppCoreGuidelines.md:4526
msgid "4526    * [C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s](#Rh-make_unique)"
msgstr""

# CppCoreGuidelines.md:4527
msgid "4527    * [C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s](#Rh-make_shared)"
msgstr""

# CppCoreGuidelines.md:4528
msgid "4528    * [C.152: Never assign a pointer to an array of derived class objects to a pointer to its base](#Rh-array)"
msgstr""

# CppCoreGuidelines.md:4529
msgid "4529    * [C.153: Prefer virtual function to casting](#Rh-use-virtual)"
msgstr""

       
# CppCoreGuidelines.md:4530
msgid "4530    ### <a name=\"Rh-domain\"></a>C.120: Use class hierarchies to represent concepts with inherent hierarchical structure (only)"
msgstr""

       
# CppCoreGuidelines.md:4531
msgid "4531    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4532
msgid "4532    Direct representation of ideas in code eases comprehension and maintenance. Make sure the idea represented in the base class exactly matches all derived types and there is not a better way to express it than using the tight coupling of inheritance."
msgstr""

       
# CppCoreGuidelines.md:4533
msgid "4533    Do *not* use inheritance when simply having a data member will do. Usually this means that the derived type needs to override a base virtual function or needs access to a protected member."
msgstr""

       
# CppCoreGuidelines.md:4534
msgid "4534    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4535
msgid "4535        class DrawableUIElement {"
msgstr""

# CppCoreGuidelines.md:4536
msgid "4536        public:"
msgstr""

# CppCoreGuidelines.md:4537
msgid "4537            virtual void render() const = 0;"
msgstr""

# CppCoreGuidelines.md:4538
msgid "4538            // ..."
msgstr""

# CppCoreGuidelines.md:4539
msgid "4539        };"
msgstr""

       
# CppCoreGuidelines.md:4540
msgid "4540        class AbstractButton : public DrawableUIElement {"
msgstr""

# CppCoreGuidelines.md:4541
msgid "4541        public:"
msgstr""

# CppCoreGuidelines.md:4542
msgid "4542            virtual void onClick() = 0;"
msgstr""

# CppCoreGuidelines.md:4543
msgid "4543            // ..."
msgstr""

# CppCoreGuidelines.md:4544
msgid "4544        };"
msgstr""

       
# CppCoreGuidelines.md:4545
msgid "4545        class PushButton : public AbstractButton {"
msgstr""

# CppCoreGuidelines.md:4546
msgid "4546            virtual void render() const override;"
msgstr""

# CppCoreGuidelines.md:4547
msgid "4547            virtual void onClick() override;"
msgstr""

# CppCoreGuidelines.md:4548
msgid "4548            // ..."
msgstr""

# CppCoreGuidelines.md:4549
msgid "4549        };"
msgstr""

       
# CppCoreGuidelines.md:4550
msgid "4550        class Checkbox : public AbstractButton {"
msgstr""

# CppCoreGuidelines.md:4551
msgid "4551        // ..."
msgstr""

# CppCoreGuidelines.md:4552
msgid "4552        };"
msgstr""

       
# CppCoreGuidelines.md:4553
msgid "4553    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4554
msgid "4554    Do *not* represent non-hierarchical domain concepts as class hierarchies."
msgstr""

       
# CppCoreGuidelines.md:4555
msgid "4555        template<typename T>"
msgstr""

# CppCoreGuidelines.md:4556
msgid "4556        class Container {"
msgstr""

# CppCoreGuidelines.md:4557
msgid "4557        public:"
msgstr""

# CppCoreGuidelines.md:4558
msgid "4558            // list operations:"
msgstr""

# CppCoreGuidelines.md:4559
msgid "4559            virtual T& get() = 0;"
msgstr""

# CppCoreGuidelines.md:4560
msgid "4560            virtual void put(T&) = 0;"
msgstr""

# CppCoreGuidelines.md:4561
msgid "4561            virtual void insert(Position) = 0;"
msgstr""

# CppCoreGuidelines.md:4562
msgid "4562            // ..."
msgstr""

# CppCoreGuidelines.md:4563
msgid "4563            // vector operations:"
msgstr""

# CppCoreGuidelines.md:4564
msgid "4564            virtual T& operator[](int) = 0;"
msgstr""

# CppCoreGuidelines.md:4565
msgid "4565            virtual void sort() = 0;"
msgstr""

# CppCoreGuidelines.md:4566
msgid "4566            // ..."
msgstr""

# CppCoreGuidelines.md:4567
msgid "4567            // tree operations:"
msgstr""

# CppCoreGuidelines.md:4568
msgid "4568            virtual void balance() = 0;"
msgstr""

# CppCoreGuidelines.md:4569
msgid "4569            // ..."
msgstr""

# CppCoreGuidelines.md:4570
msgid "4570        };"
msgstr""

       
# CppCoreGuidelines.md:4571
msgid "4571    Here most overriding classes cannot implement most of the functions required in the interface well."
msgstr""

# CppCoreGuidelines.md:4572
msgid "4572    Thus the base class becomes an implementation burden."
msgstr""

# CppCoreGuidelines.md:4573
msgid "4573    Furthermore, the user of `Container` cannot rely on the member functions actually performing a meaningful operations reasonably efficiently;"
msgstr""

# CppCoreGuidelines.md:4574
msgid "4574    it may throw an exception instead."
msgstr""

# CppCoreGuidelines.md:4575
msgid "4575    Thus users have to resort to run-time checking and/or"
msgstr""

# CppCoreGuidelines.md:4576
msgid "4576    not using this (over)general interface in favor of a particular interface found by a run-time type inquiry (e.g., a `dynamic_cast`)."
msgstr""

       
# CppCoreGuidelines.md:4577
msgid "4577    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4578
msgid "4578    * Look for classes with lots of members that do nothing but throw."
msgstr""

# CppCoreGuidelines.md:4579
msgid "4579    * Flag every use of a nonpublic base class `B` where the derived class `D` does not override a virtual function or access a protected member in `B`, and `B` is not one of the following: empty, a template parameter or parameter pack of `D`, a class template specialized with `D`."
msgstr""

       
# CppCoreGuidelines.md:4580
msgid "4580    ### <a name=\"Rh-abstract\"></a>C.121: If a base class is used as an interface, make it a pure abstract class"
msgstr""

       
# CppCoreGuidelines.md:4581
msgid "4581    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4582
msgid "4582    A class is more stable (less brittle) if it does not contain data."
msgstr""

# CppCoreGuidelines.md:4583
msgid "4583    Interfaces should normally be composed entirely of public pure virtual functions and a default/empty virtual destructor."
msgstr""

       
# CppCoreGuidelines.md:4584
msgid "4584    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4585
msgid "4585        class My_interface {"
msgstr""

# CppCoreGuidelines.md:4586
msgid "4586        public:"
msgstr""

# CppCoreGuidelines.md:4587
msgid "4587            // ...only pure virtual functions here ..."
msgstr""

# CppCoreGuidelines.md:4588
msgid "4588            virtual ~My_interface() {}   // or =default"
msgstr""

# CppCoreGuidelines.md:4589
msgid "4589        };"
msgstr""

       
# CppCoreGuidelines.md:4590
msgid "4590    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4591
msgid "4591        class Goof {"
msgstr""

# CppCoreGuidelines.md:4592
msgid "4592        public:"
msgstr""

# CppCoreGuidelines.md:4593
msgid "4593            // ...only pure virtual functions here ..."
msgstr""

# CppCoreGuidelines.md:4594
msgid "4594            // no virtual destructor"
msgstr""

# CppCoreGuidelines.md:4595
msgid "4595        };"
msgstr""

       
# CppCoreGuidelines.md:4596
msgid "4596        class Derived : public Goof {"
msgstr""

# CppCoreGuidelines.md:4597
msgid "4597            string s;"
msgstr""

# CppCoreGuidelines.md:4598
msgid "4598            // ..."
msgstr""

# CppCoreGuidelines.md:4599
msgid "4599        };"
msgstr""

       
# CppCoreGuidelines.md:4600
msgid "4600        void use()"
msgstr""

# CppCoreGuidelines.md:4601
msgid "4601        {"
msgstr""

# CppCoreGuidelines.md:4602
msgid "4602            unique_ptr<Goof> p {new Derived{\"here we go\"}};"
msgstr""

# CppCoreGuidelines.md:4603
msgid "4603            f(p.get()); // use Derived through the Goof interface"
msgstr""

# CppCoreGuidelines.md:4604
msgid "4604            g(p.get()); // use Derived through the Goof interface"
msgstr""

# CppCoreGuidelines.md:4605
msgid "4605        } // leak"
msgstr""

       
# CppCoreGuidelines.md:4606
msgid "4606    The `Derived` is `delete`d through its `Goof` interface, so its `string` is leaked."
msgstr""

# CppCoreGuidelines.md:4607
msgid "4607    Give `Goof` a virtual destructor and all is well."
msgstr""

       
       
# CppCoreGuidelines.md:4608
msgid "4608    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4609
msgid "4609    * Warn on any class that contains data members and also has an overridable (non-`final`) virtual function."
msgstr""

       
# CppCoreGuidelines.md:4610
msgid "4610    ### <a name=\"Rh-separation\"></a>C.122: Use abstract classes as interfaces when complete separation of interface and implementation is needed"
msgstr""

       
# CppCoreGuidelines.md:4611
msgid "4611    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4612
msgid "4612    Such as on an ABI (link) boundary."
msgstr""

       
# CppCoreGuidelines.md:4613
msgid "4613    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4614
msgid "4614        struct Device {"
msgstr""

# CppCoreGuidelines.md:4615
msgid "4615            virtual ~Device() = default;"
msgstr""

# CppCoreGuidelines.md:4616
msgid "4616            virtual void write(span<const char> outbuf) = 0;"
msgstr""

# CppCoreGuidelines.md:4617
msgid "4617            virtual void read(span<char> inbuf) = 0;"
msgstr""

# CppCoreGuidelines.md:4618
msgid "4618        };"
msgstr""

       
# CppCoreGuidelines.md:4619
msgid "4619        class D1 : public Device {"
msgstr""

# CppCoreGuidelines.md:4620
msgid "4620            // ... data ..."
msgstr""

       
# CppCoreGuidelines.md:4621
msgid "4621            void write(span<const char> outbuf) override;"
msgstr""

# CppCoreGuidelines.md:4622
msgid "4622            void read(span<char> inbuf) override;"
msgstr""

# CppCoreGuidelines.md:4623
msgid "4623        };"
msgstr""

       
# CppCoreGuidelines.md:4624
msgid "4624        class D2 : public Device {"
msgstr""

# CppCoreGuidelines.md:4625
msgid "4625            // ... different data ..."
msgstr""

       
# CppCoreGuidelines.md:4626
msgid "4626            void write(span<const char> outbuf) override;"
msgstr""

# CppCoreGuidelines.md:4627
msgid "4627            void read(span<char> inbuf) override;"
msgstr""

# CppCoreGuidelines.md:4628
msgid "4628        };"
msgstr""

       
# CppCoreGuidelines.md:4629
msgid "4629    A user can now use `D1`s and `D2`s interchangeably through the interface provided by `Device`."
msgstr""

# CppCoreGuidelines.md:4630
msgid "4630    Furthermore, we can update `D1` and `D2` in a ways that are not binary compatible with older versions as long as all access goes through `Device`."
msgstr""

       
# CppCoreGuidelines.md:4631
msgid "4631    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4632
msgid "4632        ???"
msgstr""

       
# CppCoreGuidelines.md:4633
msgid "4633    ## C.hierclass: Designing classes in a hierarchy:"
msgstr""

       
# CppCoreGuidelines.md:4634
msgid "4634    ### <a name=\"Rh-abstract-ctor\"></a>C.126: An abstract class typically doesn't need a constructor"
msgstr""

       
# CppCoreGuidelines.md:4635
msgid "4635    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4636
msgid "4636    An abstract class typically does not have any data for a constructor to initialize."
msgstr""

       
# CppCoreGuidelines.md:4637
msgid "4637    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4638
msgid "4638        ???"
msgstr""

       
# CppCoreGuidelines.md:4639
msgid "4639    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:4640
msgid "4640    * A base class constructor that does work, such as registering an object somewhere, may need a constructor."
msgstr""

# CppCoreGuidelines.md:4641
msgid "4641    * In extremely rare cases, you might find it reasonable for an abstract class to have a bit of data shared by all derived classes"
msgstr""

# CppCoreGuidelines.md:4642
msgid "4642      (e.g., use statistics data, debug information, etc.); such classes tend to have constructors. But be warned: Such classes also tend to be prone to requiring virtual inheritance."
msgstr""

       
# CppCoreGuidelines.md:4643
msgid "4643    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4644
msgid "4644    Flag abstract classes with constructors."
msgstr""

       
# CppCoreGuidelines.md:4645
msgid "4645    ### <a name=\"Rh-dtor\"></a>C.127: A class with a virtual function should have a virtual or protected destructor"
msgstr""

       
# CppCoreGuidelines.md:4646
msgid "4646    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4647
msgid "4647    A class with a virtual function is usually (and in general) used via a pointer to base. Usually, the last user has to call delete on a pointer to base, often via a smart pointer to base, so the destructor should be public and virtual. Less commonly, if deletion through a pointer to base is not intended to be supported, the destructor should be protected and nonvirtual; see [C.35](#Rc-dtor-virtual)."
msgstr""

       
# CppCoreGuidelines.md:4648
msgid "4648    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4649
msgid "4649        struct B {"
msgstr""

# CppCoreGuidelines.md:4650
msgid "4650            virtual int f() = 0;"
msgstr""

# CppCoreGuidelines.md:4651
msgid "4651            // ... no user-written destructor, defaults to public nonvirtual ..."
msgstr""

# CppCoreGuidelines.md:4652
msgid "4652        };"
msgstr""

       
# CppCoreGuidelines.md:4653
msgid "4653        // bad: derived from a class without a virtual destructor"
msgstr""

# CppCoreGuidelines.md:4654
msgid "4654        struct D : B {"
msgstr""

# CppCoreGuidelines.md:4655
msgid "4655            string s {\"default\"};"
msgstr""

# CppCoreGuidelines.md:4656
msgid "4656        };"
msgstr""

       
# CppCoreGuidelines.md:4657
msgid "4657        void use()"
msgstr""

# CppCoreGuidelines.md:4658
msgid "4658        {"
msgstr""

# CppCoreGuidelines.md:4659
msgid "4659            unique_ptr<B> p = make_unique<D>();"
msgstr""

# CppCoreGuidelines.md:4660
msgid "4660            // ..."
msgstr""

# CppCoreGuidelines.md:4661
msgid "4661        } // undefined behavior. May call B::~B only and leak the string"
msgstr""

       
# CppCoreGuidelines.md:4662
msgid "4662    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4663
msgid "4663    There are people who don't follow this rule because they plan to use a class only through a `shared_ptr`: `std::shared_ptr<B> p = std::make_shared<D>(args);` Here, the shared pointer will take care of deletion, so no leak will occur from an inappropriate `delete` of the base. People who do this consistently can get a false positive, but the rule is important -- what if one was allocated using `make_unique`? It's not safe unless the author of `B` ensures that it can never be misused, such as by making all constructors private and providing a factory function to enforce the allocation with `make_shared`."
msgstr""

       
# CppCoreGuidelines.md:4664
msgid "4664    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4665
msgid "4665    * A class with any virtual functions should have a destructor that is either public and virtual or else protected and nonvirtual."
msgstr""

# CppCoreGuidelines.md:4666
msgid "4666    * Flag `delete` of a class with a virtual function but no virtual destructor."
msgstr""

       
# CppCoreGuidelines.md:4667
msgid "4667    ### <a name=\"Rh-override\"></a>C.128: Virtual functions should specify exactly one of `virtual`, `override`, or `final`"
msgstr""

       
# CppCoreGuidelines.md:4668
msgid "4668    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4669
msgid "4669    Readability."
msgstr""

# CppCoreGuidelines.md:4670
msgid "4670    Detection of mistakes."
msgstr""

# CppCoreGuidelines.md:4671
msgid "4671    Writing explicit `virtual`, `override`, or `final` is self-documenting and enables the compiler to catch mismatch of types and/or names between base and derived classes. However, writing more than one of these three is both redundant and a potential source of errors."
msgstr""

       
# CppCoreGuidelines.md:4672
msgid "4672    Use `virtual` only when declaring a new virtual function. Use `override` only when declaring an overrider. Use `final` only when declaring a final overrider. If a base class destructor is declared `virtual`, one should avoid declaring derived class destructors  `virtual` or `override`. Some code base and tools might insist on `override` for destructors, but that is not the recommendation of these guidelines."
msgstr""

       
# CppCoreGuidelines.md:4673
msgid "4673    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4674
msgid "4674        struct B {"
msgstr""

# CppCoreGuidelines.md:4675
msgid "4675            void f1(int);"
msgstr""

# CppCoreGuidelines.md:4676
msgid "4676            virtual void f2(int) const;"
msgstr""

# CppCoreGuidelines.md:4677
msgid "4677            virtual void f3(int);"
msgstr""

# CppCoreGuidelines.md:4678
msgid "4678            // ..."
msgstr""

# CppCoreGuidelines.md:4679
msgid "4679        };"
msgstr""

       
# CppCoreGuidelines.md:4680
msgid "4680        struct D : B {"
msgstr""

# CppCoreGuidelines.md:4681
msgid "4681            void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()"
msgstr""

# CppCoreGuidelines.md:4682
msgid "4682            void f2(int) const;  // bad (but conventional and valid): no explicit override"
msgstr""

# CppCoreGuidelines.md:4683
msgid "4683            void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()"
msgstr""

# CppCoreGuidelines.md:4684
msgid "4684            // ..."
msgstr""

# CppCoreGuidelines.md:4685
msgid "4685        };"
msgstr""

       
# CppCoreGuidelines.md:4686
msgid "4686    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:4687
msgid "4687        struct Better : B {"
msgstr""

# CppCoreGuidelines.md:4688
msgid "4688            void f1(int) override;        // error (caught): D::f1() hides B::f1()"
msgstr""

# CppCoreGuidelines.md:4689
msgid "4689            void f2(int) const override;"
msgstr""

# CppCoreGuidelines.md:4690
msgid "4690            void f3(double) override;     // error (caught): D::f3() hides B::f3()"
msgstr""

# CppCoreGuidelines.md:4691
msgid "4691            // ..."
msgstr""

# CppCoreGuidelines.md:4692
msgid "4692        };"
msgstr""

       
# CppCoreGuidelines.md:4693
msgid "4693    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4694
msgid "4694    * Compare names in base and derived classes and flag uses of the same name that does not override."
msgstr""

# CppCoreGuidelines.md:4695
msgid "4695    * Flag overrides with neither `override` nor `final`."
msgstr""

# CppCoreGuidelines.md:4696
msgid "4696    * Flag function declarations that use more than one of `virtual`, `override`, and `final`."
msgstr""

       
# CppCoreGuidelines.md:4697
msgid "4697    ### <a name=\"Rh-kind\"></a>C.129: When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance"
msgstr""

       
# CppCoreGuidelines.md:4698
msgid "4698    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4699
msgid "4699    Implementation details in an interface makes the interface brittle;"
msgstr""

# CppCoreGuidelines.md:4700
msgid "4700    that is, makes its users vulnerable to having to recompile after changes in the implementation."
msgstr""

# CppCoreGuidelines.md:4701
msgid "4701    Data in a base class increases the complexity of implementing the base and can lead to replication of code."
msgstr""

       
# CppCoreGuidelines.md:4702
msgid "4702    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4703
msgid "4703    Definition:"
msgstr""

       
# CppCoreGuidelines.md:4704
msgid "4704    * interface inheritance is the use of inheritance to separate users from implementations,"
msgstr""

# CppCoreGuidelines.md:4705
msgid "4705    in particular to allow derived classes to be added and changed without affecting the users of base classes."
msgstr""

# CppCoreGuidelines.md:4706
msgid "4706    * implementation inheritance is the use of inheritance to simplify implementation of new facilities"
msgstr""

# CppCoreGuidelines.md:4707
msgid "4707    by making useful operations available for implementers of related new operations (sometimes called \"programming by difference\")."
msgstr""

       
# CppCoreGuidelines.md:4708
msgid "4708    A pure interface class is simply a set of pure virtual functions; see [I.25](#Ri-abstract)."
msgstr""

       
# CppCoreGuidelines.md:4709
msgid "4709    In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and interface inheritance were often mixed"
msgstr""

# CppCoreGuidelines.md:4710
msgid "4710    and bad habits die hard."
msgstr""

# CppCoreGuidelines.md:4711
msgid "4711    Even now, mixtures are not uncommon in old code bases and in old-style teaching material."
msgstr""

       
# CppCoreGuidelines.md:4712
msgid "4712    The importance of keeping the two kinds of inheritance increases"
msgstr""

       
# CppCoreGuidelines.md:4713
msgid "4713    * with the size of a hierarchy (e.g., dozens of derived classes),"
msgstr""

# CppCoreGuidelines.md:4714
msgid "4714    * with the length of time the hierarchy is used (e.g., decades), and"
msgstr""

# CppCoreGuidelines.md:4715
msgid "4715    * with the number of distinct organizations in which a hierarchy is used"
msgstr""

# CppCoreGuidelines.md:4716
msgid "4716    (e.g., it can be difficult to distribute an update to a base class)"
msgstr""

       
       
# CppCoreGuidelines.md:4717
msgid "4717    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4718
msgid "4718        class Shape {   // BAD, mixed interface and implementation"
msgstr""

# CppCoreGuidelines.md:4719
msgid "4719        public:"
msgstr""

# CppCoreGuidelines.md:4720
msgid "4720            Shape();"
msgstr""

# CppCoreGuidelines.md:4721
msgid "4721            Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}"
msgstr""

       
# CppCoreGuidelines.md:4722
msgid "4722            Point center() const { return cent; }"
msgstr""

# CppCoreGuidelines.md:4723
msgid "4723            Color color() const { return col; }"
msgstr""

       
# CppCoreGuidelines.md:4724
msgid "4724            virtual void rotate(int) = 0;"
msgstr""

# CppCoreGuidelines.md:4725
msgid "4725            virtual void move(Point p) { cent = p; redraw(); }"
msgstr""

       
# CppCoreGuidelines.md:4726
msgid "4726            virtual void redraw();"
msgstr""

       
# CppCoreGuidelines.md:4727
msgid "4727            // ..."
msgstr""

# CppCoreGuidelines.md:4728
msgid "4728        private:"
msgstr""

# CppCoreGuidelines.md:4729
msgid "4729            Point cent;"
msgstr""

# CppCoreGuidelines.md:4730
msgid "4730            Color col;"
msgstr""

# CppCoreGuidelines.md:4731
msgid "4731        };"
msgstr""

       
# CppCoreGuidelines.md:4732
msgid "4732        class Circle : public Shape {"
msgstr""

# CppCoreGuidelines.md:4733
msgid "4733        public:"
msgstr""

# CppCoreGuidelines.md:4734
msgid "4734            Circle(Point c, int r) :Shape{c}, rad{r} { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:4735
msgid "4735            // ..."
msgstr""

# CppCoreGuidelines.md:4736
msgid "4736        private:"
msgstr""

# CppCoreGuidelines.md:4737
msgid "4737            int rad;"
msgstr""

# CppCoreGuidelines.md:4738
msgid "4738        };"
msgstr""

       
# CppCoreGuidelines.md:4739
msgid "4739        class Triangle : public Shape {"
msgstr""

# CppCoreGuidelines.md:4740
msgid "4740        public:"
msgstr""

# CppCoreGuidelines.md:4741
msgid "4741            Triangle(Point p1, Point p2, Point p3); // calculate center"
msgstr""

# CppCoreGuidelines.md:4742
msgid "4742            // ..."
msgstr""

# CppCoreGuidelines.md:4743
msgid "4743        };"
msgstr""

       
# CppCoreGuidelines.md:4744
msgid "4744    Problems:"
msgstr""

       
# CppCoreGuidelines.md:4745
msgid "4745    * As the hierarchy grows and more data is added to `Shape`, the constructors gets harder to write and maintain."
msgstr""

# CppCoreGuidelines.md:4746
msgid "4746    * Why calculate the center for the `Triangle`? we may never us it."
msgstr""

# CppCoreGuidelines.md:4747
msgid "4747    * Add a data member to `Shape` (e.g., drawing style or canvas)"
msgstr""

# CppCoreGuidelines.md:4748
msgid "4748    and all derived classes and all users needs to be reviewed, possibly changes, and probably recompiled."
msgstr""

       
# CppCoreGuidelines.md:4749
msgid "4749    The implementation of `Shape::move()` is an example of implementation inheritance:"
msgstr""

# CppCoreGuidelines.md:4750
msgid "4750    we have defined `move()` once and for all for all derived classes."
msgstr""

# CppCoreGuidelines.md:4751
msgid "4751    The more code there is in such base class member function implementations and the more data is shared by placing it in the base,"
msgstr""

# CppCoreGuidelines.md:4752
msgid "4752    the more benefits we gain - and the less stable the hierarchy is."
msgstr""

       
# CppCoreGuidelines.md:4753
msgid "4753    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4754
msgid "4754    This Shape hierarchy can be rewritten using interface inheritance:"
msgstr""

       
# CppCoreGuidelines.md:4755
msgid "4755        class Shape {  // pure interface"
msgstr""

# CppCoreGuidelines.md:4756
msgid "4756        public:"
msgstr""

# CppCoreGuidelines.md:4757
msgid "4757            virtual Point center() const = 0;"
msgstr""

# CppCoreGuidelines.md:4758
msgid "4758            virtual Color color() const = 0;"
msgstr""

       
# CppCoreGuidelines.md:4759
msgid "4759            virtual void rotate(int) = 0;"
msgstr""

# CppCoreGuidelines.md:4760
msgid "4760            virtual void move(Point p) = 0;"
msgstr""

       
# CppCoreGuidelines.md:4761
msgid "4761            virtual void redraw() = 0;"
msgstr""

       
# CppCoreGuidelines.md:4762
msgid "4762            // ..."
msgstr""

# CppCoreGuidelines.md:4763
msgid "4763        };"
msgstr""

       
# CppCoreGuidelines.md:4764
msgid "4764    Note that a pure interface rarely have constructors: there is nothing to construct."
msgstr""

       
# CppCoreGuidelines.md:4765
msgid "4765        class Circle : public Shape {"
msgstr""

# CppCoreGuidelines.md:4766
msgid "4766        public:"
msgstr""

# CppCoreGuidelines.md:4767
msgid "4767            Circle(Point c, int r, Color c) :cent{c}, rad{r}, col{c} { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:4768
msgid "4768            Point center() const override { return cent; }"
msgstr""

# CppCoreGuidelines.md:4769
msgid "4769            Color color() const override { return col; }"
msgstr""

       
# CppCoreGuidelines.md:4770
msgid "4770            // ..."
msgstr""

# CppCoreGuidelines.md:4771
msgid "4771        private:"
msgstr""

# CppCoreGuidelines.md:4772
msgid "4772            Point cent;"
msgstr""

# CppCoreGuidelines.md:4773
msgid "4773            int rad;"
msgstr""

# CppCoreGuidelines.md:4774
msgid "4774            Color col;"
msgstr""

# CppCoreGuidelines.md:4775
msgid "4775        };"
msgstr""

       
# CppCoreGuidelines.md:4776
msgid "4776    The interface is now less brittle, but there is more work in implementing the member functions."
msgstr""

# CppCoreGuidelines.md:4777
msgid "4777    For example, `center` has to be implemented by every class derived from `Shape`."
msgstr""

       
# CppCoreGuidelines.md:4778
msgid "4778    ##### Example, dual hierarchy"
msgstr""

       
# CppCoreGuidelines.md:4779
msgid "4779    How can we gain the benefit of the stable hierarchies from implementation hierarchies and the benefit of implementation reuse from implementation inheritance."
msgstr""

# CppCoreGuidelines.md:4780
msgid "4780    One popular technique is dual hierarchies."
msgstr""

# CppCoreGuidelines.md:4781
msgid "4781    There are many ways of implementing the idea of dual hierarchies; here, we use a multiple-inheritance variant."
msgstr""

       
# CppCoreGuidelines.md:4782
msgid "4782    First we devise a hierarchy of interface classes:"
msgstr""

       
# CppCoreGuidelines.md:4783
msgid "4783        class Shape {   // pure interface"
msgstr""

# CppCoreGuidelines.md:4784
msgid "4784        public:"
msgstr""

# CppCoreGuidelines.md:4785
msgid "4785            virtual Point center() const = 0;"
msgstr""

# CppCoreGuidelines.md:4786
msgid "4786            virtual Color color() const = 0;"
msgstr""

       
# CppCoreGuidelines.md:4787
msgid "4787            virtual void rotate(int) = 0;"
msgstr""

# CppCoreGuidelines.md:4788
msgid "4788            virtual void move(Point p) = 0;"
msgstr""

       
# CppCoreGuidelines.md:4789
msgid "4789            virtual void redraw() = 0;"
msgstr""

       
# CppCoreGuidelines.md:4790
msgid "4790            // ..."
msgstr""

# CppCoreGuidelines.md:4791
msgid "4791        };"
msgstr""

       
# CppCoreGuidelines.md:4792
msgid "4792        class Circle : public Shape {   // pure interface"
msgstr""

# CppCoreGuidelines.md:4793
msgid "4793        public:"
msgstr""

# CppCoreGuidelines.md:4794
msgid "4794            virtual int radius() = 0;"
msgstr""

# CppCoreGuidelines.md:4795
msgid "4795            // ..."
msgstr""

# CppCoreGuidelines.md:4796
msgid "4796        };"
msgstr""

       
# CppCoreGuidelines.md:4797
msgid "4797    To make this interface useful, we must provide its implementation classes (here, named equivalently, but in the `Impl` namespace):"
msgstr""

       
# CppCoreGuidelines.md:4798
msgid "4798        class Impl::Shape : public Shape { // implementation"
msgstr""

# CppCoreGuidelines.md:4799
msgid "4799        public:"
msgstr""

# CppCoreGuidelines.md:4800
msgid "4800            // constructors, destructor"
msgstr""

# CppCoreGuidelines.md:4801
msgid "4801            // ..."
msgstr""

# CppCoreGuidelines.md:4802
msgid "4802            Point center() const override { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:4803
msgid "4803            Color color() const override { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:4804
msgid "4804            void rotate(int) override { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:4805
msgid "4805            void move(Point p) override { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:4806
msgid "4806            void redraw() override { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:4807
msgid "4807            // ..."
msgstr""

# CppCoreGuidelines.md:4808
msgid "4808        };"
msgstr""

       
# CppCoreGuidelines.md:4809
msgid "4809    Now `Shape` is a poor example of a class with an implementation,"
msgstr""

# CppCoreGuidelines.md:4810
msgid "4810    but bear with us because this is just a simple example of a technique aimed at more complex hierarchies."
msgstr""

       
# CppCoreGuidelines.md:4811
msgid "4811        class Impl::Circle : public Circle, public Impl::Shape {   // implementation"
msgstr""

# CppCoreGuidelines.md:4812
msgid "4812        public:"
msgstr""

# CppCoreGuidelines.md:4813
msgid "4813            // constructors, destructor"
msgstr""

       
# CppCoreGuidelines.md:4814
msgid "4814            int radius() override { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:4815
msgid "4815            // ..."
msgstr""

# CppCoreGuidelines.md:4816
msgid "4816        };"
msgstr""

       
# CppCoreGuidelines.md:4817
msgid "4817    And we could extend the hierarchies by adding a Smiley class (:-)):"
msgstr""

       
# CppCoreGuidelines.md:4818
msgid "4818        class Smiley : public Circle { // pure interface"
msgstr""

# CppCoreGuidelines.md:4819
msgid "4819        public:"
msgstr""

# CppCoreGuidelines.md:4820
msgid "4820            // ..."
msgstr""

# CppCoreGuidelines.md:4821
msgid "4821        };"
msgstr""

       
# CppCoreGuidelines.md:4822
msgid "4822        class Impl::Smiley : public Smiley, public Impl::Circle {   // implementation"
msgstr""

# CppCoreGuidelines.md:4823
msgid "4823        public:"
msgstr""

# CppCoreGuidelines.md:4824
msgid "4824            // constructors, destructor"
msgstr""

# CppCoreGuidelines.md:4825
msgid "4825            // ..."
msgstr""

# CppCoreGuidelines.md:4826
msgid "4826        }"
msgstr""

       
# CppCoreGuidelines.md:4827
msgid "4827    There are now two hierarchies:"
msgstr""

       
# CppCoreGuidelines.md:4828
msgid "4828    * interface: Smiley -> Circle -> Shape"
msgstr""

# CppCoreGuidelines.md:4829
msgid "4829    * implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape"
msgstr""

       
# CppCoreGuidelines.md:4830
msgid "4830    Since each implementation derived from its interface as well as its implementation base class we get a lattice (DAG):"
msgstr""

       
# CppCoreGuidelines.md:4831
msgid "4831        Smiley     ->         Circle     ->  Shape"
msgstr""

# CppCoreGuidelines.md:4832
msgid "4832          ^                     ^               ^"
msgstr""

# CppCoreGuidelines.md:4833
msgid "4833          |                     |               |"
msgstr""

# CppCoreGuidelines.md:4834
msgid "4834        Impl::Smiley -> Impl::Circle -> Impl::Shape"
msgstr""

       
# CppCoreGuidelines.md:4835
msgid "4835    As mentioned, this is just one way to construct a dual hierarchy."
msgstr""

       
# CppCoreGuidelines.md:4836
msgid "4836    The implementation hierarchy can be used directly, rather than through the abstract interface."
msgstr""

       
# CppCoreGuidelines.md:4837
msgid "4837        void work_with_shape(Shape&);"
msgstr""

       
# CppCoreGuidelines.md:4838
msgid "4838        int user()"
msgstr""

# CppCoreGuidelines.md:4839
msgid "4839        {"
msgstr""

# CppCoreGuidelines.md:4840
msgid "4840            Impl::Smiley my_smiley{ /* args */ };   // create concrete shape"
msgstr""

# CppCoreGuidelines.md:4841
msgid "4841            // ..."
msgstr""

# CppCoreGuidelines.md:4842
msgid "4842            my_smiley.some_member();        // use implementation class directly"
msgstr""

# CppCoreGuidelines.md:4843
msgid "4843            // ..."
msgstr""

# CppCoreGuidelines.md:4844
msgid "4844            work_with_shape(my_smiley);     // use implementation through abstract interface"
msgstr""

# CppCoreGuidelines.md:4845
msgid "4845            // ..."
msgstr""

# CppCoreGuidelines.md:4846
msgid "4846        }"
msgstr""

       
# CppCoreGuidelines.md:4847
msgid "4847    This can be useful when the implementation class has members that are not offered in the abstract interface"
msgstr""

# CppCoreGuidelines.md:4848
msgid "4848    or if direct use of a member offers optimization opportunities (e.g., if an implementation member function is `final`)"
msgstr""

       
# CppCoreGuidelines.md:4849
msgid "4849    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4850
msgid "4850    Another (related) technique for separating interface and implementation is [Pimpl](#Ri-pimpl)."
msgstr""

       
# CppCoreGuidelines.md:4851
msgid "4851    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4852
msgid "4852    There is often a choice between offering common functionality as (implemented) base class functions and free-standing functions"
msgstr""

# CppCoreGuidelines.md:4853
msgid "4853    (in an implementation namespace)."
msgstr""

# CppCoreGuidelines.md:4854
msgid "4854    Base classes gives a shorter notation and easier access to shared data (in the base)"
msgstr""

# CppCoreGuidelines.md:4855
msgid "4855    at the cost of the functionality being available only to users of the hierarchy."
msgstr""

       
# CppCoreGuidelines.md:4856
msgid "4856    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4857
msgid "4857    * Flag a derived to base conversion to a base with both data and virtual functions"
msgstr""

# CppCoreGuidelines.md:4858
msgid "4858    (except for calls from a derived class member to a base class member)"
msgstr""

# CppCoreGuidelines.md:4859
msgid "4859    * ???"
msgstr""

       
       
# CppCoreGuidelines.md:4860
msgid "4860    ### <a name=\"Rh-copy\"></a>C.130: For making deep copies of polymorphic classes prefer a virtual `clone` function instead of copy construction/assignment"
msgstr""

       
# CppCoreGuidelines.md:4861
msgid "4861    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4862
msgid "4862    Copying a polymorphic class is discouraged due to the slicing problem, see [C.67](#Rc-copy-virtual). If you really need copy semantics, copy deeply: Provide a virtual `clone` function that will copy the actual most-derived type and return an owning pointer to the new object, and then in derived classes return the derived type (use a covariant return type)."
msgstr""

       
# CppCoreGuidelines.md:4863
msgid "4863    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4864
msgid "4864        class B {"
msgstr""

# CppCoreGuidelines.md:4865
msgid "4865        public:"
msgstr""

# CppCoreGuidelines.md:4866
msgid "4866            virtual owner<B*> clone() = 0;"
msgstr""

# CppCoreGuidelines.md:4867
msgid "4867            virtual ~B() = 0;"
msgstr""

       
# CppCoreGuidelines.md:4868
msgid "4868            B(const B&) = delete;"
msgstr""

# CppCoreGuidelines.md:4869
msgid "4869            B& operator=(const B&) = delete;"
msgstr""

# CppCoreGuidelines.md:4870
msgid "4870        };"
msgstr""

       
# CppCoreGuidelines.md:4871
msgid "4871        class D : public B {"
msgstr""

# CppCoreGuidelines.md:4872
msgid "4872        public:"
msgstr""

# CppCoreGuidelines.md:4873
msgid "4873            owner<D*> clone() override;"
msgstr""

# CppCoreGuidelines.md:4874
msgid "4874            virtual ~D() override;"
msgstr""

# CppCoreGuidelines.md:4875
msgid "4875        };"
msgstr""

       
# CppCoreGuidelines.md:4876
msgid "4876    Generally, it is recommended to use smart pointers to represent ownership (see [R.20](#Rr-owner)). However, because of language rules, the covariant return type cannot be a smart pointer: `D::clone` can't return a `unique_ptr<D>` while `B::clone` returns `unique_ptr<B>`. Therefore, you either need to consistently return `unique_ptr<B>` in all overrides, or use `owner<>` utility from the [Guidelines Support Library](#SS-views)."
msgstr""

       
       
       
# CppCoreGuidelines.md:4877
msgid "4877    ### <a name=\"Rh-get\"></a>C.131: Avoid trivial getters and setters"
msgstr""

       
# CppCoreGuidelines.md:4878
msgid "4878    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4879
msgid "4879    A trivial getter or setter adds no semantic value; the data item could just as well be `public`."
msgstr""

       
# CppCoreGuidelines.md:4880
msgid "4880    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4881
msgid "4881        class Point {   // Bad: verbose"
msgstr""

# CppCoreGuidelines.md:4882
msgid "4882            int x;"
msgstr""

# CppCoreGuidelines.md:4883
msgid "4883            int y;"
msgstr""

# CppCoreGuidelines.md:4884
msgid "4884        public:"
msgstr""

# CppCoreGuidelines.md:4885
msgid "4885            Point(int xx, int yy) : x{xx}, y{yy} { }"
msgstr""

# CppCoreGuidelines.md:4886
msgid "4886            int get_x() const { return x; }"
msgstr""

# CppCoreGuidelines.md:4887
msgid "4887            void set_x(int xx) { x = xx; }"
msgstr""

# CppCoreGuidelines.md:4888
msgid "4888            int get_y() const { return y; }"
msgstr""

# CppCoreGuidelines.md:4889
msgid "4889            void set_y(int yy) { y = yy; }"
msgstr""

# CppCoreGuidelines.md:4890
msgid "4890            // no behavioral member functions"
msgstr""

# CppCoreGuidelines.md:4891
msgid "4891        };"
msgstr""

       
# CppCoreGuidelines.md:4892
msgid "4892    Consider making such a class a `struct` -- that is, a behaviorless bunch of variables, all public data and no member functions."
msgstr""

       
# CppCoreGuidelines.md:4893
msgid "4893        struct Point {"
msgstr""

# CppCoreGuidelines.md:4894
msgid "4894            int x {0};"
msgstr""

# CppCoreGuidelines.md:4895
msgid "4895            int y {0};"
msgstr""

# CppCoreGuidelines.md:4896
msgid "4896        };"
msgstr""

       
# CppCoreGuidelines.md:4897
msgid "4897    Note that we can put default initializers on member variables: [C.49: Prefer initialization to assignment in constructors](#Rc-initialize)."
msgstr""

       
# CppCoreGuidelines.md:4898
msgid "4898    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4899
msgid "4899    The key to this rule is whether the semantics of the getter/setter are trivial. While it is not a complete definition of \"trivial\", consider whether there would be any difference beyond syntax if the getter/setter was a public data member instead. Examples of non-trivial semantics would be: maintaining a class invariant or converting between an internal type and an interface type."
msgstr""

       
# CppCoreGuidelines.md:4900
msgid "4900    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4901
msgid "4901    Flag multiple `get` and `set` member functions that simply access a member without additional semantics."
msgstr""

       
# CppCoreGuidelines.md:4902
msgid "4902    ### <a name=\"Rh-virtual\"></a>C.132: Don't make a function `virtual` without reason"
msgstr""

       
# CppCoreGuidelines.md:4903
msgid "4903    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4904
msgid "4904    Redundant `virtual` increases run-time and object-code size."
msgstr""

# CppCoreGuidelines.md:4905
msgid "4905    A virtual function can be overridden and is thus open to mistakes in a derived class."
msgstr""

# CppCoreGuidelines.md:4906
msgid "4906    A virtual function ensures code replication in a templated hierarchy."
msgstr""

       
# CppCoreGuidelines.md:4907
msgid "4907    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4908
msgid "4908        template<class T>"
msgstr""

# CppCoreGuidelines.md:4909
msgid "4909        class Vector {"
msgstr""

# CppCoreGuidelines.md:4910
msgid "4910        public:"
msgstr""

# CppCoreGuidelines.md:4911
msgid "4911            // ..."
msgstr""

# CppCoreGuidelines.md:4912
msgid "4912            virtual int size() const { return sz; }   // bad: what good could a derived class do?"
msgstr""

# CppCoreGuidelines.md:4913
msgid "4913        private:"
msgstr""

# CppCoreGuidelines.md:4914
msgid "4914            T* elem;   // the elements"
msgstr""

# CppCoreGuidelines.md:4915
msgid "4915            int sz;    // number of elements"
msgstr""

# CppCoreGuidelines.md:4916
msgid "4916        };"
msgstr""

       
# CppCoreGuidelines.md:4917
msgid "4917    This kind of \"vector\" isn't meant to be used as a base class at all."
msgstr""

       
# CppCoreGuidelines.md:4918
msgid "4918    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4919
msgid "4919    * Flag a class with virtual functions but no derived classes."
msgstr""

# CppCoreGuidelines.md:4920
msgid "4920    * Flag a class where all member functions are virtual and have implementations."
msgstr""

       
# CppCoreGuidelines.md:4921
msgid "4921    ### <a name=\"Rh-protected\"></a>C.133: Avoid `protected` data"
msgstr""

       
# CppCoreGuidelines.md:4922
msgid "4922    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4923
msgid "4923    `protected` data is a source of complexity and errors."
msgstr""

# CppCoreGuidelines.md:4924
msgid "4924    `protected` data complicates the statement of invariants."
msgstr""

# CppCoreGuidelines.md:4925
msgid "4925    `protected` data inherently violates the guidance against putting data in base classes, which usually leads to having to deal with virtual inheritance as well."
msgstr""

       
# CppCoreGuidelines.md:4926
msgid "4926    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:4927
msgid "4927        class Shape {"
msgstr""

# CppCoreGuidelines.md:4928
msgid "4928        public:"
msgstr""

# CppCoreGuidelines.md:4929
msgid "4929            // ... interface functions ..."
msgstr""

# CppCoreGuidelines.md:4930
msgid "4930        protected:"
msgstr""

# CppCoreGuidelines.md:4931
msgid "4931            // data for use in derived classes:"
msgstr""

# CppCoreGuidelines.md:4932
msgid "4932            Color fill_color;"
msgstr""

# CppCoreGuidelines.md:4933
msgid "4933            Color edge_color;"
msgstr""

# CppCoreGuidelines.md:4934
msgid "4934            Style st;"
msgstr""

# CppCoreGuidelines.md:4935
msgid "4935        };"
msgstr""

       
# CppCoreGuidelines.md:4936
msgid "4936    Now it is up to every derived `Shape` to manipulate the protected data correctly."
msgstr""

# CppCoreGuidelines.md:4937
msgid "4937    This has been popular, but also a major source of maintenance problems."
msgstr""

# CppCoreGuidelines.md:4938
msgid "4938    In a large class hierarchy, the consistent use of protected data is hard to maintain because there can be a lot of code,"
msgstr""

# CppCoreGuidelines.md:4939
msgid "4939    spread over a lot of classes."
msgstr""

# CppCoreGuidelines.md:4940
msgid "4940    The set of classes that can touch that data is open: anyone can derive a new class and start manipulating the protected data."
msgstr""

# CppCoreGuidelines.md:4941
msgid "4941    Often, it is not possible to examine the complete set of classes, so any change to the representation of the class becomes infeasible."
msgstr""

# CppCoreGuidelines.md:4942
msgid "4942    There is no enforced invariant for the protected data; it is much like a set of global variables."
msgstr""

# CppCoreGuidelines.md:4943
msgid "4943    The protected data has de facto become global to a large body of code."
msgstr""

       
# CppCoreGuidelines.md:4944
msgid "4944    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4945
msgid "4945    Protected data often looks tempting to enable arbitrary improvements through derivation."
msgstr""

# CppCoreGuidelines.md:4946
msgid "4946    Often, what you get is unprincipled changes and errors."
msgstr""

# CppCoreGuidelines.md:4947
msgid "4947    [Prefer `private` data](#Rc-private) with a well-specified and enforced invariant."
msgstr""

# CppCoreGuidelines.md:4948
msgid "4948    Alternative, and often better, [keep data out of any class used as an interface](#Rh-abstract)."
msgstr""

       
# CppCoreGuidelines.md:4949
msgid "4949    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4950
msgid "4950    Protected member function can be just fine."
msgstr""

       
# CppCoreGuidelines.md:4951
msgid "4951    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4952
msgid "4952    Flag classes with `protected` data."
msgstr""

       
# CppCoreGuidelines.md:4953
msgid "4953    ### <a name=\"Rh-public\"></a>C.134: Ensure all non-`const` data members have the same access level"
msgstr""

       
# CppCoreGuidelines.md:4954
msgid "4954    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4955
msgid "4955    Prevention of logical confusion leading to errors."
msgstr""

# CppCoreGuidelines.md:4956
msgid "4956    If the non-`const` data members don't have the same access level, the type is confused about what it's trying to do."
msgstr""

# CppCoreGuidelines.md:4957
msgid "4957    Is it a type that maintains an invariant or simply a collection of values?"
msgstr""

       
# CppCoreGuidelines.md:4958
msgid "4958    ##### Discussion"
msgstr""

       
# CppCoreGuidelines.md:4959
msgid "4959    The core question is: What code is responsible for maintaining a meaningful/correct value for that variable?"
msgstr""

       
# CppCoreGuidelines.md:4960
msgid "4960    There are exactly two kinds of data members:"
msgstr""

       
# CppCoreGuidelines.md:4961
msgid "4961    * A: Ones that don't participate in the object's invariant. Any combination of values for these members is valid."
msgstr""

# CppCoreGuidelines.md:4962
msgid "4962    * B: Ones that do participate in the object's invariant. Not every combination of values is meaningful (else there'd be no invariant). Therefore all code that has write access to these variables must know about the invariant, know the semantics, and know (and actively implement and enforce) the rules for keeping the values correct."
msgstr""

       
# CppCoreGuidelines.md:4963
msgid "4963    Data members in category A should just be `public` (or, more rarely, `protected` if you only want derived classes to see them). They don't need encapsulation. All code in the system might as well see and manipulate them."
msgstr""

       
# CppCoreGuidelines.md:4964
msgid "4964    Data members in category B should be `private` or `const`. This is because encapsulation is important. To make them non-`private` and non-`const` would mean that the object can't control its own state: An unbounded amount of code beyond the class would need to know about the invariant and participate in maintaining it accurately -- if these data members were `public`, that would be all calling code that uses the object; if they were `protected`, it would be all the code in current and future derived classes. This leads to brittle and tightly coupled code that quickly becomes a nightmare to maintain. Any code that inadvertently sets the data members to an invalid or unexpected combination of values would corrupt the object and all subsequent uses of the object."
msgstr""

       
# CppCoreGuidelines.md:4965
msgid "4965    Most classes are either all A or all B:"
msgstr""

       
# CppCoreGuidelines.md:4966
msgid "4966    * *All public*: If you're writing an aggregate bundle-of-variables without an invariant across those variables, then all the variables should be `public`."
msgstr""

# CppCoreGuidelines.md:4967
msgid "4967      [By convention, declare such classes `struct` rather than `class`](#Rc-struct)"
msgstr""

# CppCoreGuidelines.md:4968
msgid "4968    * *All private*: If you're writing a type that maintains an invariant, then all the non-`const` variables should be private -- it should be encapsulated."
msgstr""

       
# CppCoreGuidelines.md:4969
msgid "4969    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:4970
msgid "4970    Occasionally classes will mix A and B, usually for debug reasons. An encapsulated object may contain something like non-`const` debug instrumentation that isn't part of the invariant and so falls into category A -- it isn't really part of the object's value or meaningful observable state either. In that case, the A parts should be treated as A's (made `public`, or in rarer cases `protected` if they should be visible only to derived classes) and the B parts should still be treated like B's (`private` or `const`)."
msgstr""

       
# CppCoreGuidelines.md:4971
msgid "4971    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4972
msgid "4972    Flag any class that has non-`const` data members with different access levels."
msgstr""

       
# CppCoreGuidelines.md:4973
msgid "4973    ### <a name=\"Rh-mi-interface\"></a>C.135: Use multiple inheritance to represent multiple distinct interfaces"
msgstr""

       
# CppCoreGuidelines.md:4974
msgid "4974    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4975
msgid "4975    Not all classes will necessarily support all interfaces, and not all callers will necessarily want to deal with all operations."
msgstr""

# CppCoreGuidelines.md:4976
msgid "4976    Especially to break apart monolithic interfaces into \"aspects\" of behavior supported by a given derived class."
msgstr""

       
# CppCoreGuidelines.md:4977
msgid "4977    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4978
msgid "4978        class iostream : public istream, public ostream {   // very simplified"
msgstr""

# CppCoreGuidelines.md:4979
msgid "4979            // ..."
msgstr""

# CppCoreGuidelines.md:4980
msgid "4980        };"
msgstr""

       
# CppCoreGuidelines.md:4981
msgid "4981    `istream` provides the interface to input operations; `ostream` provides the interface to output operations."
msgstr""

# CppCoreGuidelines.md:4982
msgid "4982    `iostream` provides the union of the `istream` and `ostream` interfaces and the synchronization needed to allow both on a single stream."
msgstr""

       
# CppCoreGuidelines.md:4983
msgid "4983    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4984
msgid "4984    This is a very common use of inheritance because the need for multiple different interfaces to an implementation is common"
msgstr""

# CppCoreGuidelines.md:4985
msgid "4985    and such interfaces are often not easily or naturally organized into a single-rooted hierarchy."
msgstr""

       
# CppCoreGuidelines.md:4986
msgid "4986    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:4987
msgid "4987    Such interfaces are typically abstract classes."
msgstr""

       
# CppCoreGuidelines.md:4988
msgid "4988    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:4989
msgid "4989    ???"
msgstr""

       
# CppCoreGuidelines.md:4990
msgid "4990    ### <a name=\"Rh-mi-implementation\"></a>C.136: Use multiple inheritance to represent the union of implementation attributes"
msgstr""

       
# CppCoreGuidelines.md:4991
msgid "4991    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:4992
msgid "4992    Some forms of mixins have state and often operations on that state."
msgstr""

# CppCoreGuidelines.md:4993
msgid "4993    If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding."
msgstr""

       
# CppCoreGuidelines.md:4994
msgid "4994    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:4995
msgid "4995        class iostream : public istream, public ostream {   // very simplified"
msgstr""

# CppCoreGuidelines.md:4996
msgid "4996            // ..."
msgstr""

# CppCoreGuidelines.md:4997
msgid "4997        };"
msgstr""

       
# CppCoreGuidelines.md:4998
msgid "4998    `istream` provides the interface to input operations (and some data); `ostream` provides the interface to output operations (and some data)."
msgstr""

# CppCoreGuidelines.md:4999
msgid "4999    `iostream` provides the union of the `istream` and `ostream` interfaces and the synchronization needed to allow both on a single stream."
msgstr""

       
# CppCoreGuidelines.md:5000
msgid "5000    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5001
msgid "5001    This a relatively rare use because implementation can often be organized into a single-rooted hierarchy."
msgstr""

       
# CppCoreGuidelines.md:5002
msgid "5002    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5003
msgid "5003    Sometimes, an \"implementation attribute\" is more like a \"mixin\" that determine the behavior of an implementation and inject"
msgstr""

# CppCoreGuidelines.md:5004
msgid "5004    members to enable the implementation of the policies it requires."
msgstr""

# CppCoreGuidelines.md:5005
msgid "5005    For example, see `std::enable_shared_from_this`"
msgstr""

# CppCoreGuidelines.md:5006
msgid "5006    or various bases from boost.intrusive (e.g. `list_base_hook` or `intrusive_ref_counter`)."
msgstr""

       
# CppCoreGuidelines.md:5007
msgid "5007    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5008
msgid "5008    ???"
msgstr""

       
# CppCoreGuidelines.md:5009
msgid "5009    ### <a name=\"Rh-vbase\"></a>C.137: Use `virtual` bases to avoid overly general base classes"
msgstr""

       
# CppCoreGuidelines.md:5010
msgid "5010    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5011
msgid "5011     Allow separation of shared data and interface."
msgstr""

# CppCoreGuidelines.md:5012
msgid "5012     To avoid all shared data to being put into an ultimate base class."
msgstr""

       
# CppCoreGuidelines.md:5013
msgid "5013    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5014
msgid "5014        struct Interface {"
msgstr""

# CppCoreGuidelines.md:5015
msgid "5015            virtual void f();"
msgstr""

# CppCoreGuidelines.md:5016
msgid "5016            virtual int g();"
msgstr""

# CppCoreGuidelines.md:5017
msgid "5017            // ... no data here ..."
msgstr""

# CppCoreGuidelines.md:5018
msgid "5018        };"
msgstr""

       
# CppCoreGuidelines.md:5019
msgid "5019        class Utility {  // with data"
msgstr""

# CppCoreGuidelines.md:5020
msgid "5020            void utility1();"
msgstr""

# CppCoreGuidelines.md:5021
msgid "5021            virtual void utility2();    // customization point"
msgstr""

# CppCoreGuidelines.md:5022
msgid "5022        public:"
msgstr""

# CppCoreGuidelines.md:5023
msgid "5023            int x;"
msgstr""

# CppCoreGuidelines.md:5024
msgid "5024            int y;"
msgstr""

# CppCoreGuidelines.md:5025
msgid "5025        };"
msgstr""

       
# CppCoreGuidelines.md:5026
msgid "5026        class Derive1 : public Interface, virtual protected Utility {"
msgstr""

# CppCoreGuidelines.md:5027
msgid "5027            // override Interface functions"
msgstr""

# CppCoreGuidelines.md:5028
msgid "5028            // Maybe override Utility virtual functions"
msgstr""

# CppCoreGuidelines.md:5029
msgid "5029            // ..."
msgstr""

# CppCoreGuidelines.md:5030
msgid "5030        };"
msgstr""

       
# CppCoreGuidelines.md:5031
msgid "5031        class Derive2 : public Interface, virtual protected Utility {"
msgstr""

# CppCoreGuidelines.md:5032
msgid "5032            // override Interface functions"
msgstr""

# CppCoreGuidelines.md:5033
msgid "5033            // Maybe override Utility virtual functions"
msgstr""

# CppCoreGuidelines.md:5034
msgid "5034            // ..."
msgstr""

# CppCoreGuidelines.md:5035
msgid "5035        };"
msgstr""

       
# CppCoreGuidelines.md:5036
msgid "5036    Factoring out `Utility` makes sense if many derived classes share significant \"implementation details.\""
msgstr""

       
       
# CppCoreGuidelines.md:5037
msgid "5037    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5038
msgid "5038    Obviously, the example is too \"theoretical\", but it is hard to find a *small* realistic example."
msgstr""

# CppCoreGuidelines.md:5039
msgid "5039    `Interface` is the root of an [interface hierarchy](#Rh-abstract)"
msgstr""

# CppCoreGuidelines.md:5040
msgid "5040    and `Utility` is the root of an [implementation hierarchy](#Rh-kind)."
msgstr""

# CppCoreGuidelines.md:5041
msgid "5041    Here is [a slightly more realistic example](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck) with an explanation."
msgstr""

       
# CppCoreGuidelines.md:5042
msgid "5042    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5043
msgid "5043    Often, linearization of a hierarchy is a better solution."
msgstr""

       
# CppCoreGuidelines.md:5044
msgid "5044    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5045
msgid "5045    Flag mixed interface and implementation hierarchies."
msgstr""

       
# CppCoreGuidelines.md:5046
msgid "5046    ### <a name=\"Rh-using\"></a>C.138: Create an overload set for a derived class and its bases with `using`"
msgstr""

       
# CppCoreGuidelines.md:5047
msgid "5047    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5048
msgid "5048    Without a using declaration, member functions in the derived class hide the entire inherited overload sets."
msgstr""

       
# CppCoreGuidelines.md:5049
msgid "5049    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5050
msgid "5050        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:5051
msgid "5051        class B {"
msgstr""

# CppCoreGuidelines.md:5052
msgid "5052        public:"
msgstr""

# CppCoreGuidelines.md:5053
msgid "5053            virtual int f(int i) { std::cout << \"f(int): \"; return i; }"
msgstr""

# CppCoreGuidelines.md:5054
msgid "5054            virtual double f(double d) { std::cout << \"f(double): \"; return d; }"
msgstr""

# CppCoreGuidelines.md:5055
msgid "5055        };"
msgstr""

# CppCoreGuidelines.md:5056
msgid "5056        class D: public B {"
msgstr""

# CppCoreGuidelines.md:5057
msgid "5057        public:"
msgstr""

# CppCoreGuidelines.md:5058
msgid "5058            int f(int i) override { std::cout << \"f(int): \"; return i + 1; }"
msgstr""

# CppCoreGuidelines.md:5059
msgid "5059        };"
msgstr""

# CppCoreGuidelines.md:5060
msgid "5060        int main()"
msgstr""

# CppCoreGuidelines.md:5061
msgid "5061        {"
msgstr""

# CppCoreGuidelines.md:5062
msgid "5062            D d;"
msgstr""

# CppCoreGuidelines.md:5063
msgid "5063            std::cout << d.f(2) << '\\n';   // prints \"f(int): 3\""
msgstr""

# CppCoreGuidelines.md:5064
msgid "5064            std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\""
msgstr""

# CppCoreGuidelines.md:5065
msgid "5065        }"
msgstr""

       
# CppCoreGuidelines.md:5066
msgid "5066    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:5067
msgid "5067        class D: public B {"
msgstr""

# CppCoreGuidelines.md:5068
msgid "5068        public:"
msgstr""

# CppCoreGuidelines.md:5069
msgid "5069            int f(int i) override { std::cout << \"f(int): \"; return i + 1; }"
msgstr""

# CppCoreGuidelines.md:5070
msgid "5070            using B::f; // exposes f(double)"
msgstr""

# CppCoreGuidelines.md:5071
msgid "5071        };"
msgstr""

       
# CppCoreGuidelines.md:5072
msgid "5072    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5073
msgid "5073    This issue affects both virtual and nonvirtual member functions"
msgstr""

       
# CppCoreGuidelines.md:5074
msgid "5074    For variadic bases, C++17 introduced a variadic form of the using-declaration,"
msgstr""

       
# CppCoreGuidelines.md:5075
msgid "5075        template <class... Ts>"
msgstr""

# CppCoreGuidelines.md:5076
msgid "5076        struct Overloader : Ts... {"
msgstr""

# CppCoreGuidelines.md:5077
msgid "5077            using Ts::operator()...; // exposes operator() from every base"
msgstr""

# CppCoreGuidelines.md:5078
msgid "5078        };"
msgstr""

       
# CppCoreGuidelines.md:5079
msgid "5079    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5080
msgid "5080    Diagnose name hiding"
msgstr""

       
# CppCoreGuidelines.md:5081
msgid "5081    ### <a name=\"Rh-final\"></a>C.139: Use `final` sparingly"
msgstr""

       
# CppCoreGuidelines.md:5082
msgid "5082    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5083
msgid "5083    Capping a hierarchy with `final` is rarely needed for logical reasons and can be damaging to the extensibility of a hierarchy."
msgstr""

       
# CppCoreGuidelines.md:5084
msgid "5084    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5085
msgid "5085        class Widget { /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:5086
msgid "5086        // nobody will ever want to improve My_widget (or so you thought)"
msgstr""

# CppCoreGuidelines.md:5087
msgid "5087        class My_widget final : public Widget { /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:5088
msgid "5088        class My_improved_widget : public My_widget { /* ... */ };  // error: can't do that"
msgstr""

       
# CppCoreGuidelines.md:5089
msgid "5089    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5090
msgid "5090    Not every class is meant to be a base class."
msgstr""

# CppCoreGuidelines.md:5091
msgid "5091    Most standard-library classes are examples of that (e.g., `std::vector` and `std::string` are not designed to be derived from)."
msgstr""

# CppCoreGuidelines.md:5092
msgid "5092    This rule is about using `final` on classes with virtual functions meant to be interfaces for a class hierarchy."
msgstr""

       
# CppCoreGuidelines.md:5093
msgid "5093    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5094
msgid "5094    Capping an individual virtual function with `final` is error-prone as `final` can easily be overlooked when defining/overriding a set of functions."
msgstr""

# CppCoreGuidelines.md:5095
msgid "5095    Fortunately, the compiler catches such mistakes: You cannot re-declare/re-open a `final` member in a derived class."
msgstr""

       
# CppCoreGuidelines.md:5096
msgid "5096    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5097
msgid "5097    Claims of performance improvements from `final` should be substantiated."
msgstr""

# CppCoreGuidelines.md:5098
msgid "5098    Too often, such claims are based on conjecture or experience with other languages."
msgstr""

       
# CppCoreGuidelines.md:5099
msgid "5099    There are examples where `final` can be important for both logical and performance reasons."
msgstr""

# CppCoreGuidelines.md:5100
msgid "5100    One example is a performance-critical AST hierarchy in a compiler or language analysis tool."
msgstr""

# CppCoreGuidelines.md:5101
msgid "5101    New derived classes are not added every year and only by library implementers."
msgstr""

# CppCoreGuidelines.md:5102
msgid "5102    However, misuses are (or at least have been) far more common."
msgstr""

       
# CppCoreGuidelines.md:5103
msgid "5103    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5104
msgid "5104    Flag uses of `final`."
msgstr""

       
       
# CppCoreGuidelines.md:5105
msgid "5105    ### <a name=\"Rh-virtual-default-arg\"></a>C.140: Do not provide different default arguments for a virtual function and an overrider"
msgstr""

       
# CppCoreGuidelines.md:5106
msgid "5106    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5107
msgid "5107    That can cause confusion: An overrider does not inherit default arguments."
msgstr""

       
# CppCoreGuidelines.md:5108
msgid "5108    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5109
msgid "5109        class Base {"
msgstr""

# CppCoreGuidelines.md:5110
msgid "5110        public:"
msgstr""

# CppCoreGuidelines.md:5111
msgid "5111            virtual int multiply(int value, int factor = 2) = 0;"
msgstr""

# CppCoreGuidelines.md:5112
msgid "5112        };"
msgstr""

       
# CppCoreGuidelines.md:5113
msgid "5113        class Derived : public Base {"
msgstr""

# CppCoreGuidelines.md:5114
msgid "5114        public:"
msgstr""

# CppCoreGuidelines.md:5115
msgid "5115            int multiply(int value, int factor = 10) override;"
msgstr""

# CppCoreGuidelines.md:5116
msgid "5116        };"
msgstr""

       
# CppCoreGuidelines.md:5117
msgid "5117        Derived d;"
msgstr""

# CppCoreGuidelines.md:5118
msgid "5118        Base& b = d;"
msgstr""

       
# CppCoreGuidelines.md:5119
msgid "5119        b.multiply(10);  // these two calls will call the same function but"
msgstr""

# CppCoreGuidelines.md:5120
msgid "5120        d.multiply(10);  // with different arguments and so different results"
msgstr""

       
# CppCoreGuidelines.md:5121
msgid "5121    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5122
msgid "5122    Flag default arguments on virtual functions if they differ between base and derived declarations."
msgstr""

       
# CppCoreGuidelines.md:5123
msgid "5123    ## C.hier-access: Accessing objects in a hierarchy"
msgstr""

       
# CppCoreGuidelines.md:5124
msgid "5124    ### <a name=\"Rh-poly\"></a>C.145: Access polymorphic objects through pointers and references"
msgstr""

       
# CppCoreGuidelines.md:5125
msgid "5125    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5126
msgid "5126    If you have a class with a virtual function, you don't (in general) know which class provided the function to be used."
msgstr""

       
# CppCoreGuidelines.md:5127
msgid "5127    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5128
msgid "5128        struct B { int a; virtual int f(); };"
msgstr""

# CppCoreGuidelines.md:5129
msgid "5129        struct D : B { int b; int f() override; };"
msgstr""

       
# CppCoreGuidelines.md:5130
msgid "5130        void use(B b)"
msgstr""

# CppCoreGuidelines.md:5131
msgid "5131        {"
msgstr""

# CppCoreGuidelines.md:5132
msgid "5132            D d;"
msgstr""

# CppCoreGuidelines.md:5133
msgid "5133            B b2 = d;   // slice"
msgstr""

# CppCoreGuidelines.md:5134
msgid "5134            B b3 = b;"
msgstr""

# CppCoreGuidelines.md:5135
msgid "5135        }"
msgstr""

       
# CppCoreGuidelines.md:5136
msgid "5136        void use2()"
msgstr""

# CppCoreGuidelines.md:5137
msgid "5137        {"
msgstr""

# CppCoreGuidelines.md:5138
msgid "5138            D d;"
msgstr""

# CppCoreGuidelines.md:5139
msgid "5139            use(d);   // slice"
msgstr""

# CppCoreGuidelines.md:5140
msgid "5140        }"
msgstr""

       
# CppCoreGuidelines.md:5141
msgid "5141    Both `d`s are sliced."
msgstr""

       
# CppCoreGuidelines.md:5142
msgid "5142    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:5143
msgid "5143    You can safely access a named polymorphic object in the scope of its definition, just don't slice it."
msgstr""

       
# CppCoreGuidelines.md:5144
msgid "5144        void use3()"
msgstr""

# CppCoreGuidelines.md:5145
msgid "5145        {"
msgstr""

# CppCoreGuidelines.md:5146
msgid "5146            D d;"
msgstr""

# CppCoreGuidelines.md:5147
msgid "5147            d.f();   // OK"
msgstr""

# CppCoreGuidelines.md:5148
msgid "5148        }"
msgstr""

       
# CppCoreGuidelines.md:5149
msgid "5149    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5150
msgid "5150    Flag all slicing."
msgstr""

       
# CppCoreGuidelines.md:5151
msgid "5151    ### <a name=\"Rh-dynamic_cast\"></a>C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable"
msgstr""

       
# CppCoreGuidelines.md:5152
msgid "5152    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5153
msgid "5153    `dynamic_cast` is checked at run time."
msgstr""

       
# CppCoreGuidelines.md:5154
msgid "5154    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5155
msgid "5155        struct B {   // an interface"
msgstr""

# CppCoreGuidelines.md:5156
msgid "5156            virtual void f();"
msgstr""

# CppCoreGuidelines.md:5157
msgid "5157            virtual void g();"
msgstr""

# CppCoreGuidelines.md:5158
msgid "5158        };"
msgstr""

       
# CppCoreGuidelines.md:5159
msgid "5159        struct D : B {   // a wider interface"
msgstr""

# CppCoreGuidelines.md:5160
msgid "5160            void f() override;"
msgstr""

# CppCoreGuidelines.md:5161
msgid "5161            virtual void h();"
msgstr""

# CppCoreGuidelines.md:5162
msgid "5162        };"
msgstr""

       
# CppCoreGuidelines.md:5163
msgid "5163        void user(B* pb)"
msgstr""

# CppCoreGuidelines.md:5164
msgid "5164        {"
msgstr""

# CppCoreGuidelines.md:5165
msgid "5165            if (D* pd = dynamic_cast<D*>(pb)) {"
msgstr""

# CppCoreGuidelines.md:5166
msgid "5166                // ... use D's interface ..."
msgstr""

# CppCoreGuidelines.md:5167
msgid "5167            }"
msgstr""

# CppCoreGuidelines.md:5168
msgid "5168            else {"
msgstr""

# CppCoreGuidelines.md:5169
msgid "5169                // ... make do with B's interface ..."
msgstr""

# CppCoreGuidelines.md:5170
msgid "5170            }"
msgstr""

# CppCoreGuidelines.md:5171
msgid "5171        }"
msgstr""

       
# CppCoreGuidelines.md:5172
msgid "5172    Use of the other casts can violate type safety and cause the program to access a variable that is actually of type `X` to be accessed as if it were of an unrelated type `Z`:"
msgstr""

       
# CppCoreGuidelines.md:5173
msgid "5173        void user2(B* pb)   // bad"
msgstr""

# CppCoreGuidelines.md:5174
msgid "5174        {"
msgstr""

# CppCoreGuidelines.md:5175
msgid "5175            D* pd = static_cast<D*>(pb);    // I know that pb really points to a D; trust me"
msgstr""

# CppCoreGuidelines.md:5176
msgid "5176            // ... use D's interface ..."
msgstr""

# CppCoreGuidelines.md:5177
msgid "5177        }"
msgstr""

       
# CppCoreGuidelines.md:5178
msgid "5178        void user3(B* pb)    // unsafe"
msgstr""

# CppCoreGuidelines.md:5179
msgid "5179        {"
msgstr""

# CppCoreGuidelines.md:5180
msgid "5180            if (some_condition) {"
msgstr""

# CppCoreGuidelines.md:5181
msgid "5181                D* pd = static_cast<D*>(pb);   // I know that pb really points to a D; trust me"
msgstr""

# CppCoreGuidelines.md:5182
msgid "5182                // ... use D's interface ..."
msgstr""

# CppCoreGuidelines.md:5183
msgid "5183            }"
msgstr""

# CppCoreGuidelines.md:5184
msgid "5184            else {"
msgstr""

# CppCoreGuidelines.md:5185
msgid "5185                // ... make do with B's interface ..."
msgstr""

# CppCoreGuidelines.md:5186
msgid "5186            }"
msgstr""

# CppCoreGuidelines.md:5187
msgid "5187        }"
msgstr""

       
# CppCoreGuidelines.md:5188
msgid "5188        void f()"
msgstr""

# CppCoreGuidelines.md:5189
msgid "5189        {"
msgstr""

# CppCoreGuidelines.md:5190
msgid "5190            B b;"
msgstr""

# CppCoreGuidelines.md:5191
msgid "5191            user(&b);   // OK"
msgstr""

# CppCoreGuidelines.md:5192
msgid "5192            user2(&b);  // bad error"
msgstr""

# CppCoreGuidelines.md:5193
msgid "5193            user3(&b);  // OK *if* the programmer got the some_condition check right"
msgstr""

# CppCoreGuidelines.md:5194
msgid "5194        }"
msgstr""

       
# CppCoreGuidelines.md:5195
msgid "5195    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5196
msgid "5196    Like other casts, `dynamic_cast` is overused."
msgstr""

# CppCoreGuidelines.md:5197
msgid "5197    [Prefer virtual functions to casting](#Rh-use-virtual)."
msgstr""

# CppCoreGuidelines.md:5198
msgid "5198    Prefer [static polymorphism](#???) to hierarchy navigation where it is possible (no run-time resolution necessary)"
msgstr""

# CppCoreGuidelines.md:5199
msgid "5199    and reasonably convenient."
msgstr""

       
# CppCoreGuidelines.md:5200
msgid "5200    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5201
msgid "5201    Some people use `dynamic_cast` where a `typeid` would have been more appropriate;"
msgstr""

# CppCoreGuidelines.md:5202
msgid "5202    `dynamic_cast` is a general \"is kind of\" operation for discovering the best interface to an object,"
msgstr""

# CppCoreGuidelines.md:5203
msgid "5203    whereas `typeid` is a \"give me the exact type of this object\" operation to discover the actual type of an object."
msgstr""

# CppCoreGuidelines.md:5204
msgid "5204    The latter is an inherently simpler operation that ought to be faster."
msgstr""

# CppCoreGuidelines.md:5205
msgid "5205    The latter (`typeid`) is easily hand-crafted if necessary (e.g., if working on a system where RTTI is -- for some reason -- prohibited),"
msgstr""

# CppCoreGuidelines.md:5206
msgid "5206    the former (`dynamic_cast`) is far harder to implement correctly in general."
msgstr""

       
# CppCoreGuidelines.md:5207
msgid "5207    Consider:"
msgstr""

       
# CppCoreGuidelines.md:5208
msgid "5208        struct B {"
msgstr""

# CppCoreGuidelines.md:5209
msgid "5209            const char* name {\"B\"};"
msgstr""

# CppCoreGuidelines.md:5210
msgid "5210            // if pb1->id() == pb2->id() *pb1 is the same type as *pb2"
msgstr""

# CppCoreGuidelines.md:5211
msgid "5211            virtual const char* id() const { return name; }"
msgstr""

# CppCoreGuidelines.md:5212
msgid "5212            // ..."
msgstr""

# CppCoreGuidelines.md:5213
msgid "5213        };"
msgstr""

       
# CppCoreGuidelines.md:5214
msgid "5214        struct D : B {"
msgstr""

# CppCoreGuidelines.md:5215
msgid "5215            const char* name {\"D\"};"
msgstr""

# CppCoreGuidelines.md:5216
msgid "5216            const char* id() const override { return name; }"
msgstr""

# CppCoreGuidelines.md:5217
msgid "5217            // ..."
msgstr""

# CppCoreGuidelines.md:5218
msgid "5218        };"
msgstr""

       
# CppCoreGuidelines.md:5219
msgid "5219        void use()"
msgstr""

# CppCoreGuidelines.md:5220
msgid "5220        {"
msgstr""

# CppCoreGuidelines.md:5221
msgid "5221            B* pb1 = new B;"
msgstr""

# CppCoreGuidelines.md:5222
msgid "5222            B* pb2 = new D;"
msgstr""

       
# CppCoreGuidelines.md:5223
msgid "5223            cout << pb1->id(); // \"B\""
msgstr""

# CppCoreGuidelines.md:5224
msgid "5224            cout << pb2->id(); // \"D\""
msgstr""

       
       
# CppCoreGuidelines.md:5225
msgid "5225            if (pb1->id() == \"D\") {         // looks innocent"
msgstr""

# CppCoreGuidelines.md:5226
msgid "5226                D* pd = static_cast<D*>(pb1);"
msgstr""

# CppCoreGuidelines.md:5227
msgid "5227                // ..."
msgstr""

# CppCoreGuidelines.md:5228
msgid "5228            }"
msgstr""

# CppCoreGuidelines.md:5229
msgid "5229            // ..."
msgstr""

# CppCoreGuidelines.md:5230
msgid "5230        }"
msgstr""

       
# CppCoreGuidelines.md:5231
msgid "5231    The result of `pb2->id() == \"D\"` is actually implementation defined."
msgstr""

# CppCoreGuidelines.md:5232
msgid "5232    We added it to warn of the dangers of home-brew RTTI."
msgstr""

# CppCoreGuidelines.md:5233
msgid "5233    This code may work as expected for years, just to fail on a new machine, new compiler, or a new linker that does not unify character literals."
msgstr""

       
# CppCoreGuidelines.md:5234
msgid "5234    If you implement your own RTTI, be careful."
msgstr""

       
# CppCoreGuidelines.md:5235
msgid "5235    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:5236
msgid "5236    If your implementation provided a really slow `dynamic_cast`, you may have to use a workaround."
msgstr""

# CppCoreGuidelines.md:5237
msgid "5237    However, all workarounds that cannot be statically resolved involve explicit casting (typically `static_cast`) and are error-prone."
msgstr""

# CppCoreGuidelines.md:5238
msgid "5238    You will basically be crafting your own special-purpose `dynamic_cast`."
msgstr""

# CppCoreGuidelines.md:5239
msgid "5239    So, first make sure that your `dynamic_cast` really is as slow as you think it is (there are a fair number of unsupported rumors about)"
msgstr""

# CppCoreGuidelines.md:5240
msgid "5240    and that your use of `dynamic_cast` is really performance critical."
msgstr""

       
# CppCoreGuidelines.md:5241
msgid "5241    We are of the opinion that current implementations of `dynamic_cast` are unnecessarily slow."
msgstr""

# CppCoreGuidelines.md:5242
msgid "5242    For example, under suitable conditions, it is possible to perform a `dynamic_cast` in [fast constant time](http://www.stroustrup.com/fast_dynamic_casting.pdf)."
msgstr""

# CppCoreGuidelines.md:5243
msgid "5243    However, compatibility makes changes difficult even if all agree that an effort to optimize is worthwhile."
msgstr""

       
# CppCoreGuidelines.md:5244
msgid "5244    In very rare cases, if you have measured that the `dynamic_cast` overhead is material, you have other means to statically guarantee that a downcast will succeed (e.g., you are using CRTP carefully), and there is no virtual inheritance involved, consider tactically resorting `static_cast` with a prominent comment and disclaimer summarizing this paragraph and that human attention is needed under maintenance because the type system can't verify correctness. Even so, in our experience such \"I know what I'm doing\" situations are still a known bug source."
msgstr""

       
# CppCoreGuidelines.md:5245
msgid "5245    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:5246
msgid "5246    Consider:"
msgstr""

       
# CppCoreGuidelines.md:5247
msgid "5247        template<typename B>"
msgstr""

# CppCoreGuidelines.md:5248
msgid "5248        class Dx : B {"
msgstr""

# CppCoreGuidelines.md:5249
msgid "5249            // ..."
msgstr""

# CppCoreGuidelines.md:5250
msgid "5250        };"
msgstr""

       
# CppCoreGuidelines.md:5251
msgid "5251    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5252
msgid "5252    * Flag all uses of `static_cast` for downcasts, including C-style casts that perform a `static_cast`."
msgstr""

# CppCoreGuidelines.md:5253
msgid "5253    * This rule is part of the [type-safety profile](#Pro-type-downcast)."
msgstr""

       
# CppCoreGuidelines.md:5254
msgid "5254    ### <a name=\"Rh-ref-cast\"></a>C.147: Use `dynamic_cast` to a reference type when failure to find the required class is considered an error"
msgstr""

       
# CppCoreGuidelines.md:5255
msgid "5255    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5256
msgid "5256    Casting to a reference expresses that you intend to end up with a valid object, so the cast must succeed. `dynamic_cast` will then throw if it does not succeed."
msgstr""

       
# CppCoreGuidelines.md:5257
msgid "5257    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5258
msgid "5258        ???"
msgstr""

       
# CppCoreGuidelines.md:5259
msgid "5259    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5260
msgid "5260    ???"
msgstr""

       
# CppCoreGuidelines.md:5261
msgid "5261    ### <a name=\"Rh-ptr-cast\"></a>C.148: Use `dynamic_cast` to a pointer type when failure to find the required class is considered a valid alternative"
msgstr""

       
# CppCoreGuidelines.md:5262
msgid "5262    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5263
msgid "5263    The `dynamic_cast` conversion allows to test whether a pointer is pointing at a polymorphic object that has a given class in its hierarchy. Since failure to find the class merely returns a null value, it can be tested during run time. This allows writing code that can choose alternative paths depending on the results."
msgstr""

       
# CppCoreGuidelines.md:5264
msgid "5264    Contrast with [C.147](#Rh-ptr-cast), where failure is an error, and should not be used for conditional execution."
msgstr""

       
# CppCoreGuidelines.md:5265
msgid "5265    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5266
msgid "5266    The example below describes the `add` function of a `Shape_owner` that takes ownership of constructed `Shape` objects. The objects are also sorted into views, according to their geometric attributes."
msgstr""

# CppCoreGuidelines.md:5267
msgid "5267    In this example, `Shape` does not inherit from `Geometric_attributes`. Only its subclasses do."
msgstr""

       
# CppCoreGuidelines.md:5268
msgid "5268        void add(Shape* const item)"
msgstr""

# CppCoreGuidelines.md:5269
msgid "5269        {"
msgstr""

# CppCoreGuidelines.md:5270
msgid "5270          // Ownership is always taken"
msgstr""

# CppCoreGuidelines.md:5271
msgid "5271          owned_shapes.emplace_back(item);"
msgstr""

       
# CppCoreGuidelines.md:5272
msgid "5272          // Check the Geometric_attributes and add the shape to none/one/some/all of the views"
msgstr""

       
# CppCoreGuidelines.md:5273
msgid "5273          if (auto even = dynamic_cast<Even_sided*>(item))"
msgstr""

# CppCoreGuidelines.md:5274
msgid "5274          {"
msgstr""

# CppCoreGuidelines.md:5275
msgid "5275            view_of_evens.emplace_back(even);"
msgstr""

# CppCoreGuidelines.md:5276
msgid "5276          }"
msgstr""

       
# CppCoreGuidelines.md:5277
msgid "5277          if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))"
msgstr""

# CppCoreGuidelines.md:5278
msgid "5278          {"
msgstr""

# CppCoreGuidelines.md:5279
msgid "5279            view_of_trisyms.emplace_back(trisym);"
msgstr""

# CppCoreGuidelines.md:5280
msgid "5280          }"
msgstr""

# CppCoreGuidelines.md:5281
msgid "5281        }"
msgstr""

       
# CppCoreGuidelines.md:5282
msgid "5282    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:5283
msgid "5283    A failure to find the required class will cause `dynamic_cast` to return a null value, and de-referencing a null-valued pointer will lead to undefined behavior."
msgstr""

# CppCoreGuidelines.md:5284
msgid "5284    Therefore the result of the `dynamic_cast` should always be treated as if it may contain a null value, and tested."
msgstr""

       
# CppCoreGuidelines.md:5285
msgid "5285    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5286
msgid "5286    * (Complex) Unless there is a null test on the result of a `dynamic_cast` of a pointer type, warn upon dereference of the pointer."
msgstr""

       
# CppCoreGuidelines.md:5287
msgid "5287    ### <a name=\"Rh-smart\"></a>C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects created using `new`"
msgstr""

       
# CppCoreGuidelines.md:5288
msgid "5288    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5289
msgid "5289    Avoid resource leaks."
msgstr""

       
# CppCoreGuidelines.md:5290
msgid "5290    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5291
msgid "5291        void use(int i)"
msgstr""

# CppCoreGuidelines.md:5292
msgid "5292        {"
msgstr""

# CppCoreGuidelines.md:5293
msgid "5293            auto p = new int {7};           // bad: initialize local pointers with new"
msgstr""

# CppCoreGuidelines.md:5294
msgid "5294            auto q = make_unique<int>(9);   // ok: guarantee the release of the memory-allocated for 9"
msgstr""

# CppCoreGuidelines.md:5295
msgid "5295            if (0 < i) return;              // maybe return and leak"
msgstr""

# CppCoreGuidelines.md:5296
msgid "5296            delete p;                       // too late"
msgstr""

# CppCoreGuidelines.md:5297
msgid "5297        }"
msgstr""

       
# CppCoreGuidelines.md:5298
msgid "5298    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5299
msgid "5299    * Flag initialization of a naked pointer with the result of a `new`"
msgstr""

# CppCoreGuidelines.md:5300
msgid "5300    * Flag `delete` of local variable"
msgstr""

       
# CppCoreGuidelines.md:5301
msgid "5301    ### <a name=\"Rh-make_unique\"></a>C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s"
msgstr""

       
# CppCoreGuidelines.md:5302
msgid "5302    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5303
msgid "5303     `make_unique` gives a more concise statement of the construction."
msgstr""

# CppCoreGuidelines.md:5304
msgid "5304    It also ensures exception safety in complex expressions."
msgstr""

       
# CppCoreGuidelines.md:5305
msgid "5305    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5306
msgid "5306        unique_ptr<Foo> p {new<Foo>{7}};   // OK: but repetitive"
msgstr""

       
# CppCoreGuidelines.md:5307
msgid "5307        auto q = make_unique<Foo>(7);      // Better: no repetition of Foo"
msgstr""

       
# CppCoreGuidelines.md:5308
msgid "5308        // Not exception-safe: the compiler may interleave the computations of arguments as follows:"
msgstr""

# CppCoreGuidelines.md:5309
msgid "5309        //"
msgstr""

# CppCoreGuidelines.md:5310
msgid "5310        // 1. allocate memory for Foo,"
msgstr""

# CppCoreGuidelines.md:5311
msgid "5311        // 2. construct Foo,"
msgstr""

# CppCoreGuidelines.md:5312
msgid "5312        // 3. call bar,"
msgstr""

# CppCoreGuidelines.md:5313
msgid "5313        // 4. construct unique_ptr<Foo>."
msgstr""

# CppCoreGuidelines.md:5314
msgid "5314        //"
msgstr""

# CppCoreGuidelines.md:5315
msgid "5315        // If bar throws, Foo will not be destroyed, and the memory-allocated for it will leak."
msgstr""

# CppCoreGuidelines.md:5316
msgid "5316        f(unique_ptr<Foo>(new Foo()), bar());"
msgstr""

       
# CppCoreGuidelines.md:5317
msgid "5317        // Exception-safe: calls to functions are never interleaved."
msgstr""

# CppCoreGuidelines.md:5318
msgid "5318        f(make_unique<Foo>(), bar());"
msgstr""

       
# CppCoreGuidelines.md:5319
msgid "5319    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5320
msgid "5320    * Flag the repetitive usage of template specialization list `<Foo>`"
msgstr""

# CppCoreGuidelines.md:5321
msgid "5321    * Flag variables declared to be `unique_ptr<Foo>`"
msgstr""

       
# CppCoreGuidelines.md:5322
msgid "5322    ### <a name=\"Rh-make_shared\"></a>C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s"
msgstr""

       
# CppCoreGuidelines.md:5323
msgid "5323    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5324
msgid "5324     `make_shared` gives a more concise statement of the construction."
msgstr""

# CppCoreGuidelines.md:5325
msgid "5325    It also gives an opportunity to eliminate a separate allocation for the reference counts, by placing the `shared_ptr`'s use counts next to its object."
msgstr""

       
# CppCoreGuidelines.md:5326
msgid "5326    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5327
msgid "5327        void test() {"
msgstr""

# CppCoreGuidelines.md:5328
msgid "5328            // OK: but repetitive; and separate allocations for the Bar and shared_ptr's use count"
msgstr""

# CppCoreGuidelines.md:5329
msgid "5329            shared_ptr<Bar> p {new<Bar>{7}};"
msgstr""

       
# CppCoreGuidelines.md:5330
msgid "5330            auto q = make_shared<Bar>(7);   // Better: no repetition of Bar; one object"
msgstr""

# CppCoreGuidelines.md:5331
msgid "5331        }"
msgstr""

       
# CppCoreGuidelines.md:5332
msgid "5332    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5333
msgid "5333    * Flag the repetitive usage of template specialization list`<Bar>`"
msgstr""

# CppCoreGuidelines.md:5334
msgid "5334    * Flag variables declared to be `shared_ptr<Bar>`"
msgstr""

       
# CppCoreGuidelines.md:5335
msgid "5335    ### <a name=\"Rh-array\"></a>C.152: Never assign a pointer to an array of derived class objects to a pointer to its base"
msgstr""

       
# CppCoreGuidelines.md:5336
msgid "5336    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5337
msgid "5337    Subscripting the resulting base pointer will lead to invalid object access and probably to memory corruption."
msgstr""

       
# CppCoreGuidelines.md:5338
msgid "5338    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5339
msgid "5339        struct B { int x; };"
msgstr""

# CppCoreGuidelines.md:5340
msgid "5340        struct D : B { int y; };"
msgstr""

       
# CppCoreGuidelines.md:5341
msgid "5341        void use(B*);"
msgstr""

       
# CppCoreGuidelines.md:5342
msgid "5342        D a[] = {{1, 2}, {3, 4}, {5, 6}};"
msgstr""

# CppCoreGuidelines.md:5343
msgid "5343        B* p = a;     // bad: a decays to &a[0] which is converted to a B*"
msgstr""

# CppCoreGuidelines.md:5344
msgid "5344        p[1].x = 7;   // overwrite D[0].y"
msgstr""

       
# CppCoreGuidelines.md:5345
msgid "5345        use(a);       // bad: a decays to &a[0] which is converted to a B*"
msgstr""

       
# CppCoreGuidelines.md:5346
msgid "5346    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5347
msgid "5347    * Flag all combinations of array decay and base to derived conversions."
msgstr""

# CppCoreGuidelines.md:5348
msgid "5348    * Pass an array as a `span` rather than as a pointer, and don't let the array name suffer a derived-to-base conversion before getting into the `span`"
msgstr""

       
       
# CppCoreGuidelines.md:5349
msgid "5349    ### <a name=\"Rh-use-virtual\"></a>C.153: Prefer virtual function to casting"
msgstr""

       
# CppCoreGuidelines.md:5350
msgid "5350    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5351
msgid "5351    A virtual function call is safe, whereas casting is error-prone."
msgstr""

# CppCoreGuidelines.md:5352
msgid "5352    A virtual function call reaches the most derived function, whereas a cast may reach an intermediate class and therefore"
msgstr""

# CppCoreGuidelines.md:5353
msgid "5353    give a wrong result (especially as a hierarchy is modified during maintenance)."
msgstr""

       
# CppCoreGuidelines.md:5354
msgid "5354    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5355
msgid "5355        ???"
msgstr""

       
# CppCoreGuidelines.md:5356
msgid "5356    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5357
msgid "5357    See [C.146](#Rh-dynamic_cast) and ???"
msgstr""

       
# CppCoreGuidelines.md:5358
msgid "5358    ## <a name=\"SS-overload\"></a>C.over: Overloading and overloaded operators"
msgstr""

       
# CppCoreGuidelines.md:5359
msgid "5359    You can overload ordinary functions, template functions, and operators."
msgstr""

# CppCoreGuidelines.md:5360
msgid "5360    You cannot overload function objects."
msgstr""

       
# CppCoreGuidelines.md:5361
msgid "5361    Overload rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5362
msgid "5362    * [C.160: Define operators primarily to mimic conventional usage](#Ro-conventional)"
msgstr""

# CppCoreGuidelines.md:5363
msgid "5363    * [C.161: Use nonmember functions for symmetric operators](#Ro-symmetric)"
msgstr""

# CppCoreGuidelines.md:5364
msgid "5364    * [C.162: Overload operations that are roughly equivalent](#Ro-equivalent)"
msgstr""

# CppCoreGuidelines.md:5365
msgid "5365    * [C.163: Overload only for operations that are roughly equivalent](#Ro-equivalent-2)"
msgstr""

# CppCoreGuidelines.md:5366
msgid "5366    * [C.164: Avoid conversion operators](#Ro-conversion)"
msgstr""

# CppCoreGuidelines.md:5367
msgid "5367    * [C.165: Use `using` for customization points](#Ro-custom)"
msgstr""

# CppCoreGuidelines.md:5368
msgid "5368    * [C.166: Overload unary `&` only as part of a system of smart pointers and references](#Ro-address-of)"
msgstr""

# CppCoreGuidelines.md:5369
msgid "5369    * [C.167: Use an operator for an operation with its conventional meaning](#Ro-overload)"
msgstr""

# CppCoreGuidelines.md:5370
msgid "5370    * [C.168: Define overloaded operators in the namespace of their operands](#Ro-namespace)"
msgstr""

# CppCoreGuidelines.md:5371
msgid "5371    * [C.170: If you feel like overloading a lambda, use a generic lambda](#Ro-lambda)"
msgstr""

       
# CppCoreGuidelines.md:5372
msgid "5372    ### <a name=\"Ro-conventional\"></a>C.160: Define operators primarily to mimic conventional usage"
msgstr""

       
# CppCoreGuidelines.md:5373
msgid "5373    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5374
msgid "5374    Minimize surprises."
msgstr""

       
# CppCoreGuidelines.md:5375
msgid "5375    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5376
msgid "5376        class X {"
msgstr""

# CppCoreGuidelines.md:5377
msgid "5377        public:"
msgstr""

# CppCoreGuidelines.md:5378
msgid "5378            // ..."
msgstr""

# CppCoreGuidelines.md:5379
msgid "5379            X& operator=(const X&); // member function defining assignment"
msgstr""

# CppCoreGuidelines.md:5380
msgid "5380            friend bool operator==(const X&, const X&); // == needs access to representation"
msgstr""

# CppCoreGuidelines.md:5381
msgid "5381                                                        // after a = b we have a == b"
msgstr""

# CppCoreGuidelines.md:5382
msgid "5382            // ..."
msgstr""

# CppCoreGuidelines.md:5383
msgid "5383        };"
msgstr""

       
# CppCoreGuidelines.md:5384
msgid "5384    Here, the conventional semantics is maintained: [Copies compare equal](#SS-copy)."
msgstr""

       
# CppCoreGuidelines.md:5385
msgid "5385    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5386
msgid "5386        X operator+(X a, X b) { return a.v - b.v; }   // bad: makes + subtract"
msgstr""

       
# CppCoreGuidelines.md:5387
msgid "5387    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5388
msgid "5388    Nonmember operators should be either friends or defined in [the same namespace as their operands](#Ro-namespace)."
msgstr""

# CppCoreGuidelines.md:5389
msgid "5389    [Binary operators should treat their operands equivalently](#Ro-symmetric)."
msgstr""

       
# CppCoreGuidelines.md:5390
msgid "5390    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5391
msgid "5391    Possibly impossible."
msgstr""

       
# CppCoreGuidelines.md:5392
msgid "5392    ### <a name=\"Ro-symmetric\"></a>C.161: Use nonmember functions for symmetric operators"
msgstr""

       
# CppCoreGuidelines.md:5393
msgid "5393    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5394
msgid "5394    If you use member functions, you need two."
msgstr""

# CppCoreGuidelines.md:5395
msgid "5395    Unless you use a nonmember function for (say) `==`, `a == b` and `b == a` will be subtly different."
msgstr""

       
# CppCoreGuidelines.md:5396
msgid "5396    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5397
msgid "5397        bool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; }"
msgstr""

       
# CppCoreGuidelines.md:5398
msgid "5398    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5399
msgid "5399    Flag member operator functions."
msgstr""

       
# CppCoreGuidelines.md:5400
msgid "5400    ### <a name=\"Ro-equivalent\"></a>C.162: Overload operations that are roughly equivalent"
msgstr""

       
# CppCoreGuidelines.md:5401
msgid "5401    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5402
msgid "5402    Having different names for logically equivalent operations on different argument types is confusing, leads to encoding type information in function names, and inhibits generic programming."
msgstr""

       
# CppCoreGuidelines.md:5403
msgid "5403    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5404
msgid "5404    Consider:"
msgstr""

       
# CppCoreGuidelines.md:5405
msgid "5405        void print(int a);"
msgstr""

# CppCoreGuidelines.md:5406
msgid "5406        void print(int a, int base);"
msgstr""

# CppCoreGuidelines.md:5407
msgid "5407        void print(const string&);"
msgstr""

       
# CppCoreGuidelines.md:5408
msgid "5408    These three functions all print their arguments (appropriately). Conversely:"
msgstr""

       
# CppCoreGuidelines.md:5409
msgid "5409        void print_int(int a);"
msgstr""

# CppCoreGuidelines.md:5410
msgid "5410        void print_based(int a, int base);"
msgstr""

# CppCoreGuidelines.md:5411
msgid "5411        void print_string(const string&);"
msgstr""

       
# CppCoreGuidelines.md:5412
msgid "5412    These three functions all print their arguments (appropriately). Adding to the name just introduced verbosity and inhibits generic code."
msgstr""

       
# CppCoreGuidelines.md:5413
msgid "5413    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5414
msgid "5414    ???"
msgstr""

       
# CppCoreGuidelines.md:5415
msgid "5415    ### <a name=\"Ro-equivalent-2\"></a>C.163: Overload only for operations that are roughly equivalent"
msgstr""

       
# CppCoreGuidelines.md:5416
msgid "5416    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5417
msgid "5417    Having the same name for logically different functions is confusing and leads to errors when using generic programming."
msgstr""

       
# CppCoreGuidelines.md:5418
msgid "5418    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5419
msgid "5419    Consider:"
msgstr""

       
# CppCoreGuidelines.md:5420
msgid "5420        void open_gate(Gate& g);   // remove obstacle from garage exit lane"
msgstr""

# CppCoreGuidelines.md:5421
msgid "5421        void fopen(const char* name, const char* mode);   // open file"
msgstr""

       
# CppCoreGuidelines.md:5422
msgid "5422    The two operations are fundamentally different (and unrelated) so it is good that their names differ. Conversely:"
msgstr""

       
# CppCoreGuidelines.md:5423
msgid "5423        void open(Gate& g);   // remove obstacle from garage exit lane"
msgstr""

# CppCoreGuidelines.md:5424
msgid "5424        void open(const char* name, const char* mode =\"r\");   // open file"
msgstr""

       
# CppCoreGuidelines.md:5425
msgid "5425    The two operations are still fundamentally different (and unrelated) but the names have been reduced to their (common) minimum, opening opportunities for confusion."
msgstr""

# CppCoreGuidelines.md:5426
msgid "5426    Fortunately, the type system will catch many such mistakes."
msgstr""

       
# CppCoreGuidelines.md:5427
msgid "5427    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5428
msgid "5428    Be particularly careful about common and popular names, such as `open`, `move`, `+`, and `==`."
msgstr""

       
# CppCoreGuidelines.md:5429
msgid "5429    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5430
msgid "5430    ???"
msgstr""

       
# CppCoreGuidelines.md:5431
msgid "5431    ### <a name=\"Ro-conversion\"></a>C.164: Avoid conversion operators"
msgstr""

       
# CppCoreGuidelines.md:5432
msgid "5432    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5433
msgid "5433    Implicit conversions can be essential (e.g., `double` to `int`) but often cause surprises (e.g., `String` to C-style string)."
msgstr""

       
# CppCoreGuidelines.md:5434
msgid "5434    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5435
msgid "5435    Prefer explicitly named conversions until a serious need is demonstrated."
msgstr""

# CppCoreGuidelines.md:5436
msgid "5436    By \"serious need\" we mean a reason that is fundamental in the application domain (such as an integer to complex number conversion)"
msgstr""

# CppCoreGuidelines.md:5437
msgid "5437    and frequently needed. Do not introduce implicit conversions (through conversion operators or non-`explicit` constructors)"
msgstr""

# CppCoreGuidelines.md:5438
msgid "5438    just to gain a minor convenience."
msgstr""

       
# CppCoreGuidelines.md:5439
msgid "5439    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5440
msgid "5440        class String {   // handle ownership and access to a sequence of characters"
msgstr""

# CppCoreGuidelines.md:5441
msgid "5441            // ..."
msgstr""

# CppCoreGuidelines.md:5442
msgid "5442            String(czstring p); // copy from *p to *(this->elem)"
msgstr""

# CppCoreGuidelines.md:5443
msgid "5443            // ..."
msgstr""

# CppCoreGuidelines.md:5444
msgid "5444            operator zstring() { return elem; }"
msgstr""

# CppCoreGuidelines.md:5445
msgid "5445            // ..."
msgstr""

# CppCoreGuidelines.md:5446
msgid "5446        };"
msgstr""

       
# CppCoreGuidelines.md:5447
msgid "5447        void user(zstring p)"
msgstr""

# CppCoreGuidelines.md:5448
msgid "5448        {"
msgstr""

# CppCoreGuidelines.md:5449
msgid "5449            if (*p == \"\") {"
msgstr""

# CppCoreGuidelines.md:5450
msgid "5450                String s {\"Trouble ahead!\"};"
msgstr""

# CppCoreGuidelines.md:5451
msgid "5451                // ..."
msgstr""

# CppCoreGuidelines.md:5452
msgid "5452                p = s;"
msgstr""

# CppCoreGuidelines.md:5453
msgid "5453            }"
msgstr""

# CppCoreGuidelines.md:5454
msgid "5454            // use p"
msgstr""

# CppCoreGuidelines.md:5455
msgid "5455        }"
msgstr""

       
# CppCoreGuidelines.md:5456
msgid "5456    The string allocated for `s` and assigned to `p` is destroyed before it can be used."
msgstr""

       
# CppCoreGuidelines.md:5457
msgid "5457    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5458
msgid "5458    Flag all conversion operators."
msgstr""

       
# CppCoreGuidelines.md:5459
msgid "5459    ### <a name=\"Ro-custom\"></a>C.165: Use `using` for customization points"
msgstr""

       
# CppCoreGuidelines.md:5460
msgid "5460    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5461
msgid "5461    To find function objects and functions defined in a separate namespace to \"customize\" a common function."
msgstr""

       
# CppCoreGuidelines.md:5462
msgid "5462    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5463
msgid "5463    Consider `swap`. It is a general (standard-library) function with a definition that will work for just about any type."
msgstr""

# CppCoreGuidelines.md:5464
msgid "5464    However, it is desirable to define specific `swap()`s for specific types."
msgstr""

# CppCoreGuidelines.md:5465
msgid "5465    For example, the general `swap()` will copy the elements of two `vector`s being swapped, whereas a good specific implementation will not copy elements at all."
msgstr""

       
# CppCoreGuidelines.md:5466
msgid "5466        namespace N {"
msgstr""

# CppCoreGuidelines.md:5467
msgid "5467            My_type X { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:5468
msgid "5468            void swap(X&, X&);   // optimized swap for N::X"
msgstr""

# CppCoreGuidelines.md:5469
msgid "5469            // ..."
msgstr""

# CppCoreGuidelines.md:5470
msgid "5470        }"
msgstr""

       
# CppCoreGuidelines.md:5471
msgid "5471        void f1(N::X& a, N::X& b)"
msgstr""

# CppCoreGuidelines.md:5472
msgid "5472        {"
msgstr""

# CppCoreGuidelines.md:5473
msgid "5473            std::swap(a, b);   // probably not what we wanted: calls std::swap()"
msgstr""

# CppCoreGuidelines.md:5474
msgid "5474        }"
msgstr""

       
# CppCoreGuidelines.md:5475
msgid "5475    The `std::swap()` in `f1()` does exactly what we asked it to do: it calls the `swap()` in namespace `std`."
msgstr""

# CppCoreGuidelines.md:5476
msgid "5476    Unfortunately, that's probably not what we wanted."
msgstr""

# CppCoreGuidelines.md:5477
msgid "5477    How do we get `N::X` considered?"
msgstr""

       
# CppCoreGuidelines.md:5478
msgid "5478        void f2(N::X& a, N::X& b)"
msgstr""

# CppCoreGuidelines.md:5479
msgid "5479        {"
msgstr""

# CppCoreGuidelines.md:5480
msgid "5480            swap(a, b);   // calls N::swap"
msgstr""

# CppCoreGuidelines.md:5481
msgid "5481        }"
msgstr""

       
# CppCoreGuidelines.md:5482
msgid "5482    But that may not be what we wanted for generic code."
msgstr""

# CppCoreGuidelines.md:5483
msgid "5483    There, we typically want the specific function if it exists and the general function if not."
msgstr""

# CppCoreGuidelines.md:5484
msgid "5484    This is done by including the general function in the lookup for the function:"
msgstr""

       
# CppCoreGuidelines.md:5485
msgid "5485        void f3(N::X& a, N::X& b)"
msgstr""

# CppCoreGuidelines.md:5486
msgid "5486        {"
msgstr""

# CppCoreGuidelines.md:5487
msgid "5487            using std::swap;  // make std::swap available"
msgstr""

# CppCoreGuidelines.md:5488
msgid "5488            swap(a, b);        // calls N::swap if it exists, otherwise std::swap"
msgstr""

# CppCoreGuidelines.md:5489
msgid "5489        }"
msgstr""

       
# CppCoreGuidelines.md:5490
msgid "5490    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5491
msgid "5491    Unlikely, except for known customization points, such as `swap`."
msgstr""

# CppCoreGuidelines.md:5492
msgid "5492    The problem is that the unqualified and qualified lookups both have uses."
msgstr""

       
# CppCoreGuidelines.md:5493
msgid "5493    ### <a name=\"Ro-address-of\"></a>C.166: Overload unary `&` only as part of a system of smart pointers and references"
msgstr""

       
# CppCoreGuidelines.md:5494
msgid "5494    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5495
msgid "5495    The `&` operator is fundamental in C++."
msgstr""

# CppCoreGuidelines.md:5496
msgid "5496    Many parts of the C++ semantics assumes its default meaning."
msgstr""

       
# CppCoreGuidelines.md:5497
msgid "5497    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5498
msgid "5498        class Ptr { // a somewhat smart pointer"
msgstr""

# CppCoreGuidelines.md:5499
msgid "5499            Ptr(X* pp) :p(pp) { /* check */ }"
msgstr""

# CppCoreGuidelines.md:5500
msgid "5500            X* operator->() { /* check */ return p; }"
msgstr""

# CppCoreGuidelines.md:5501
msgid "5501            X operator[](int i);"
msgstr""

# CppCoreGuidelines.md:5502
msgid "5502            X operator*();"
msgstr""

# CppCoreGuidelines.md:5503
msgid "5503        private:"
msgstr""

# CppCoreGuidelines.md:5504
msgid "5504            T* p;"
msgstr""

# CppCoreGuidelines.md:5505
msgid "5505        };"
msgstr""

       
# CppCoreGuidelines.md:5506
msgid "5506        class X {"
msgstr""

# CppCoreGuidelines.md:5507
msgid "5507            Ptr operator&() { return Ptr{this}; }"
msgstr""

# CppCoreGuidelines.md:5508
msgid "5508            // ..."
msgstr""

# CppCoreGuidelines.md:5509
msgid "5509        };"
msgstr""

       
# CppCoreGuidelines.md:5510
msgid "5510    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5511
msgid "5511    If you \"mess with\" operator `&` be sure that its definition has matching meanings for `->`, `[]`, `*`, and `.` on the result type."
msgstr""

# CppCoreGuidelines.md:5512
msgid "5512    Note that operator `.` currently cannot be overloaded so a perfect system is impossible."
msgstr""

# CppCoreGuidelines.md:5513
msgid "5513    We hope to remedy that: <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf>."
msgstr""

# CppCoreGuidelines.md:5514
msgid "5514    Note that `std::addressof()` always yields a built-in pointer."
msgstr""

       
# CppCoreGuidelines.md:5515
msgid "5515    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5516
msgid "5516    Tricky. Warn if `&` is user-defined without also defining `->` for the result type."
msgstr""

       
# CppCoreGuidelines.md:5517
msgid "5517    ### <a name=\"Ro-overload\"></a>C.167: Use an operator for an operation with its conventional meaning"
msgstr""

       
# CppCoreGuidelines.md:5518
msgid "5518    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5519
msgid "5519    Readability. Convention. Reusability. Support for generic code"
msgstr""

       
# CppCoreGuidelines.md:5520
msgid "5520    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5521
msgid "5521        void cout_my_class(const My_class& c) // confusing, not conventional,not generic"
msgstr""

# CppCoreGuidelines.md:5522
msgid "5522        {"
msgstr""

# CppCoreGuidelines.md:5523
msgid "5523            std::cout << /* class members here */;"
msgstr""

# CppCoreGuidelines.md:5524
msgid "5524        }"
msgstr""

       
# CppCoreGuidelines.md:5525
msgid "5525        std::ostream& operator<<(std::ostream& os, const my_class& c) // OK"
msgstr""

# CppCoreGuidelines.md:5526
msgid "5526        {"
msgstr""

# CppCoreGuidelines.md:5527
msgid "5527            return os << /* class members here */;"
msgstr""

# CppCoreGuidelines.md:5528
msgid "5528        }"
msgstr""

       
# CppCoreGuidelines.md:5529
msgid "5529    By itself, `cout_my_class` would be OK, but it is not usable/composable with code that rely on the `<<` convention for output:"
msgstr""

       
# CppCoreGuidelines.md:5530
msgid "5530        My_class var { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:5531
msgid "5531        // ..."
msgstr""

# CppCoreGuidelines.md:5532
msgid "5532        cout << \"var = \" << var << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:5533
msgid "5533    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5534
msgid "5534    There are strong and vigorous conventions for the meaning most operators, such as"
msgstr""

       
# CppCoreGuidelines.md:5535
msgid "5535    * comparisons (`==`, `!=`, `<`, `<=`, `>`, and `>=`),"
msgstr""

# CppCoreGuidelines.md:5536
msgid "5536    * arithmetic operations (`+`, `-`, `*`, `/`, and `%`)"
msgstr""

# CppCoreGuidelines.md:5537
msgid "5537    * access operations (`.`, `->`, unary `*`, and `[]`)"
msgstr""

# CppCoreGuidelines.md:5538
msgid "5538    * assignment (`=`)"
msgstr""

       
# CppCoreGuidelines.md:5539
msgid "5539    Don't define those unconventionally and don't invent your own names for them."
msgstr""

       
# CppCoreGuidelines.md:5540
msgid "5540    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5541
msgid "5541    Tricky. Requires semantic insight."
msgstr""

       
# CppCoreGuidelines.md:5542
msgid "5542    ### <a name=\"Ro-namespace\"></a>C.168: Define overloaded operators in the namespace of their operands"
msgstr""

       
# CppCoreGuidelines.md:5543
msgid "5543    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5544
msgid "5544    Readability."
msgstr""

# CppCoreGuidelines.md:5545
msgid "5545    Ability for find operators using ADL."
msgstr""

# CppCoreGuidelines.md:5546
msgid "5546    Avoiding inconsistent definition in different namespaces"
msgstr""

       
# CppCoreGuidelines.md:5547
msgid "5547    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5548
msgid "5548        struct S { };"
msgstr""

# CppCoreGuidelines.md:5549
msgid "5549        bool operator==(S, S);   // OK: in the same namespace as S, and even next to S"
msgstr""

# CppCoreGuidelines.md:5550
msgid "5550        S s;"
msgstr""

       
# CppCoreGuidelines.md:5551
msgid "5551        bool x = (s == s);"
msgstr""

       
# CppCoreGuidelines.md:5552
msgid "5552    This is what a default `==` would do, if we had such defaults."
msgstr""

       
# CppCoreGuidelines.md:5553
msgid "5553    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5554
msgid "5554        namespace N {"
msgstr""

# CppCoreGuidelines.md:5555
msgid "5555            struct S { };"
msgstr""

# CppCoreGuidelines.md:5556
msgid "5556            bool operator==(S, S);   // OK: in the same namespace as S, and even next to S"
msgstr""

# CppCoreGuidelines.md:5557
msgid "5557        }"
msgstr""

       
# CppCoreGuidelines.md:5558
msgid "5558        N::S s;"
msgstr""

       
# CppCoreGuidelines.md:5559
msgid "5559        bool x = (s == s);  // finds N::operator==() by ADL"
msgstr""

       
# CppCoreGuidelines.md:5560
msgid "5560    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5561
msgid "5561        struct S { };"
msgstr""

# CppCoreGuidelines.md:5562
msgid "5562        S s;"
msgstr""

       
# CppCoreGuidelines.md:5563
msgid "5563        namespace N {"
msgstr""

# CppCoreGuidelines.md:5564
msgid "5564            S::operator!(S a) { return true; }"
msgstr""

# CppCoreGuidelines.md:5565
msgid "5565            S not_s = !s;"
msgstr""

# CppCoreGuidelines.md:5566
msgid "5566        }"
msgstr""

       
# CppCoreGuidelines.md:5567
msgid "5567        namespace M {"
msgstr""

# CppCoreGuidelines.md:5568
msgid "5568            S::operator!(S a) { return false; }"
msgstr""

# CppCoreGuidelines.md:5569
msgid "5569            S not_s = !s;"
msgstr""

# CppCoreGuidelines.md:5570
msgid "5570        }"
msgstr""

       
# CppCoreGuidelines.md:5571
msgid "5571    Here, the meaning of `!s` differs in `N` and `M`."
msgstr""

# CppCoreGuidelines.md:5572
msgid "5572    This can be most confusing."
msgstr""

# CppCoreGuidelines.md:5573
msgid "5573    Remove the definition of `namespace M` and the confusion is replaced by an opportunity to make the mistake."
msgstr""

       
# CppCoreGuidelines.md:5574
msgid "5574    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5575
msgid "5575    If a binary operator is defined for two types that are defined in different namespaces, you cannot follow this rule."
msgstr""

# CppCoreGuidelines.md:5576
msgid "5576    For example:"
msgstr""

       
# CppCoreGuidelines.md:5577
msgid "5577        Vec::Vector operator*(const Vec::Vector&, const Mat::Matrix&);"
msgstr""

       
# CppCoreGuidelines.md:5578
msgid "5578    This may be something best avoided."
msgstr""

       
# CppCoreGuidelines.md:5579
msgid "5579    ##### See also"
msgstr""

       
# CppCoreGuidelines.md:5580
msgid "5580    This is a special case of the rule that [helper functions should be defined in the same namespace as their class](#Rc-helper)."
msgstr""

       
# CppCoreGuidelines.md:5581
msgid "5581    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5582
msgid "5582    * Flag operator definitions that are not it the namespace of their operands"
msgstr""

       
# CppCoreGuidelines.md:5583
msgid "5583    ### <a name=\"Ro-lambda\"></a>C.170: If you feel like overloading a lambda, use a generic lambda"
msgstr""

       
# CppCoreGuidelines.md:5584
msgid "5584    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5585
msgid "5585    You cannot overload by defining two different lambdas with the same name."
msgstr""

       
# CppCoreGuidelines.md:5586
msgid "5586    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5587
msgid "5587        void f(int);"
msgstr""

# CppCoreGuidelines.md:5588
msgid "5588        void f(double);"
msgstr""

# CppCoreGuidelines.md:5589
msgid "5589        auto f = [](char);   // error: cannot overload variable and function"
msgstr""

       
# CppCoreGuidelines.md:5590
msgid "5590        auto g = [](int) { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:5591
msgid "5591        auto g = [](double) { /* ... */ };   // error: cannot overload variables"
msgstr""

       
# CppCoreGuidelines.md:5592
msgid "5592        auto h = [](auto) { /* ... */ };   // OK"
msgstr""

       
# CppCoreGuidelines.md:5593
msgid "5593    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5594
msgid "5594    The compiler catches the attempt to overload a lambda."
msgstr""

       
# CppCoreGuidelines.md:5595
msgid "5595    ## <a name=\"SS-union\"></a>C.union: Unions"
msgstr""

       
# CppCoreGuidelines.md:5596
msgid "5596    A `union` is a `struct` where all members start at the same address so that it can hold only one member at a time."
msgstr""

# CppCoreGuidelines.md:5597
msgid "5597    A `union` does not keep track of which member is stored so the programmer has to get it right;"
msgstr""

# CppCoreGuidelines.md:5598
msgid "5598    this is inherently error-prone, but there are ways to compensate."
msgstr""

       
# CppCoreGuidelines.md:5599
msgid "5599    A type that is a `union` plus an indicator of which member is currently held is called a *tagged union*, a *discriminated union*, or a *variant*."
msgstr""

       
# CppCoreGuidelines.md:5600
msgid "5600    Union rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5601
msgid "5601    * [C.180: Use `union`s to save Memory](#Ru-union)"
msgstr""

# CppCoreGuidelines.md:5602
msgid "5602    * [C.181: Avoid \"naked\" `union`s](#Ru-naked)"
msgstr""

# CppCoreGuidelines.md:5603
msgid "5603    * [C.182: Use anonymous `union`s to implement tagged unions](#Ru-anonymous)"
msgstr""

# CppCoreGuidelines.md:5604
msgid "5604    * [C.183: Don't use a `union` for type punning](#Ru-pun)"
msgstr""

# CppCoreGuidelines.md:5605
msgid "5605    * ???"
msgstr""

       
# CppCoreGuidelines.md:5606
msgid "5606    ### <a name=\"Ru-union\"></a>C.180: Use `union`s to save memory"
msgstr""

       
# CppCoreGuidelines.md:5607
msgid "5607    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5608
msgid "5608    A `union` allows a single piece of memory to be used for different types of objects at different times."
msgstr""

# CppCoreGuidelines.md:5609
msgid "5609    Consequently, it can be used to save memory when we have several objects that are never used at the same time."
msgstr""

       
# CppCoreGuidelines.md:5610
msgid "5610    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5611
msgid "5611        union Value {"
msgstr""

# CppCoreGuidelines.md:5612
msgid "5612            int x;"
msgstr""

# CppCoreGuidelines.md:5613
msgid "5613            double d;"
msgstr""

# CppCoreGuidelines.md:5614
msgid "5614        };"
msgstr""

       
# CppCoreGuidelines.md:5615
msgid "5615        Value v = { 123 };  // now v holds an int"
msgstr""

# CppCoreGuidelines.md:5616
msgid "5616        cout << v.x << '\\n';    // write 123"
msgstr""

# CppCoreGuidelines.md:5617
msgid "5617        v.d = 987.654;  // now v holds a double"
msgstr""

# CppCoreGuidelines.md:5618
msgid "5618        cout << v.d << '\\n';    // write 987.654"
msgstr""

       
# CppCoreGuidelines.md:5619
msgid "5619    But heed the warning: [Avoid \"naked\" `union`s](#Ru-naked)"
msgstr""

       
# CppCoreGuidelines.md:5620
msgid "5620    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5621
msgid "5621        // Short-string optimization"
msgstr""

       
# CppCoreGuidelines.md:5622
msgid "5622        constexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer"
msgstr""

       
# CppCoreGuidelines.md:5623
msgid "5623        class Immutable_string {"
msgstr""

# CppCoreGuidelines.md:5624
msgid "5624        public:"
msgstr""

# CppCoreGuidelines.md:5625
msgid "5625            Immutable_string(const char* str) :"
msgstr""

# CppCoreGuidelines.md:5626
msgid "5626                size(strlen(str))"
msgstr""

# CppCoreGuidelines.md:5627
msgid "5627            {"
msgstr""

# CppCoreGuidelines.md:5628
msgid "5628                if (size < buffer_size)"
msgstr""

# CppCoreGuidelines.md:5629
msgid "5629                    strcpy_s(string_buffer, buffer_size, str);"
msgstr""

# CppCoreGuidelines.md:5630
msgid "5630                else {"
msgstr""

# CppCoreGuidelines.md:5631
msgid "5631                    string_ptr = new char[size + 1];"
msgstr""

# CppCoreGuidelines.md:5632
msgid "5632                    strcpy_s(string_ptr, size + 1, str);"
msgstr""

# CppCoreGuidelines.md:5633
msgid "5633                }"
msgstr""

# CppCoreGuidelines.md:5634
msgid "5634            }"
msgstr""

       
# CppCoreGuidelines.md:5635
msgid "5635            ~Immutable_string()"
msgstr""

# CppCoreGuidelines.md:5636
msgid "5636            {"
msgstr""

# CppCoreGuidelines.md:5637
msgid "5637                if (size >= buffer_size)"
msgstr""

# CppCoreGuidelines.md:5638
msgid "5638                    delete string_ptr;"
msgstr""

# CppCoreGuidelines.md:5639
msgid "5639            }"
msgstr""

       
# CppCoreGuidelines.md:5640
msgid "5640            const char* get_str() const"
msgstr""

# CppCoreGuidelines.md:5641
msgid "5641            {"
msgstr""

# CppCoreGuidelines.md:5642
msgid "5642                return (size < buffer_size) ? string_buffer : string_ptr;"
msgstr""

# CppCoreGuidelines.md:5643
msgid "5643            }"
msgstr""

       
# CppCoreGuidelines.md:5644
msgid "5644        private:"
msgstr""

# CppCoreGuidelines.md:5645
msgid "5645            // If the string is short enough, we store the string itself"
msgstr""

# CppCoreGuidelines.md:5646
msgid "5646            // instead of a pointer to the string."
msgstr""

# CppCoreGuidelines.md:5647
msgid "5647            union {"
msgstr""

# CppCoreGuidelines.md:5648
msgid "5648                char* string_ptr;"
msgstr""

# CppCoreGuidelines.md:5649
msgid "5649                char string_buffer[buffer_size];"
msgstr""

# CppCoreGuidelines.md:5650
msgid "5650            };"
msgstr""

       
# CppCoreGuidelines.md:5651
msgid "5651            const size_t size;"
msgstr""

# CppCoreGuidelines.md:5652
msgid "5652        };"
msgstr""

       
# CppCoreGuidelines.md:5653
msgid "5653    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5654
msgid "5654    ???"
msgstr""

       
# CppCoreGuidelines.md:5655
msgid "5655    ### <a name=\"Ru-naked\"></a>C.181: Avoid \"naked\" `union`s"
msgstr""

       
# CppCoreGuidelines.md:5656
msgid "5656    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5657
msgid "5657    A *naked union* is a union without an associated indicator which member (if any) it holds,"
msgstr""

# CppCoreGuidelines.md:5658
msgid "5658    so that the programmer has to keep track."
msgstr""

# CppCoreGuidelines.md:5659
msgid "5659    Naked unions are a source of type errors."
msgstr""

       
# CppCoreGuidelines.md:5660
msgid "5660    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5661
msgid "5661        union Value {"
msgstr""

# CppCoreGuidelines.md:5662
msgid "5662            int x;"
msgstr""

# CppCoreGuidelines.md:5663
msgid "5663            double d;"
msgstr""

# CppCoreGuidelines.md:5664
msgid "5664        };"
msgstr""

       
# CppCoreGuidelines.md:5665
msgid "5665        Value v;"
msgstr""

# CppCoreGuidelines.md:5666
msgid "5666        v.d = 987.654;  // v holds a double"
msgstr""

       
# CppCoreGuidelines.md:5667
msgid "5667    So far, so good, but we can easily misuse the `union`:"
msgstr""

       
# CppCoreGuidelines.md:5668
msgid "5668        cout << v.x << '\\n';    // BAD, undefined behavior: v holds a double, but we read it as an int"
msgstr""

       
# CppCoreGuidelines.md:5669
msgid "5669    Note that the type error happened without any explicit cast."
msgstr""

# CppCoreGuidelines.md:5670
msgid "5670    When we tested that program the last value printed was `1683627180` which it the integer value for the bit pattern for `987.654`."
msgstr""

# CppCoreGuidelines.md:5671
msgid "5671    What we have here is an \"invisible\" type error that happens to give a result that could easily look innocent."
msgstr""

       
# CppCoreGuidelines.md:5672
msgid "5672    And, talking about \"invisible\", this code produced no output:"
msgstr""

       
# CppCoreGuidelines.md:5673
msgid "5673        v.x = 123;"
msgstr""

# CppCoreGuidelines.md:5674
msgid "5674        cout << v.d << '\\n';    // BAD: undefined behavior"
msgstr""

       
# CppCoreGuidelines.md:5675
msgid "5675    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:5676
msgid "5676    Wrap a `union` in a class together with a type field."
msgstr""

       
# CppCoreGuidelines.md:5677
msgid "5677    The soon-to-be-standard `variant` type (to be found in `<variant>`) does that for you:"
msgstr""

       
# CppCoreGuidelines.md:5678
msgid "5678        variant<int, double> v;"
msgstr""

# CppCoreGuidelines.md:5679
msgid "5679        v = 123;        // v holds an int"
msgstr""

# CppCoreGuidelines.md:5680
msgid "5680        int x = get<int>(v);"
msgstr""

# CppCoreGuidelines.md:5681
msgid "5681        v = 123.456;    // v holds a double"
msgstr""

# CppCoreGuidelines.md:5682
msgid "5682        w = get<double>(v);"
msgstr""

       
# CppCoreGuidelines.md:5683
msgid "5683    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5684
msgid "5684    ???"
msgstr""

       
# CppCoreGuidelines.md:5685
msgid "5685    ### <a name=\"Ru-anonymous\"></a>C.182: Use anonymous `union`s to implement tagged unions"
msgstr""

       
# CppCoreGuidelines.md:5686
msgid "5686    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5687
msgid "5687    A well-designed tagged union is type safe."
msgstr""

# CppCoreGuidelines.md:5688
msgid "5688    An *anonymous* union simplifies the definition of a class with a (tag, union) pair."
msgstr""

       
# CppCoreGuidelines.md:5689
msgid "5689    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5690
msgid "5690    This example is mostly borrowed from TC++PL4 pp216-218."
msgstr""

# CppCoreGuidelines.md:5691
msgid "5691    You can look there for an explanation."
msgstr""

       
# CppCoreGuidelines.md:5692
msgid "5692    The code is somewhat elaborate."
msgstr""

# CppCoreGuidelines.md:5693
msgid "5693    Handling a type with user-defined assignment and destructor is tricky."
msgstr""

# CppCoreGuidelines.md:5694
msgid "5694    Saving programmers from having to write such code is one reason for including `variant` in the standard."
msgstr""

       
# CppCoreGuidelines.md:5695
msgid "5695        class Value { // two alternative representations represented as a union"
msgstr""

# CppCoreGuidelines.md:5696
msgid "5696        private:"
msgstr""

# CppCoreGuidelines.md:5697
msgid "5697            enum class Tag { number, text };"
msgstr""

# CppCoreGuidelines.md:5698
msgid "5698            Tag type; // discriminant"
msgstr""

       
# CppCoreGuidelines.md:5699
msgid "5699            union { // representation (note: anonymous union)"
msgstr""

# CppCoreGuidelines.md:5700
msgid "5700                int i;"
msgstr""

# CppCoreGuidelines.md:5701
msgid "5701                string s; // string has default constructor, copy operations, and destructor"
msgstr""

# CppCoreGuidelines.md:5702
msgid "5702            };"
msgstr""

# CppCoreGuidelines.md:5703
msgid "5703        public:"
msgstr""

# CppCoreGuidelines.md:5704
msgid "5704            struct Bad_entry { }; // used for exceptions"
msgstr""

       
# CppCoreGuidelines.md:5705
msgid "5705            ~Value();"
msgstr""

# CppCoreGuidelines.md:5706
msgid "5706            Value& operator=(const Value&);   // necessary because of the string variant"
msgstr""

# CppCoreGuidelines.md:5707
msgid "5707            Value(const Value&);"
msgstr""

# CppCoreGuidelines.md:5708
msgid "5708            // ..."
msgstr""

# CppCoreGuidelines.md:5709
msgid "5709            int number() const;"
msgstr""

# CppCoreGuidelines.md:5710
msgid "5710            string text() const;"
msgstr""

       
# CppCoreGuidelines.md:5711
msgid "5711            void set_number(int n);"
msgstr""

# CppCoreGuidelines.md:5712
msgid "5712            void set_text(const string&);"
msgstr""

# CppCoreGuidelines.md:5713
msgid "5713            // ..."
msgstr""

# CppCoreGuidelines.md:5714
msgid "5714        };"
msgstr""

       
# CppCoreGuidelines.md:5715
msgid "5715        int Value::number() const"
msgstr""

# CppCoreGuidelines.md:5716
msgid "5716        {"
msgstr""

# CppCoreGuidelines.md:5717
msgid "5717            if (type != Tag::number) throw Bad_entry{};"
msgstr""

# CppCoreGuidelines.md:5718
msgid "5718            return i;"
msgstr""

# CppCoreGuidelines.md:5719
msgid "5719        }"
msgstr""

       
# CppCoreGuidelines.md:5720
msgid "5720        string Value::text() const"
msgstr""

# CppCoreGuidelines.md:5721
msgid "5721        {"
msgstr""

# CppCoreGuidelines.md:5722
msgid "5722            if (type != Tag::text) throw Bad_entry{};"
msgstr""

# CppCoreGuidelines.md:5723
msgid "5723            return s;"
msgstr""

# CppCoreGuidelines.md:5724
msgid "5724        }"
msgstr""

       
# CppCoreGuidelines.md:5725
msgid "5725        void Value::set_number(int n)"
msgstr""

# CppCoreGuidelines.md:5726
msgid "5726        {"
msgstr""

# CppCoreGuidelines.md:5727
msgid "5727            if (type == Tag::text) {"
msgstr""

# CppCoreGuidelines.md:5728
msgid "5728                s.~string();      // explicitly destroy string"
msgstr""

# CppCoreGuidelines.md:5729
msgid "5729                type = Tag::number;"
msgstr""

# CppCoreGuidelines.md:5730
msgid "5730            }"
msgstr""

# CppCoreGuidelines.md:5731
msgid "5731            i = n;"
msgstr""

# CppCoreGuidelines.md:5732
msgid "5732        }"
msgstr""

       
# CppCoreGuidelines.md:5733
msgid "5733        void Value::set_text(const string& ss)"
msgstr""

# CppCoreGuidelines.md:5734
msgid "5734        {"
msgstr""

# CppCoreGuidelines.md:5735
msgid "5735            if (type == Tag::text)"
msgstr""

# CppCoreGuidelines.md:5736
msgid "5736                s = ss;"
msgstr""

# CppCoreGuidelines.md:5737
msgid "5737            else {"
msgstr""

# CppCoreGuidelines.md:5738
msgid "5738                new(&s) string{ss};   // placement new: explicitly construct string"
msgstr""

# CppCoreGuidelines.md:5739
msgid "5739                type = Tag::text;"
msgstr""

# CppCoreGuidelines.md:5740
msgid "5740            }"
msgstr""

# CppCoreGuidelines.md:5741
msgid "5741        }"
msgstr""

       
# CppCoreGuidelines.md:5742
msgid "5742        Value& Value::operator=(const Value& e)   // necessary because of the string variant"
msgstr""

# CppCoreGuidelines.md:5743
msgid "5743        {"
msgstr""

# CppCoreGuidelines.md:5744
msgid "5744            if (type == Tag::text && e.type == Tag::text) {"
msgstr""

# CppCoreGuidelines.md:5745
msgid "5745                s = e.s;    // usual string assignment"
msgstr""

# CppCoreGuidelines.md:5746
msgid "5746                return *this;"
msgstr""

# CppCoreGuidelines.md:5747
msgid "5747            }"
msgstr""

       
# CppCoreGuidelines.md:5748
msgid "5748            if (type == Tag::text) s.~string(); // explicit destroy"
msgstr""

       
# CppCoreGuidelines.md:5749
msgid "5749            switch (e.type) {"
msgstr""

# CppCoreGuidelines.md:5750
msgid "5750            case Tag::number:"
msgstr""

# CppCoreGuidelines.md:5751
msgid "5751                i = e.i;"
msgstr""

# CppCoreGuidelines.md:5752
msgid "5752                break;"
msgstr""

# CppCoreGuidelines.md:5753
msgid "5753            case Tag::text:"
msgstr""

# CppCoreGuidelines.md:5754
msgid "5754                new(&s)(e.s);   // placement new: explicit construct"
msgstr""

# CppCoreGuidelines.md:5755
msgid "5755                type = e.type;"
msgstr""

# CppCoreGuidelines.md:5756
msgid "5756            }"
msgstr""

       
# CppCoreGuidelines.md:5757
msgid "5757            return *this;"
msgstr""

# CppCoreGuidelines.md:5758
msgid "5758        }"
msgstr""

       
# CppCoreGuidelines.md:5759
msgid "5759        Value::~Value()"
msgstr""

# CppCoreGuidelines.md:5760
msgid "5760        {"
msgstr""

# CppCoreGuidelines.md:5761
msgid "5761            if (type == Tag::text) s.~string(); // explicit destroy"
msgstr""

# CppCoreGuidelines.md:5762
msgid "5762        }"
msgstr""

       
# CppCoreGuidelines.md:5763
msgid "5763    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5764
msgid "5764    ???"
msgstr""

       
# CppCoreGuidelines.md:5765
msgid "5765    ### <a name=\"Ru-pun\"></a>C.183: Don't use a `union` for type punning"
msgstr""

       
# CppCoreGuidelines.md:5766
msgid "5766    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5767
msgid "5767    It is undefined behavior to read a `union` member with a different type from the one with which it was written."
msgstr""

# CppCoreGuidelines.md:5768
msgid "5768    Such punning is invisible, or at least harder to spot than using a named cast."
msgstr""

# CppCoreGuidelines.md:5769
msgid "5769    Type punning using a `union` is a source of errors."
msgstr""

       
# CppCoreGuidelines.md:5770
msgid "5770    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5771
msgid "5771        union Pun {"
msgstr""

# CppCoreGuidelines.md:5772
msgid "5772            int x;"
msgstr""

# CppCoreGuidelines.md:5773
msgid "5773            unsigned char c[sizeof(int)];"
msgstr""

# CppCoreGuidelines.md:5774
msgid "5774        };"
msgstr""

       
# CppCoreGuidelines.md:5775
msgid "5775    The idea of `Pun` is to be able to look at the character representation of an `int`."
msgstr""

       
# CppCoreGuidelines.md:5776
msgid "5776        void bad(Pun& u)"
msgstr""

# CppCoreGuidelines.md:5777
msgid "5777        {"
msgstr""

# CppCoreGuidelines.md:5778
msgid "5778            u.x = 'x';"
msgstr""

# CppCoreGuidelines.md:5779
msgid "5779            cout << u.c[0] << '\\n';     // undefined behavior"
msgstr""

# CppCoreGuidelines.md:5780
msgid "5780        }"
msgstr""

       
# CppCoreGuidelines.md:5781
msgid "5781    If you wanted to see the bytes of an `int`, use a (named) cast:"
msgstr""

       
# CppCoreGuidelines.md:5782
msgid "5782        void if_you_must_pun(int& x)"
msgstr""

# CppCoreGuidelines.md:5783
msgid "5783        {"
msgstr""

# CppCoreGuidelines.md:5784
msgid "5784            auto p = reinterpret_cast<unsigned char*>(&x);"
msgstr""

# CppCoreGuidelines.md:5785
msgid "5785            cout << p[0] << '\\n';     // OK; better"
msgstr""

# CppCoreGuidelines.md:5786
msgid "5786            // ..."
msgstr""

# CppCoreGuidelines.md:5787
msgid "5787        }"
msgstr""

       
# CppCoreGuidelines.md:5788
msgid "5788    Accessing the result of an `reinterpret_cast` to a different type from the objects declared type is defined behavior (even though `reinterpret_cast` is discouraged),"
msgstr""

# CppCoreGuidelines.md:5789
msgid "5789    but at least we can see that something tricky is going on."
msgstr""

       
# CppCoreGuidelines.md:5790
msgid "5790    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5791
msgid "5791    Unfortunately, `union`s are commonly used for type punning."
msgstr""

# CppCoreGuidelines.md:5792
msgid "5792    We don't consider \"sometimes, it works as expected\" a strong argument."
msgstr""

       
# CppCoreGuidelines.md:5793
msgid "5793    C++17 introduced a distinct type `std::byte` to facilitate operations on raw object representation.  Use that type instead of `unsigned char` or `char` for these operations."
msgstr""

       
# CppCoreGuidelines.md:5794
msgid "5794    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5795
msgid "5795    ???"
msgstr""

       
       
       
# CppCoreGuidelines.md:5796
msgid "5796    # <a name=\"S-enum\"></a>Enum: Enumerations"
msgstr""

       
# CppCoreGuidelines.md:5797
msgid "5797    Enumerations are used to define sets of integer values and for defining types for such sets of values."
msgstr""

# CppCoreGuidelines.md:5798
msgid "5798    There are two kind of enumerations, \"plain\" `enum`s and `class enum`s."
msgstr""

       
# CppCoreGuidelines.md:5799
msgid "5799    Enumeration rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5800
msgid "5800    * [Enum.1: Prefer enumerations over macros](#Renum-macro)"
msgstr""

# CppCoreGuidelines.md:5801
msgid "5801    * [Enum.2: Use enumerations to represent sets of related named constants](#Renum-set)"
msgstr""

# CppCoreGuidelines.md:5802
msgid "5802    * [Enum.3: Prefer `enum class`es over \"plain\" `enum`s](#Renum-class)"
msgstr""

# CppCoreGuidelines.md:5803
msgid "5803    * [Enum.4: Define operations on enumerations for safe and simple use](#Renum-oper)"
msgstr""

# CppCoreGuidelines.md:5804
msgid "5804    * [Enum.5: Don't use `ALL_CAPS` for enumerators](#Renum-caps)"
msgstr""

# CppCoreGuidelines.md:5805
msgid "5805    * [Enum.6: Avoid unnamed enumerations](#Renum-unnamed)"
msgstr""

# CppCoreGuidelines.md:5806
msgid "5806    * [Enum.7: Specify the underlying type of an enumeration only when necessary](#Renum-underlying)"
msgstr""

# CppCoreGuidelines.md:5807
msgid "5807    * [Enum.8: Specify enumerator values only when necessary](#Renum-value)"
msgstr""

       
# CppCoreGuidelines.md:5808
msgid "5808    ### <a name=\"Renum-macro\"></a>Enum.1: Prefer enumerations over macros"
msgstr""

       
# CppCoreGuidelines.md:5809
msgid "5809    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5810
msgid "5810    Macros do not obey scope and type rules. Also, macro names are removed during preprocessing and so usually don't appear in tools like debuggers."
msgstr""

       
# CppCoreGuidelines.md:5811
msgid "5811    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5812
msgid "5812    First some bad old code:"
msgstr""

       
# CppCoreGuidelines.md:5813
msgid "5813        // webcolors.h (third party header)"
msgstr""

# CppCoreGuidelines.md:5814
msgid "5814        #define RED   0xFF0000"
msgstr""

# CppCoreGuidelines.md:5815
msgid "5815        #define GREEN 0x00FF00"
msgstr""

# CppCoreGuidelines.md:5816
msgid "5816        #define BLUE  0x0000FF"
msgstr""

       
# CppCoreGuidelines.md:5817
msgid "5817        // productinfo.h"
msgstr""

# CppCoreGuidelines.md:5818
msgid "5818        // The following define product subtypes based on color"
msgstr""

# CppCoreGuidelines.md:5819
msgid "5819        #define RED    0"
msgstr""

# CppCoreGuidelines.md:5820
msgid "5820        #define PURPLE 1"
msgstr""

# CppCoreGuidelines.md:5821
msgid "5821        #define BLUE   2"
msgstr""

       
# CppCoreGuidelines.md:5822
msgid "5822        int webby = BLUE;   // webby == 2; probably not what was desired"
msgstr""

       
# CppCoreGuidelines.md:5823
msgid "5823    Instead use an `enum`:"
msgstr""

       
# CppCoreGuidelines.md:5824
msgid "5824        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };"
msgstr""

# CppCoreGuidelines.md:5825
msgid "5825        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr""

       
# CppCoreGuidelines.md:5826
msgid "5826        int webby = blue;   // error: be specific"
msgstr""

# CppCoreGuidelines.md:5827
msgid "5827        Web_color webby = Web_color::blue;"
msgstr""

       
# CppCoreGuidelines.md:5828
msgid "5828    We used an `enum class` to avoid name clashes."
msgstr""

       
# CppCoreGuidelines.md:5829
msgid "5829    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5830
msgid "5830    Flag macros that define integer values."
msgstr""

       
       
# CppCoreGuidelines.md:5831
msgid "5831    ### <a name=\"Renum-set\"></a>Enum.2: Use enumerations to represent sets of related named constants"
msgstr""

       
# CppCoreGuidelines.md:5832
msgid "5832    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5833
msgid "5833    An enumeration shows the enumerators to be related and can be a named type."
msgstr""

       
       
       
# CppCoreGuidelines.md:5834
msgid "5834    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5835
msgid "5835        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };"
msgstr""

       
       
# CppCoreGuidelines.md:5836
msgid "5836    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5837
msgid "5837    Switching on an enumeration is common and the compiler can warn against unusual patterns of case labels. For example:"
msgstr""

       
# CppCoreGuidelines.md:5838
msgid "5838        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr""

       
# CppCoreGuidelines.md:5839
msgid "5839        void print(Product_info inf)"
msgstr""

# CppCoreGuidelines.md:5840
msgid "5840        {"
msgstr""

# CppCoreGuidelines.md:5841
msgid "5841            switch (inf) {"
msgstr""

# CppCoreGuidelines.md:5842
msgid "5842            case Product_info::red: cout << \"red\"; break;"
msgstr""

# CppCoreGuidelines.md:5843
msgid "5843            case Product_info::purple: cout << \"purple\"; break;"
msgstr""

# CppCoreGuidelines.md:5844
msgid "5844            }"
msgstr""

# CppCoreGuidelines.md:5845
msgid "5845        }"
msgstr""

       
# CppCoreGuidelines.md:5846
msgid "5846    Such off-by-one switch`statements are often the results of an added enumerator and insufficient testing."
msgstr""

       
# CppCoreGuidelines.md:5847
msgid "5847    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5848
msgid "5848    * Flag `switch`-statements where the `case`s cover most but not all enumerators of an enumeration."
msgstr""

# CppCoreGuidelines.md:5849
msgid "5849    * Flag `switch`-statements where the `case`s cover a few enumerators of an enumeration, but has no `default`."
msgstr""

       
       
# CppCoreGuidelines.md:5850
msgid "5850    ### <a name=\"Renum-class\"></a>Enum.3: Prefer class enums over \"plain\" enums"
msgstr""

       
# CppCoreGuidelines.md:5851
msgid "5851    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5852
msgid "5852    To minimize surprises: traditional enums convert to int too readily."
msgstr""

       
# CppCoreGuidelines.md:5853
msgid "5853    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5854
msgid "5854        void Print_color(int color);"
msgstr""

       
# CppCoreGuidelines.md:5855
msgid "5855        enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };"
msgstr""

# CppCoreGuidelines.md:5856
msgid "5856        enum Product_info { Red = 0, Purple = 1, Blue = 2 };"
msgstr""

       
# CppCoreGuidelines.md:5857
msgid "5857        Web_color webby = Web_color::blue;"
msgstr""

       
# CppCoreGuidelines.md:5858
msgid "5858        // Clearly at least one of these calls is buggy."
msgstr""

# CppCoreGuidelines.md:5859
msgid "5859        Print_color(webby);"
msgstr""

# CppCoreGuidelines.md:5860
msgid "5860        Print_color(Product_info::Blue);"
msgstr""

       
# CppCoreGuidelines.md:5861
msgid "5861    Instead use an `enum class`:"
msgstr""

       
# CppCoreGuidelines.md:5862
msgid "5862        void Print_color(int color);"
msgstr""

       
# CppCoreGuidelines.md:5863
msgid "5863        enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };"
msgstr""

# CppCoreGuidelines.md:5864
msgid "5864        enum class Product_info { red = 0, purple = 1, blue = 2 };"
msgstr""

       
# CppCoreGuidelines.md:5865
msgid "5865        Web_color webby = Web_color::blue;"
msgstr""

# CppCoreGuidelines.md:5866
msgid "5866        Print_color(webby);  // Error: cannot convert Web_color to int."
msgstr""

# CppCoreGuidelines.md:5867
msgid "5867        Print_color(Product_info::Red);  // Error: cannot convert Product_info to int."
msgstr""

       
# CppCoreGuidelines.md:5868
msgid "5868    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5869
msgid "5869    (Simple) Warn on any non-class `enum` definition."
msgstr""

       
# CppCoreGuidelines.md:5870
msgid "5870    ### <a name=\"Renum-oper\"></a>Enum.4: Define operations on enumerations for safe and simple use"
msgstr""

       
# CppCoreGuidelines.md:5871
msgid "5871    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5872
msgid "5872    Convenience of use and avoidance of errors."
msgstr""

       
# CppCoreGuidelines.md:5873
msgid "5873    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5874
msgid "5874        enum Day { mon, tue, wed, thu, fri, sat, sun };"
msgstr""

       
# CppCoreGuidelines.md:5875
msgid "5875        Day& operator++(Day& d)"
msgstr""

# CppCoreGuidelines.md:5876
msgid "5876        {"
msgstr""

# CppCoreGuidelines.md:5877
msgid "5877            return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);"
msgstr""

# CppCoreGuidelines.md:5878
msgid "5878        }"
msgstr""

       
# CppCoreGuidelines.md:5879
msgid "5879        Day today = Day::sat;"
msgstr""

# CppCoreGuidelines.md:5880
msgid "5880        Day tomorrow = ++today;"
msgstr""

       
# CppCoreGuidelines.md:5881
msgid "5881    The use of a `static_cast` is not pretty, but"
msgstr""

       
# CppCoreGuidelines.md:5882
msgid "5882        Day& operator++(Day& d)"
msgstr""

# CppCoreGuidelines.md:5883
msgid "5883        {"
msgstr""

# CppCoreGuidelines.md:5884
msgid "5884            return d = (d == Day::sun) ? Day::mon : Day{++d};    // error"
msgstr""

# CppCoreGuidelines.md:5885
msgid "5885        }"
msgstr""

       
# CppCoreGuidelines.md:5886
msgid "5886    is an infinite recursion, and writing it without a cast, using a `switch` on all cases is long-winded."
msgstr""

       
       
# CppCoreGuidelines.md:5887
msgid "5887    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5888
msgid "5888    Flag repeated expressions cast back into an enumeration."
msgstr""

       
       
# CppCoreGuidelines.md:5889
msgid "5889    ### <a name=\"Renum-caps\"></a>Enum.5: Don't use `ALL_CAPS` for enumerators"
msgstr""

       
# CppCoreGuidelines.md:5890
msgid "5890    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5891
msgid "5891    Avoid clashes with macros."
msgstr""

       
# CppCoreGuidelines.md:5892
msgid "5892    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5893
msgid "5893         // webcolors.h (third party header)"
msgstr""

# CppCoreGuidelines.md:5894
msgid "5894        #define RED   0xFF0000"
msgstr""

# CppCoreGuidelines.md:5895
msgid "5895        #define GREEN 0x00FF00"
msgstr""

# CppCoreGuidelines.md:5896
msgid "5896        #define BLUE  0x0000FF"
msgstr""

       
# CppCoreGuidelines.md:5897
msgid "5897        // productinfo.h"
msgstr""

# CppCoreGuidelines.md:5898
msgid "5898        // The following define product subtypes based on color"
msgstr""

       
# CppCoreGuidelines.md:5899
msgid "5899        enum class Product_info { RED, PURPLE, BLUE };   // syntax error"
msgstr""

       
# CppCoreGuidelines.md:5900
msgid "5900    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5901
msgid "5901    Flag ALL_CAPS enumerators."
msgstr""

       
# CppCoreGuidelines.md:5902
msgid "5902    ### <a name=\"Renum-unnamed\"></a>Enum.6: Avoid unnamed enumerations"
msgstr""

       
# CppCoreGuidelines.md:5903
msgid "5903    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5904
msgid "5904    If you can't name an enumeration, the values are not related"
msgstr""

       
# CppCoreGuidelines.md:5905
msgid "5905    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5906
msgid "5906        enum { red = 0xFF0000, scale = 4, is_signed = 1 };"
msgstr""

       
# CppCoreGuidelines.md:5907
msgid "5907    Such code is not uncommon in code written before there were convenient alternative ways of specifying integer constants."
msgstr""

       
# CppCoreGuidelines.md:5908
msgid "5908    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:5909
msgid "5909    Use `constexpr` values instead. For example:"
msgstr""

       
# CppCoreGuidelines.md:5910
msgid "5910        constexpr int red = 0xFF0000;"
msgstr""

# CppCoreGuidelines.md:5911
msgid "5911        constexpr short scale = 4;"
msgstr""

# CppCoreGuidelines.md:5912
msgid "5912        constexpr bool is_signed = true;"
msgstr""

       
# CppCoreGuidelines.md:5913
msgid "5913    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5914
msgid "5914    Flag unnamed enumerations."
msgstr""

       
       
# CppCoreGuidelines.md:5915
msgid "5915    ### <a name=\"Renum-underlying\"></a>Enum.7: Specify the underlying type of an enumeration only when necessary"
msgstr""

       
# CppCoreGuidelines.md:5916
msgid "5916    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5917
msgid "5917    The default is the easiest to read and write."
msgstr""

# CppCoreGuidelines.md:5918
msgid "5918    `int` is the default integer type."
msgstr""

# CppCoreGuidelines.md:5919
msgid "5919    `int` is compatible with C `enum`s."
msgstr""

       
# CppCoreGuidelines.md:5920
msgid "5920    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5921
msgid "5921        enum class Direction : char { n, s, e, w,"
msgstr""

# CppCoreGuidelines.md:5922
msgid "5922                                      ne, nw, se, sw };  // underlying type saves space"
msgstr""

       
# CppCoreGuidelines.md:5923
msgid "5923        enum class Web_color : int32_t { red   = 0xFF0000,"
msgstr""

# CppCoreGuidelines.md:5924
msgid "5924                                         green = 0x00FF00,"
msgstr""

# CppCoreGuidelines.md:5925
msgid "5925                                         blue  = 0x0000FF };  // underlying type is redundant"
msgstr""

       
# CppCoreGuidelines.md:5926
msgid "5926    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:5927
msgid "5927    Specifying the underlying type is necessary in forward declarations of enumerations:"
msgstr""

       
# CppCoreGuidelines.md:5928
msgid "5928        enum Flags : char;"
msgstr""

       
# CppCoreGuidelines.md:5929
msgid "5929        void f(Flags);"
msgstr""

       
# CppCoreGuidelines.md:5930
msgid "5930        // ...."
msgstr""

       
# CppCoreGuidelines.md:5931
msgid "5931        enum flags : char { /* ... */ };"
msgstr""

       
       
# CppCoreGuidelines.md:5932
msgid "5932    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5933
msgid "5933    ????"
msgstr""

       
       
# CppCoreGuidelines.md:5934
msgid "5934    ### <a name=\"Renum-value\"></a>Enum.8: Specify enumerator values only when necessary"
msgstr""

       
# CppCoreGuidelines.md:5935
msgid "5935    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5936
msgid "5936    It's the simplest."
msgstr""

# CppCoreGuidelines.md:5937
msgid "5937    It avoids duplicate enumerator values."
msgstr""

# CppCoreGuidelines.md:5938
msgid "5938    The default gives a consecutive set of values that is good for `switch`-statement implementations."
msgstr""

       
# CppCoreGuidelines.md:5939
msgid "5939    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:5940
msgid "5940        enum class Col1 { red, yellow, blue };"
msgstr""

# CppCoreGuidelines.md:5941
msgid "5941        enum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo"
msgstr""

# CppCoreGuidelines.md:5942
msgid "5942        enum class Month { jan = 1, feb, mar, apr, may, jun,"
msgstr""

# CppCoreGuidelines.md:5943
msgid "5943                           jul, august, sep, oct, nov, dec }; // starting with 1 is conventional"
msgstr""

# CppCoreGuidelines.md:5944
msgid "5944        enum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // set of bits"
msgstr""

       
# CppCoreGuidelines.md:5945
msgid "5945    Specifying values is necessary to match conventional values (e.g., `Month`)"
msgstr""

# CppCoreGuidelines.md:5946
msgid "5946    and where consecutive values are undesirable (e.g., to get separate bits as in `Base_flag`)."
msgstr""

       
# CppCoreGuidelines.md:5947
msgid "5947    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:5948
msgid "5948    * Flag duplicate enumerator values"
msgstr""

# CppCoreGuidelines.md:5949
msgid "5949    * Flag explicitly specified all-consecutive enumerator values"
msgstr""

       
       
# CppCoreGuidelines.md:5950
msgid "5950    # <a name=\"S-resource\"></a>R: Resource management"
msgstr""

       
# CppCoreGuidelines.md:5951
msgid "5951    This section contains rules related to resources."
msgstr""

# CppCoreGuidelines.md:5952
msgid "5952    A resource is anything that must be acquired and (explicitly or implicitly) released, such as memory, file handles, sockets, and locks."
msgstr""

# CppCoreGuidelines.md:5953
msgid "5953    The reason it must be released is typically that it can be in short supply, so even delayed release may do harm."
msgstr""

# CppCoreGuidelines.md:5954
msgid "5954    The fundamental aim is to ensure that we don't leak any resources and that we don't hold a resource longer than we need to."
msgstr""

# CppCoreGuidelines.md:5955
msgid "5955    An entity that is responsible for releasing a resource is called an owner."
msgstr""

       
# CppCoreGuidelines.md:5956
msgid "5956    There are a few cases where leaks can be acceptable or even optimal:"
msgstr""

# CppCoreGuidelines.md:5957
msgid "5957    If you are writing a program that simply produces an output based on an input and the amount of memory needed is proportional to the size of the input, the optimal strategy (for performance and ease of programming) is sometimes simply never to delete anything."
msgstr""

# CppCoreGuidelines.md:5958
msgid "5958    If you have enough memory to handle your largest input, leak away, but be sure to give a good error message if you are wrong."
msgstr""

# CppCoreGuidelines.md:5959
msgid "5959    Here, we ignore such cases."
msgstr""

       
# CppCoreGuidelines.md:5960
msgid "5960    * Resource management rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5961
msgid "5961      * [R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)](#Rr-raii)"
msgstr""

# CppCoreGuidelines.md:5962
msgid "5962      * [R.2: In interfaces, use raw pointers to denote individual objects (only)](#Rr-use-ptr)"
msgstr""

# CppCoreGuidelines.md:5963
msgid "5963      * [R.3: A raw pointer (a `T*`) is non-owning](#Rr-ptr)"
msgstr""

# CppCoreGuidelines.md:5964
msgid "5964      * [R.4: A raw reference (a `T&`) is non-owning](#Rr-ref)"
msgstr""

# CppCoreGuidelines.md:5965
msgid "5965      * [R.5: Prefer scoped objects, don't heap-allocate unnecessarily](#Rr-scoped)"
msgstr""

# CppCoreGuidelines.md:5966
msgid "5966      * [R.6: Avoid non-`const` global variables](#Rr-global)"
msgstr""

       
# CppCoreGuidelines.md:5967
msgid "5967    * Allocation and deallocation rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5968
msgid "5968      * [R.10: Avoid `malloc()` and `free()`](#Rr-mallocfree)"
msgstr""

# CppCoreGuidelines.md:5969
msgid "5969      * [R.11: Avoid calling `new` and `delete` explicitly](#Rr-newdelete)"
msgstr""

# CppCoreGuidelines.md:5970
msgid "5970      * [R.12: Immediately give the result of an explicit resource allocation to a manager object](#Rr-immediate-alloc)"
msgstr""

# CppCoreGuidelines.md:5971
msgid "5971      * [R.13: Perform at most one explicit resource allocation in a single expression statement](#Rr-single-alloc)"
msgstr""

# CppCoreGuidelines.md:5972
msgid "5972      * [R.14: ??? array vs. pointer parameter](#Rr-ap)"
msgstr""

# CppCoreGuidelines.md:5973
msgid "5973      * [R.15: Always overload matched allocation/deallocation pairs](#Rr-pair)"
msgstr""

       
# CppCoreGuidelines.md:5974
msgid "5974    * <a name=\"Rr-summary-smartptrs\"></a>Smart pointer rule summary:"
msgstr""

       
# CppCoreGuidelines.md:5975
msgid "5975      * [R.20: Use `unique_ptr` or `shared_ptr` to represent ownership](#Rr-owner)"
msgstr""

# CppCoreGuidelines.md:5976
msgid "5976      * [R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership](#Rr-unique)"
msgstr""

# CppCoreGuidelines.md:5977
msgid "5977      * [R.22: Use `make_shared()` to make `shared_ptr`s](#Rr-make_shared)"
msgstr""

# CppCoreGuidelines.md:5978
msgid "5978      * [R.23: Use `make_unique()` to make `unique_ptr`s](#Rr-make_unique)"
msgstr""

# CppCoreGuidelines.md:5979
msgid "5979      * [R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s](#Rr-weak_ptr)"
msgstr""

# CppCoreGuidelines.md:5980
msgid "5980      * [R.30: Take smart pointers as parameters only to explicitly express lifetime semantics](#Rr-smartptrparam)"
msgstr""

# CppCoreGuidelines.md:5981
msgid "5981      * [R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`](#Rr-smart)"
msgstr""

# CppCoreGuidelines.md:5982
msgid "5982      * [R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a `widget`](#Rr-uniqueptrparam)"
msgstr""

# CppCoreGuidelines.md:5983
msgid "5983      * [R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats the `widget`](#Rr-reseat)"
msgstr""

# CppCoreGuidelines.md:5984
msgid "5984      * [R.34: Take a `shared_ptr<widget>` parameter to express that a function is part owner](#Rr-sharedptrparam-owner)"
msgstr""

# CppCoreGuidelines.md:5985
msgid "5985      * [R.35: Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer](#Rr-sharedptrparam)"
msgstr""

# CppCoreGuidelines.md:5986
msgid "5986      * [R.36: Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object ???](#Rr-sharedptrparam-const)"
msgstr""

# CppCoreGuidelines.md:5987
msgid "5987      * [R.37: Do not pass a pointer or reference obtained from an aliased smart pointer](#Rr-smartptrget)"
msgstr""

       
# CppCoreGuidelines.md:5988
msgid "5988    ### <a name=\"Rr-raii\"></a>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)"
msgstr""

       
# CppCoreGuidelines.md:5989
msgid "5989    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:5990
msgid "5990    To avoid leaks and the complexity of manual resource management."
msgstr""

# CppCoreGuidelines.md:5991
msgid "5991    C++'s language-enforced constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release function pairs such as `fopen`/`fclose`, `lock`/`unlock`, and `new`/`delete`."
msgstr""

# CppCoreGuidelines.md:5992
msgid "5992    Whenever you deal with a resource that needs paired acquire/release function calls, encapsulate that resource in an object that enforces pairing for you -- acquire the resource in its constructor, and release it in its destructor."
msgstr""

       
# CppCoreGuidelines.md:5993
msgid "5993    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:5994
msgid "5994    Consider:"
msgstr""

       
# CppCoreGuidelines.md:5995
msgid "5995        void send(X* x, cstring_span destination)"
msgstr""

# CppCoreGuidelines.md:5996
msgid "5996        {"
msgstr""

# CppCoreGuidelines.md:5997
msgid "5997            auto port = open_port(destination);"
msgstr""

# CppCoreGuidelines.md:5998
msgid "5998            my_mutex.lock();"
msgstr""

# CppCoreGuidelines.md:5999
msgid "5999            // ..."
msgstr""

# CppCoreGuidelines.md:6000
msgid "6000            send(port, x);"
msgstr""

# CppCoreGuidelines.md:6001
msgid "6001            // ..."
msgstr""

# CppCoreGuidelines.md:6002
msgid "6002            my_mutex.unlock();"
msgstr""

# CppCoreGuidelines.md:6003
msgid "6003            close_port(port);"
msgstr""

# CppCoreGuidelines.md:6004
msgid "6004            delete x;"
msgstr""

# CppCoreGuidelines.md:6005
msgid "6005        }"
msgstr""

       
# CppCoreGuidelines.md:6006
msgid "6006    In this code, you have to remember to `unlock`, `close_port`, and `delete` on all paths, and do each exactly once."
msgstr""

# CppCoreGuidelines.md:6007
msgid "6007    Further, if any of the code marked `...` throws an exception, then `x` is leaked and `my_mutex` remains locked."
msgstr""

       
# CppCoreGuidelines.md:6008
msgid "6008    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6009
msgid "6009    Consider:"
msgstr""

       
# CppCoreGuidelines.md:6010
msgid "6010        void send(unique_ptr<X> x, cstring_span destination)  // x owns the X"
msgstr""

# CppCoreGuidelines.md:6011
msgid "6011        {"
msgstr""

# CppCoreGuidelines.md:6012
msgid "6012            Port port{destination};            // port owns the PortHandle"
msgstr""

# CppCoreGuidelines.md:6013
msgid "6013            lock_guard<mutex> guard{my_mutex}; // guard owns the lock"
msgstr""

# CppCoreGuidelines.md:6014
msgid "6014            // ..."
msgstr""

# CppCoreGuidelines.md:6015
msgid "6015            send(port, x);"
msgstr""

# CppCoreGuidelines.md:6016
msgid "6016            // ..."
msgstr""

# CppCoreGuidelines.md:6017
msgid "6017        } // automatically unlocks my_mutex and deletes the pointer in x"
msgstr""

       
# CppCoreGuidelines.md:6018
msgid "6018    Now all resource cleanup is automatic, performed once on all paths whether or not there is an exception. As a bonus, the function now advertises that it takes over ownership of the pointer."
msgstr""

       
# CppCoreGuidelines.md:6019
msgid "6019    What is `Port`? A handy wrapper that encapsulates the resource:"
msgstr""

       
# CppCoreGuidelines.md:6020
msgid "6020        class Port {"
msgstr""

# CppCoreGuidelines.md:6021
msgid "6021            PortHandle port;"
msgstr""

# CppCoreGuidelines.md:6022
msgid "6022        public:"
msgstr""

# CppCoreGuidelines.md:6023
msgid "6023            Port(cstring_span destination) : port{open_port(destination)} { }"
msgstr""

# CppCoreGuidelines.md:6024
msgid "6024            ~Port() { close_port(port); }"
msgstr""

# CppCoreGuidelines.md:6025
msgid "6025            operator PortHandle() { return port; }"
msgstr""

       
# CppCoreGuidelines.md:6026
msgid "6026            // port handles can't usually be cloned, so disable copying and assignment if necessary"
msgstr""

# CppCoreGuidelines.md:6027
msgid "6027            Port(const Port&) = delete;"
msgstr""

# CppCoreGuidelines.md:6028
msgid "6028            Port& operator=(const Port&) = delete;"
msgstr""

# CppCoreGuidelines.md:6029
msgid "6029        };"
msgstr""

       
# CppCoreGuidelines.md:6030
msgid "6030    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6031
msgid "6031    Where a resource is \"ill-behaved\" in that it isn't represented as a class with a destructor, wrap it in a class or use [`finally`](#Re-finally)"
msgstr""

       
# CppCoreGuidelines.md:6032
msgid "6032    **See also**: [RAII](#Rr-raii)"
msgstr""

       
# CppCoreGuidelines.md:6033
msgid "6033    ### <a name=\"Rr-use-ptr\"></a>R.2: In interfaces, use raw pointers to denote individual objects (only)"
msgstr""

       
# CppCoreGuidelines.md:6034
msgid "6034    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6035
msgid "6035    Arrays are best represented by a container type (e.g., `vector` (owning)) or a `span` (non-owning)."
msgstr""

# CppCoreGuidelines.md:6036
msgid "6036    Such containers and views hold sufficient information to do range checking."
msgstr""

       
# CppCoreGuidelines.md:6037
msgid "6037    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6038
msgid "6038        void f(int* p, int n)   // n is the number of elements in p[]"
msgstr""

# CppCoreGuidelines.md:6039
msgid "6039        {"
msgstr""

# CppCoreGuidelines.md:6040
msgid "6040            // ..."
msgstr""

# CppCoreGuidelines.md:6041
msgid "6041            p[2] = 7;   // bad: subscript raw pointer"
msgstr""

# CppCoreGuidelines.md:6042
msgid "6042            // ..."
msgstr""

# CppCoreGuidelines.md:6043
msgid "6043        }"
msgstr""

       
# CppCoreGuidelines.md:6044
msgid "6044    The compiler does not read comments, and without reading other code you do not know whether `p` really points to `n` elements."
msgstr""

# CppCoreGuidelines.md:6045
msgid "6045    Use a `span` instead."
msgstr""

       
# CppCoreGuidelines.md:6046
msgid "6046    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6047
msgid "6047        void g(int* p, int fmt)   // print *p using format #fmt"
msgstr""

# CppCoreGuidelines.md:6048
msgid "6048        {"
msgstr""

# CppCoreGuidelines.md:6049
msgid "6049            // ... uses *p and p[0] only ..."
msgstr""

# CppCoreGuidelines.md:6050
msgid "6050        }"
msgstr""

       
# CppCoreGuidelines.md:6051
msgid "6051    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6052
msgid "6052    C-style strings are passed as single pointers to a zero-terminated sequence of characters."
msgstr""

# CppCoreGuidelines.md:6053
msgid "6053    Use `zstring` rather than `char*` to indicate that you rely on that convention."
msgstr""

       
# CppCoreGuidelines.md:6054
msgid "6054    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6055
msgid "6055    Many current uses of pointers to a single element could be references."
msgstr""

# CppCoreGuidelines.md:6056
msgid "6056    However, where `nullptr` is a possible value, a reference may not be a reasonable alternative."
msgstr""

       
# CppCoreGuidelines.md:6057
msgid "6057    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6058
msgid "6058    * Flag pointer arithmetic (including `++`) on a pointer that is not part of a container, view, or iterator."
msgstr""

# CppCoreGuidelines.md:6059
msgid "6059      This rule would generate a huge number of false positives if applied to an older code base."
msgstr""

# CppCoreGuidelines.md:6060
msgid "6060    * Flag array names passed as simple pointers"
msgstr""

       
# CppCoreGuidelines.md:6061
msgid "6061    ### <a name=\"Rr-ptr\"></a>R.3: A raw pointer (a `T*`) is non-owning"
msgstr""

       
# CppCoreGuidelines.md:6062
msgid "6062    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6063
msgid "6063    There is nothing (in the C++ standard or in most code) to say otherwise and most raw pointers are non-owning."
msgstr""

# CppCoreGuidelines.md:6064
msgid "6064    We want owning pointers identified so that we can reliably and efficiently delete the objects pointed to by owning pointers."
msgstr""

       
# CppCoreGuidelines.md:6065
msgid "6065    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6066
msgid "6066        void f()"
msgstr""

# CppCoreGuidelines.md:6067
msgid "6067        {"
msgstr""

# CppCoreGuidelines.md:6068
msgid "6068            int* p1 = new int{7};           // bad: raw owning pointer"
msgstr""

# CppCoreGuidelines.md:6069
msgid "6069            auto p2 = make_unique<int>(7);  // OK: the int is owned by a unique pointer"
msgstr""

# CppCoreGuidelines.md:6070
msgid "6070            // ..."
msgstr""

# CppCoreGuidelines.md:6071
msgid "6071        }"
msgstr""

       
# CppCoreGuidelines.md:6072
msgid "6072    The `unique_ptr` protects against leaks by guaranteeing the deletion of its object (even in the presence of exceptions). The `T*` does not."
msgstr""

       
# CppCoreGuidelines.md:6073
msgid "6073    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6074
msgid "6074        template<typename T>"
msgstr""

# CppCoreGuidelines.md:6075
msgid "6075        class X {"
msgstr""

# CppCoreGuidelines.md:6076
msgid "6076            // ..."
msgstr""

# CppCoreGuidelines.md:6077
msgid "6077        public:"
msgstr""

# CppCoreGuidelines.md:6078
msgid "6078            T* p;   // bad: it is unclear whether p is owning or not"
msgstr""

# CppCoreGuidelines.md:6079
msgid "6079            T* q;   // bad: it is unclear whether q is owning or not"
msgstr""

# CppCoreGuidelines.md:6080
msgid "6080        };"
msgstr""

       
# CppCoreGuidelines.md:6081
msgid "6081    We can fix that problem by making ownership explicit:"
msgstr""

       
# CppCoreGuidelines.md:6082
msgid "6082        template<typename T>"
msgstr""

# CppCoreGuidelines.md:6083
msgid "6083        class X2 {"
msgstr""

# CppCoreGuidelines.md:6084
msgid "6084            // ..."
msgstr""

# CppCoreGuidelines.md:6085
msgid "6085        public:"
msgstr""

# CppCoreGuidelines.md:6086
msgid "6086            owner<T*> p;  // OK: p is owning"
msgstr""

# CppCoreGuidelines.md:6087
msgid "6087            T* q;         // OK: q is not owning"
msgstr""

# CppCoreGuidelines.md:6088
msgid "6088        };"
msgstr""

       
# CppCoreGuidelines.md:6089
msgid "6089    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6090
msgid "6090    A major class of exception is legacy code, especially code that must remain compilable as C or interface with C and C-style C++ through ABIs."
msgstr""

# CppCoreGuidelines.md:6091
msgid "6091    The fact that there are billions of lines of code that violate this rule against owning `T*`s cannot be ignored."
msgstr""

# CppCoreGuidelines.md:6092
msgid "6092    We'd love to see program transformation tools turning 20-year-old \"legacy\" code into shiny modern code,"
msgstr""

# CppCoreGuidelines.md:6093
msgid "6093    we encourage the development, deployment and use of such tools,"
msgstr""

# CppCoreGuidelines.md:6094
msgid "6094    we hope the guidelines will help the development of such tools,"
msgstr""

# CppCoreGuidelines.md:6095
msgid "6095    and we even contributed (and contribute) to the research and development in this area."
msgstr""

# CppCoreGuidelines.md:6096
msgid "6096    However, it will take time: \"legacy code\" is generated faster than we can renovate old code, and so it will be for a few years."
msgstr""

       
# CppCoreGuidelines.md:6097
msgid "6097    This code cannot all be rewritten (ever assuming good code transformation software), especially not soon."
msgstr""

# CppCoreGuidelines.md:6098
msgid "6098    This problem cannot be solved (at scale) by transforming all owning pointers to `unique_ptr`s and `shared_ptr`s,"
msgstr""

# CppCoreGuidelines.md:6099
msgid "6099    partly because we need/use owning \"raw pointers\" as well as simple pointers in the implementation of our fundamental resource handles."
msgstr""

# CppCoreGuidelines.md:6100
msgid "6100    For example, common `vector` implementations have one owning pointer and two non-owning pointers."
msgstr""

# CppCoreGuidelines.md:6101
msgid "6101    Many ABIs (and essentially all interfaces to C code) use `T*`s, some of them owning."
msgstr""

# CppCoreGuidelines.md:6102
msgid "6102    Some interfaces cannot be simply annotated with `owner` because they need to remain compilable as C"
msgstr""

# CppCoreGuidelines.md:6103
msgid "6103    (although this would be a rare good use for a macro, that expands to `owner` in C++ mode only)."
msgstr""

       
# CppCoreGuidelines.md:6104
msgid "6104    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6105
msgid "6105    `owner<T*>` has no default semantics beyond `T*`. It can be used without changing any code using it and without affecting ABIs."
msgstr""

# CppCoreGuidelines.md:6106
msgid "6106    It is simply a indicator to programmers and analysis tools."
msgstr""

# CppCoreGuidelines.md:6107
msgid "6107    For example, if an `owner<T*>` is a member of a class, that class better have a destructor that `delete`s it."
msgstr""

       
# CppCoreGuidelines.md:6108
msgid "6108    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6109
msgid "6109    Returning a (raw) pointer imposes a lifetime management uncertainty on the caller; that is, who deletes the pointed-to object?"
msgstr""

       
# CppCoreGuidelines.md:6110
msgid "6110        Gadget* make_gadget(int n)"
msgstr""

# CppCoreGuidelines.md:6111
msgid "6111        {"
msgstr""

# CppCoreGuidelines.md:6112
msgid "6112            auto p = new Gadget{n};"
msgstr""

# CppCoreGuidelines.md:6113
msgid "6113            // ..."
msgstr""

# CppCoreGuidelines.md:6114
msgid "6114            return p;"
msgstr""

# CppCoreGuidelines.md:6115
msgid "6115        }"
msgstr""

       
# CppCoreGuidelines.md:6116
msgid "6116        void caller(int n)"
msgstr""

# CppCoreGuidelines.md:6117
msgid "6117        {"
msgstr""

# CppCoreGuidelines.md:6118
msgid "6118            auto p = make_gadget(n);   // remember to delete p"
msgstr""

# CppCoreGuidelines.md:6119
msgid "6119            // ..."
msgstr""

# CppCoreGuidelines.md:6120
msgid "6120            delete p;"
msgstr""

# CppCoreGuidelines.md:6121
msgid "6121        }"
msgstr""

       
# CppCoreGuidelines.md:6122
msgid "6122    In addition to suffering from the problem from [leak](#???), this adds a spurious allocation and deallocation operation, and is needlessly verbose. If Gadget is cheap to move out of a function (i.e., is small or has an efficient move operation), just return it \"by value\" (see [\"out\" return values](#Rf-out)):"
msgstr""

       
# CppCoreGuidelines.md:6123
msgid "6123        Gadget make_gadget(int n)"
msgstr""

# CppCoreGuidelines.md:6124
msgid "6124        {"
msgstr""

# CppCoreGuidelines.md:6125
msgid "6125            Gadget g{n};"
msgstr""

# CppCoreGuidelines.md:6126
msgid "6126            // ..."
msgstr""

# CppCoreGuidelines.md:6127
msgid "6127            return g;"
msgstr""

# CppCoreGuidelines.md:6128
msgid "6128        }"
msgstr""

       
# CppCoreGuidelines.md:6129
msgid "6129    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6130
msgid "6130    This rule applies to factory functions."
msgstr""

       
# CppCoreGuidelines.md:6131
msgid "6131    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6132
msgid "6132    If pointer semantics are required (e.g., because the return type needs to refer to a base class of a class hierarchy (an interface)), return a \"smart pointer.\""
msgstr""

       
# CppCoreGuidelines.md:6133
msgid "6133    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6134
msgid "6134    * (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`."
msgstr""

# CppCoreGuidelines.md:6135
msgid "6135    * (Moderate) Warn on failure to either `reset` or explicitly `delete` an `owner<T>` pointer on every code path."
msgstr""

# CppCoreGuidelines.md:6136
msgid "6136    * (Simple) Warn if the return value of `new` is assigned to a raw pointer."
msgstr""

# CppCoreGuidelines.md:6137
msgid "6137    * (Simple) Warn if a function returns an object that was allocated within the function but has a move constructor."
msgstr""

# CppCoreGuidelines.md:6138
msgid "6138      Suggest considering returning it by value instead."
msgstr""

       
# CppCoreGuidelines.md:6139
msgid "6139    ### <a name=\"Rr-ref\"></a>R.4: A raw reference (a `T&`) is non-owning"
msgstr""

       
# CppCoreGuidelines.md:6140
msgid "6140    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6141
msgid "6141    There is nothing (in the C++ standard or in most code) to say otherwise and most raw references are non-owning."
msgstr""

# CppCoreGuidelines.md:6142
msgid "6142    We want owners identified so that we can reliably and efficiently delete the objects pointed to by owning pointers."
msgstr""

       
# CppCoreGuidelines.md:6143
msgid "6143    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6144
msgid "6144        void f()"
msgstr""

# CppCoreGuidelines.md:6145
msgid "6145        {"
msgstr""

# CppCoreGuidelines.md:6146
msgid "6146            int& r = *new int{7};  // bad: raw owning reference"
msgstr""

# CppCoreGuidelines.md:6147
msgid "6147            // ..."
msgstr""

# CppCoreGuidelines.md:6148
msgid "6148            delete &r;             // bad: violated the rule against deleting raw pointers"
msgstr""

# CppCoreGuidelines.md:6149
msgid "6149        }"
msgstr""

       
# CppCoreGuidelines.md:6150
msgid "6150    **See also**: [The raw pointer rule](#Rr-ptr)"
msgstr""

       
# CppCoreGuidelines.md:6151
msgid "6151    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6152
msgid "6152    See [the raw pointer rule](#Rr-ptr)"
msgstr""

       
# CppCoreGuidelines.md:6153
msgid "6153    ### <a name=\"Rr-scoped\"></a>R.5: Prefer scoped objects, don't heap-allocate unnecessarily"
msgstr""

       
# CppCoreGuidelines.md:6154
msgid "6154    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6155
msgid "6155    A scoped object is a local object, a global object, or a member."
msgstr""

# CppCoreGuidelines.md:6156
msgid "6156    This implies that there is no separate allocation and deallocation cost in excess of that already used for the containing scope or object."
msgstr""

# CppCoreGuidelines.md:6157
msgid "6157    The members of a scoped object are themselves scoped and the scoped object's constructor and destructor manage the members' lifetimes."
msgstr""

       
# CppCoreGuidelines.md:6158
msgid "6158    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6159
msgid "6159    The following example is inefficient (because it has unnecessary allocation and deallocation), vulnerable to exception throws and returns in the `...` part (leading to leaks), and verbose:"
msgstr""

       
# CppCoreGuidelines.md:6160
msgid "6160        void f(int n)"
msgstr""

# CppCoreGuidelines.md:6161
msgid "6161        {"
msgstr""

# CppCoreGuidelines.md:6162
msgid "6162            auto p = new Gadget{n};"
msgstr""

# CppCoreGuidelines.md:6163
msgid "6163            // ..."
msgstr""

# CppCoreGuidelines.md:6164
msgid "6164            delete p;"
msgstr""

# CppCoreGuidelines.md:6165
msgid "6165        }"
msgstr""

       
# CppCoreGuidelines.md:6166
msgid "6166    Instead, use a local variable:"
msgstr""

       
# CppCoreGuidelines.md:6167
msgid "6167        void f(int n)"
msgstr""

# CppCoreGuidelines.md:6168
msgid "6168        {"
msgstr""

# CppCoreGuidelines.md:6169
msgid "6169            Gadget g{n};"
msgstr""

# CppCoreGuidelines.md:6170
msgid "6170            // ..."
msgstr""

# CppCoreGuidelines.md:6171
msgid "6171        }"
msgstr""

       
# CppCoreGuidelines.md:6172
msgid "6172    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6173
msgid "6173    * (Moderate) Warn if an object is allocated and then deallocated on all paths within a function. Suggest it should be a local `auto` stack object instead."
msgstr""

# CppCoreGuidelines.md:6174
msgid "6174    * (Simple) Warn if a local `Unique_ptr` or `Shared_ptr` is not moved, copied, reassigned or `reset` before its lifetime ends."
msgstr""

       
# CppCoreGuidelines.md:6175
msgid "6175    ### <a name=\"Rr-global\"></a>R.6: Avoid non-`const` global variables"
msgstr""

       
# CppCoreGuidelines.md:6176
msgid "6176    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6177
msgid "6177    Global variables can be accessed from everywhere so they can introduce surprising dependencies between apparently unrelated objects."
msgstr""

# CppCoreGuidelines.md:6178
msgid "6178    They are a notable source of errors."
msgstr""

       
# CppCoreGuidelines.md:6179
msgid "6179    **Warning**: The initialization of global objects is not totally ordered."
msgstr""

# CppCoreGuidelines.md:6180
msgid "6180    If you use a global object initialize it with a constant."
msgstr""

# CppCoreGuidelines.md:6181
msgid "6181    Note that it is possible to get undefined initialization order even for `const` objects."
msgstr""

       
# CppCoreGuidelines.md:6182
msgid "6182    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6183
msgid "6183    A global object is often better than a singleton."
msgstr""

       
# CppCoreGuidelines.md:6184
msgid "6184    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6185
msgid "6185    An immutable (`const`) global does not introduce the problems we try to avoid by banning global objects."
msgstr""

       
# CppCoreGuidelines.md:6186
msgid "6186    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6187
msgid "6187    (??? NM: Obviously we can warn about non-`const` statics ... do we want to?)"
msgstr""

       
# CppCoreGuidelines.md:6188
msgid "6188    ## <a name=\"SS-alloc\"></a>R.alloc: Allocation and deallocation"
msgstr""

       
# CppCoreGuidelines.md:6189
msgid "6189    ### <a name=\"Rr-mallocfree\"></a>R.10: Avoid `malloc()` and `free()`"
msgstr""

       
# CppCoreGuidelines.md:6190
msgid "6190    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6191
msgid "6191     `malloc()` and `free()` do not support construction and destruction, and do not mix well with `new` and `delete`."
msgstr""

       
# CppCoreGuidelines.md:6192
msgid "6192    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6193
msgid "6193        class Record {"
msgstr""

# CppCoreGuidelines.md:6194
msgid "6194            int id;"
msgstr""

# CppCoreGuidelines.md:6195
msgid "6195            string name;"
msgstr""

# CppCoreGuidelines.md:6196
msgid "6196            // ..."
msgstr""

# CppCoreGuidelines.md:6197
msgid "6197        };"
msgstr""

       
# CppCoreGuidelines.md:6198
msgid "6198        void use()"
msgstr""

# CppCoreGuidelines.md:6199
msgid "6199        {"
msgstr""

# CppCoreGuidelines.md:6200
msgid "6200            // p1 may be nullptr"
msgstr""

# CppCoreGuidelines.md:6201
msgid "6201            // *p1 is not initialized; in particular,"
msgstr""

# CppCoreGuidelines.md:6202
msgid "6202            // that string isn't a string, but a string-sized bag of bits"
msgstr""

# CppCoreGuidelines.md:6203
msgid "6203            Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));"
msgstr""

       
# CppCoreGuidelines.md:6204
msgid "6204            auto p2 = new Record;"
msgstr""

       
# CppCoreGuidelines.md:6205
msgid "6205            // unless an exception is thrown, *p2 is default initialized"
msgstr""

# CppCoreGuidelines.md:6206
msgid "6206            auto p3 = new(nothrow) Record;"
msgstr""

# CppCoreGuidelines.md:6207
msgid "6207            // p3 may be nullptr; if not, *p3 is default initialized"
msgstr""

       
# CppCoreGuidelines.md:6208
msgid "6208            // ..."
msgstr""

       
# CppCoreGuidelines.md:6209
msgid "6209            delete p1;    // error: cannot delete object allocated by malloc()"
msgstr""

# CppCoreGuidelines.md:6210
msgid "6210            free(p2);    // error: cannot free() object allocated by new"
msgstr""

# CppCoreGuidelines.md:6211
msgid "6211        }"
msgstr""

       
# CppCoreGuidelines.md:6212
msgid "6212    In some implementations that `delete` and that `free()` might work, or maybe they will cause run-time errors."
msgstr""

       
# CppCoreGuidelines.md:6213
msgid "6213    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6214
msgid "6214    There are applications and sections of code where exceptions are not acceptable."
msgstr""

# CppCoreGuidelines.md:6215
msgid "6215    Some of the best such examples are in life-critical hard-real-time code."
msgstr""

# CppCoreGuidelines.md:6216
msgid "6216    Beware that many bans on exception use are based on superstition (bad)"
msgstr""

# CppCoreGuidelines.md:6217
msgid "6217    or by concerns for older code bases with unsystematic resource management (unfortunately, but sometimes necessary)."
msgstr""

# CppCoreGuidelines.md:6218
msgid "6218    In such cases, consider the `nothrow` versions of `new`."
msgstr""

       
# CppCoreGuidelines.md:6219
msgid "6219    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6220
msgid "6220    Flag explicit use of `malloc` and `free`."
msgstr""

       
# CppCoreGuidelines.md:6221
msgid "6221    ### <a name=\"Rr-newdelete\"></a>R.11: Avoid calling `new` and `delete` explicitly"
msgstr""

       
# CppCoreGuidelines.md:6222
msgid "6222    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6223
msgid "6223    The pointer returned by `new` should belong to a resource handle (that can call `delete`)."
msgstr""

# CppCoreGuidelines.md:6224
msgid "6224    If the pointer returned by `new` is assigned to a plain/naked pointer, the object can be leaked."
msgstr""

       
# CppCoreGuidelines.md:6225
msgid "6225    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6226
msgid "6226    In a large program, a naked `delete` (that is a `delete` in application code, rather than part of code devoted to resource management)"
msgstr""

# CppCoreGuidelines.md:6227
msgid "6227    is a likely bug: if you have N `delete`s, how can you be certain that you don't need N+1 or N-1?"
msgstr""

# CppCoreGuidelines.md:6228
msgid "6228    The bug may be latent: it may emerge only during maintenance."
msgstr""

# CppCoreGuidelines.md:6229
msgid "6229    If you have a naked `new`, you probably need a naked `delete` somewhere, so you probably have a bug."
msgstr""

       
# CppCoreGuidelines.md:6230
msgid "6230    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6231
msgid "6231    (Simple) Warn on any explicit use of `new` and `delete`. Suggest using `make_unique` instead."
msgstr""

       
# CppCoreGuidelines.md:6232
msgid "6232    ### <a name=\"Rr-immediate-alloc\"></a>R.12: Immediately give the result of an explicit resource allocation to a manager object"
msgstr""

       
# CppCoreGuidelines.md:6233
msgid "6233    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6234
msgid "6234    If you don't, an exception or a return may lead to a leak."
msgstr""

       
# CppCoreGuidelines.md:6235
msgid "6235    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6236
msgid "6236        void f(const string& name)"
msgstr""

# CppCoreGuidelines.md:6237
msgid "6237        {"
msgstr""

# CppCoreGuidelines.md:6238
msgid "6238            FILE* f = fopen(name, \"r\");            // open the file"
msgstr""

# CppCoreGuidelines.md:6239
msgid "6239            vector<char> buf(1024);"
msgstr""

# CppCoreGuidelines.md:6240
msgid "6240            auto _ = finally([f] { fclose(f); });  // remember to close the file"
msgstr""

# CppCoreGuidelines.md:6241
msgid "6241            // ..."
msgstr""

# CppCoreGuidelines.md:6242
msgid "6242        }"
msgstr""

       
# CppCoreGuidelines.md:6243
msgid "6243    The allocation of `buf` may fail and leak the file handle."
msgstr""

       
# CppCoreGuidelines.md:6244
msgid "6244    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6245
msgid "6245        void f(const string& name)"
msgstr""

# CppCoreGuidelines.md:6246
msgid "6246        {"
msgstr""

# CppCoreGuidelines.md:6247
msgid "6247            ifstream f{name};   // open the file"
msgstr""

# CppCoreGuidelines.md:6248
msgid "6248            vector<char> buf(1024);"
msgstr""

# CppCoreGuidelines.md:6249
msgid "6249            // ..."
msgstr""

# CppCoreGuidelines.md:6250
msgid "6250        }"
msgstr""

       
# CppCoreGuidelines.md:6251
msgid "6251    The use of the file handle (in `ifstream`) is simple, efficient, and safe."
msgstr""

       
# CppCoreGuidelines.md:6252
msgid "6252    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6253
msgid "6253    * Flag explicit allocations used to initialize pointers (problem: how many direct resource allocations can we recognize?)"
msgstr""

       
# CppCoreGuidelines.md:6254
msgid "6254    ### <a name=\"Rr-single-alloc\"></a>R.13: Perform at most one explicit resource allocation in a single expression statement"
msgstr""

       
# CppCoreGuidelines.md:6255
msgid "6255    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6256
msgid "6256    If you perform two explicit resource allocations in one statement, you could leak resources because the order of evaluation of many subexpressions, including function arguments, is unspecified."
msgstr""

       
# CppCoreGuidelines.md:6257
msgid "6257    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6258
msgid "6258        void fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2);"
msgstr""

       
# CppCoreGuidelines.md:6259
msgid "6259    This `fun` can be called like this:"
msgstr""

       
# CppCoreGuidelines.md:6260
msgid "6260        // BAD: potential leak"
msgstr""

# CppCoreGuidelines.md:6261
msgid "6261        fun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d)));"
msgstr""

       
# CppCoreGuidelines.md:6262
msgid "6262    This is exception-unsafe because the compiler may reorder the two expressions building the function's two arguments."
msgstr""

# CppCoreGuidelines.md:6263
msgid "6263    In particular, the compiler can interleave execution of the two expressions:"
msgstr""

# CppCoreGuidelines.md:6264
msgid "6264    Memory allocation (by calling `operator new`) could be done first for both objects, followed by attempts to call the two `Widget` constructors."
msgstr""

# CppCoreGuidelines.md:6265
msgid "6265    If one of the constructor calls throws an exception, then the other object's memory will never be released!"
msgstr""

       
# CppCoreGuidelines.md:6266
msgid "6266    This subtle problem has a simple solution: Never perform more than one explicit resource allocation in a single expression statement."
msgstr""

# CppCoreGuidelines.md:6267
msgid "6267    For example:"
msgstr""

       
# CppCoreGuidelines.md:6268
msgid "6268        shared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy"
msgstr""

# CppCoreGuidelines.md:6269
msgid "6269        fun(sp1, new Widget(c, d));"
msgstr""

       
# CppCoreGuidelines.md:6270
msgid "6270    The best solution is to avoid explicit allocation entirely use factory functions that return owning objects:"
msgstr""

       
# CppCoreGuidelines.md:6271
msgid "6271        fun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // Best"
msgstr""

       
# CppCoreGuidelines.md:6272
msgid "6272    Write your own factory wrapper if there is not one already."
msgstr""

       
# CppCoreGuidelines.md:6273
msgid "6273    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6274
msgid "6274    * Flag expressions with multiple explicit resource allocations (problem: how many direct resource allocations can we recognize?)"
msgstr""

       
# CppCoreGuidelines.md:6275
msgid "6275    ### <a name=\"Rr-ap\"></a>R.14: ??? array vs. pointer parameter"
msgstr""

       
# CppCoreGuidelines.md:6276
msgid "6276    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6277
msgid "6277    An array decays to a pointer, thereby losing its size, opening the opportunity for range errors."
msgstr""

       
# CppCoreGuidelines.md:6278
msgid "6278    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6279
msgid "6279        ??? what do we recommend: f(int*[]) or f(int**) ???"
msgstr""

       
# CppCoreGuidelines.md:6280
msgid "6280    **Alternative**: Use `span` to preserve size information."
msgstr""

       
# CppCoreGuidelines.md:6281
msgid "6281    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6282
msgid "6282    Flag `[]` parameters."
msgstr""

       
# CppCoreGuidelines.md:6283
msgid "6283    ### <a name=\"Rr-pair\"></a>R.15: Always overload matched allocation/deallocation pairs"
msgstr""

       
# CppCoreGuidelines.md:6284
msgid "6284    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6285
msgid "6285    Otherwise you get mismatched operations and chaos."
msgstr""

       
# CppCoreGuidelines.md:6286
msgid "6286    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6287
msgid "6287        class X {"
msgstr""

# CppCoreGuidelines.md:6288
msgid "6288            // ..."
msgstr""

# CppCoreGuidelines.md:6289
msgid "6289            void* operator new(size_t s);"
msgstr""

# CppCoreGuidelines.md:6290
msgid "6290            void operator delete(void*);"
msgstr""

# CppCoreGuidelines.md:6291
msgid "6291            // ..."
msgstr""

# CppCoreGuidelines.md:6292
msgid "6292        };"
msgstr""

       
# CppCoreGuidelines.md:6293
msgid "6293    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6294
msgid "6294    If you want memory that cannot be deallocated, `=delete` the deallocation operation."
msgstr""

# CppCoreGuidelines.md:6295
msgid "6295    Don't leave it undeclared."
msgstr""

       
# CppCoreGuidelines.md:6296
msgid "6296    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6297
msgid "6297    Flag incomplete pairs."
msgstr""

       
# CppCoreGuidelines.md:6298
msgid "6298    ## <a name=\"SS-smart\"></a>R.smart: Smart pointers"
msgstr""

       
# CppCoreGuidelines.md:6299
msgid "6299    ### <a name=\"Rr-owner\"></a>R.20: Use `unique_ptr` or `shared_ptr` to represent ownership"
msgstr""

       
# CppCoreGuidelines.md:6300
msgid "6300    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6301
msgid "6301    They can prevent resource leaks."
msgstr""

       
# CppCoreGuidelines.md:6302
msgid "6302    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6303
msgid "6303    Consider:"
msgstr""

       
# CppCoreGuidelines.md:6304
msgid "6304        void f()"
msgstr""

# CppCoreGuidelines.md:6305
msgid "6305        {"
msgstr""

# CppCoreGuidelines.md:6306
msgid "6306            X x;"
msgstr""

# CppCoreGuidelines.md:6307
msgid "6307            X* p1 { new X };              // see also ???"
msgstr""

# CppCoreGuidelines.md:6308
msgid "6308            unique_ptr<T> p2 { new X };   // unique ownership; see also ???"
msgstr""

# CppCoreGuidelines.md:6309
msgid "6309            shared_ptr<T> p3 { new X };   // shared ownership; see also ???"
msgstr""

# CppCoreGuidelines.md:6310
msgid "6310            auto p4 = make_unique<X>();   // unique_ownership, preferable to the explicit use \"new\""
msgstr""

# CppCoreGuidelines.md:6311
msgid "6311            auto p5 = make_shared<X>();   // shared ownership, preferable to the explicit use \"new\""
msgstr""

# CppCoreGuidelines.md:6312
msgid "6312        }"
msgstr""

       
# CppCoreGuidelines.md:6313
msgid "6313    This will leak the object used to initialize `p1` (only)."
msgstr""

       
# CppCoreGuidelines.md:6314
msgid "6314    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6315
msgid "6315    (Simple) Warn if the return value of `new` or a function call with return value of pointer type is assigned to a raw pointer."
msgstr""

       
# CppCoreGuidelines.md:6316
msgid "6316    ### <a name=\"Rr-unique\"></a>R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership"
msgstr""

       
# CppCoreGuidelines.md:6317
msgid "6317    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6318
msgid "6318    A `unique_ptr` is conceptually simpler and more predictable (you know when destruction happens) and faster (you don't implicitly maintain a use count)."
msgstr""

       
# CppCoreGuidelines.md:6319
msgid "6319    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6320
msgid "6320    This needlessly adds and maintains a reference count."
msgstr""

       
# CppCoreGuidelines.md:6321
msgid "6321        void f()"
msgstr""

# CppCoreGuidelines.md:6322
msgid "6322        {"
msgstr""

# CppCoreGuidelines.md:6323
msgid "6323            shared_ptr<Base> base = make_shared<Derived>();"
msgstr""

# CppCoreGuidelines.md:6324
msgid "6324            // use base locally, without copying it -- refcount never exceeds 1"
msgstr""

# CppCoreGuidelines.md:6325
msgid "6325        } // destroy base"
msgstr""

       
# CppCoreGuidelines.md:6326
msgid "6326    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6327
msgid "6327    This is more efficient:"
msgstr""

       
# CppCoreGuidelines.md:6328
msgid "6328        void f()"
msgstr""

# CppCoreGuidelines.md:6329
msgid "6329        {"
msgstr""

# CppCoreGuidelines.md:6330
msgid "6330            unique_ptr<Base> base = make_unique<Derived>();"
msgstr""

# CppCoreGuidelines.md:6331
msgid "6331            // use base locally"
msgstr""

# CppCoreGuidelines.md:6332
msgid "6332        } // destroy base"
msgstr""

       
# CppCoreGuidelines.md:6333
msgid "6333    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6334
msgid "6334    (Simple) Warn if a function uses a `Shared_ptr` with an object allocated within the function, but never returns the `Shared_ptr` or passes it to a function requiring a `Shared_ptr&`. Suggest using `unique_ptr` instead."
msgstr""

       
# CppCoreGuidelines.md:6335
msgid "6335    ### <a name=\"Rr-make_shared\"></a>R.22: Use `make_shared()` to make `shared_ptr`s"
msgstr""

       
# CppCoreGuidelines.md:6336
msgid "6336    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6337
msgid "6337    If you first make an object and then give it to a `shared_ptr` constructor, you (most likely) do one more allocation (and later deallocation) than if you use `make_shared()` because the reference counts must be allocated separately from the object."
msgstr""

       
# CppCoreGuidelines.md:6338
msgid "6338    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6339
msgid "6339    Consider:"
msgstr""

       
# CppCoreGuidelines.md:6340
msgid "6340        shared_ptr<X> p1 { new X{2} }; // bad"
msgstr""

# CppCoreGuidelines.md:6341
msgid "6341        auto p = make_shared<X>(2);    // good"
msgstr""

       
# CppCoreGuidelines.md:6342
msgid "6342    The `make_shared()` version mentions `X` only once, so it is usually shorter (as well as faster) than the version with the explicit `new`."
msgstr""

       
# CppCoreGuidelines.md:6343
msgid "6343    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6344
msgid "6344    (Simple) Warn if a `shared_ptr` is constructed from the result of `new` rather than `make_shared`."
msgstr""

       
# CppCoreGuidelines.md:6345
msgid "6345    ### <a name=\"Rr-make_unique\"></a>R.23: Use `make_unique()` to make `unique_ptr`s"
msgstr""

       
# CppCoreGuidelines.md:6346
msgid "6346    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6347
msgid "6347    For convenience and consistency with `shared_ptr`."
msgstr""

       
# CppCoreGuidelines.md:6348
msgid "6348    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6349
msgid "6349    `make_unique()` is C++14, but widely available (as well as simple to write)."
msgstr""

       
# CppCoreGuidelines.md:6350
msgid "6350    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6351
msgid "6351    (Simple) Warn if a `unique_ptr` is constructed from the result of `new` rather than `make_unique`."
msgstr""

       
# CppCoreGuidelines.md:6352
msgid "6352    ### <a name=\"Rr-weak_ptr\"></a>R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s"
msgstr""

       
# CppCoreGuidelines.md:6353
msgid "6353    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6354
msgid "6354     `shared_ptr`'s rely on use counting and the use count for a cyclic structure never goes to zero, so we need a mechanism to"
msgstr""

# CppCoreGuidelines.md:6355
msgid "6355    be able to destroy a cyclic structure."
msgstr""

       
# CppCoreGuidelines.md:6356
msgid "6356    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6357
msgid "6357        #include <memory>"
msgstr""

       
# CppCoreGuidelines.md:6358
msgid "6358        class bar;"
msgstr""

       
# CppCoreGuidelines.md:6359
msgid "6359        class foo"
msgstr""

# CppCoreGuidelines.md:6360
msgid "6360        {"
msgstr""

# CppCoreGuidelines.md:6361
msgid "6361        public:"
msgstr""

# CppCoreGuidelines.md:6362
msgid "6362          explicit foo(const std::shared_ptr<bar>& forward_reference)"
msgstr""

# CppCoreGuidelines.md:6363
msgid "6363            : forward_reference_(forward_reference)"
msgstr""

# CppCoreGuidelines.md:6364
msgid "6364          { }"
msgstr""

# CppCoreGuidelines.md:6365
msgid "6365        private:"
msgstr""

# CppCoreGuidelines.md:6366
msgid "6366          std::shared_ptr<bar> forward_reference_;"
msgstr""

# CppCoreGuidelines.md:6367
msgid "6367        };"
msgstr""

       
# CppCoreGuidelines.md:6368
msgid "6368        class bar"
msgstr""

# CppCoreGuidelines.md:6369
msgid "6369        {"
msgstr""

# CppCoreGuidelines.md:6370
msgid "6370        public:"
msgstr""

# CppCoreGuidelines.md:6371
msgid "6371          explicit bar(const std::weak_ptr<foo>& back_reference)"
msgstr""

# CppCoreGuidelines.md:6372
msgid "6372            : back_reference_(back_reference)"
msgstr""

# CppCoreGuidelines.md:6373
msgid "6373          { }"
msgstr""

# CppCoreGuidelines.md:6374
msgid "6374          void do_something()"
msgstr""

# CppCoreGuidelines.md:6375
msgid "6375          {"
msgstr""

# CppCoreGuidelines.md:6376
msgid "6376            if (auto shared_back_reference = back_reference_.lock()) {"
msgstr""

# CppCoreGuidelines.md:6377
msgid "6377              // Use *shared_back_reference"
msgstr""

# CppCoreGuidelines.md:6378
msgid "6378            }"
msgstr""

# CppCoreGuidelines.md:6379
msgid "6379          }"
msgstr""

# CppCoreGuidelines.md:6380
msgid "6380        private:"
msgstr""

# CppCoreGuidelines.md:6381
msgid "6381          std::weak_ptr<foo> back_reference_;"
msgstr""

# CppCoreGuidelines.md:6382
msgid "6382        };"
msgstr""

       
# CppCoreGuidelines.md:6383
msgid "6383    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6384
msgid "6384     ??? (HS: A lot of people say \"to break cycles\", while I think \"temporary shared ownership\" is more to the point.)"
msgstr""

# CppCoreGuidelines.md:6385
msgid "6385    ???(BS: breaking cycles is what you must do; temporarily sharing ownership is how you do it."
msgstr""

# CppCoreGuidelines.md:6386
msgid "6386    You could \"temporarily share ownership\" simply by using another `shared_ptr`.)"
msgstr""

       
# CppCoreGuidelines.md:6387
msgid "6387    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6388
msgid "6388    ??? probably impossible. If we could statically detect cycles, we wouldn't need `weak_ptr`"
msgstr""

       
# CppCoreGuidelines.md:6389
msgid "6389    ### <a name=\"Rr-smartptrparam\"></a>R.30: Take smart pointers as parameters only to explicitly express lifetime semantics"
msgstr""

       
# CppCoreGuidelines.md:6390
msgid "6390    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6391
msgid "6391    Accepting a smart pointer to a `widget` is wrong if the function just needs the `widget` itself."
msgstr""

# CppCoreGuidelines.md:6392
msgid "6392    It should be able to accept any `widget` object, not just ones whose lifetimes are managed by a particular kind of smart pointer."
msgstr""

# CppCoreGuidelines.md:6393
msgid "6393    A function that does not manipulate lifetime should take raw pointers or references instead."
msgstr""

       
# CppCoreGuidelines.md:6394
msgid "6394    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6395
msgid "6395        // callee"
msgstr""

# CppCoreGuidelines.md:6396
msgid "6396        void f(shared_ptr<widget>& w)"
msgstr""

# CppCoreGuidelines.md:6397
msgid "6397        {"
msgstr""

# CppCoreGuidelines.md:6398
msgid "6398            // ..."
msgstr""

# CppCoreGuidelines.md:6399
msgid "6399            use(*w); // only use of w -- the lifetime is not used at all"
msgstr""

# CppCoreGuidelines.md:6400
msgid "6400            // ..."
msgstr""

# CppCoreGuidelines.md:6401
msgid "6401        };"
msgstr""

       
# CppCoreGuidelines.md:6402
msgid "6402        // caller"
msgstr""

# CppCoreGuidelines.md:6403
msgid "6403        shared_ptr<widget> my_widget = /* ... */;"
msgstr""

# CppCoreGuidelines.md:6404
msgid "6404        f(my_widget);"
msgstr""

       
# CppCoreGuidelines.md:6405
msgid "6405        widget stack_widget;"
msgstr""

# CppCoreGuidelines.md:6406
msgid "6406        f(stack_widget); // error"
msgstr""

       
# CppCoreGuidelines.md:6407
msgid "6407    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:6408
msgid "6408        // callee"
msgstr""

# CppCoreGuidelines.md:6409
msgid "6409        void f(widget& w)"
msgstr""

# CppCoreGuidelines.md:6410
msgid "6410        {"
msgstr""

# CppCoreGuidelines.md:6411
msgid "6411            // ..."
msgstr""

# CppCoreGuidelines.md:6412
msgid "6412            use(w);"
msgstr""

# CppCoreGuidelines.md:6413
msgid "6413            // ..."
msgstr""

# CppCoreGuidelines.md:6414
msgid "6414        };"
msgstr""

       
# CppCoreGuidelines.md:6415
msgid "6415        // caller"
msgstr""

# CppCoreGuidelines.md:6416
msgid "6416        shared_ptr<widget> my_widget = /* ... */;"
msgstr""

# CppCoreGuidelines.md:6417
msgid "6417        f(*my_widget);"
msgstr""

       
# CppCoreGuidelines.md:6418
msgid "6418        widget stack_widget;"
msgstr""

# CppCoreGuidelines.md:6419
msgid "6419        f(stack_widget); // ok -- now this works"
msgstr""

       
# CppCoreGuidelines.md:6420
msgid "6420    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6421
msgid "6421    * (Simple) Warn if a function takes a parameter of a smart pointer type (that overloads `operator->` or `operator*`) that is copyable but the function only calls any of: `operator*`, `operator->` or `get()`."
msgstr""

# CppCoreGuidelines.md:6422
msgid "6422      Suggest using a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6423
msgid "6423    * Flag a parameter of a smart pointer type (a type that overloads `operator->` or `operator*`) that is copyable/movable but never copied/moved from in the function body, and that is never modified, and that is not passed along to another function that could do so. That means the ownership semantics are not used."
msgstr""

# CppCoreGuidelines.md:6424
msgid "6424      Suggest using a `T*` or `T&` instead."
msgstr""

       
# CppCoreGuidelines.md:6425
msgid "6425    ### <a name=\"Rr-smart\"></a>R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`"
msgstr""

       
# CppCoreGuidelines.md:6426
msgid "6426    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6427
msgid "6427    The rules in the following section also work for other kinds of third-party and custom smart pointers and are very useful for diagnosing common smart pointer errors that cause performance and correctness problems."
msgstr""

# CppCoreGuidelines.md:6428
msgid "6428    You want the rules to work on all the smart pointers you use."
msgstr""

       
# CppCoreGuidelines.md:6429
msgid "6429    Any type (including primary template or specialization) that overloads unary `*` and `->` is considered a smart pointer:"
msgstr""

       
# CppCoreGuidelines.md:6430
msgid "6430    * If it is copyable, it is recognized as a reference-counted `shared_ptr`."
msgstr""

# CppCoreGuidelines.md:6431
msgid "6431    * If it is not copyable, it is recognized as a unique `unique_ptr`."
msgstr""

       
# CppCoreGuidelines.md:6432
msgid "6432    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6433
msgid "6433        // use Boost's intrusive_ptr"
msgstr""

# CppCoreGuidelines.md:6434
msgid "6434        #include <boost/intrusive_ptr.hpp>"
msgstr""

# CppCoreGuidelines.md:6435
msgid "6435        void f(boost::intrusive_ptr<widget> p)  // error under rule 'sharedptrparam'"
msgstr""

# CppCoreGuidelines.md:6436
msgid "6436        {"
msgstr""

# CppCoreGuidelines.md:6437
msgid "6437            p->foo();"
msgstr""

# CppCoreGuidelines.md:6438
msgid "6438        }"
msgstr""

       
# CppCoreGuidelines.md:6439
msgid "6439        // use Microsoft's CComPtr"
msgstr""

# CppCoreGuidelines.md:6440
msgid "6440        #include <atlbase.h>"
msgstr""

# CppCoreGuidelines.md:6441
msgid "6441        void f(CComPtr<widget> p)               // error under rule 'sharedptrparam'"
msgstr""

# CppCoreGuidelines.md:6442
msgid "6442        {"
msgstr""

# CppCoreGuidelines.md:6443
msgid "6443            p->foo();"
msgstr""

# CppCoreGuidelines.md:6444
msgid "6444        }"
msgstr""

       
# CppCoreGuidelines.md:6445
msgid "6445    Both cases are an error under the [`sharedptrparam` guideline](#Rr-smartptrparam):"
msgstr""

# CppCoreGuidelines.md:6446
msgid "6446    `p` is a `Shared_ptr`, but nothing about its sharedness is used here and passing it by value is a silent pessimization;"
msgstr""

# CppCoreGuidelines.md:6447
msgid "6447    these functions should accept a smart pointer only if they need to participate in the widget's lifetime management. Otherwise they should accept a `widget*`, if it can be `nullptr`. Otherwise, and ideally, the function should accept a `widget&`."
msgstr""

# CppCoreGuidelines.md:6448
msgid "6448    These smart pointers match the `Shared_ptr` concept, so these guideline enforcement rules work on them out of the box and expose this common pessimization."
msgstr""

       
# CppCoreGuidelines.md:6449
msgid "6449    ### <a name=\"Rr-uniqueptrparam\"></a>R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a `widget`"
msgstr""

       
# CppCoreGuidelines.md:6450
msgid "6450    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6451
msgid "6451    Using `unique_ptr` in this way both documents and enforces the function call's ownership transfer."
msgstr""

       
# CppCoreGuidelines.md:6452
msgid "6452    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6453
msgid "6453        void sink(unique_ptr<widget>); // takes ownership of the widget"
msgstr""

       
# CppCoreGuidelines.md:6454
msgid "6454        void uses(widget*);            // just uses the widget"
msgstr""

       
# CppCoreGuidelines.md:6455
msgid "6455    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6456
msgid "6456        void thinko(const unique_ptr<widget>&); // usually not what you want"
msgstr""

       
# CppCoreGuidelines.md:6457
msgid "6457    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6458
msgid "6458    * (Simple) Warn if a function takes a `Unique_ptr<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6459
msgid "6459    * (Simple) ((Foundation)) Warn if a function takes a `Unique_ptr<T>` parameter by reference to `const`. Suggest taking a `const T*` or `const T&` instead."
msgstr""

       
# CppCoreGuidelines.md:6460
msgid "6460    ### <a name=\"Rr-reseat\"></a>R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats the`widget`"
msgstr""

       
# CppCoreGuidelines.md:6461
msgid "6461    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6462
msgid "6462    Using `unique_ptr` in this way both documents and enforces the function call's reseating semantics."
msgstr""

       
# CppCoreGuidelines.md:6463
msgid "6463    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6464
msgid "6464    \"reseat\" means \"making a pointer or a smart pointer refer to a different object.\""
msgstr""

       
# CppCoreGuidelines.md:6465
msgid "6465    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6466
msgid "6466        void reseat(unique_ptr<widget>&); // \"will\" or \"might\" reseat pointer"
msgstr""

       
# CppCoreGuidelines.md:6467
msgid "6467    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6468
msgid "6468        void thinko(const unique_ptr<widget>&); // usually not what you want"
msgstr""

       
# CppCoreGuidelines.md:6469
msgid "6469    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6470
msgid "6470    * (Simple) Warn if a function takes a `Unique_ptr<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6471
msgid "6471    * (Simple) ((Foundation)) Warn if a function takes a `Unique_ptr<T>` parameter by reference to `const`. Suggest taking a `const T*` or `const T&` instead."
msgstr""

       
# CppCoreGuidelines.md:6472
msgid "6472    ### <a name=\"Rr-sharedptrparam-owner\"></a>R.34: Take a `shared_ptr<widget>` parameter to express that a function is part owner"
msgstr""

       
# CppCoreGuidelines.md:6473
msgid "6473    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6474
msgid "6474    This makes the function's ownership sharing explicit."
msgstr""

       
# CppCoreGuidelines.md:6475
msgid "6475    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:6476
msgid "6476        void share(shared_ptr<widget>);            // share -- \"will\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6477
msgid "6477        void may_share(const shared_ptr<widget>&); // \"might\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6478
msgid "6478        void reseat(shared_ptr<widget>&);          // \"might\" reseat ptr"
msgstr""

       
# CppCoreGuidelines.md:6479
msgid "6479    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6480
msgid "6480    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6481
msgid "6481    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by value or by reference to `const` and does not copy or move it to another `Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6482
msgid "6482    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by rvalue reference. Suggesting taking it by value instead."
msgstr""

       
# CppCoreGuidelines.md:6483
msgid "6483    ### <a name=\"Rr-sharedptrparam\"></a>R.35: Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer"
msgstr""

       
# CppCoreGuidelines.md:6484
msgid "6484    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6485
msgid "6485    This makes the function's reseating explicit."
msgstr""

       
# CppCoreGuidelines.md:6486
msgid "6486    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6487
msgid "6487    \"reseat\" means \"making a reference or a smart pointer refer to a different object.\""
msgstr""

       
# CppCoreGuidelines.md:6488
msgid "6488    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:6489
msgid "6489        void share(shared_ptr<widget>);            // share -- \"will\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6490
msgid "6490        void reseat(shared_ptr<widget>&);          // \"might\" reseat ptr"
msgstr""

       
# CppCoreGuidelines.md:6491
msgid "6491        void may_share(const shared_ptr<widget>&); // \"might\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6492
msgid "6492    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6493
msgid "6493    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6494
msgid "6494    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by value or by reference to `const` and does not copy or move it to another `Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6495
msgid "6495    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by rvalue reference. Suggesting taking it by value instead."
msgstr""

       
# CppCoreGuidelines.md:6496
msgid "6496    ### <a name=\"Rr-sharedptrparam-const\"></a>R.36: Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object ???"
msgstr""

       
# CppCoreGuidelines.md:6497
msgid "6497    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6498
msgid "6498    This makes the function's ??? explicit."
msgstr""

       
# CppCoreGuidelines.md:6499
msgid "6499    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:6500
msgid "6500        void share(shared_ptr<widget>);            // share -- \"will\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6501
msgid "6501        void reseat(shared_ptr<widget>&);          // \"might\" reseat ptr"
msgstr""

       
# CppCoreGuidelines.md:6502
msgid "6502        void may_share(const shared_ptr<widget>&); // \"might\" retain refcount"
msgstr""

       
# CppCoreGuidelines.md:6503
msgid "6503    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6504
msgid "6504    * (Simple) Warn if a function takes a `Shared_ptr<T>` parameter by lvalue reference and does not either assign to it or call `reset()` on it on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6505
msgid "6505    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by value or by reference to `const` and does not copy or move it to another `Shared_ptr` on at least one code path. Suggest taking a `T*` or `T&` instead."
msgstr""

# CppCoreGuidelines.md:6506
msgid "6506    * (Simple) ((Foundation)) Warn if a function takes a `Shared_ptr<T>` by rvalue reference. Suggesting taking it by value instead."
msgstr""

       
# CppCoreGuidelines.md:6507
msgid "6507    ### <a name=\"Rr-smartptrget\"></a>R.37: Do not pass a pointer or reference obtained from an aliased smart pointer"
msgstr""

       
# CppCoreGuidelines.md:6508
msgid "6508    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6509
msgid "6509    Violating this rule is the number one cause of losing reference counts and finding yourself with a dangling pointer."
msgstr""

# CppCoreGuidelines.md:6510
msgid "6510    Functions should prefer to pass raw pointers and references down call chains."
msgstr""

# CppCoreGuidelines.md:6511
msgid "6511    At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive."
msgstr""

# CppCoreGuidelines.md:6512
msgid "6512    You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below."
msgstr""

       
# CppCoreGuidelines.md:6513
msgid "6513    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6514
msgid "6514    To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree."
msgstr""

       
# CppCoreGuidelines.md:6515
msgid "6515    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6516
msgid "6516    Consider this code:"
msgstr""

       
# CppCoreGuidelines.md:6517
msgid "6517        // global (static or heap), or aliased local ..."
msgstr""

# CppCoreGuidelines.md:6518
msgid "6518        shared_ptr<widget> g_p = ...;"
msgstr""

       
# CppCoreGuidelines.md:6519
msgid "6519        void f(widget& w)"
msgstr""

# CppCoreGuidelines.md:6520
msgid "6520        {"
msgstr""

# CppCoreGuidelines.md:6521
msgid "6521            g();"
msgstr""

# CppCoreGuidelines.md:6522
msgid "6522            use(w);  // A"
msgstr""

# CppCoreGuidelines.md:6523
msgid "6523        }"
msgstr""

       
# CppCoreGuidelines.md:6524
msgid "6524        void g()"
msgstr""

# CppCoreGuidelines.md:6525
msgid "6525        {"
msgstr""

# CppCoreGuidelines.md:6526
msgid "6526            g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget"
msgstr""

# CppCoreGuidelines.md:6527
msgid "6527        }"
msgstr""

       
# CppCoreGuidelines.md:6528
msgid "6528    The following should not pass code review:"
msgstr""

       
# CppCoreGuidelines.md:6529
msgid "6529        void my_code()"
msgstr""

# CppCoreGuidelines.md:6530
msgid "6530        {"
msgstr""

# CppCoreGuidelines.md:6531
msgid "6531            // BAD: passing pointer or reference obtained from a nonlocal smart pointer"
msgstr""

# CppCoreGuidelines.md:6532
msgid "6532            //      that could be inadvertently reset somewhere inside f or it callees"
msgstr""

# CppCoreGuidelines.md:6533
msgid "6533            f(*g_p);"
msgstr""

       
# CppCoreGuidelines.md:6534
msgid "6534            // BAD: same reason, just passing it as a \"this\" pointer"
msgstr""

# CppCoreGuidelines.md:6535
msgid "6535             g_p->func();"
msgstr""

# CppCoreGuidelines.md:6536
msgid "6536        }"
msgstr""

       
# CppCoreGuidelines.md:6537
msgid "6537    The fix is simple -- take a local copy of the pointer to \"keep a ref count\" for your call tree:"
msgstr""

       
# CppCoreGuidelines.md:6538
msgid "6538        void my_code()"
msgstr""

# CppCoreGuidelines.md:6539
msgid "6539        {"
msgstr""

# CppCoreGuidelines.md:6540
msgid "6540            // cheap: 1 increment covers this entire function and all the call trees below us"
msgstr""

# CppCoreGuidelines.md:6541
msgid "6541            auto pin = g_p;"
msgstr""

       
# CppCoreGuidelines.md:6542
msgid "6542            // GOOD: passing pointer or reference obtained from a local unaliased smart pointer"
msgstr""

# CppCoreGuidelines.md:6543
msgid "6543            f(*pin);"
msgstr""

       
# CppCoreGuidelines.md:6544
msgid "6544            // GOOD: same reason"
msgstr""

# CppCoreGuidelines.md:6545
msgid "6545            pin->func();"
msgstr""

# CppCoreGuidelines.md:6546
msgid "6546        }"
msgstr""

       
# CppCoreGuidelines.md:6547
msgid "6547    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6548
msgid "6548    * (Simple) Warn if a pointer or reference obtained from a smart pointer variable (`Unique_ptr` or `Shared_ptr`) that is nonlocal, or that is local but potentially aliased, is used in a function call. If the smart pointer is a `Shared_ptr` then suggest taking a local copy of the smart pointer and obtain a pointer or reference from that instead."
msgstr""

       
# CppCoreGuidelines.md:6549
msgid "6549    # <a name=\"S-expr\"></a>ES: Expressions and statements"
msgstr""

       
# CppCoreGuidelines.md:6550
msgid "6550    Expressions and statements are the lowest and most direct way of expressing actions and computation. Declarations in local scopes are statements."
msgstr""

       
# CppCoreGuidelines.md:6551
msgid "6551    For naming, commenting, and indentation rules, see [NL: Naming and layout](#S-naming)."
msgstr""

       
# CppCoreGuidelines.md:6552
msgid "6552    General rules:"
msgstr""

       
# CppCoreGuidelines.md:6553
msgid "6553    * [ES.1: Prefer the standard library to other libraries and to \"handcrafted code\"](#Res-lib)"
msgstr""

# CppCoreGuidelines.md:6554
msgid "6554    * [ES.2: Prefer suitable abstractions to direct use of language features](#Res-abstr)"
msgstr""

       
# CppCoreGuidelines.md:6555
msgid "6555    Declaration rules:"
msgstr""

       
# CppCoreGuidelines.md:6556
msgid "6556    * [ES.5: Keep scopes small](#Res-scope)"
msgstr""

# CppCoreGuidelines.md:6557
msgid "6557    * [ES.6: Declare names in for-statement initializers and conditions to limit scope](#Res-cond)"
msgstr""

# CppCoreGuidelines.md:6558
msgid "6558    * [ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer](#Res-name-length)"
msgstr""

# CppCoreGuidelines.md:6559
msgid "6559    * [ES.8: Avoid similar-looking names](#Res-name-similar)"
msgstr""

# CppCoreGuidelines.md:6560
msgid "6560    * [ES.9: Avoid `ALL_CAPS` names](#Res-not-CAPS)"
msgstr""

# CppCoreGuidelines.md:6561
msgid "6561    * [ES.10: Declare one name (only) per declaration](#Res-name-one)"
msgstr""

# CppCoreGuidelines.md:6562
msgid "6562    * [ES.11: Use `auto` to avoid redundant repetition of type names](#Res-auto)"
msgstr""

# CppCoreGuidelines.md:6563
msgid "6563    * [ES.12: Do not reuse names in nested scopes](#Res-reuse)"
msgstr""

# CppCoreGuidelines.md:6564
msgid "6564    * [ES.20: Always initialize an object](#Res-always)"
msgstr""

# CppCoreGuidelines.md:6565
msgid "6565    * [ES.21: Don't introduce a variable (or constant) before you need to use it](#Res-introduce)"
msgstr""

# CppCoreGuidelines.md:6566
msgid "6566    * [ES.22: Don't declare a variable until you have a value to initialize it with](#Res-init)"
msgstr""

# CppCoreGuidelines.md:6567
msgid "6567    * [ES.23: Prefer the `{}`-initializer syntax](#Res-list)"
msgstr""

# CppCoreGuidelines.md:6568
msgid "6568    * [ES.24: Use a `unique_ptr<T>` to hold pointers](#Res-unique)"
msgstr""

# CppCoreGuidelines.md:6569
msgid "6569    * [ES.25: Declare an object `const` or `constexpr` unless you want to modify its value later on](#Res-const)"
msgstr""

# CppCoreGuidelines.md:6570
msgid "6570    * [ES.26: Don't use a variable for two unrelated purposes](#Res-recycle)"
msgstr""

# CppCoreGuidelines.md:6571
msgid "6571    * [ES.27: Use `std::array` or `stack_array` for arrays on the stack](#Res-stack)"
msgstr""

# CppCoreGuidelines.md:6572
msgid "6572    * [ES.28: Use lambdas for complex initialization, especially of `const` variables](#Res-lambda-init)"
msgstr""

# CppCoreGuidelines.md:6573
msgid "6573    * [ES.30: Don't use macros for program text manipulation](#Res-macros)"
msgstr""

# CppCoreGuidelines.md:6574
msgid "6574    * [ES.31: Don't use macros for constants or \"functions\"](#Res-macros2)"
msgstr""

# CppCoreGuidelines.md:6575
msgid "6575    * [ES.32: Use `ALL_CAPS` for all macro names](#Res-ALL_CAPS)"
msgstr""

# CppCoreGuidelines.md:6576
msgid "6576    * [ES.33: If you must use macros, give them unique names](#Res-MACROS)"
msgstr""

# CppCoreGuidelines.md:6577
msgid "6577    * [ES.34: Don't define a (C-style) variadic function](#Res-ellipses)"
msgstr""

       
# CppCoreGuidelines.md:6578
msgid "6578    Expression rules:"
msgstr""

       
# CppCoreGuidelines.md:6579
msgid "6579    * [ES.40: Avoid complicated expressions](#Res-complicated)"
msgstr""

# CppCoreGuidelines.md:6580
msgid "6580    * [ES.41: If in doubt about operator precedence, parenthesize](#Res-parens)"
msgstr""

# CppCoreGuidelines.md:6581
msgid "6581    * [ES.42: Keep use of pointers simple and straightforward](#Res-ptr)"
msgstr""

# CppCoreGuidelines.md:6582
msgid "6582    * [ES.43: Avoid expressions with undefined order of evaluation](#Res-order)"
msgstr""

# CppCoreGuidelines.md:6583
msgid "6583    * [ES.44: Don't depend on order of evaluation of function arguments](#Res-order-fct)"
msgstr""

# CppCoreGuidelines.md:6584
msgid "6584    * [ES.45: Avoid \"magic constants\"; use symbolic constants](#Res-magic)"
msgstr""

# CppCoreGuidelines.md:6585
msgid "6585    * [ES.46: Avoid narrowing conversions](#Res-narrowing)"
msgstr""

# CppCoreGuidelines.md:6586
msgid "6586    * [ES.47: Use `nullptr` rather than `0` or `NULL`](#Res-nullptr)"
msgstr""

# CppCoreGuidelines.md:6587
msgid "6587    * [ES.48: Avoid casts](#Res-casts)"
msgstr""

# CppCoreGuidelines.md:6588
msgid "6588    * [ES.49: If you must use a cast, use a named cast](#Res-casts-named)"
msgstr""

# CppCoreGuidelines.md:6589
msgid "6589    * [ES.50: Don't cast away `const`](#Res-casts-const)"
msgstr""

# CppCoreGuidelines.md:6590
msgid "6590    * [ES.55: Avoid the need for range checking](#Res-range-checking)"
msgstr""

# CppCoreGuidelines.md:6591
msgid "6591    * [ES.56: Write `std::move()` only when you need to explicitly move an object to another scope](#Res-move)"
msgstr""

# CppCoreGuidelines.md:6592
msgid "6592    * [ES.60: Avoid `new` and `delete` outside resource management functions](#Res-new)"
msgstr""

# CppCoreGuidelines.md:6593
msgid "6593    * [ES.61: Delete arrays using `delete[]` and non-arrays using `delete`](#Res-del)"
msgstr""

# CppCoreGuidelines.md:6594
msgid "6594    * [ES.62: Don't compare pointers into different arrays](#Res-arr2)"
msgstr""

# CppCoreGuidelines.md:6595
msgid "6595    * [ES.63: Don't slice](#Res-slice)"
msgstr""

# CppCoreGuidelines.md:6596
msgid "6596    * [ES.64: Use the `T{e}`notation for construction](#Res-construct)"
msgstr""

# CppCoreGuidelines.md:6597
msgid "6597    * [ES.65: Don't dereference an invalid pointer](#Res-deref)"
msgstr""

       
# CppCoreGuidelines.md:6598
msgid "6598    Statement rules:"
msgstr""

       
# CppCoreGuidelines.md:6599
msgid "6599    * [ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice](#Res-switch-if)"
msgstr""

# CppCoreGuidelines.md:6600
msgid "6600    * [ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a choice](#Res-for-range)"
msgstr""

# CppCoreGuidelines.md:6601
msgid "6601    * [ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious loop variable](#Res-for-while)"
msgstr""

# CppCoreGuidelines.md:6602
msgid "6602    * [ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious loop variable](#Res-while-for)"
msgstr""

# CppCoreGuidelines.md:6603
msgid "6603    * [ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement](#Res-for-init)"
msgstr""

# CppCoreGuidelines.md:6604
msgid "6604    * [ES.75: Avoid `do`-statements](#Res-do)"
msgstr""

# CppCoreGuidelines.md:6605
msgid "6605    * [ES.76: Avoid `goto`](#Res-goto)"
msgstr""

# CppCoreGuidelines.md:6606
msgid "6606    * [ES.77: Minimize the use of `break` and `continue` in loops](#Res-continue)"
msgstr""

# CppCoreGuidelines.md:6607
msgid "6607    * [ES.78: Always end a non-empty `case` with a `break`](#Res-break)"
msgstr""

# CppCoreGuidelines.md:6608
msgid "6608    * [ES.79: Use `default` to handle common cases (only)](#Res-default)"
msgstr""

# CppCoreGuidelines.md:6609
msgid "6609    * [ES.84: Don't (try to) declare a local variable with no name](#Res-noname)"
msgstr""

# CppCoreGuidelines.md:6610
msgid "6610    * [ES.85: Make empty statements visible](#Res-empty)"
msgstr""

# CppCoreGuidelines.md:6611
msgid "6611    * [ES.86: Avoid modifying loop control variables inside the body of raw for-loops](#Res-loop-counter)"
msgstr""

# CppCoreGuidelines.md:6612
msgid "6612    * [ES.87: Don't add redundant `==` or `!=` to conditions](#Res-if)"
msgstr""

       
# CppCoreGuidelines.md:6613
msgid "6613    Arithmetic rules:"
msgstr""

       
# CppCoreGuidelines.md:6614
msgid "6614    * [ES.100: Don't mix signed and unsigned arithmetic](#Res-mix)"
msgstr""

# CppCoreGuidelines.md:6615
msgid "6615    * [ES.101: Use unsigned types for bit manipulation](#Res-unsigned)"
msgstr""

# CppCoreGuidelines.md:6616
msgid "6616    * [ES.102: Use signed types for arithmetic](#Res-signed)"
msgstr""

# CppCoreGuidelines.md:6617
msgid "6617    * [ES.103: Don't overflow](#Res-overflow)"
msgstr""

# CppCoreGuidelines.md:6618
msgid "6618    * [ES.104: Don't underflow](#Res-underflow)"
msgstr""

# CppCoreGuidelines.md:6619
msgid "6619    * [ES.105: Don't divide by zero](#Res-zero)"
msgstr""

# CppCoreGuidelines.md:6620
msgid "6620    * [ES.106: Don't try to avoid negative values by using `unsigned`](#Res-nonnegative)"
msgstr""

# CppCoreGuidelines.md:6621
msgid "6621    * [ES.107: Don't use `unsigned` for subscripts, prefer `gsl::index`](#Res-subscripts)"
msgstr""

       
# CppCoreGuidelines.md:6622
msgid "6622    ### <a name=\"Res-lib\"></a>ES.1: Prefer the standard library to other libraries and to \"handcrafted code\""
msgstr""

       
# CppCoreGuidelines.md:6623
msgid "6623    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6624
msgid "6624    Code using a library can be much easier to write than code working directly with language features, much shorter, tend to be of a higher level of abstraction, and the library code is presumably already tested."
msgstr""

# CppCoreGuidelines.md:6625
msgid "6625    The ISO C++ Standard Library is among the most widely known and best tested libraries."
msgstr""

# CppCoreGuidelines.md:6626
msgid "6626    It is available as part of all C++ Implementations."
msgstr""

       
# CppCoreGuidelines.md:6627
msgid "6627    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6628
msgid "6628        auto sum = accumulate(begin(a), end(a), 0.0);   // good"
msgstr""

       
# CppCoreGuidelines.md:6629
msgid "6629    a range version of `accumulate` would be even better:"
msgstr""

       
# CppCoreGuidelines.md:6630
msgid "6630        auto sum = accumulate(v, 0.0); // better"
msgstr""

       
# CppCoreGuidelines.md:6631
msgid "6631    but don't hand-code a well-known algorithm:"
msgstr""

       
# CppCoreGuidelines.md:6632
msgid "6632        int max = v.size();   // bad: verbose, purpose unstated"
msgstr""

# CppCoreGuidelines.md:6633
msgid "6633        double sum = 0.0;"
msgstr""

# CppCoreGuidelines.md:6634
msgid "6634        for (int i = 0; i < max; ++i)"
msgstr""

# CppCoreGuidelines.md:6635
msgid "6635            sum = sum + v[i];"
msgstr""

       
# CppCoreGuidelines.md:6636
msgid "6636    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6637
msgid "6637    Large parts of the standard library rely on dynamic allocation (free store). These parts, notably the containers but not the algorithms, are unsuitable for some hard-real-time and embedded applications. In such cases, consider providing/using similar facilities, e.g.,  a standard-library-style container implemented using a pool allocator."
msgstr""

       
# CppCoreGuidelines.md:6638
msgid "6638    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6639
msgid "6639    Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?"
msgstr""

       
# CppCoreGuidelines.md:6640
msgid "6640    ### <a name=\"Res-abstr\"></a>ES.2: Prefer suitable abstractions to direct use of language features"
msgstr""

       
# CppCoreGuidelines.md:6641
msgid "6641    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6642
msgid "6642    A \"suitable abstraction\" (e.g., library or class) is closer to the application concepts than the bare language, leads to shorter and clearer code, and is likely to be better tested."
msgstr""

       
# CppCoreGuidelines.md:6643
msgid "6643    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6644
msgid "6644        vector<string> read1(istream& is)   // good"
msgstr""

# CppCoreGuidelines.md:6645
msgid "6645        {"
msgstr""

# CppCoreGuidelines.md:6646
msgid "6646            vector<string> res;"
msgstr""

# CppCoreGuidelines.md:6647
msgid "6647            for (string s; is >> s;)"
msgstr""

# CppCoreGuidelines.md:6648
msgid "6648                res.push_back(s);"
msgstr""

# CppCoreGuidelines.md:6649
msgid "6649            return res;"
msgstr""

# CppCoreGuidelines.md:6650
msgid "6650        }"
msgstr""

       
# CppCoreGuidelines.md:6651
msgid "6651    The more traditional and lower-level near-equivalent is longer, messier, harder to get right, and most likely slower:"
msgstr""

       
# CppCoreGuidelines.md:6652
msgid "6652        char** read2(istream& is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete"
msgstr""

# CppCoreGuidelines.md:6653
msgid "6653        {"
msgstr""

# CppCoreGuidelines.md:6654
msgid "6654            auto res = new char*[maxelem];"
msgstr""

# CppCoreGuidelines.md:6655
msgid "6655            int elemcount = 0;"
msgstr""

# CppCoreGuidelines.md:6656
msgid "6656            while (is && elemcount < maxelem) {"
msgstr""

# CppCoreGuidelines.md:6657
msgid "6657                auto s = new char[maxstring];"
msgstr""

# CppCoreGuidelines.md:6658
msgid "6658                is.read(s, maxstring);"
msgstr""

# CppCoreGuidelines.md:6659
msgid "6659                res[elemcount++] = s;"
msgstr""

# CppCoreGuidelines.md:6660
msgid "6660            }"
msgstr""

# CppCoreGuidelines.md:6661
msgid "6661            nread = &elemcount;"
msgstr""

# CppCoreGuidelines.md:6662
msgid "6662            return res;"
msgstr""

# CppCoreGuidelines.md:6663
msgid "6663        }"
msgstr""

       
# CppCoreGuidelines.md:6664
msgid "6664    Once the checking for overflow and error handling has been added that code gets quite messy, and there is the problem remembering to `delete` the returned pointer and the C-style strings that array contains."
msgstr""

       
# CppCoreGuidelines.md:6665
msgid "6665    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6666
msgid "6666    Not easy. ??? Look for messy loops, nested loops, long functions, absence of function calls, lack of use of non-built-in types. Cyclomatic complexity?"
msgstr""

       
# CppCoreGuidelines.md:6667
msgid "6667    ## ES.dcl: Declarations"
msgstr""

       
# CppCoreGuidelines.md:6668
msgid "6668    A declaration is a statement. A declaration introduces a name into a scope and may cause the construction of a named object."
msgstr""

       
# CppCoreGuidelines.md:6669
msgid "6669    ### <a name=\"Res-scope\"></a>ES.5: Keep scopes small"
msgstr""

       
# CppCoreGuidelines.md:6670
msgid "6670    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6671
msgid "6671    Readability. Minimize resource retention. Avoid accidental misuse of value."
msgstr""

       
# CppCoreGuidelines.md:6672
msgid "6672    **Alternative formulation**: Don't declare a name in an unnecessarily large scope."
msgstr""

       
# CppCoreGuidelines.md:6673
msgid "6673    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6674
msgid "6674        void use()"
msgstr""

# CppCoreGuidelines.md:6675
msgid "6675        {"
msgstr""

# CppCoreGuidelines.md:6676
msgid "6676            int i;    // bad: i is needlessly accessible after loop"
msgstr""

# CppCoreGuidelines.md:6677
msgid "6677            for (i = 0; i < 20; ++i) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:6678
msgid "6678            // no intended use of i here"
msgstr""

# CppCoreGuidelines.md:6679
msgid "6679            for (int i = 0; i < 20; ++i) { /* ... */ }  // good: i is local to for-loop"
msgstr""

       
# CppCoreGuidelines.md:6680
msgid "6680            if (auto pc = dynamic_cast<Circle*>(ps)) {  // good: pc is local to if-statement"
msgstr""

# CppCoreGuidelines.md:6681
msgid "6681                // ... deal with Circle ..."
msgstr""

# CppCoreGuidelines.md:6682
msgid "6682            }"
msgstr""

# CppCoreGuidelines.md:6683
msgid "6683            else {"
msgstr""

# CppCoreGuidelines.md:6684
msgid "6684                // ... handle error ..."
msgstr""

# CppCoreGuidelines.md:6685
msgid "6685            }"
msgstr""

# CppCoreGuidelines.md:6686
msgid "6686        }"
msgstr""

       
# CppCoreGuidelines.md:6687
msgid "6687    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6688
msgid "6688        void use(const string& name)"
msgstr""

# CppCoreGuidelines.md:6689
msgid "6689        {"
msgstr""

# CppCoreGuidelines.md:6690
msgid "6690            string fn = name + \".txt\";"
msgstr""

# CppCoreGuidelines.md:6691
msgid "6691            ifstream is {fn};"
msgstr""

# CppCoreGuidelines.md:6692
msgid "6692            Record r;"
msgstr""

# CppCoreGuidelines.md:6693
msgid "6693            is >> r;"
msgstr""

# CppCoreGuidelines.md:6694
msgid "6694            // ... 200 lines of code without intended use of fn or is ..."
msgstr""

# CppCoreGuidelines.md:6695
msgid "6695        }"
msgstr""

       
# CppCoreGuidelines.md:6696
msgid "6696    This function is by most measure too long anyway, but the point is that the resources used by `fn` and the file handle held by `is`"
msgstr""

# CppCoreGuidelines.md:6697
msgid "6697    are retained for much longer than needed and that unanticipated use of `is` and `fn` could happen later in the function."
msgstr""

# CppCoreGuidelines.md:6698
msgid "6698    In this case, it might be a good idea to factor out the read:"
msgstr""

       
# CppCoreGuidelines.md:6699
msgid "6699        Record load_record(const string& name)"
msgstr""

# CppCoreGuidelines.md:6700
msgid "6700        {"
msgstr""

# CppCoreGuidelines.md:6701
msgid "6701            string fn = name + \".txt\";"
msgstr""

# CppCoreGuidelines.md:6702
msgid "6702            ifstream is {fn};"
msgstr""

# CppCoreGuidelines.md:6703
msgid "6703            Record r;"
msgstr""

# CppCoreGuidelines.md:6704
msgid "6704            is >> r;"
msgstr""

# CppCoreGuidelines.md:6705
msgid "6705            return r;"
msgstr""

# CppCoreGuidelines.md:6706
msgid "6706        }"
msgstr""

       
# CppCoreGuidelines.md:6707
msgid "6707        void use(const string& name)"
msgstr""

# CppCoreGuidelines.md:6708
msgid "6708        {"
msgstr""

# CppCoreGuidelines.md:6709
msgid "6709            Record r = load_record(name);"
msgstr""

# CppCoreGuidelines.md:6710
msgid "6710            // ... 200 lines of code ..."
msgstr""

# CppCoreGuidelines.md:6711
msgid "6711        }"
msgstr""

       
# CppCoreGuidelines.md:6712
msgid "6712    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6713
msgid "6713    * Flag loop variable declared outside a loop and not used after the loop"
msgstr""

# CppCoreGuidelines.md:6714
msgid "6714    * Flag when expensive resources, such as file handles and locks are not used for N-lines (for some suitable N)"
msgstr""

       
# CppCoreGuidelines.md:6715
msgid "6715    ### <a name=\"Res-cond\"></a>ES.6: Declare names in for-statement initializers and conditions to limit scope"
msgstr""

       
# CppCoreGuidelines.md:6716
msgid "6716    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6717
msgid "6717    Readability. Minimize resource retention."
msgstr""

       
# CppCoreGuidelines.md:6718
msgid "6718    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6719
msgid "6719        void use()"
msgstr""

# CppCoreGuidelines.md:6720
msgid "6720        {"
msgstr""

# CppCoreGuidelines.md:6721
msgid "6721            for (string s; cin >> s;)"
msgstr""

# CppCoreGuidelines.md:6722
msgid "6722                v.push_back(s);"
msgstr""

       
# CppCoreGuidelines.md:6723
msgid "6723            for (int i = 0; i < 20; ++i) {   // good: i is local to for-loop"
msgstr""

# CppCoreGuidelines.md:6724
msgid "6724                // ..."
msgstr""

# CppCoreGuidelines.md:6725
msgid "6725            }"
msgstr""

       
# CppCoreGuidelines.md:6726
msgid "6726            if (auto pc = dynamic_cast<Circle*>(ps)) {   // good: pc is local to if-statement"
msgstr""

# CppCoreGuidelines.md:6727
msgid "6727                // ... deal with Circle ..."
msgstr""

# CppCoreGuidelines.md:6728
msgid "6728            }"
msgstr""

# CppCoreGuidelines.md:6729
msgid "6729            else {"
msgstr""

# CppCoreGuidelines.md:6730
msgid "6730                // ... handle error ..."
msgstr""

# CppCoreGuidelines.md:6731
msgid "6731            }"
msgstr""

# CppCoreGuidelines.md:6732
msgid "6732        }"
msgstr""

       
# CppCoreGuidelines.md:6733
msgid "6733    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6734
msgid "6734    * Flag loop variables declared before the loop and not used after the loop"
msgstr""

# CppCoreGuidelines.md:6735
msgid "6735    * (hard) Flag loop variables declared before the loop and used after the loop for an unrelated purpose."
msgstr""

       
# CppCoreGuidelines.md:6736
msgid "6736    ##### C++17 example"
msgstr""

       
# CppCoreGuidelines.md:6737
msgid "6737    Note: C++17 also adds `if` and `switch` initializer statements. These require C++17 support."
msgstr""

       
# CppCoreGuidelines.md:6738
msgid "6738        map<int, string> mymap;"
msgstr""

       
# CppCoreGuidelines.md:6739
msgid "6739        if (auto result = mymap.insert(value); result.second) {"
msgstr""

# CppCoreGuidelines.md:6740
msgid "6740            // insert succeeded, and result is valid for this block"
msgstr""

# CppCoreGuidelines.md:6741
msgid "6741            use(result.first);  // ok"
msgstr""

# CppCoreGuidelines.md:6742
msgid "6742            // ..."
msgstr""

# CppCoreGuidelines.md:6743
msgid "6743        } // result is destroyed here"
msgstr""

       
# CppCoreGuidelines.md:6744
msgid "6744    ##### C++17 enforcement (if using a C++17 compiler)"
msgstr""

       
# CppCoreGuidelines.md:6745
msgid "6745    * Flag selection/loop variables declared before the body and not used after the body"
msgstr""

# CppCoreGuidelines.md:6746
msgid "6746    * (hard) Flag selection/loop variables declared before the body and used after the body for an unrelated purpose."
msgstr""

       
       
       
# CppCoreGuidelines.md:6747
msgid "6747    ### <a name=\"Res-name-length\"></a>ES.7: Keep common and local names short, and keep uncommon and nonlocal names longer"
msgstr""

       
# CppCoreGuidelines.md:6748
msgid "6748    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6749
msgid "6749    Readability. Lowering the chance of clashes between unrelated non-local names."
msgstr""

       
# CppCoreGuidelines.md:6750
msgid "6750    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6751
msgid "6751    Conventional short, local names increase readability:"
msgstr""

       
# CppCoreGuidelines.md:6752
msgid "6752        template<typename T>    // good"
msgstr""

# CppCoreGuidelines.md:6753
msgid "6753        void print(ostream& os, const vector<T>& v)"
msgstr""

# CppCoreGuidelines.md:6754
msgid "6754        {"
msgstr""

# CppCoreGuidelines.md:6755
msgid "6755            for (gsl::index i = 0; i < v.size(); ++i)"
msgstr""

# CppCoreGuidelines.md:6756
msgid "6756                os << v[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:6757
msgid "6757        }"
msgstr""

       
# CppCoreGuidelines.md:6758
msgid "6758    An index is conventionally called `i` and there is no hint about the meaning of the vector in this generic function, so `v` is as good name as any. Compare"
msgstr""

       
# CppCoreGuidelines.md:6759
msgid "6759        template<typename Element_type>   // bad: verbose, hard to read"
msgstr""

# CppCoreGuidelines.md:6760
msgid "6760        void print(ostream& target_stream, const vector<Element_type>& current_vector)"
msgstr""

# CppCoreGuidelines.md:6761
msgid "6761        {"
msgstr""

# CppCoreGuidelines.md:6762
msgid "6762            for (gsl::index current_element_index = 0;"
msgstr""

# CppCoreGuidelines.md:6763
msgid "6763                 current_element_index < current_vector.size();"
msgstr""

# CppCoreGuidelines.md:6764
msgid "6764                 ++current_element_index"
msgstr""

# CppCoreGuidelines.md:6765
msgid "6765            )"
msgstr""

# CppCoreGuidelines.md:6766
msgid "6766            target_stream << current_vector[current_element_index] << '\\n';"
msgstr""

# CppCoreGuidelines.md:6767
msgid "6767        }"
msgstr""

       
# CppCoreGuidelines.md:6768
msgid "6768    Yes, it is a caricature, but we have seen worse."
msgstr""

       
# CppCoreGuidelines.md:6769
msgid "6769    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6770
msgid "6770    Unconventional and short non-local names obscure code:"
msgstr""

       
# CppCoreGuidelines.md:6771
msgid "6771        void use1(const string& s)"
msgstr""

# CppCoreGuidelines.md:6772
msgid "6772        {"
msgstr""

# CppCoreGuidelines.md:6773
msgid "6773            // ..."
msgstr""

# CppCoreGuidelines.md:6774
msgid "6774            tt(s);   // bad: what is tt()?"
msgstr""

# CppCoreGuidelines.md:6775
msgid "6775            // ..."
msgstr""

# CppCoreGuidelines.md:6776
msgid "6776        }"
msgstr""

       
# CppCoreGuidelines.md:6777
msgid "6777    Better, give non-local entities readable names:"
msgstr""

       
# CppCoreGuidelines.md:6778
msgid "6778        void use1(const string& s)"
msgstr""

# CppCoreGuidelines.md:6779
msgid "6779        {"
msgstr""

# CppCoreGuidelines.md:6780
msgid "6780            // ..."
msgstr""

# CppCoreGuidelines.md:6781
msgid "6781            trim_tail(s);   // better"
msgstr""

# CppCoreGuidelines.md:6782
msgid "6782            // ..."
msgstr""

# CppCoreGuidelines.md:6783
msgid "6783        }"
msgstr""

       
# CppCoreGuidelines.md:6784
msgid "6784    Here, there is a chance that the reader knows what `trim_tail` means and that the reader can remember it after looking it up."
msgstr""

       
# CppCoreGuidelines.md:6785
msgid "6785    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6786
msgid "6786    Argument names of large functions are de facto non-local and should be meaningful:"
msgstr""

       
# CppCoreGuidelines.md:6787
msgid "6787        void complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out)"
msgstr""

# CppCoreGuidelines.md:6788
msgid "6788        // read from events in vr (marking used Records) for the indices in"
msgstr""

# CppCoreGuidelines.md:6789
msgid "6789        // vi placing (name, index) pairs into out"
msgstr""

# CppCoreGuidelines.md:6790
msgid "6790        {"
msgstr""

# CppCoreGuidelines.md:6791
msgid "6791            // ... 500 lines of code using vr, vi, and out ..."
msgstr""

# CppCoreGuidelines.md:6792
msgid "6792        }"
msgstr""

       
# CppCoreGuidelines.md:6793
msgid "6793    We recommend keeping functions short, but that rule isn't universally adhered to and naming should reflect that."
msgstr""

       
# CppCoreGuidelines.md:6794
msgid "6794    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6795
msgid "6795    Check length of local and non-local names. Also take function length into account."
msgstr""

       
# CppCoreGuidelines.md:6796
msgid "6796    ### <a name=\"Res-name-similar\"></a>ES.8: Avoid similar-looking names"
msgstr""

       
# CppCoreGuidelines.md:6797
msgid "6797    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6798
msgid "6798    Code clarity and readability. Too-similar names slow down comprehension and increase the likelihood of error."
msgstr""

       
# CppCoreGuidelines.md:6799
msgid "6799    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:6800
msgid "6800        if (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise();"
msgstr""

       
# CppCoreGuidelines.md:6801
msgid "6801    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:6802
msgid "6802    Do not declare a non-type with the same name as a type in the same scope. This removes the need to disambiguate with a keyword such as `struct` or `enum`. It also removes a source of errors, as `struct X` can implicitly declare `X` if lookup fails."
msgstr""

       
# CppCoreGuidelines.md:6803
msgid "6803        struct foo { int n; };"
msgstr""

# CppCoreGuidelines.md:6804
msgid "6804        struct foo foo();       // BAD, foo is a type already in scope"
msgstr""

# CppCoreGuidelines.md:6805
msgid "6805        struct foo x = foo();   // requires disambiguation"
msgstr""

       
# CppCoreGuidelines.md:6806
msgid "6806    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6807
msgid "6807    Antique header files might declare non-types and types with the same name in the same scope."
msgstr""

       
# CppCoreGuidelines.md:6808
msgid "6808    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6809
msgid "6809    * Check names against a list of known confusing letter and digit combinations."
msgstr""

# CppCoreGuidelines.md:6810
msgid "6810    * Flag a declaration of a variable, function, or enumerator that hides a class or enumeration declared in the same scope."
msgstr""

       
# CppCoreGuidelines.md:6811
msgid "6811    ### <a name=\"Res-not-CAPS\"></a>ES.9: Avoid `ALL_CAPS` names"
msgstr""

       
# CppCoreGuidelines.md:6812
msgid "6812    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6813
msgid "6813    Such names are commonly used for macros. Thus, `ALL_CAPS` name are vulnerable to unintended macro substitution."
msgstr""

       
# CppCoreGuidelines.md:6814
msgid "6814    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6815
msgid "6815        // somewhere in some header:"
msgstr""

# CppCoreGuidelines.md:6816
msgid "6816        #define NE !="
msgstr""

       
# CppCoreGuidelines.md:6817
msgid "6817        // somewhere else in some other header:"
msgstr""

# CppCoreGuidelines.md:6818
msgid "6818        enum Coord { N, NE, NW, S, SE, SW, E, W };"
msgstr""

       
# CppCoreGuidelines.md:6819
msgid "6819        // somewhere third in some poor programmer's .cpp:"
msgstr""

# CppCoreGuidelines.md:6820
msgid "6820        switch (direction) {"
msgstr""

# CppCoreGuidelines.md:6821
msgid "6821        case N:"
msgstr""

# CppCoreGuidelines.md:6822
msgid "6822            // ..."
msgstr""

# CppCoreGuidelines.md:6823
msgid "6823        case NE:"
msgstr""

# CppCoreGuidelines.md:6824
msgid "6824            // ..."
msgstr""

# CppCoreGuidelines.md:6825
msgid "6825        // ..."
msgstr""

# CppCoreGuidelines.md:6826
msgid "6826        }"
msgstr""

       
# CppCoreGuidelines.md:6827
msgid "6827    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6828
msgid "6828    Do not use `ALL_CAPS` for constants just because constants used to be macros."
msgstr""

       
# CppCoreGuidelines.md:6829
msgid "6829    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6830
msgid "6830    Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and flag all non-ALL-CAPS macro names."
msgstr""

       
# CppCoreGuidelines.md:6831
msgid "6831    ### <a name=\"Res-name-one\"></a>ES.10: Declare one name (only) per declaration"
msgstr""

       
# CppCoreGuidelines.md:6832
msgid "6832    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6833
msgid "6833    One-declaration-per line increases readability and avoids mistakes related to"
msgstr""

# CppCoreGuidelines.md:6834
msgid "6834    the C/C++ grammar. It also leaves room for a more descriptive end-of-line"
msgstr""

# CppCoreGuidelines.md:6835
msgid "6835    comment."
msgstr""

       
# CppCoreGuidelines.md:6836
msgid "6836    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6837
msgid "6837        char *p, c, a[7], *pp[7], **aa[10];   // yuck!"
msgstr""

       
# CppCoreGuidelines.md:6838
msgid "6838    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6839
msgid "6839    A function declaration can contain several function argument declarations."
msgstr""

       
# CppCoreGuidelines.md:6840
msgid "6840    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6841
msgid "6841    A structured binding (C++17) is specifically designed to introduce several variables:"
msgstr""

       
# CppCoreGuidelines.md:6842
msgid "6842        auto [iter, inserted] = m.insert_or_assign(k, val);"
msgstr""

# CppCoreGuidelines.md:6843
msgid "6843        if (inserted) { /* new entry was inserted */ }"
msgstr""

       
# CppCoreGuidelines.md:6844
msgid "6844    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6845
msgid "6845        template <class InputIterator, class Predicate>"
msgstr""

# CppCoreGuidelines.md:6846
msgid "6846        bool any_of(InputIterator first, InputIterator last, Predicate pred);"
msgstr""

       
# CppCoreGuidelines.md:6847
msgid "6847    or better using concepts:"
msgstr""

       
# CppCoreGuidelines.md:6848
msgid "6848        bool any_of(InputIterator first, InputIterator last, Predicate pred);"
msgstr""

       
# CppCoreGuidelines.md:6849
msgid "6849    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6850
msgid "6850        double scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2"
msgstr""

       
# CppCoreGuidelines.md:6851
msgid "6851    or:"
msgstr""

       
# CppCoreGuidelines.md:6852
msgid "6852        double scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2"
msgstr""

# CppCoreGuidelines.md:6853
msgid "6853            double x,     // base value"
msgstr""

# CppCoreGuidelines.md:6854
msgid "6854            int n         // exponent"
msgstr""

# CppCoreGuidelines.md:6855
msgid "6855        );"
msgstr""

       
# CppCoreGuidelines.md:6856
msgid "6856    or:"
msgstr""

       
# CppCoreGuidelines.md:6857
msgid "6857        // better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2"
msgstr""

# CppCoreGuidelines.md:6858
msgid "6858        double scalbn(double base, int exponent);"
msgstr""

       
# CppCoreGuidelines.md:6859
msgid "6859    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6860
msgid "6860        int a = 7, b = 9, c, d = 10, e = 3;"
msgstr""

       
# CppCoreGuidelines.md:6861
msgid "6861    In a long list of declarators is is easy to overlook an uninitialized variable."
msgstr""

       
# CppCoreGuidelines.md:6862
msgid "6862    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6863
msgid "6863    Flag variable and constant declarations with multiple declarators (e.g., `int* p, q;`)"
msgstr""

       
# CppCoreGuidelines.md:6864
msgid "6864    ### <a name=\"Res-auto\"></a>ES.11: Use `auto` to avoid redundant repetition of type names"
msgstr""

       
# CppCoreGuidelines.md:6865
msgid "6865    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6866
msgid "6866    * Simple repetition is tedious and error-prone."
msgstr""

# CppCoreGuidelines.md:6867
msgid "6867    * When you use `auto`, the name of the declared entity is in a fixed position in the declaration, increasing readability."
msgstr""

# CppCoreGuidelines.md:6868
msgid "6868    * In a template function declaration the return type can be a member type."
msgstr""

       
# CppCoreGuidelines.md:6869
msgid "6869    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6870
msgid "6870    Consider:"
msgstr""

       
# CppCoreGuidelines.md:6871
msgid "6871        auto p = v.begin();   // vector<int>::iterator"
msgstr""

# CppCoreGuidelines.md:6872
msgid "6872        auto h = t.future();"
msgstr""

# CppCoreGuidelines.md:6873
msgid "6873        auto q = make_unique<int[]>(s);"
msgstr""

# CppCoreGuidelines.md:6874
msgid "6874        auto f = [](int x){ return x + 10; };"
msgstr""

       
# CppCoreGuidelines.md:6875
msgid "6875    In each case, we save writing a longish, hard-to-remember type that the compiler already knows but a programmer could get wrong."
msgstr""

       
# CppCoreGuidelines.md:6876
msgid "6876    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6877
msgid "6877        template<class T>"
msgstr""

# CppCoreGuidelines.md:6878
msgid "6878        auto Container<T>::first() -> Iterator;   // Container<T>::Iterator"
msgstr""

       
# CppCoreGuidelines.md:6879
msgid "6879    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6880
msgid "6880    Avoid `auto` for initializer lists and in cases where you know exactly which type you want and where an initializer might require conversion."
msgstr""

       
# CppCoreGuidelines.md:6881
msgid "6881    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6882
msgid "6882        auto lst = { 1, 2, 3 };   // lst is an initializer list"
msgstr""

# CppCoreGuidelines.md:6883
msgid "6883        auto x{1};   // x is an int (after correction of the C++14 standard; initializer_list in C++11)"
msgstr""

       
# CppCoreGuidelines.md:6884
msgid "6884    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6885
msgid "6885    When concepts become available, we can (and should) be more specific about the type we are deducing:"
msgstr""

       
# CppCoreGuidelines.md:6886
msgid "6886        // ..."
msgstr""

# CppCoreGuidelines.md:6887
msgid "6887        ForwardIterator p = algo(x, y, z);"
msgstr""

       
# CppCoreGuidelines.md:6888
msgid "6888    ##### Example (C++17)"
msgstr""

       
# CppCoreGuidelines.md:6889
msgid "6889        auto [ quotient, remainder ] = div(123456, 73);   // break out the members of the div_t result"
msgstr""

       
# CppCoreGuidelines.md:6890
msgid "6890    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6891
msgid "6891    Flag redundant repetition of type names in a declaration."
msgstr""

       
# CppCoreGuidelines.md:6892
msgid "6892    ### <a name=\"Res-reuse\"></a>ES.12: Do not reuse names in nested scopes"
msgstr""

       
# CppCoreGuidelines.md:6893
msgid "6893    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6894
msgid "6894    It is easy to get confused about which variable is used."
msgstr""

# CppCoreGuidelines.md:6895
msgid "6895    Can cause maintenance problems."
msgstr""

       
# CppCoreGuidelines.md:6896
msgid "6896    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6897
msgid "6897        int d = 0;"
msgstr""

# CppCoreGuidelines.md:6898
msgid "6898        // ..."
msgstr""

# CppCoreGuidelines.md:6899
msgid "6899        if (cond) {"
msgstr""

# CppCoreGuidelines.md:6900
msgid "6900            // ..."
msgstr""

# CppCoreGuidelines.md:6901
msgid "6901            d = 9;"
msgstr""

# CppCoreGuidelines.md:6902
msgid "6902            // ..."
msgstr""

# CppCoreGuidelines.md:6903
msgid "6903        }"
msgstr""

# CppCoreGuidelines.md:6904
msgid "6904        else {"
msgstr""

# CppCoreGuidelines.md:6905
msgid "6905            // ..."
msgstr""

# CppCoreGuidelines.md:6906
msgid "6906            int d = 7;"
msgstr""

# CppCoreGuidelines.md:6907
msgid "6907            // ..."
msgstr""

# CppCoreGuidelines.md:6908
msgid "6908            d = value_to_be_returned;"
msgstr""

# CppCoreGuidelines.md:6909
msgid "6909            // ..."
msgstr""

# CppCoreGuidelines.md:6910
msgid "6910        }"
msgstr""

       
# CppCoreGuidelines.md:6911
msgid "6911        return d;"
msgstr""

       
# CppCoreGuidelines.md:6912
msgid "6912    If this is a large `if`-statement, it is easy to overlook that a new `d` has been introduced in the inner scope."
msgstr""

# CppCoreGuidelines.md:6913
msgid "6913    This is a known source of bugs."
msgstr""

# CppCoreGuidelines.md:6914
msgid "6914    Sometimes such reuse of a name in an inner scope is called \"shadowing\"."
msgstr""

       
# CppCoreGuidelines.md:6915
msgid "6915    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6916
msgid "6916    Shadowing is primarily a problem when functions are too large and too complex."
msgstr""

       
# CppCoreGuidelines.md:6917
msgid "6917    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6918
msgid "6918    Shadowing of function arguments in the outermost block is disallowed by the language:"
msgstr""

       
# CppCoreGuidelines.md:6919
msgid "6919        void f(int x)"
msgstr""

# CppCoreGuidelines.md:6920
msgid "6920        {"
msgstr""

# CppCoreGuidelines.md:6921
msgid "6921            int x = 4;  // error: reuse of function argument name"
msgstr""

       
# CppCoreGuidelines.md:6922
msgid "6922            if (x) {"
msgstr""

# CppCoreGuidelines.md:6923
msgid "6923                int x = 7;  // allowed, but bad"
msgstr""

# CppCoreGuidelines.md:6924
msgid "6924                // ..."
msgstr""

# CppCoreGuidelines.md:6925
msgid "6925            }"
msgstr""

# CppCoreGuidelines.md:6926
msgid "6926        }"
msgstr""

       
# CppCoreGuidelines.md:6927
msgid "6927    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:6928
msgid "6928    Reuse of a member name as a local variable can also be a problem:"
msgstr""

       
# CppCoreGuidelines.md:6929
msgid "6929        struct S {"
msgstr""

# CppCoreGuidelines.md:6930
msgid "6930            int m;"
msgstr""

# CppCoreGuidelines.md:6931
msgid "6931            void f(int x);"
msgstr""

# CppCoreGuidelines.md:6932
msgid "6932        };"
msgstr""

       
# CppCoreGuidelines.md:6933
msgid "6933        void S::f(int x)"
msgstr""

# CppCoreGuidelines.md:6934
msgid "6934        {"
msgstr""

# CppCoreGuidelines.md:6935
msgid "6935            m = 7;    // assign to member"
msgstr""

# CppCoreGuidelines.md:6936
msgid "6936            if (x) {"
msgstr""

# CppCoreGuidelines.md:6937
msgid "6937                int m = 9;"
msgstr""

# CppCoreGuidelines.md:6938
msgid "6938                // ..."
msgstr""

# CppCoreGuidelines.md:6939
msgid "6939                m = 99; // assign to member"
msgstr""

# CppCoreGuidelines.md:6940
msgid "6940                // ..."
msgstr""

# CppCoreGuidelines.md:6941
msgid "6941            }"
msgstr""

# CppCoreGuidelines.md:6942
msgid "6942        }"
msgstr""

       
# CppCoreGuidelines.md:6943
msgid "6943    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:6944
msgid "6944    We often reuse function names from a base class in a derived class:"
msgstr""

       
# CppCoreGuidelines.md:6945
msgid "6945        struct B {"
msgstr""

# CppCoreGuidelines.md:6946
msgid "6946            void f(int);"
msgstr""

# CppCoreGuidelines.md:6947
msgid "6947        };"
msgstr""

       
# CppCoreGuidelines.md:6948
msgid "6948        struct D : B {"
msgstr""

# CppCoreGuidelines.md:6949
msgid "6949            void f(double);"
msgstr""

# CppCoreGuidelines.md:6950
msgid "6950            using B::f;"
msgstr""

# CppCoreGuidelines.md:6951
msgid "6951        };"
msgstr""

       
# CppCoreGuidelines.md:6952
msgid "6952    This is error-prone."
msgstr""

# CppCoreGuidelines.md:6953
msgid "6953    For example, had we forgotten the using declaration, a call `d.f(1)` would not have found the `int` version of `f`."
msgstr""

       
# CppCoreGuidelines.md:6954
msgid "6954    ??? Do we need a specific rule about shadowing/hiding in class hierarchies?"
msgstr""

       
# CppCoreGuidelines.md:6955
msgid "6955    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:6956
msgid "6956    * Flag reuse of a name in nested local scopes"
msgstr""

# CppCoreGuidelines.md:6957
msgid "6957    * Flag reuse of a member name as a local variable in a member function"
msgstr""

# CppCoreGuidelines.md:6958
msgid "6958    * Flag reuse of a global name as a local variable or a member name"
msgstr""

# CppCoreGuidelines.md:6959
msgid "6959    * Flag reuse of a base class member name in a derived class (except for function names)"
msgstr""

       
# CppCoreGuidelines.md:6960
msgid "6960    ### <a name=\"Res-always\"></a>ES.20: Always initialize an object"
msgstr""

       
# CppCoreGuidelines.md:6961
msgid "6961    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:6962
msgid "6962    Avoid used-before-set errors and their associated undefined behavior."
msgstr""

# CppCoreGuidelines.md:6963
msgid "6963    Avoid problems with comprehension of complex initialization."
msgstr""

# CppCoreGuidelines.md:6964
msgid "6964    Simplify refactoring."
msgstr""

       
# CppCoreGuidelines.md:6965
msgid "6965    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6966
msgid "6966        void use(int arg)"
msgstr""

# CppCoreGuidelines.md:6967
msgid "6967        {"
msgstr""

# CppCoreGuidelines.md:6968
msgid "6968            int i;   // bad: uninitialized variable"
msgstr""

# CppCoreGuidelines.md:6969
msgid "6969            // ..."
msgstr""

# CppCoreGuidelines.md:6970
msgid "6970            i = 7;   // initialize i"
msgstr""

# CppCoreGuidelines.md:6971
msgid "6971        }"
msgstr""

       
# CppCoreGuidelines.md:6972
msgid "6972    No, `i = 7` does not initialize `i`; it assigns to it. Also, `i` can be read in the `...` part. Better:"
msgstr""

       
# CppCoreGuidelines.md:6973
msgid "6973        void use(int arg)   // OK"
msgstr""

# CppCoreGuidelines.md:6974
msgid "6974        {"
msgstr""

# CppCoreGuidelines.md:6975
msgid "6975            int i = 7;   // OK: initialized"
msgstr""

# CppCoreGuidelines.md:6976
msgid "6976            string s;    // OK: default initialized"
msgstr""

# CppCoreGuidelines.md:6977
msgid "6977            // ..."
msgstr""

# CppCoreGuidelines.md:6978
msgid "6978        }"
msgstr""

       
# CppCoreGuidelines.md:6979
msgid "6979    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:6980
msgid "6980    The *always initialize* rule is deliberately stronger than the *an object must be set before used* language rule."
msgstr""

# CppCoreGuidelines.md:6981
msgid "6981    The latter, more relaxed rule, catches the technical bugs, but:"
msgstr""

       
# CppCoreGuidelines.md:6982
msgid "6982    * It leads to less readable code"
msgstr""

# CppCoreGuidelines.md:6983
msgid "6983    * It encourages people to declare names in greater than necessary scopes"
msgstr""

# CppCoreGuidelines.md:6984
msgid "6984    * It leads to harder to read code"
msgstr""

# CppCoreGuidelines.md:6985
msgid "6985    * It leads to logic bugs by encouraging complex code"
msgstr""

# CppCoreGuidelines.md:6986
msgid "6986    * It hampers refactoring"
msgstr""

       
# CppCoreGuidelines.md:6987
msgid "6987    The *always initialize* rule is a style rule aimed to improve maintainability as well as a rule protecting against used-before-set errors."
msgstr""

       
# CppCoreGuidelines.md:6988
msgid "6988    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:6989
msgid "6989    Here is an example that is often considered to demonstrate the need for a more relaxed rule for initialization"
msgstr""

       
# CppCoreGuidelines.md:6990
msgid "6990        widget i;    // \"widget\" a type that's expensive to initialize, possibly a large POD"
msgstr""

# CppCoreGuidelines.md:6991
msgid "6991        widget j;"
msgstr""

       
# CppCoreGuidelines.md:6992
msgid "6992        if (cond) {  // bad: i and j are initialized \"late\""
msgstr""

# CppCoreGuidelines.md:6993
msgid "6993            i = f1();"
msgstr""

# CppCoreGuidelines.md:6994
msgid "6994            j = f2();"
msgstr""

# CppCoreGuidelines.md:6995
msgid "6995        }"
msgstr""

# CppCoreGuidelines.md:6996
msgid "6996        else {"
msgstr""

# CppCoreGuidelines.md:6997
msgid "6997            i = f3();"
msgstr""

# CppCoreGuidelines.md:6998
msgid "6998            j = f4();"
msgstr""

# CppCoreGuidelines.md:6999
msgid "6999        }"
msgstr""

       
# CppCoreGuidelines.md:7000
msgid "7000    This cannot trivially be rewritten to initialize `i` and `j` with initializers."
msgstr""

# CppCoreGuidelines.md:7001
msgid "7001    Note that for types with a default constructor, attempting to postpone initialization simply leads to a default initialization followed by an assignment."
msgstr""

# CppCoreGuidelines.md:7002
msgid "7002    A popular reason for such examples is \"efficiency\", but a compiler that can detect whether we made a used-before-set error can also eliminate any redundant double initialization."
msgstr""

       
# CppCoreGuidelines.md:7003
msgid "7003    Assuming that there is a logical connection between `i` and `j`, that connection should probably be expressed in code:"
msgstr""

       
# CppCoreGuidelines.md:7004
msgid "7004        pair<widget, widget> make_related_widgets(bool x)"
msgstr""

# CppCoreGuidelines.md:7005
msgid "7005        {"
msgstr""

# CppCoreGuidelines.md:7006
msgid "7006            return (x) ? {f1(), f2()} : {f3(), f4() };"
msgstr""

# CppCoreGuidelines.md:7007
msgid "7007        }"
msgstr""

       
# CppCoreGuidelines.md:7008
msgid "7008        auto [i, j] = make_related_widgets(cond);    // C++17"
msgstr""

       
# CppCoreGuidelines.md:7009
msgid "7009    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7010
msgid "7010    Complex initialization has been popular with clever programmers for decades."
msgstr""

# CppCoreGuidelines.md:7011
msgid "7011    It has also been a major source of errors and complexity."
msgstr""

# CppCoreGuidelines.md:7012
msgid "7012    Many such errors are introduced during maintenance years after the initial implementation."
msgstr""

       
# CppCoreGuidelines.md:7013
msgid "7013    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7014
msgid "7014    This rule covers member variables."
msgstr""

       
# CppCoreGuidelines.md:7015
msgid "7015        class X {"
msgstr""

# CppCoreGuidelines.md:7016
msgid "7016        public:"
msgstr""

# CppCoreGuidelines.md:7017
msgid "7017            X(int i, int ci) : m2{i}, cm2{ci} {}"
msgstr""

# CppCoreGuidelines.md:7018
msgid "7018            // ..."
msgstr""

       
# CppCoreGuidelines.md:7019
msgid "7019        private:"
msgstr""

# CppCoreGuidelines.md:7020
msgid "7020            int m1 = 7;"
msgstr""

# CppCoreGuidelines.md:7021
msgid "7021            int m2;"
msgstr""

# CppCoreGuidelines.md:7022
msgid "7022            int m3;"
msgstr""

       
# CppCoreGuidelines.md:7023
msgid "7023            const int cm1 = 7;"
msgstr""

# CppCoreGuidelines.md:7024
msgid "7024            const int cm2;"
msgstr""

# CppCoreGuidelines.md:7025
msgid "7025            const int cm3;"
msgstr""

# CppCoreGuidelines.md:7026
msgid "7026        };"
msgstr""

       
# CppCoreGuidelines.md:7027
msgid "7027    The compiler will flag the uninitialized `cm3` because it is a `const`, but it will not catch the lack of initialization of `m3`."
msgstr""

# CppCoreGuidelines.md:7028
msgid "7028    Usually, a rare spurious member initialization is worth the absence of errors from lack of initialization and often an optimizer"
msgstr""

# CppCoreGuidelines.md:7029
msgid "7029    can eliminate a redundant initialization (e.g., an initialization that occurs immediately before an assignment)."
msgstr""

       
# CppCoreGuidelines.md:7030
msgid "7030    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:7031
msgid "7031    If you are declaring an object that is just about to be initialized from input, initializing it would cause a double initialization."
msgstr""

# CppCoreGuidelines.md:7032
msgid "7032    However, beware that this may leave uninitialized data beyond the input -- and that has been a fertile source of errors and security breaches:"
msgstr""

       
# CppCoreGuidelines.md:7033
msgid "7033        constexpr int max = 8 * 1024;"
msgstr""

# CppCoreGuidelines.md:7034
msgid "7034        int buf[max];         // OK, but suspicious: uninitialized"
msgstr""

# CppCoreGuidelines.md:7035
msgid "7035        f.read(buf, max);"
msgstr""

       
# CppCoreGuidelines.md:7036
msgid "7036    The cost of initializing that array could be significant in some situations."
msgstr""

# CppCoreGuidelines.md:7037
msgid "7037    However, such examples do tend to leave uninitialized variables accessible, so they should be treated with suspicion."
msgstr""

       
# CppCoreGuidelines.md:7038
msgid "7038        constexpr int max = 8 * 1024;"
msgstr""

# CppCoreGuidelines.md:7039
msgid "7039        int buf[max] = {};   // zero all elements; better in some situations"
msgstr""

# CppCoreGuidelines.md:7040
msgid "7040        f.read(buf, max);"
msgstr""

       
# CppCoreGuidelines.md:7041
msgid "7041    When feasible use a library function that is known not to overflow. For example:"
msgstr""

       
# CppCoreGuidelines.md:7042
msgid "7042        string s;   // s is default initialized to \"\""
msgstr""

# CppCoreGuidelines.md:7043
msgid "7043        cin >> s;   // s expands to hold the string"
msgstr""

       
# CppCoreGuidelines.md:7044
msgid "7044    Don't consider simple variables that are targets for input operations exceptions to this rule:"
msgstr""

       
# CppCoreGuidelines.md:7045
msgid "7045        int i;   // bad"
msgstr""

# CppCoreGuidelines.md:7046
msgid "7046        // ..."
msgstr""

# CppCoreGuidelines.md:7047
msgid "7047        cin >> i;"
msgstr""

       
# CppCoreGuidelines.md:7048
msgid "7048    In the not uncommon case where the input target and the input operation get separated (as they should not) the possibility of used-before-set opens up."
msgstr""

       
# CppCoreGuidelines.md:7049
msgid "7049        int i2 = 0;   // better"
msgstr""

# CppCoreGuidelines.md:7050
msgid "7050        // ..."
msgstr""

# CppCoreGuidelines.md:7051
msgid "7051        cin >> i2;"
msgstr""

       
# CppCoreGuidelines.md:7052
msgid "7052    A good optimizer should know about input operations and eliminate the redundant operation."
msgstr""

       
# CppCoreGuidelines.md:7053
msgid "7053    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7054
msgid "7054    Using an `uninitialized` or sentinel value is a symptom of a problem and not a"
msgstr""

# CppCoreGuidelines.md:7055
msgid "7055    solution:"
msgstr""

       
# CppCoreGuidelines.md:7056
msgid "7056        widget i = uninit;  // bad"
msgstr""

# CppCoreGuidelines.md:7057
msgid "7057        widget j = uninit;"
msgstr""

       
# CppCoreGuidelines.md:7058
msgid "7058        // ..."
msgstr""

# CppCoreGuidelines.md:7059
msgid "7059        use(i);         // possibly used before set"
msgstr""

# CppCoreGuidelines.md:7060
msgid "7060        // ..."
msgstr""

       
# CppCoreGuidelines.md:7061
msgid "7061        if (cond) {     // bad: i and j are initialized \"late\""
msgstr""

# CppCoreGuidelines.md:7062
msgid "7062            i = f1();"
msgstr""

# CppCoreGuidelines.md:7063
msgid "7063            j = f2();"
msgstr""

# CppCoreGuidelines.md:7064
msgid "7064        }"
msgstr""

# CppCoreGuidelines.md:7065
msgid "7065        else {"
msgstr""

# CppCoreGuidelines.md:7066
msgid "7066            i = f3();"
msgstr""

# CppCoreGuidelines.md:7067
msgid "7067            j = f4();"
msgstr""

# CppCoreGuidelines.md:7068
msgid "7068        }"
msgstr""

       
# CppCoreGuidelines.md:7069
msgid "7069    Now the compiler cannot even simply detect a used-before-set. Further, we've introduced complexity in the state space for widget: which operations are valid on an `uninit` widget and which are not?"
msgstr""

       
# CppCoreGuidelines.md:7070
msgid "7070    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7071
msgid "7071    Sometimes, a lambda can be used as an initializer to avoid an uninitialized variable:"
msgstr""

       
# CppCoreGuidelines.md:7072
msgid "7072        error_code ec;"
msgstr""

# CppCoreGuidelines.md:7073
msgid "7073        Value v = [&] {"
msgstr""

# CppCoreGuidelines.md:7074
msgid "7074            auto p = get_value();   // get_value() returns a pair<error_code, Value>"
msgstr""

# CppCoreGuidelines.md:7075
msgid "7075            ec = p.first;"
msgstr""

# CppCoreGuidelines.md:7076
msgid "7076            return p.second;"
msgstr""

# CppCoreGuidelines.md:7077
msgid "7077        }();"
msgstr""

       
# CppCoreGuidelines.md:7078
msgid "7078    or maybe:"
msgstr""

       
# CppCoreGuidelines.md:7079
msgid "7079        Value v = [] {"
msgstr""

# CppCoreGuidelines.md:7080
msgid "7080            auto p = get_value();   // get_value() returns a pair<error_code, Value>"
msgstr""

# CppCoreGuidelines.md:7081
msgid "7081            if (p.first) throw Bad_value{p.first};"
msgstr""

# CppCoreGuidelines.md:7082
msgid "7082            return p.second;"
msgstr""

# CppCoreGuidelines.md:7083
msgid "7083        }();"
msgstr""

       
# CppCoreGuidelines.md:7084
msgid "7084    **See also**: [ES.28](#Res-lambda-init)"
msgstr""

       
# CppCoreGuidelines.md:7085
msgid "7085    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7086
msgid "7086    * Flag every uninitialized variable."
msgstr""

# CppCoreGuidelines.md:7087
msgid "7087      Don't flag variables of user-defined types with default constructors."
msgstr""

# CppCoreGuidelines.md:7088
msgid "7088    * Check that an uninitialized buffer is written into *immediately* after declaration."
msgstr""

# CppCoreGuidelines.md:7089
msgid "7089      Passing an uninitialized variable as a reference to non-`const` argument can be assumed to be a write into the variable."
msgstr""

       
# CppCoreGuidelines.md:7090
msgid "7090    ### <a name=\"Res-introduce\"></a>ES.21: Don't introduce a variable (or constant) before you need to use it"
msgstr""

       
# CppCoreGuidelines.md:7091
msgid "7091    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7092
msgid "7092    Readability. To limit the scope in which the variable can be used."
msgstr""

       
# CppCoreGuidelines.md:7093
msgid "7093    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7094
msgid "7094        int x = 7;"
msgstr""

# CppCoreGuidelines.md:7095
msgid "7095        // ... no use of x here ..."
msgstr""

# CppCoreGuidelines.md:7096
msgid "7096        ++x;"
msgstr""

       
# CppCoreGuidelines.md:7097
msgid "7097    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7098
msgid "7098    Flag declarations that are distant from their first use."
msgstr""

       
# CppCoreGuidelines.md:7099
msgid "7099    ### <a name=\"Res-init\"></a>ES.22: Don't declare a variable until you have a value to initialize it with"
msgstr""

       
# CppCoreGuidelines.md:7100
msgid "7100    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7101
msgid "7101    Readability. Limit the scope in which a variable can be used. Don't risk used-before-set. Initialization is often more efficient than assignment."
msgstr""

       
# CppCoreGuidelines.md:7102
msgid "7102    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7103
msgid "7103        string s;"
msgstr""

# CppCoreGuidelines.md:7104
msgid "7104        // ... no use of s here ..."
msgstr""

# CppCoreGuidelines.md:7105
msgid "7105        s = \"what a waste\";"
msgstr""

       
# CppCoreGuidelines.md:7106
msgid "7106    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7107
msgid "7107        SomeLargeType var;   // ugly CaMeLcAsEvArIaBlE"
msgstr""

       
# CppCoreGuidelines.md:7108
msgid "7108        if (cond)   // some non-trivial condition"
msgstr""

# CppCoreGuidelines.md:7109
msgid "7109            Set(&var);"
msgstr""

# CppCoreGuidelines.md:7110
msgid "7110        else if (cond2 || !cond3) {"
msgstr""

# CppCoreGuidelines.md:7111
msgid "7111            var = Set2(3.14);"
msgstr""

# CppCoreGuidelines.md:7112
msgid "7112        }"
msgstr""

# CppCoreGuidelines.md:7113
msgid "7113        else {"
msgstr""

# CppCoreGuidelines.md:7114
msgid "7114            var = 0;"
msgstr""

# CppCoreGuidelines.md:7115
msgid "7115            for (auto& e : something)"
msgstr""

# CppCoreGuidelines.md:7116
msgid "7116                var += e;"
msgstr""

# CppCoreGuidelines.md:7117
msgid "7117        }"
msgstr""

       
# CppCoreGuidelines.md:7118
msgid "7118        // use var; that this isn't done too early can be enforced statically with only control flow"
msgstr""

       
# CppCoreGuidelines.md:7119
msgid "7119    This would be fine if there was a default initialization for `SomeLargeType` that wasn't too expensive."
msgstr""

# CppCoreGuidelines.md:7120
msgid "7120    Otherwise, a programmer might very well wonder if every possible path through the maze of conditions has been covered."
msgstr""

# CppCoreGuidelines.md:7121
msgid "7121    If not, we have a \"use before set\" bug. This is a maintenance trap."
msgstr""

       
# CppCoreGuidelines.md:7122
msgid "7122    For initializers of moderate complexity, including for `const` variables, consider using a lambda to express the initializer; see [ES.28](#Res-lambda-init)."
msgstr""

       
# CppCoreGuidelines.md:7123
msgid "7123    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7124
msgid "7124    * Flag declarations with default initialization that are assigned to before they are first read."
msgstr""

# CppCoreGuidelines.md:7125
msgid "7125    * Flag any complicated computation after an uninitialized variable and before its use."
msgstr""

       
# CppCoreGuidelines.md:7126
msgid "7126    ### <a name=\"Res-list\"></a>ES.23: Prefer the `{}` initializer syntax"
msgstr""

       
# CppCoreGuidelines.md:7127
msgid "7127    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7128
msgid "7128    The rules for `{}` initialization are simpler, more general, less ambiguous, and safer than for other forms of initialization."
msgstr""

       
# CppCoreGuidelines.md:7129
msgid "7129    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7130
msgid "7130        int x {f(99)};"
msgstr""

# CppCoreGuidelines.md:7131
msgid "7131        vector<int> v = {1, 2, 3, 4, 5, 6};"
msgstr""

       
# CppCoreGuidelines.md:7132
msgid "7132    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:7133
msgid "7133    For containers, there is a tradition for using `{...}` for a list of elements and `(...)` for sizes:"
msgstr""

       
# CppCoreGuidelines.md:7134
msgid "7134        vector<int> v1(10);    // vector of 10 elements with the default value 0"
msgstr""

# CppCoreGuidelines.md:7135
msgid "7135        vector<int> v2 {10};   // vector of 1 element with the value 10"
msgstr""

       
# CppCoreGuidelines.md:7136
msgid "7136    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7137
msgid "7137    `{}`-initializers do not allow narrowing conversions."
msgstr""

       
# CppCoreGuidelines.md:7138
msgid "7138    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7139
msgid "7139        int x {7.9};   // error: narrowing"
msgstr""

# CppCoreGuidelines.md:7140
msgid "7140        int y = 7.9;   // OK: y becomes 7. Hope for a compiler warning"
msgstr""

       
# CppCoreGuidelines.md:7141
msgid "7141    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7142
msgid "7142    `{}` initialization can be used for all initialization; other forms of initialization can't:"
msgstr""

       
# CppCoreGuidelines.md:7143
msgid "7143        auto p = new vector<int> {1, 2, 3, 4, 5};   // initialized vector"
msgstr""

# CppCoreGuidelines.md:7144
msgid "7144        D::D(int a, int b) :m{a, b} {   // member initializer (e.g., m might be a pair)"
msgstr""

# CppCoreGuidelines.md:7145
msgid "7145            // ..."
msgstr""

# CppCoreGuidelines.md:7146
msgid "7146        };"
msgstr""

# CppCoreGuidelines.md:7147
msgid "7147        X var {};   // initialize var to be empty"
msgstr""

# CppCoreGuidelines.md:7148
msgid "7148        struct S {"
msgstr""

# CppCoreGuidelines.md:7149
msgid "7149            int m {7};   // default initializer for a member"
msgstr""

# CppCoreGuidelines.md:7150
msgid "7150            // ..."
msgstr""

# CppCoreGuidelines.md:7151
msgid "7151        };"
msgstr""

       
# CppCoreGuidelines.md:7152
msgid "7152    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7153
msgid "7153    Initialization of a variable declared using `auto` with a single value, e.g., `{v}`, had surprising results until C++17."
msgstr""

# CppCoreGuidelines.md:7154
msgid "7154    The C++17 rules are somewhat less surprising:"
msgstr""

       
# CppCoreGuidelines.md:7155
msgid "7155        auto x1 {7};        // x1 is an int with the value 7"
msgstr""

# CppCoreGuidelines.md:7156
msgid "7156        auto x2 = {7};  // x2 is an initializer_list<int> with an element 7"
msgstr""

       
# CppCoreGuidelines.md:7157
msgid "7157        auto x11 {7, 8};    // error: two initializers"
msgstr""

# CppCoreGuidelines.md:7158
msgid "7158        auto x22 = {7, 8};  // x2 is an initializer_list<int> with elements 7 and 8"
msgstr""

       
# CppCoreGuidelines.md:7159
msgid "7159    So use `={...}` if you really want an `initializer_list<T>`"
msgstr""

       
# CppCoreGuidelines.md:7160
msgid "7160        auto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a list"
msgstr""

       
# CppCoreGuidelines.md:7161
msgid "7161    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7162
msgid "7162    Old habits die hard, so this rule is hard to apply consistently, especially as there are so many cases where `=` is innocent."
msgstr""

       
# CppCoreGuidelines.md:7163
msgid "7163    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7164
msgid "7164        template<typename T>"
msgstr""

# CppCoreGuidelines.md:7165
msgid "7165        void f()"
msgstr""

# CppCoreGuidelines.md:7166
msgid "7166        {"
msgstr""

# CppCoreGuidelines.md:7167
msgid "7167            T x1(1);    // T initialized with 1"
msgstr""

# CppCoreGuidelines.md:7168
msgid "7168            T x0();     // bad: function declaration (often a mistake)"
msgstr""

       
# CppCoreGuidelines.md:7169
msgid "7169            T y1 {1};   // T initialized with 1"
msgstr""

# CppCoreGuidelines.md:7170
msgid "7170            T y0 {};    // default initialized T"
msgstr""

# CppCoreGuidelines.md:7171
msgid "7171            // ..."
msgstr""

# CppCoreGuidelines.md:7172
msgid "7172        }"
msgstr""

       
# CppCoreGuidelines.md:7173
msgid "7173    **See also**: [Discussion](#???)"
msgstr""

       
# CppCoreGuidelines.md:7174
msgid "7174    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7175
msgid "7175    Tricky."
msgstr""

       
# CppCoreGuidelines.md:7176
msgid "7176    * Don't flag uses of `=` for simple initializers."
msgstr""

# CppCoreGuidelines.md:7177
msgid "7177    * Look for `=` after `auto` has been seen."
msgstr""

       
# CppCoreGuidelines.md:7178
msgid "7178    ### <a name=\"Res-unique\"></a>ES.24: Use a `unique_ptr<T>` to hold pointers"
msgstr""

       
# CppCoreGuidelines.md:7179
msgid "7179    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7180
msgid "7180    Using `std::unique_ptr` is the simplest way to avoid leaks. It is reliable, it"
msgstr""

# CppCoreGuidelines.md:7181
msgid "7181    makes the type system do much of the work to validate ownership safety, it"
msgstr""

# CppCoreGuidelines.md:7182
msgid "7182    increases readability, and it has zero or near zero run-time cost."
msgstr""

       
# CppCoreGuidelines.md:7183
msgid "7183    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7184
msgid "7184        void use(bool leak)"
msgstr""

# CppCoreGuidelines.md:7185
msgid "7185        {"
msgstr""

# CppCoreGuidelines.md:7186
msgid "7186            auto p1 = make_unique<int>(7);   // OK"
msgstr""

# CppCoreGuidelines.md:7187
msgid "7187            int* p2 = new int{7};            // bad: might leak"
msgstr""

# CppCoreGuidelines.md:7188
msgid "7188            // ... no assignment to p2 ..."
msgstr""

# CppCoreGuidelines.md:7189
msgid "7189            if (leak) return;"
msgstr""

# CppCoreGuidelines.md:7190
msgid "7190            // ... no assignment to p2 ..."
msgstr""

# CppCoreGuidelines.md:7191
msgid "7191            vector<int> v(7);"
msgstr""

# CppCoreGuidelines.md:7192
msgid "7192            v.at(7) = 0;                    // exception thrown"
msgstr""

# CppCoreGuidelines.md:7193
msgid "7193            // ..."
msgstr""

# CppCoreGuidelines.md:7194
msgid "7194        }"
msgstr""

       
# CppCoreGuidelines.md:7195
msgid "7195    If `leak == true` the object pointed to by `p2` is leaked and the object pointed to by `p1` is not."
msgstr""

# CppCoreGuidelines.md:7196
msgid "7196    The same is the case when `at()` throws."
msgstr""

       
# CppCoreGuidelines.md:7197
msgid "7197    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7198
msgid "7198    Look for raw pointers that are targets of `new`, `malloc()`, or functions that may return such pointers."
msgstr""

       
# CppCoreGuidelines.md:7199
msgid "7199    ### <a name=\"Res-const\"></a>ES.25: Declare an object `const` or `constexpr` unless you want to modify its value later on"
msgstr""

       
# CppCoreGuidelines.md:7200
msgid "7200    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7201
msgid "7201    That way you can't change the value by mistake. That way may offer the compiler optimization opportunities."
msgstr""

       
# CppCoreGuidelines.md:7202
msgid "7202    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7203
msgid "7203        void f(int n)"
msgstr""

# CppCoreGuidelines.md:7204
msgid "7204        {"
msgstr""

# CppCoreGuidelines.md:7205
msgid "7205            const int bufmax = 2 * n + 2;  // good: we can't change bufmax by accident"
msgstr""

# CppCoreGuidelines.md:7206
msgid "7206            int xmax = n;                  // suspicious: is xmax intended to change?"
msgstr""

# CppCoreGuidelines.md:7207
msgid "7207            // ..."
msgstr""

# CppCoreGuidelines.md:7208
msgid "7208        }"
msgstr""

       
# CppCoreGuidelines.md:7209
msgid "7209    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7210
msgid "7210    Look to see if a variable is actually mutated, and flag it if"
msgstr""

# CppCoreGuidelines.md:7211
msgid "7211    not. Unfortunately, it may be impossible to detect when a non-`const` was not"
msgstr""

# CppCoreGuidelines.md:7212
msgid "7212    *intended* to vary (vs when it merely did not vary)."
msgstr""

       
# CppCoreGuidelines.md:7213
msgid "7213    ### <a name=\"Res-recycle\"></a>ES.26: Don't use a variable for two unrelated purposes"
msgstr""

       
# CppCoreGuidelines.md:7214
msgid "7214    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7215
msgid "7215    Readability and safety."
msgstr""

       
# CppCoreGuidelines.md:7216
msgid "7216    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7217
msgid "7217        void use()"
msgstr""

# CppCoreGuidelines.md:7218
msgid "7218        {"
msgstr""

# CppCoreGuidelines.md:7219
msgid "7219            int i;"
msgstr""

# CppCoreGuidelines.md:7220
msgid "7220            for (i = 0; i < 20; ++i) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:7221
msgid "7221            for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled"
msgstr""

# CppCoreGuidelines.md:7222
msgid "7222        }"
msgstr""

       
# CppCoreGuidelines.md:7223
msgid "7223    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7224
msgid "7224    As an optimization, you may want to reuse a buffer as a scratch pad, but even then prefer to limit the variable's scope as much as possible and be careful not to cause bugs from data left in a recycled buffer as this is a common source of security bugs."
msgstr""

       
# CppCoreGuidelines.md:7225
msgid "7225        void write_to_file() {"
msgstr""

# CppCoreGuidelines.md:7226
msgid "7226            std::string buffer;             // to avoid reallocations on every loop iteration"
msgstr""

# CppCoreGuidelines.md:7227
msgid "7227            for (auto& o : objects)"
msgstr""

# CppCoreGuidelines.md:7228
msgid "7228            {"
msgstr""

# CppCoreGuidelines.md:7229
msgid "7229                // First part of the work."
msgstr""

# CppCoreGuidelines.md:7230
msgid "7230                generate_first_String(buffer, o);"
msgstr""

# CppCoreGuidelines.md:7231
msgid "7231                write_to_file(buffer);"
msgstr""

       
# CppCoreGuidelines.md:7232
msgid "7232                // Second part of the work."
msgstr""

# CppCoreGuidelines.md:7233
msgid "7233                generate_second_string(buffer, o);"
msgstr""

# CppCoreGuidelines.md:7234
msgid "7234                write_to_file(buffer);"
msgstr""

       
# CppCoreGuidelines.md:7235
msgid "7235                // etc..."
msgstr""

# CppCoreGuidelines.md:7236
msgid "7236            }"
msgstr""

# CppCoreGuidelines.md:7237
msgid "7237        }"
msgstr""

       
# CppCoreGuidelines.md:7238
msgid "7238    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7239
msgid "7239    Flag recycled variables."
msgstr""

       
# CppCoreGuidelines.md:7240
msgid "7240    ### <a name=\"Res-stack\"></a>ES.27: Use `std::array` or `stack_array` for arrays on the stack"
msgstr""

       
# CppCoreGuidelines.md:7241
msgid "7241    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7242
msgid "7242    They are readable and don't implicitly convert to pointers."
msgstr""

# CppCoreGuidelines.md:7243
msgid "7243    They are not confused with non-standard extensions of built-in arrays."
msgstr""

       
# CppCoreGuidelines.md:7244
msgid "7244    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7245
msgid "7245        const int n = 7;"
msgstr""

# CppCoreGuidelines.md:7246
msgid "7246        int m = 9;"
msgstr""

       
# CppCoreGuidelines.md:7247
msgid "7247        void f()"
msgstr""

# CppCoreGuidelines.md:7248
msgid "7248        {"
msgstr""

# CppCoreGuidelines.md:7249
msgid "7249            int a1[n];"
msgstr""

# CppCoreGuidelines.md:7250
msgid "7250            int a2[m];   // error: not ISO C++"
msgstr""

# CppCoreGuidelines.md:7251
msgid "7251            // ..."
msgstr""

# CppCoreGuidelines.md:7252
msgid "7252        }"
msgstr""

       
# CppCoreGuidelines.md:7253
msgid "7253    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7254
msgid "7254    The definition of `a1` is legal C++ and has always been."
msgstr""

# CppCoreGuidelines.md:7255
msgid "7255    There is a lot of such code."
msgstr""

# CppCoreGuidelines.md:7256
msgid "7256    It is error-prone, though, especially when the bound is non-local."
msgstr""

# CppCoreGuidelines.md:7257
msgid "7257    Also, it is a \"popular\" source of errors (buffer overflow, pointers from array decay, etc.)."
msgstr""

# CppCoreGuidelines.md:7258
msgid "7258    The definition of `a2` is C but not C++ and is considered a security risk"
msgstr""

       
# CppCoreGuidelines.md:7259
msgid "7259    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7260
msgid "7260        const int n = 7;"
msgstr""

# CppCoreGuidelines.md:7261
msgid "7261        int m = 9;"
msgstr""

       
# CppCoreGuidelines.md:7262
msgid "7262        void f()"
msgstr""

# CppCoreGuidelines.md:7263
msgid "7263        {"
msgstr""

# CppCoreGuidelines.md:7264
msgid "7264            array<int, n> a1;"
msgstr""

# CppCoreGuidelines.md:7265
msgid "7265            stack_array<int> a2(m);"
msgstr""

# CppCoreGuidelines.md:7266
msgid "7266            // ..."
msgstr""

# CppCoreGuidelines.md:7267
msgid "7267        }"
msgstr""

       
# CppCoreGuidelines.md:7268
msgid "7268    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7269
msgid "7269    * Flag arrays with non-constant bounds (C-style VLAs)"
msgstr""

# CppCoreGuidelines.md:7270
msgid "7270    * Flag arrays with non-local constant bounds"
msgstr""

       
# CppCoreGuidelines.md:7271
msgid "7271    ### <a name=\"Res-lambda-init\"></a>ES.28: Use lambdas for complex initialization, especially of `const` variables"
msgstr""

       
# CppCoreGuidelines.md:7272
msgid "7272    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7273
msgid "7273    It nicely encapsulates local initialization, including cleaning up scratch variables needed only for the initialization, without needing to create a needless nonlocal yet nonreusable function. It also works for variables that should be `const` but only after some initialization work."
msgstr""

       
# CppCoreGuidelines.md:7274
msgid "7274    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7275
msgid "7275        widget x;   // should be const, but:"
msgstr""

# CppCoreGuidelines.md:7276
msgid "7276        for (auto i = 2; i <= N; ++i) {          // this could be some"
msgstr""

# CppCoreGuidelines.md:7277
msgid "7277            x += some_obj.do_something_with(i);  // arbitrarily long code"
msgstr""

# CppCoreGuidelines.md:7278
msgid "7278        }                                        // needed to initialize x"
msgstr""

# CppCoreGuidelines.md:7279
msgid "7279        // from here, x should be const, but we can't say so in code in this style"
msgstr""

       
# CppCoreGuidelines.md:7280
msgid "7280    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:7281
msgid "7281        const widget x = [&]{"
msgstr""

# CppCoreGuidelines.md:7282
msgid "7282            widget val;                                // assume that widget has a default constructor"
msgstr""

# CppCoreGuidelines.md:7283
msgid "7283            for (auto i = 2; i <= N; ++i) {            // this could be some"
msgstr""

# CppCoreGuidelines.md:7284
msgid "7284                val += some_obj.do_something_with(i);  // arbitrarily long code"
msgstr""

# CppCoreGuidelines.md:7285
msgid "7285            }                                          // needed to initialize x"
msgstr""

# CppCoreGuidelines.md:7286
msgid "7286            return val;"
msgstr""

# CppCoreGuidelines.md:7287
msgid "7287        }();"
msgstr""

       
# CppCoreGuidelines.md:7288
msgid "7288    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7289
msgid "7289        string var = [&]{"
msgstr""

# CppCoreGuidelines.md:7290
msgid "7290            if (!in) return \"\";   // default"
msgstr""

# CppCoreGuidelines.md:7291
msgid "7291            string s;"
msgstr""

# CppCoreGuidelines.md:7292
msgid "7292            for (char c : in >> c)"
msgstr""

# CppCoreGuidelines.md:7293
msgid "7293                s += toupper(c);"
msgstr""

# CppCoreGuidelines.md:7294
msgid "7294            return s;"
msgstr""

# CppCoreGuidelines.md:7295
msgid "7295        }(); // note ()"
msgstr""

       
# CppCoreGuidelines.md:7296
msgid "7296    If at all possible, reduce the conditions to a simple set of alternatives (e.g., an `enum`) and don't mix up selection and initialization."
msgstr""

       
# CppCoreGuidelines.md:7297
msgid "7297    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7298
msgid "7298    Hard. At best a heuristic. Look for an uninitialized variable followed by a loop assigning to it."
msgstr""

       
# CppCoreGuidelines.md:7299
msgid "7299    ### <a name=\"Res-macros\"></a>ES.30: Don't use macros for program text manipulation"
msgstr""

       
# CppCoreGuidelines.md:7300
msgid "7300    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7301
msgid "7301    Macros are a major source of bugs."
msgstr""

# CppCoreGuidelines.md:7302
msgid "7302    Macros don't obey the usual scope and type rules."
msgstr""

# CppCoreGuidelines.md:7303
msgid "7303    Macros ensure that the human reader sees something different from what the compiler sees."
msgstr""

# CppCoreGuidelines.md:7304
msgid "7304    Macros complicate tool building."
msgstr""

       
# CppCoreGuidelines.md:7305
msgid "7305    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7306
msgid "7306        #define Case break; case   /* BAD */"
msgstr""

       
# CppCoreGuidelines.md:7307
msgid "7307    This innocuous-looking macro makes a single lower case `c` instead of a `C` into a bad flow-control bug."
msgstr""

       
# CppCoreGuidelines.md:7308
msgid "7308    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7309
msgid "7309    This rule does not ban the use of macros for \"configuration control\" use in `#ifdef`s, etc."
msgstr""

       
# CppCoreGuidelines.md:7310
msgid "7310    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7311
msgid "7311    Scream when you see a macro that isn't just used for source control (e.g., `#ifdef`)"
msgstr""

       
# CppCoreGuidelines.md:7312
msgid "7312    ### <a name=\"Res-macros2\"></a>ES.31: Don't use macros for constants or \"functions\""
msgstr""

       
# CppCoreGuidelines.md:7313
msgid "7313    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7314
msgid "7314    Macros are a major source of bugs."
msgstr""

# CppCoreGuidelines.md:7315
msgid "7315    Macros don't obey the usual scope and type rules."
msgstr""

# CppCoreGuidelines.md:7316
msgid "7316    Macros don't obey the usual rules for argument passing."
msgstr""

# CppCoreGuidelines.md:7317
msgid "7317    Macros ensure that the human reader sees something different from what the compiler sees."
msgstr""

# CppCoreGuidelines.md:7318
msgid "7318    Macros complicate tool building."
msgstr""

       
# CppCoreGuidelines.md:7319
msgid "7319    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7320
msgid "7320        #define PI 3.14"
msgstr""

# CppCoreGuidelines.md:7321
msgid "7321        #define SQUARE(a, b) (a * b)"
msgstr""

       
# CppCoreGuidelines.md:7322
msgid "7322    Even if we hadn't left a well-known bug in `SQUARE` there are much better behaved alternatives; for example:"
msgstr""

       
# CppCoreGuidelines.md:7323
msgid "7323        constexpr double pi = 3.14;"
msgstr""

# CppCoreGuidelines.md:7324
msgid "7324        template<typename T> T square(T a, T b) { return a * b; }"
msgstr""

       
# CppCoreGuidelines.md:7325
msgid "7325    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7326
msgid "7326    Scream when you see a macro that isn't just used for source control (e.g., `#ifdef`)"
msgstr""

       
# CppCoreGuidelines.md:7327
msgid "7327    ### <a name=\"Res-ALL_CAPS\"></a>ES.32: Use `ALL_CAPS` for all macro names"
msgstr""

       
# CppCoreGuidelines.md:7328
msgid "7328    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7329
msgid "7329    Convention. Readability. Distinguishing macros."
msgstr""

       
# CppCoreGuidelines.md:7330
msgid "7330    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7331
msgid "7331        #define forever for (;;)   /* very BAD */"
msgstr""

       
# CppCoreGuidelines.md:7332
msgid "7332        #define FOREVER for (;;)   /* Still evil, but at least visible to humans */"
msgstr""

       
# CppCoreGuidelines.md:7333
msgid "7333    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7334
msgid "7334    Scream when you see a lower case macro."
msgstr""

       
# CppCoreGuidelines.md:7335
msgid "7335    ### <a name=\"Res-MACROS\"></a>ES.33: If you must use macros, give them unique names"
msgstr""

       
# CppCoreGuidelines.md:7336
msgid "7336    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7337
msgid "7337    Macros do not obey scope rules."
msgstr""

       
# CppCoreGuidelines.md:7338
msgid "7338    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7339
msgid "7339        #define MYCHAR        /* BAD, will eventually clash with someone else's MYCHAR*/"
msgstr""

       
# CppCoreGuidelines.md:7340
msgid "7340        #define ZCORP_CHAR    /* Still evil, but less likely to clash */"
msgstr""

       
# CppCoreGuidelines.md:7341
msgid "7341    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7342
msgid "7342    Avoid macros if you can: [ES.30](#Res-macros), [ES.31](#Res-macros2), and [ES.32](#Res-ALL_CAPS)."
msgstr""

# CppCoreGuidelines.md:7343
msgid "7343    However, there are billions of lines of code littered with macros and a long tradition for using and overusing macros."
msgstr""

# CppCoreGuidelines.md:7344
msgid "7344    If you are forced to use macros, use long names and supposedly unique prefixes (e.g., your organization's name) to lower the likelihood of a clash."
msgstr""

       
# CppCoreGuidelines.md:7345
msgid "7345    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7346
msgid "7346    Warn against short macro names."
msgstr""

       
# CppCoreGuidelines.md:7347
msgid "7347    ### <a name=\"Res-ellipses\"></a> ES.34: Don't define a (C-style) variadic function"
msgstr""

       
# CppCoreGuidelines.md:7348
msgid "7348    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7349
msgid "7349    Not type safe."
msgstr""

# CppCoreGuidelines.md:7350
msgid "7350    Requires messy cast-and-macro-laden code to get working right."
msgstr""

       
# CppCoreGuidelines.md:7351
msgid "7351    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7352
msgid "7352        #include <cstdarg>"
msgstr""

       
# CppCoreGuidelines.md:7353
msgid "7353        // \"severity\" followed by a zero-terminated list of char*s; write the C-style strings to cerr"
msgstr""

# CppCoreGuidelines.md:7354
msgid "7354        void error(int severity ...)"
msgstr""

# CppCoreGuidelines.md:7355
msgid "7355        {"
msgstr""

# CppCoreGuidelines.md:7356
msgid "7356            va_list ap;             // a magic type for holding arguments"
msgstr""

# CppCoreGuidelines.md:7357
msgid "7357            va_start(ap, severity); // arg startup: \"severity\" is the first argument of error()"
msgstr""

       
# CppCoreGuidelines.md:7358
msgid "7358            for (;;) {"
msgstr""

# CppCoreGuidelines.md:7359
msgid "7359                // treat the next var as a char*; no checking: a cast in disguise"
msgstr""

# CppCoreGuidelines.md:7360
msgid "7360                char* p = va_arg(ap, char*);"
msgstr""

# CppCoreGuidelines.md:7361
msgid "7361                if (!p) break;"
msgstr""

# CppCoreGuidelines.md:7362
msgid "7362                cerr << p << ' ';"
msgstr""

# CppCoreGuidelines.md:7363
msgid "7363            }"
msgstr""

       
# CppCoreGuidelines.md:7364
msgid "7364            va_end(ap);             // arg cleanup (don't forget this)"
msgstr""

       
# CppCoreGuidelines.md:7365
msgid "7365            cerr << '\\n';"
msgstr""

# CppCoreGuidelines.md:7366
msgid "7366            if (severity) exit(severity);"
msgstr""

# CppCoreGuidelines.md:7367
msgid "7367        }"
msgstr""

       
# CppCoreGuidelines.md:7368
msgid "7368        void use()"
msgstr""

# CppCoreGuidelines.md:7369
msgid "7369        {"
msgstr""

# CppCoreGuidelines.md:7370
msgid "7370            error(7, \"this\", \"is\", \"an\", \"error\", nullptr);"
msgstr""

# CppCoreGuidelines.md:7371
msgid "7371            error(7); // crash"
msgstr""

# CppCoreGuidelines.md:7372
msgid "7372            error(7, \"this\", \"is\", \"an\", \"error\");  // crash"
msgstr""

# CppCoreGuidelines.md:7373
msgid "7373            const char* is = \"is\";"
msgstr""

# CppCoreGuidelines.md:7374
msgid "7374            string an = \"an\";"
msgstr""

# CppCoreGuidelines.md:7375
msgid "7375            error(7, \"this\", \"is\", an, \"error\"); // crash"
msgstr""

# CppCoreGuidelines.md:7376
msgid "7376        }"
msgstr""

       
# CppCoreGuidelines.md:7377
msgid "7377    **Alternative**: Overloading. Templates. Variadic templates."
msgstr""

# CppCoreGuidelines.md:7378
msgid "7378        #include <iostream>"
msgstr""

       
# CppCoreGuidelines.md:7379
msgid "7379        void error(int severity)"
msgstr""

# CppCoreGuidelines.md:7380
msgid "7380        {"
msgstr""

# CppCoreGuidelines.md:7381
msgid "7381            std::cerr << '\\n';"
msgstr""

# CppCoreGuidelines.md:7382
msgid "7382            std::exit(severity);"
msgstr""

# CppCoreGuidelines.md:7383
msgid "7383        }"
msgstr""

       
# CppCoreGuidelines.md:7384
msgid "7384        template <typename T, typename... Ts>"
msgstr""

# CppCoreGuidelines.md:7385
msgid "7385        constexpr void error(int severity, T head, Ts... tail)"
msgstr""

# CppCoreGuidelines.md:7386
msgid "7386        {"
msgstr""

# CppCoreGuidelines.md:7387
msgid "7387            std::cerr << head;"
msgstr""

# CppCoreGuidelines.md:7388
msgid "7388            error(severity, tail...);"
msgstr""

# CppCoreGuidelines.md:7389
msgid "7389        }"
msgstr""

       
# CppCoreGuidelines.md:7390
msgid "7390        void use()"
msgstr""

# CppCoreGuidelines.md:7391
msgid "7391        {"
msgstr""

# CppCoreGuidelines.md:7392
msgid "7392            error(7); // No crash!"
msgstr""

# CppCoreGuidelines.md:7393
msgid "7393            error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // No crash!"
msgstr""

       
# CppCoreGuidelines.md:7394
msgid "7394            std::string an = \"an\";"
msgstr""

# CppCoreGuidelines.md:7395
msgid "7395            error(7, \"this\", \"is\", \"not\", an, \"error\"); // No crash!"
msgstr""

       
# CppCoreGuidelines.md:7396
msgid "7396            error(5, \"oh\", \"no\", nullptr); // Compile error! No need for nullptr."
msgstr""

# CppCoreGuidelines.md:7397
msgid "7397        }"
msgstr""

       
       
# CppCoreGuidelines.md:7398
msgid "7398    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7399
msgid "7399    This is basically the way `printf` is implemented."
msgstr""

       
# CppCoreGuidelines.md:7400
msgid "7400    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7401
msgid "7401    * Flag definitions of C-style variadic functions."
msgstr""

# CppCoreGuidelines.md:7402
msgid "7402    * Flag `#include <cstdarg>` and `#include <stdarg.h>`"
msgstr""

       
       
# CppCoreGuidelines.md:7403
msgid "7403    ## ES.expr: Expressions"
msgstr""

       
# CppCoreGuidelines.md:7404
msgid "7404    Expressions manipulate values."
msgstr""

       
# CppCoreGuidelines.md:7405
msgid "7405    ### <a name=\"Res-complicated\"></a>ES.40: Avoid complicated expressions"
msgstr""

       
# CppCoreGuidelines.md:7406
msgid "7406    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7407
msgid "7407    Complicated expressions are error-prone."
msgstr""

       
# CppCoreGuidelines.md:7408
msgid "7408    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7409
msgid "7409        // bad: assignment hidden in subexpression"
msgstr""

# CppCoreGuidelines.md:7410
msgid "7410        while ((c = getc()) != -1)"
msgstr""

       
# CppCoreGuidelines.md:7411
msgid "7411        // bad: two non-local variables assigned in a sub-expressions"
msgstr""

# CppCoreGuidelines.md:7412
msgid "7412        while ((cin >> c1, cin >> c2), c1 == c2)"
msgstr""

       
# CppCoreGuidelines.md:7413
msgid "7413        // better, but possibly still too complicated"
msgstr""

# CppCoreGuidelines.md:7414
msgid "7414        for (char c1, c2; cin >> c1 >> c2 && c1 == c2;)"
msgstr""

       
# CppCoreGuidelines.md:7415
msgid "7415        // OK: if i and j are not aliased"
msgstr""

# CppCoreGuidelines.md:7416
msgid "7416        int x = ++i + ++j;"
msgstr""

       
# CppCoreGuidelines.md:7417
msgid "7417        // OK: if i != j and i != k"
msgstr""

# CppCoreGuidelines.md:7418
msgid "7418        v[i] = v[j] + v[k];"
msgstr""

       
# CppCoreGuidelines.md:7419
msgid "7419        // bad: multiple assignments \"hidden\" in subexpressions"
msgstr""

# CppCoreGuidelines.md:7420
msgid "7420        x = a + (b = f()) + (c = g()) * 7;"
msgstr""

       
# CppCoreGuidelines.md:7421
msgid "7421        // bad: relies on commonly misunderstood precedence rules"
msgstr""

# CppCoreGuidelines.md:7422
msgid "7422        x = a & b + c * d && e ^ f == 7;"
msgstr""

       
# CppCoreGuidelines.md:7423
msgid "7423        // bad: undefined behavior"
msgstr""

# CppCoreGuidelines.md:7424
msgid "7424        x = x++ + x++ + ++x;"
msgstr""

       
# CppCoreGuidelines.md:7425
msgid "7425    Some of these expressions are unconditionally bad (e.g., they rely on undefined behavior). Others are simply so complicated and/or unusual that even good programmers could misunderstand them or overlook a problem when in a hurry."
msgstr""

       
# CppCoreGuidelines.md:7426
msgid "7426    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7427
msgid "7427    C++17 tightens up the rules for the order of evaluation"
msgstr""

# CppCoreGuidelines.md:7428
msgid "7428    (left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified; [see ES.43](#Res-order)),"
msgstr""

# CppCoreGuidelines.md:7429
msgid "7429    but that doesn't change the fact that complicated expressions are potentially confusing."
msgstr""

       
# CppCoreGuidelines.md:7430
msgid "7430    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7431
msgid "7431    A programmer should know and use the basic rules for expressions."
msgstr""

       
# CppCoreGuidelines.md:7432
msgid "7432    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7433
msgid "7433        x = k * y + z;             // OK"
msgstr""

       
# CppCoreGuidelines.md:7434
msgid "7434        auto t1 = k * y;           // bad: unnecessarily verbose"
msgstr""

# CppCoreGuidelines.md:7435
msgid "7435        x = t1 + z;"
msgstr""

       
# CppCoreGuidelines.md:7436
msgid "7436        if (0 <= x && x < max)   // OK"
msgstr""

       
# CppCoreGuidelines.md:7437
msgid "7437        auto t1 = 0 <= x;        // bad: unnecessarily verbose"
msgstr""

# CppCoreGuidelines.md:7438
msgid "7438        auto t2 = x < max;"
msgstr""

# CppCoreGuidelines.md:7439
msgid "7439        if (t1 && t2)            // ..."
msgstr""

       
# CppCoreGuidelines.md:7440
msgid "7440    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7441
msgid "7441    Tricky. How complicated must an expression be to be considered complicated? Writing computations as statements with one operation each is also confusing. Things to consider:"
msgstr""

       
# CppCoreGuidelines.md:7442
msgid "7442    * side effects: side effects on multiple non-local variables (for some definition of non-local) can be suspect, especially if the side effects are in separate subexpressions"
msgstr""

# CppCoreGuidelines.md:7443
msgid "7443    * writes to aliased variables"
msgstr""

# CppCoreGuidelines.md:7444
msgid "7444    * more than N operators (and what should N be?)"
msgstr""

# CppCoreGuidelines.md:7445
msgid "7445    * reliance of subtle precedence rules"
msgstr""

# CppCoreGuidelines.md:7446
msgid "7446    * uses undefined behavior (can we catch all undefined behavior?)"
msgstr""

# CppCoreGuidelines.md:7447
msgid "7447    * implementation defined behavior?"
msgstr""

# CppCoreGuidelines.md:7448
msgid "7448    * ???"
msgstr""

       
# CppCoreGuidelines.md:7449
msgid "7449    ### <a name=\"Res-parens\"></a>ES.41: If in doubt about operator precedence, parenthesize"
msgstr""

       
# CppCoreGuidelines.md:7450
msgid "7450    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7451
msgid "7451    Avoid errors. Readability. Not everyone has the operator table memorized."
msgstr""

       
# CppCoreGuidelines.md:7452
msgid "7452    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7453
msgid "7453        const unsigned int flag = 2;"
msgstr""

# CppCoreGuidelines.md:7454
msgid "7454        unsigned int a = flag;"
msgstr""

       
# CppCoreGuidelines.md:7455
msgid "7455        if (a & flag != 0)  // bad: means a&(flag != 0)"
msgstr""

       
# CppCoreGuidelines.md:7456
msgid "7456    Note: We recommend that programmers know their precedence table for the arithmetic operations, the logical operations, but consider mixing bitwise logical operations with other operators in need of parentheses."
msgstr""

       
# CppCoreGuidelines.md:7457
msgid "7457        if ((a & flag) != 0)  // OK: works as intended"
msgstr""

       
# CppCoreGuidelines.md:7458
msgid "7458    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7459
msgid "7459    You should know enough not to need parentheses for:"
msgstr""

       
# CppCoreGuidelines.md:7460
msgid "7460        if (a < 0 || a <= max) {"
msgstr""

# CppCoreGuidelines.md:7461
msgid "7461            // ..."
msgstr""

# CppCoreGuidelines.md:7462
msgid "7462        }"
msgstr""

       
# CppCoreGuidelines.md:7463
msgid "7463    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7464
msgid "7464    * Flag combinations of bitwise-logical operators and other operators."
msgstr""

# CppCoreGuidelines.md:7465
msgid "7465    * Flag assignment operators not as the leftmost operator."
msgstr""

# CppCoreGuidelines.md:7466
msgid "7466    * ???"
msgstr""

       
# CppCoreGuidelines.md:7467
msgid "7467    ### <a name=\"Res-ptr\"></a>ES.42: Keep use of pointers simple and straightforward"
msgstr""

       
# CppCoreGuidelines.md:7468
msgid "7468    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7469
msgid "7469    Complicated pointer manipulation is a major source of errors."
msgstr""

       
# CppCoreGuidelines.md:7470
msgid "7470    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7471
msgid "7471    Use `gsl::span` instead."
msgstr""

# CppCoreGuidelines.md:7472
msgid "7472    Pointers should [only refer to single objects](#Ri-array)."
msgstr""

# CppCoreGuidelines.md:7473
msgid "7473    Pointer arithmetic is fragile and easy to get wrong, the source of many, many bad bugs and security violations."
msgstr""

# CppCoreGuidelines.md:7474
msgid "7474    `span` is a bounds-checked, safe type for accessing arrays of data."
msgstr""

# CppCoreGuidelines.md:7475
msgid "7475    Access into an array with known bounds using a constant as a subscript can be validated by the compiler."
msgstr""

       
# CppCoreGuidelines.md:7476
msgid "7476    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7477
msgid "7477        void f(int* p, int count)"
msgstr""

# CppCoreGuidelines.md:7478
msgid "7478        {"
msgstr""

# CppCoreGuidelines.md:7479
msgid "7479            if (count < 2) return;"
msgstr""

       
# CppCoreGuidelines.md:7480
msgid "7480            int* q = p + 1;    // BAD"
msgstr""

       
# CppCoreGuidelines.md:7481
msgid "7481            ptrdiff_t d;"
msgstr""

# CppCoreGuidelines.md:7482
msgid "7482            int n;"
msgstr""

# CppCoreGuidelines.md:7483
msgid "7483            d = (p - &n);      // OK"
msgstr""

# CppCoreGuidelines.md:7484
msgid "7484            d = (q - p);       // OK"
msgstr""

       
# CppCoreGuidelines.md:7485
msgid "7485            int n = *p++;      // BAD"
msgstr""

       
# CppCoreGuidelines.md:7486
msgid "7486            if (count < 6) return;"
msgstr""

       
# CppCoreGuidelines.md:7487
msgid "7487            p[4] = 1;          // BAD"
msgstr""

       
# CppCoreGuidelines.md:7488
msgid "7488            p[count - 1] = 2;  // BAD"
msgstr""

       
# CppCoreGuidelines.md:7489
msgid "7489            use(&p[0], 3);     // BAD"
msgstr""

# CppCoreGuidelines.md:7490
msgid "7490        }"
msgstr""

       
# CppCoreGuidelines.md:7491
msgid "7491    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:7492
msgid "7492        void f(span<int> a) // BETTER: use span in the function declaration"
msgstr""

# CppCoreGuidelines.md:7493
msgid "7493        {"
msgstr""

# CppCoreGuidelines.md:7494
msgid "7494            if (a.size() < 2) return;"
msgstr""

       
# CppCoreGuidelines.md:7495
msgid "7495            int n = a[0];      // OK"
msgstr""

       
# CppCoreGuidelines.md:7496
msgid "7496            span<int> q = a.subspan(1); // OK"
msgstr""

       
# CppCoreGuidelines.md:7497
msgid "7497            if (a.size() < 6) return;"
msgstr""

       
# CppCoreGuidelines.md:7498
msgid "7498            a[4] = 1;          // OK"
msgstr""

       
# CppCoreGuidelines.md:7499
msgid "7499            a[a.size() - 1] = 2;  // OK"
msgstr""

       
# CppCoreGuidelines.md:7500
msgid "7500            use(a.data(), 3);  // OK"
msgstr""

# CppCoreGuidelines.md:7501
msgid "7501        }"
msgstr""

       
# CppCoreGuidelines.md:7502
msgid "7502    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7503
msgid "7503    Subscripting with a variable is difficult for both tools and humans to validate as safe."
msgstr""

# CppCoreGuidelines.md:7504
msgid "7504    `span` is a run-time bounds-checked, safe type for accessing arrays of data."
msgstr""

# CppCoreGuidelines.md:7505
msgid "7505    `at()` is another alternative that ensures single accesses are bounds-checked."
msgstr""

# CppCoreGuidelines.md:7506
msgid "7506    If iterators are needed to access an array, use the iterators from a `span` constructed over the array."
msgstr""

       
# CppCoreGuidelines.md:7507
msgid "7507    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7508
msgid "7508        void f(array<int, 10> a, int pos)"
msgstr""

# CppCoreGuidelines.md:7509
msgid "7509        {"
msgstr""

# CppCoreGuidelines.md:7510
msgid "7510            a[pos / 2] = 1; // BAD"
msgstr""

# CppCoreGuidelines.md:7511
msgid "7511            a[pos - 1] = 2; // BAD"
msgstr""

# CppCoreGuidelines.md:7512
msgid "7512            a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don't do this"
msgstr""

# CppCoreGuidelines.md:7513
msgid "7513            a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don't do this"
msgstr""

# CppCoreGuidelines.md:7514
msgid "7514        }"
msgstr""

       
# CppCoreGuidelines.md:7515
msgid "7515    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:7516
msgid "7516    Use a `span`:"
msgstr""

       
# CppCoreGuidelines.md:7517
msgid "7517        void f1(span<int, 10> a, int pos) // A1: Change parameter type to use span"
msgstr""

# CppCoreGuidelines.md:7518
msgid "7518        {"
msgstr""

# CppCoreGuidelines.md:7519
msgid "7519            a[pos / 2] = 1; // OK"
msgstr""

# CppCoreGuidelines.md:7520
msgid "7520            a[pos - 1] = 2; // OK"
msgstr""

# CppCoreGuidelines.md:7521
msgid "7521        }"
msgstr""

       
# CppCoreGuidelines.md:7522
msgid "7522        void f2(array<int, 10> arr, int pos) // A2: Add local span and use that"
msgstr""

# CppCoreGuidelines.md:7523
msgid "7523        {"
msgstr""

# CppCoreGuidelines.md:7524
msgid "7524            span<int> a = {arr, pos};"
msgstr""

# CppCoreGuidelines.md:7525
msgid "7525            a[pos / 2] = 1; // OK"
msgstr""

# CppCoreGuidelines.md:7526
msgid "7526            a[pos - 1] = 2; // OK"
msgstr""

# CppCoreGuidelines.md:7527
msgid "7527        }"
msgstr""

       
# CppCoreGuidelines.md:7528
msgid "7528    Use a `at()`:"
msgstr""

       
# CppCoreGuidelines.md:7529
msgid "7529        void f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() for access"
msgstr""

# CppCoreGuidelines.md:7530
msgid "7530        {"
msgstr""

# CppCoreGuidelines.md:7531
msgid "7531            at(a, pos / 2) = 1; // OK"
msgstr""

# CppCoreGuidelines.md:7532
msgid "7532            at(a, pos - 1) = 2; // OK"
msgstr""

# CppCoreGuidelines.md:7533
msgid "7533        }"
msgstr""

       
# CppCoreGuidelines.md:7534
msgid "7534    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7535
msgid "7535        void f()"
msgstr""

# CppCoreGuidelines.md:7536
msgid "7536        {"
msgstr""

# CppCoreGuidelines.md:7537
msgid "7537            int arr[COUNT];"
msgstr""

# CppCoreGuidelines.md:7538
msgid "7538            for (int i = 0; i < COUNT; ++i)"
msgstr""

# CppCoreGuidelines.md:7539
msgid "7539                arr[i] = i; // BAD, cannot use non-constant indexer"
msgstr""

# CppCoreGuidelines.md:7540
msgid "7540        }"
msgstr""

       
# CppCoreGuidelines.md:7541
msgid "7541    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:7542
msgid "7542    Use a `span`:"
msgstr""

       
# CppCoreGuidelines.md:7543
msgid "7543        void f1()"
msgstr""

# CppCoreGuidelines.md:7544
msgid "7544        {"
msgstr""

# CppCoreGuidelines.md:7545
msgid "7545            int arr[COUNT];"
msgstr""

# CppCoreGuidelines.md:7546
msgid "7546            span<int> av = arr;"
msgstr""

# CppCoreGuidelines.md:7547
msgid "7547            for (int i = 0; i < COUNT; ++i)"
msgstr""

# CppCoreGuidelines.md:7548
msgid "7548                av[i] = i;"
msgstr""

# CppCoreGuidelines.md:7549
msgid "7549        }"
msgstr""

       
# CppCoreGuidelines.md:7550
msgid "7550    Use a `span` and range-`for`:"
msgstr""

       
# CppCoreGuidelines.md:7551
msgid "7551        void f1a()"
msgstr""

# CppCoreGuidelines.md:7552
msgid "7552        {"
msgstr""

# CppCoreGuidelines.md:7553
msgid "7553             int arr[COUNT];"
msgstr""

# CppCoreGuidelines.md:7554
msgid "7554             span<int, COUNT> av = arr;"
msgstr""

# CppCoreGuidelines.md:7555
msgid "7555             int i = 0;"
msgstr""

# CppCoreGuidelines.md:7556
msgid "7556             for (auto& e : av)"
msgstr""

# CppCoreGuidelines.md:7557
msgid "7557                 e = i++;"
msgstr""

# CppCoreGuidelines.md:7558
msgid "7558        }"
msgstr""

       
# CppCoreGuidelines.md:7559
msgid "7559    Use `at()` for access:"
msgstr""

       
# CppCoreGuidelines.md:7560
msgid "7560        void f2()"
msgstr""

# CppCoreGuidelines.md:7561
msgid "7561        {"
msgstr""

# CppCoreGuidelines.md:7562
msgid "7562            int arr[COUNT];"
msgstr""

# CppCoreGuidelines.md:7563
msgid "7563            for (int i = 0; i < COUNT; ++i)"
msgstr""

# CppCoreGuidelines.md:7564
msgid "7564                at(arr, i) = i;"
msgstr""

# CppCoreGuidelines.md:7565
msgid "7565        }"
msgstr""

       
# CppCoreGuidelines.md:7566
msgid "7566    Use a range-`for`:"
msgstr""

       
# CppCoreGuidelines.md:7567
msgid "7567        void f3()"
msgstr""

# CppCoreGuidelines.md:7568
msgid "7568        {"
msgstr""

# CppCoreGuidelines.md:7569
msgid "7569            int arr[COUNT];"
msgstr""

# CppCoreGuidelines.md:7570
msgid "7570            for (auto& e : arr)"
msgstr""

# CppCoreGuidelines.md:7571
msgid "7571                 e = i++;"
msgstr""

# CppCoreGuidelines.md:7572
msgid "7572        }"
msgstr""

       
# CppCoreGuidelines.md:7573
msgid "7573    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7574
msgid "7574    Tooling can offer rewrites of array accesses that involve dynamic index expressions to use `at()` instead:"
msgstr""

       
# CppCoreGuidelines.md:7575
msgid "7575        static int a[10];"
msgstr""

       
# CppCoreGuidelines.md:7576
msgid "7576        void f(int i, int j)"
msgstr""

# CppCoreGuidelines.md:7577
msgid "7577        {"
msgstr""

# CppCoreGuidelines.md:7578
msgid "7578            a[i + j] = 12;      // BAD, could be rewritten as ..."
msgstr""

# CppCoreGuidelines.md:7579
msgid "7579            at(a, i + j) = 12;  // OK -- bounds-checked"
msgstr""

# CppCoreGuidelines.md:7580
msgid "7580        }"
msgstr""

       
# CppCoreGuidelines.md:7581
msgid "7581    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7582
msgid "7582    Turning an array into a pointer (as the language does essentially always) removes opportunities for checking, so avoid it"
msgstr""

       
# CppCoreGuidelines.md:7583
msgid "7583        void g(int* p);"
msgstr""

       
# CppCoreGuidelines.md:7584
msgid "7584        void f()"
msgstr""

# CppCoreGuidelines.md:7585
msgid "7585        {"
msgstr""

# CppCoreGuidelines.md:7586
msgid "7586            int a[5];"
msgstr""

# CppCoreGuidelines.md:7587
msgid "7587            g(a);        // BAD: are we trying to pass an array?"
msgstr""

# CppCoreGuidelines.md:7588
msgid "7588            g(&a[0]);    // OK: passing one object"
msgstr""

# CppCoreGuidelines.md:7589
msgid "7589        }"
msgstr""

       
# CppCoreGuidelines.md:7590
msgid "7590    If you want to pass an array, say so:"
msgstr""

       
# CppCoreGuidelines.md:7591
msgid "7591        void g(int* p, size_t length);  // old (dangerous) code"
msgstr""

       
# CppCoreGuidelines.md:7592
msgid "7592        void g1(span<int> av); // BETTER: get g() changed."
msgstr""

       
# CppCoreGuidelines.md:7593
msgid "7593        void f2()"
msgstr""

# CppCoreGuidelines.md:7594
msgid "7594        {"
msgstr""

# CppCoreGuidelines.md:7595
msgid "7595            int a[5];"
msgstr""

# CppCoreGuidelines.md:7596
msgid "7596            span<int> av = a;"
msgstr""

       
# CppCoreGuidelines.md:7597
msgid "7597            g(av.data(), av.size());   // OK, if you have no choice"
msgstr""

# CppCoreGuidelines.md:7598
msgid "7598            g1(a);                     // OK -- no decay here, instead use implicit span ctor"
msgstr""

# CppCoreGuidelines.md:7599
msgid "7599        }"
msgstr""

       
# CppCoreGuidelines.md:7600
msgid "7600    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7601
msgid "7601    * Flag any arithmetic operation on an expression of pointer type that results in a value of pointer type."
msgstr""

# CppCoreGuidelines.md:7602
msgid "7602    * Flag any indexing expression on an expression or variable of array type (either static array or `std::array`) where the indexer is not a compile-time constant expression with a value between `0` or and the upper bound of the array."
msgstr""

# CppCoreGuidelines.md:7603
msgid "7603    * Flag any expression that would rely on implicit conversion of an array type to a pointer type."
msgstr""

       
# CppCoreGuidelines.md:7604
msgid "7604    This rule is part of the [bounds-safety profile](#SS-bounds)."
msgstr""

       
       
# CppCoreGuidelines.md:7605
msgid "7605    ### <a name=\"Res-order\"></a>ES.43: Avoid expressions with undefined order of evaluation"
msgstr""

       
# CppCoreGuidelines.md:7606
msgid "7606    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7607
msgid "7607    You have no idea what such code does. Portability."
msgstr""

# CppCoreGuidelines.md:7608
msgid "7608    Even if it does something sensible for you, it may do something different on another compiler (e.g., the next release of your compiler) or with a different optimizer setting."
msgstr""

       
# CppCoreGuidelines.md:7609
msgid "7609    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7610
msgid "7610    C++17 tightens up the rules for the order of evaluation:"
msgstr""

# CppCoreGuidelines.md:7611
msgid "7611    left-to-right except right-to-left in assignments, and the order of evaluation of function arguments is unspecified."
msgstr""

       
# CppCoreGuidelines.md:7612
msgid "7612    However, remember that your code may be compiled with a pre-C++17 compiler (e.g., through cut-and-paste) so don't be too clever."
msgstr""

       
# CppCoreGuidelines.md:7613
msgid "7613    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7614
msgid "7614        v[i] = ++i;   //  the result is undefined"
msgstr""

       
# CppCoreGuidelines.md:7615
msgid "7615    A good rule of thumb is that you should not read a value twice in an expression where you write to it."
msgstr""

       
# CppCoreGuidelines.md:7616
msgid "7616    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7617
msgid "7617    Can be detected by a good analyzer."
msgstr""

       
# CppCoreGuidelines.md:7618
msgid "7618    ### <a name=\"Res-order-fct\"></a>ES.44: Don't depend on order of evaluation of function arguments"
msgstr""

       
# CppCoreGuidelines.md:7619
msgid "7619    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7620
msgid "7620    Because that order is unspecified."
msgstr""

       
# CppCoreGuidelines.md:7621
msgid "7621    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7622
msgid "7622    C++17 tightens up the rules for the order of evaluation, but the order of evaluation of function arguments is still unspecified."
msgstr""

       
# CppCoreGuidelines.md:7623
msgid "7623    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7624
msgid "7624        int i = 0;"
msgstr""

# CppCoreGuidelines.md:7625
msgid "7625        f(++i, ++i);"
msgstr""

       
# CppCoreGuidelines.md:7626
msgid "7626    The call will most likely be `f(0, 1)` or `f(1, 0)`, but you don't know which."
msgstr""

# CppCoreGuidelines.md:7627
msgid "7627    Technically, the behavior is undefined."
msgstr""

# CppCoreGuidelines.md:7628
msgid "7628    In C++17, this code does not have undefined behavior, but it is still not specified which argument is evaluated first."
msgstr""

       
# CppCoreGuidelines.md:7629
msgid "7629    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7630
msgid "7630    Overloaded operators can lead to order of evaluation problems:"
msgstr""

       
# CppCoreGuidelines.md:7631
msgid "7631        f1()->m(f2());          // m(f1(), f2())"
msgstr""

# CppCoreGuidelines.md:7632
msgid "7632        cout << f1() << f2();   // operator<<(operator<<(cout, f1()), f2())"
msgstr""

       
# CppCoreGuidelines.md:7633
msgid "7633    In C++17, these examples work as expected (left to right) and assignments are evaluated right to left (just as ='s binding is right-to-left)"
msgstr""

       
# CppCoreGuidelines.md:7634
msgid "7634        f1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1()"
msgstr""

       
# CppCoreGuidelines.md:7635
msgid "7635    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7636
msgid "7636    Can be detected by a good analyzer."
msgstr""

       
# CppCoreGuidelines.md:7637
msgid "7637    ### <a name=\"Res-magic\"></a>ES.45: Avoid \"magic constants\"; use symbolic constants"
msgstr""

       
# CppCoreGuidelines.md:7638
msgid "7638    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7639
msgid "7639    Unnamed constants embedded in expressions are easily overlooked and often hard to understand:"
msgstr""

       
# CppCoreGuidelines.md:7640
msgid "7640    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7641
msgid "7641        for (int m = 1; m <= 12; ++m)   // don't: magic constant 12"
msgstr""

# CppCoreGuidelines.md:7642
msgid "7642            cout << month[m] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7643
msgid "7643    No, we don't all know that there are 12 months, numbered 1..12, in a year. Better:"
msgstr""

       
# CppCoreGuidelines.md:7644
msgid "7644        // months are indexed 1..12"
msgstr""

# CppCoreGuidelines.md:7645
msgid "7645        constexpr int first_month = 1;"
msgstr""

# CppCoreGuidelines.md:7646
msgid "7646        constexpr int last_month = 12;"
msgstr""

       
# CppCoreGuidelines.md:7647
msgid "7647        for (int m = first_month; m <= last_month; ++m)   // better"
msgstr""

# CppCoreGuidelines.md:7648
msgid "7648            cout << month[m] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7649
msgid "7649    Better still, don't expose constants:"
msgstr""

       
# CppCoreGuidelines.md:7650
msgid "7650        for (auto m : month)"
msgstr""

# CppCoreGuidelines.md:7651
msgid "7651            cout << m << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7652
msgid "7652    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7653
msgid "7653    Flag literals in code. Give a pass to `0`, `1`, `nullptr`, `\\n`, `\"\"`, and others on a positive list."
msgstr""

       
# CppCoreGuidelines.md:7654
msgid "7654    ### <a name=\"Res-narrowing\"></a>ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions"
msgstr""

       
# CppCoreGuidelines.md:7655
msgid "7655    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7656
msgid "7656    A narrowing conversion destroys information, often unexpectedly so."
msgstr""

       
# CppCoreGuidelines.md:7657
msgid "7657    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7658
msgid "7658    A key example is basic narrowing:"
msgstr""

       
# CppCoreGuidelines.md:7659
msgid "7659        double d = 7.9;"
msgstr""

# CppCoreGuidelines.md:7660
msgid "7660        int i = d;    // bad: narrowing: i becomes 7"
msgstr""

# CppCoreGuidelines.md:7661
msgid "7661        i = (int) d;  // bad: we're going to claim this is still not explicit enough"
msgstr""

       
# CppCoreGuidelines.md:7662
msgid "7662        void f(int x, long y, double d)"
msgstr""

# CppCoreGuidelines.md:7663
msgid "7663        {"
msgstr""

# CppCoreGuidelines.md:7664
msgid "7664            char c1 = x;   // bad: narrowing"
msgstr""

# CppCoreGuidelines.md:7665
msgid "7665            char c2 = y;   // bad: narrowing"
msgstr""

# CppCoreGuidelines.md:7666
msgid "7666            char c3 = d;   // bad: narrowing"
msgstr""

# CppCoreGuidelines.md:7667
msgid "7667        }"
msgstr""

       
# CppCoreGuidelines.md:7668
msgid "7668    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7669
msgid "7669    The guidelines support library offers a `narrow_cast` operation for specifying that narrowing is acceptable and a `narrow` (\"narrow if\") that throws an exception if a narrowing would throw away information:"
msgstr""

       
# CppCoreGuidelines.md:7670
msgid "7670        i = narrow_cast<int>(d);   // OK (you asked for it): narrowing: i becomes 7"
msgstr""

# CppCoreGuidelines.md:7671
msgid "7671        i = narrow<int>(d);        // OK: throws narrowing_error"
msgstr""

       
# CppCoreGuidelines.md:7672
msgid "7672    We also include lossy arithmetic casts, such as from a negative floating point type to an unsigned integral type:"
msgstr""

       
# CppCoreGuidelines.md:7673
msgid "7673        double d = -7.9;"
msgstr""

# CppCoreGuidelines.md:7674
msgid "7674        unsigned u = 0;"
msgstr""

       
# CppCoreGuidelines.md:7675
msgid "7675        u = d;                          // BAD"
msgstr""

# CppCoreGuidelines.md:7676
msgid "7676        u = narrow_cast<unsigned>(d);   // OK (you asked for it): u becomes 0"
msgstr""

# CppCoreGuidelines.md:7677
msgid "7677        u = narrow<unsigned>(d);        // OK: throws narrowing_error"
msgstr""

       
# CppCoreGuidelines.md:7678
msgid "7678    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7679
msgid "7679    A good analyzer can detect all narrowing conversions. However, flagging all narrowing conversions will lead to a lot of false positives. Suggestions:"
msgstr""

       
# CppCoreGuidelines.md:7680
msgid "7680    * flag all floating-point to integer conversions (maybe only `float`->`char` and `double`->`int`. Here be dragons! we need data)"
msgstr""

# CppCoreGuidelines.md:7681
msgid "7681    * flag all `long`->`char` (I suspect `int`->`char` is very common. Here be dragons! we need data)"
msgstr""

# CppCoreGuidelines.md:7682
msgid "7682    * consider narrowing conversions for function arguments especially suspect"
msgstr""

       
# CppCoreGuidelines.md:7683
msgid "7683    ### <a name=\"Res-nullptr\"></a>ES.47: Use `nullptr` rather than `0` or `NULL`"
msgstr""

       
# CppCoreGuidelines.md:7684
msgid "7684    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7685
msgid "7685    Readability. Minimize surprises: `nullptr` cannot be confused with an"
msgstr""

# CppCoreGuidelines.md:7686
msgid "7686    `int`. `nullptr` also has a well-specified (very restrictive) type, and thus"
msgstr""

# CppCoreGuidelines.md:7687
msgid "7687    works in more scenarios where type deduction might do the wrong thing on `NULL`"
msgstr""

# CppCoreGuidelines.md:7688
msgid "7688    or `0`."
msgstr""

       
# CppCoreGuidelines.md:7689
msgid "7689    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7690
msgid "7690    Consider:"
msgstr""

       
# CppCoreGuidelines.md:7691
msgid "7691        void f(int);"
msgstr""

# CppCoreGuidelines.md:7692
msgid "7692        void f(char*);"
msgstr""

# CppCoreGuidelines.md:7693
msgid "7693        f(0);         // call f(int)"
msgstr""

# CppCoreGuidelines.md:7694
msgid "7694        f(nullptr);   // call f(char*)"
msgstr""

       
# CppCoreGuidelines.md:7695
msgid "7695    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7696
msgid "7696    Flag uses of `0` and `NULL` for pointers. The transformation may be helped by simple program transformation."
msgstr""

       
# CppCoreGuidelines.md:7697
msgid "7697    ### <a name=\"Res-casts\"></a>ES.48: Avoid casts"
msgstr""

       
# CppCoreGuidelines.md:7698
msgid "7698    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7699
msgid "7699    Casts are a well-known source of errors. Make some optimizations unreliable."
msgstr""

       
# CppCoreGuidelines.md:7700
msgid "7700    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7701
msgid "7701        double d = 2;"
msgstr""

# CppCoreGuidelines.md:7702
msgid "7702        auto p = (long*)&d;"
msgstr""

# CppCoreGuidelines.md:7703
msgid "7703        auto q = (long long*)&d;"
msgstr""

# CppCoreGuidelines.md:7704
msgid "7704        cout << d << ' ' << *p << ' ' << *q << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7705
msgid "7705    What would you think this fragment prints? The result is at best implementation defined. I got"
msgstr""

       
# CppCoreGuidelines.md:7706
msgid "7706        2 0 4611686018427387904"
msgstr""

       
# CppCoreGuidelines.md:7707
msgid "7707    Adding"
msgstr""

       
# CppCoreGuidelines.md:7708
msgid "7708        *q = 666;"
msgstr""

# CppCoreGuidelines.md:7709
msgid "7709        cout << d << ' ' << *p << ' ' << *q << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7710
msgid "7710    I got"
msgstr""

       
# CppCoreGuidelines.md:7711
msgid "7711        3.29048e-321 666 666"
msgstr""

       
# CppCoreGuidelines.md:7712
msgid "7712    Surprised? I'm just glad I didn't crash the program."
msgstr""

       
# CppCoreGuidelines.md:7713
msgid "7713    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7714
msgid "7714    Programmers who write casts typically assume that they know what they are doing,"
msgstr""

# CppCoreGuidelines.md:7715
msgid "7715    or that writing a cast makes the program \"easier to read\"."
msgstr""

# CppCoreGuidelines.md:7716
msgid "7716    In fact, they often disable the general rules for using values."
msgstr""

# CppCoreGuidelines.md:7717
msgid "7717    Overload resolution and template instantiation usually pick the right function if there is a right function to pick."
msgstr""

# CppCoreGuidelines.md:7718
msgid "7718    If there is not, maybe there ought to be, rather than applying a local fix (cast)."
msgstr""

       
# CppCoreGuidelines.md:7719
msgid "7719    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7720
msgid "7720    Casts are necessary in a systems programming language.  For example, how else"
msgstr""

# CppCoreGuidelines.md:7721
msgid "7721    would we get the address of a device register into a pointer?  However, casts"
msgstr""

# CppCoreGuidelines.md:7722
msgid "7722    are seriously overused as well as a major source of errors."
msgstr""

       
# CppCoreGuidelines.md:7723
msgid "7723    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7724
msgid "7724    If you feel the need for a lot of casts, there may be a fundamental design problem."
msgstr""

       
# CppCoreGuidelines.md:7725
msgid "7725    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:7726
msgid "7726    Casting to `(void)` is the Standard-sanctioned way to turn off `[[nodiscard]]` warnings. If you are calling a function with a `[[nodiscard]]` return and you deliberately want to discard the result, first think hard about whether that is really a good idea (there is usually a good reason the author of the function or of the return type used `[[nodiscard]]` in the first place), but if you still think it's appropriate and your code reviewer agrees, write `(void)` to turn off the warning."
msgstr""

       
# CppCoreGuidelines.md:7727
msgid "7727    ##### Alternatives"
msgstr""

       
# CppCoreGuidelines.md:7728
msgid "7728    Casts are widely (mis) used. Modern C++ has rules and constructs that eliminate the need for casts in many contexts, such as"
msgstr""

       
# CppCoreGuidelines.md:7729
msgid "7729    * Use templates"
msgstr""

# CppCoreGuidelines.md:7730
msgid "7730    * Use `std::variant`"
msgstr""

# CppCoreGuidelines.md:7731
msgid "7731    * Rely on the well-defined, safe, implicit conversions between pointer types"
msgstr""

       
# CppCoreGuidelines.md:7732
msgid "7732    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7733
msgid "7733    * Force the elimination of C-style casts, except on a function with a `[[nodiscard]]` return"
msgstr""

# CppCoreGuidelines.md:7734
msgid "7734    * Warn if there are many functional style casts (there is an obvious problem in quantifying 'many')"
msgstr""

# CppCoreGuidelines.md:7735
msgid "7735    * The [type profile](#Pro-type-reinterpretcast) bans `reinterpret_cast`."
msgstr""

# CppCoreGuidelines.md:7736
msgid "7736    * Warn against [identity casts](#Pro-type-identitycast) between pointer types, where the source and target types are the same (#Pro-type-identitycast)"
msgstr""

# CppCoreGuidelines.md:7737
msgid "7737    * Warn if a pointer cast could be [implicit](#Pro-type-implicitpointercast)"
msgstr""

       
# CppCoreGuidelines.md:7738
msgid "7738    ### <a name=\"Res-casts-named\"></a>ES.49: If you must use a cast, use a named cast"
msgstr""

       
# CppCoreGuidelines.md:7739
msgid "7739    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7740
msgid "7740    Readability. Error avoidance."
msgstr""

# CppCoreGuidelines.md:7741
msgid "7741    Named casts are more specific than a C-style or functional cast, allowing the compiler to catch some errors."
msgstr""

       
# CppCoreGuidelines.md:7742
msgid "7742    The named casts are:"
msgstr""

       
# CppCoreGuidelines.md:7743
msgid "7743    * `static_cast`"
msgstr""

# CppCoreGuidelines.md:7744
msgid "7744    * `const_cast`"
msgstr""

# CppCoreGuidelines.md:7745
msgid "7745    * `reinterpret_cast`"
msgstr""

# CppCoreGuidelines.md:7746
msgid "7746    * `dynamic_cast`"
msgstr""

# CppCoreGuidelines.md:7747
msgid "7747    * `std::move`         // `move(x)` is an rvalue reference to `x`"
msgstr""

# CppCoreGuidelines.md:7748
msgid "7748    * `std::forward`      // `forward(x)` is an rvalue reference to `x`"
msgstr""

# CppCoreGuidelines.md:7749
msgid "7749    * `gsl::narrow_cast`  // `narrow_cast<T>(x)` is `static_cast<T>(x)`"
msgstr""

# CppCoreGuidelines.md:7750
msgid "7750    * `gsl::narrow`       // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) == x` or it throws `narrowing_error`"
msgstr""

       
# CppCoreGuidelines.md:7751
msgid "7751    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7752
msgid "7752        class B { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:7753
msgid "7753        class D { /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:7754
msgid "7754        template<typename D> D* upcast(B* pb)"
msgstr""

# CppCoreGuidelines.md:7755
msgid "7755        {"
msgstr""

# CppCoreGuidelines.md:7756
msgid "7756            D* pd0 = pb;                        // error: no implicit conversion from B* to D*"
msgstr""

# CppCoreGuidelines.md:7757
msgid "7757            D* pd1 = (D*)pb;                    // legal, but what is done?"
msgstr""

# CppCoreGuidelines.md:7758
msgid "7758            D* pd2 = static_cast<D*>(pb);       // error: D is not derived from B"
msgstr""

# CppCoreGuidelines.md:7759
msgid "7759            D* pd3 = reinterpret_cast<D*>(pb);  // OK: on your head be it!"
msgstr""

# CppCoreGuidelines.md:7760
msgid "7760            D* pd4 = dynamic_cast<D*>(pb);      // OK: return nullptr"
msgstr""

# CppCoreGuidelines.md:7761
msgid "7761            // ..."
msgstr""

# CppCoreGuidelines.md:7762
msgid "7762        }"
msgstr""

       
# CppCoreGuidelines.md:7763
msgid "7763    The example was synthesized from real-world bugs where `D` used to be derived from `B`, but someone refactored the hierarchy."
msgstr""

# CppCoreGuidelines.md:7764
msgid "7764    The C-style cast is dangerous because it can do any kind of conversion, depriving us of any protection from mistakes (now or in the future)."
msgstr""

       
# CppCoreGuidelines.md:7765
msgid "7765    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7766
msgid "7766    When converting between types with no information loss (e.g. from `float` to"
msgstr""

# CppCoreGuidelines.md:7767
msgid "7767    `double` or `int64` from `int32`), brace initialization may be used instead."
msgstr""

       
# CppCoreGuidelines.md:7768
msgid "7768        double d {some_float};"
msgstr""

# CppCoreGuidelines.md:7769
msgid "7769        int64_t i {some_int32};"
msgstr""

       
# CppCoreGuidelines.md:7770
msgid "7770    This makes it clear that the type conversion was intended and also prevents"
msgstr""

# CppCoreGuidelines.md:7771
msgid "7771    conversions between types that might result in loss of precision. (It is a"
msgstr""

# CppCoreGuidelines.md:7772
msgid "7772    compilation error to try to initialize a `float` from a `double` in this fashion,"
msgstr""

# CppCoreGuidelines.md:7773
msgid "7773    for example.)"
msgstr""

       
# CppCoreGuidelines.md:7774
msgid "7774    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:7775
msgid "7775    `reinterpret_cast` can be essential, but the essential uses (e.g., turning a machine address into pointer) are not type safe:"
msgstr""

       
# CppCoreGuidelines.md:7776
msgid "7776        auto p = reinterpret_cast<Device_register>(0x800);  // inherently dangerous"
msgstr""

       
       
# CppCoreGuidelines.md:7777
msgid "7777    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7778
msgid "7778    * Flag C-style and functional casts."
msgstr""

# CppCoreGuidelines.md:7779
msgid "7779    * The [type profile](#Pro-type-reinterpretcast) bans `reinterpret_cast`."
msgstr""

# CppCoreGuidelines.md:7780
msgid "7780    * The [type profile](#Pro-type-arithmeticcast) warns when using `static_cast` between arithmetic types."
msgstr""

       
# CppCoreGuidelines.md:7781
msgid "7781    ### <a name=\"Res-casts-const\"></a>ES.50: Don't cast away `const`"
msgstr""

       
# CppCoreGuidelines.md:7782
msgid "7782    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7783
msgid "7783    It makes a lie out of `const`."
msgstr""

# CppCoreGuidelines.md:7784
msgid "7784    If the variable is actually declared `const`, the result of \"casting away `const`\" is undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:7785
msgid "7785    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7786
msgid "7786        void f(const int& i)"
msgstr""

# CppCoreGuidelines.md:7787
msgid "7787        {"
msgstr""

# CppCoreGuidelines.md:7788
msgid "7788            const_cast<int&>(i) = 42;   // BAD"
msgstr""

# CppCoreGuidelines.md:7789
msgid "7789        }"
msgstr""

       
# CppCoreGuidelines.md:7790
msgid "7790        static int i = 0;"
msgstr""

# CppCoreGuidelines.md:7791
msgid "7791        static const int j = 0;"
msgstr""

       
# CppCoreGuidelines.md:7792
msgid "7792        f(i); // silent side effect"
msgstr""

# CppCoreGuidelines.md:7793
msgid "7793        f(j); // undefined behavior"
msgstr""

       
# CppCoreGuidelines.md:7794
msgid "7794    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7795
msgid "7795    Sometimes, you may be tempted to resort to `const_cast` to avoid code duplication, such as when two accessor functions that differ only in `const`-ness have similar implementations. For example:"
msgstr""

       
# CppCoreGuidelines.md:7796
msgid "7796        class Bar;"
msgstr""

       
# CppCoreGuidelines.md:7797
msgid "7797        class Foo {"
msgstr""

# CppCoreGuidelines.md:7798
msgid "7798        public:"
msgstr""

# CppCoreGuidelines.md:7799
msgid "7799            // BAD, duplicates logic"
msgstr""

# CppCoreGuidelines.md:7800
msgid "7800            Bar& get_bar() {"
msgstr""

# CppCoreGuidelines.md:7801
msgid "7801                /* complex logic around getting a non-const reference to my_bar */"
msgstr""

# CppCoreGuidelines.md:7802
msgid "7802            }"
msgstr""

       
# CppCoreGuidelines.md:7803
msgid "7803            const Bar& get_bar() const {"
msgstr""

# CppCoreGuidelines.md:7804
msgid "7804                /* same complex logic around getting a const reference to my_bar */"
msgstr""

# CppCoreGuidelines.md:7805
msgid "7805            }"
msgstr""

# CppCoreGuidelines.md:7806
msgid "7806        private:"
msgstr""

# CppCoreGuidelines.md:7807
msgid "7807            Bar my_bar;"
msgstr""

# CppCoreGuidelines.md:7808
msgid "7808        };"
msgstr""

       
# CppCoreGuidelines.md:7809
msgid "7809    Instead, prefer to share implementations. Normally, you can just have the non-`const` function call the `const` function. However, when there is complex logic this can lead to the following pattern that still resorts to a `const_cast`:"
msgstr""

       
# CppCoreGuidelines.md:7810
msgid "7810        class Foo {"
msgstr""

# CppCoreGuidelines.md:7811
msgid "7811        public:"
msgstr""

# CppCoreGuidelines.md:7812
msgid "7812            // not great, non-const calls const version but resorts to const_cast"
msgstr""

# CppCoreGuidelines.md:7813
msgid "7813            Bar& get_bar() {"
msgstr""

# CppCoreGuidelines.md:7814
msgid "7814                return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar());"
msgstr""

# CppCoreGuidelines.md:7815
msgid "7815            }"
msgstr""

# CppCoreGuidelines.md:7816
msgid "7816            const Bar& get_bar() const {"
msgstr""

# CppCoreGuidelines.md:7817
msgid "7817                /* the complex logic around getting a const reference to my_bar */"
msgstr""

# CppCoreGuidelines.md:7818
msgid "7818            }"
msgstr""

# CppCoreGuidelines.md:7819
msgid "7819        private:"
msgstr""

# CppCoreGuidelines.md:7820
msgid "7820            Bar my_bar;"
msgstr""

# CppCoreGuidelines.md:7821
msgid "7821        };"
msgstr""

       
# CppCoreGuidelines.md:7822
msgid "7822    Although this pattern is safe when applied correctly, because the caller must have had a non-`const` object to begin with, it's not ideal because the safety is hard to enforce automatically as a checker rule."
msgstr""

       
# CppCoreGuidelines.md:7823
msgid "7823    Instead, prefer to put the common code in a common helper function -- and make it a template so that it deduces `const`. This doesn't use any `const_cast` at all:"
msgstr""

       
# CppCoreGuidelines.md:7824
msgid "7824        class Foo {"
msgstr""

# CppCoreGuidelines.md:7825
msgid "7825        public:                         // good"
msgstr""

# CppCoreGuidelines.md:7826
msgid "7826                  Bar& get_bar()       { return get_bar_impl(*this); }"
msgstr""

# CppCoreGuidelines.md:7827
msgid "7827            const Bar& get_bar() const { return get_bar_impl(*this); }"
msgstr""

# CppCoreGuidelines.md:7828
msgid "7828        private:"
msgstr""

# CppCoreGuidelines.md:7829
msgid "7829            Bar my_bar;"
msgstr""

       
# CppCoreGuidelines.md:7830
msgid "7830            template<class T>           // good, deduces whether T is const or non-const"
msgstr""

# CppCoreGuidelines.md:7831
msgid "7831            static auto get_bar_impl(T& t) -> decltype(t.get_bar())"
msgstr""

# CppCoreGuidelines.md:7832
msgid "7832                { /* the complex logic around getting a possibly-const reference to my_bar */ }"
msgstr""

# CppCoreGuidelines.md:7833
msgid "7833        };"
msgstr""

       
# CppCoreGuidelines.md:7834
msgid "7834    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:7835
msgid "7835    You may need to cast away `const` when calling `const`-incorrect functions."
msgstr""

# CppCoreGuidelines.md:7836
msgid "7836    Prefer to wrap such functions in inline `const`-correct wrappers to encapsulate the cast in one place."
msgstr""

       
# CppCoreGuidelines.md:7837
msgid "7837    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7838
msgid "7838    Sometimes, \"cast away `const`\" is to allow the updating of some transient information of an otherwise immutable object."
msgstr""

# CppCoreGuidelines.md:7839
msgid "7839    Examples are caching, memoization, and precomputation."
msgstr""

# CppCoreGuidelines.md:7840
msgid "7840    Such examples are often handled as well or better using `mutable` or an indirection than with a `const_cast`."
msgstr""

       
# CppCoreGuidelines.md:7841
msgid "7841    Consider keeping previously computed results around for a costly operation:"
msgstr""

       
# CppCoreGuidelines.md:7842
msgid "7842        int compute(int x); // compute a value for x; assume this to be costly"
msgstr""

       
# CppCoreGuidelines.md:7843
msgid "7843        class Cache {   // some type implementing a cache for an int->int operation"
msgstr""

# CppCoreGuidelines.md:7844
msgid "7844        public:"
msgstr""

# CppCoreGuidelines.md:7845
msgid "7845            pair<bool, int> find(int x) const;   // is there a value for x?"
msgstr""

# CppCoreGuidelines.md:7846
msgid "7846            void set(int x, int v);             // make y the value for x"
msgstr""

# CppCoreGuidelines.md:7847
msgid "7847            // ..."
msgstr""

# CppCoreGuidelines.md:7848
msgid "7848        private:"
msgstr""

# CppCoreGuidelines.md:7849
msgid "7849            // ..."
msgstr""

# CppCoreGuidelines.md:7850
msgid "7850        };"
msgstr""

       
# CppCoreGuidelines.md:7851
msgid "7851        class X {"
msgstr""

# CppCoreGuidelines.md:7852
msgid "7852        public:"
msgstr""

# CppCoreGuidelines.md:7853
msgid "7853            int get_val(int x)"
msgstr""

# CppCoreGuidelines.md:7854
msgid "7854            {"
msgstr""

# CppCoreGuidelines.md:7855
msgid "7855                auto p = cache.find(x);"
msgstr""

# CppCoreGuidelines.md:7856
msgid "7856                if (p.first) return p.second;"
msgstr""

# CppCoreGuidelines.md:7857
msgid "7857                int val = compute(x);"
msgstr""

# CppCoreGuidelines.md:7858
msgid "7858                cache.set(x, val); // insert value for x"
msgstr""

# CppCoreGuidelines.md:7859
msgid "7859                return val;"
msgstr""

# CppCoreGuidelines.md:7860
msgid "7860            }"
msgstr""

# CppCoreGuidelines.md:7861
msgid "7861            // ..."
msgstr""

# CppCoreGuidelines.md:7862
msgid "7862        private:"
msgstr""

# CppCoreGuidelines.md:7863
msgid "7863            Cache cache;"
msgstr""

# CppCoreGuidelines.md:7864
msgid "7864        };"
msgstr""

       
# CppCoreGuidelines.md:7865
msgid "7865    Here, `get_val()` is logically constant, so we would like to make it a `const` member."
msgstr""

# CppCoreGuidelines.md:7866
msgid "7866    To do this we still need to mutate `cache`, so people sometimes resort to a `const_cast`:"
msgstr""

       
# CppCoreGuidelines.md:7867
msgid "7867        class X {   // Suspicious solution based on casting"
msgstr""

# CppCoreGuidelines.md:7868
msgid "7868        public:"
msgstr""

# CppCoreGuidelines.md:7869
msgid "7869            int get_val(int x) const"
msgstr""

# CppCoreGuidelines.md:7870
msgid "7870            {"
msgstr""

# CppCoreGuidelines.md:7871
msgid "7871                auto p = cache.find(x);"
msgstr""

# CppCoreGuidelines.md:7872
msgid "7872                if (p.first) return p.second;"
msgstr""

# CppCoreGuidelines.md:7873
msgid "7873                int val = compute(x);"
msgstr""

# CppCoreGuidelines.md:7874
msgid "7874                const_cast<Cache&>(cache).set(x, val);   // ugly"
msgstr""

# CppCoreGuidelines.md:7875
msgid "7875                return val;"
msgstr""

# CppCoreGuidelines.md:7876
msgid "7876            }"
msgstr""

# CppCoreGuidelines.md:7877
msgid "7877            // ..."
msgstr""

# CppCoreGuidelines.md:7878
msgid "7878        private:"
msgstr""

# CppCoreGuidelines.md:7879
msgid "7879            Cache cache;"
msgstr""

# CppCoreGuidelines.md:7880
msgid "7880        };"
msgstr""

       
# CppCoreGuidelines.md:7881
msgid "7881    Fortunately, there is a better solution:"
msgstr""

# CppCoreGuidelines.md:7882
msgid "7882    State that `cache` is mutable even for a `const` object:"
msgstr""

       
# CppCoreGuidelines.md:7883
msgid "7883        class X {   // better solution"
msgstr""

# CppCoreGuidelines.md:7884
msgid "7884        public:"
msgstr""

# CppCoreGuidelines.md:7885
msgid "7885            int get_val(int x) const"
msgstr""

# CppCoreGuidelines.md:7886
msgid "7886            {"
msgstr""

# CppCoreGuidelines.md:7887
msgid "7887                auto p = cache.find(x);"
msgstr""

# CppCoreGuidelines.md:7888
msgid "7888                if (p.first) return p.second;"
msgstr""

# CppCoreGuidelines.md:7889
msgid "7889                int val = compute(x);"
msgstr""

# CppCoreGuidelines.md:7890
msgid "7890                cache.set(x, val);"
msgstr""

# CppCoreGuidelines.md:7891
msgid "7891                return val;"
msgstr""

# CppCoreGuidelines.md:7892
msgid "7892            }"
msgstr""

# CppCoreGuidelines.md:7893
msgid "7893            // ..."
msgstr""

# CppCoreGuidelines.md:7894
msgid "7894        private:"
msgstr""

# CppCoreGuidelines.md:7895
msgid "7895            mutable Cache cache;"
msgstr""

# CppCoreGuidelines.md:7896
msgid "7896        };"
msgstr""

       
# CppCoreGuidelines.md:7897
msgid "7897    An alternative solution would to store a pointer to the `cache`:"
msgstr""

       
# CppCoreGuidelines.md:7898
msgid "7898        class X {   // OK, but slightly messier solution"
msgstr""

# CppCoreGuidelines.md:7899
msgid "7899        public:"
msgstr""

# CppCoreGuidelines.md:7900
msgid "7900            int get_val(int x) const"
msgstr""

# CppCoreGuidelines.md:7901
msgid "7901            {"
msgstr""

# CppCoreGuidelines.md:7902
msgid "7902                auto p = cache->find(x);"
msgstr""

# CppCoreGuidelines.md:7903
msgid "7903                if (p.first) return p.second;"
msgstr""

# CppCoreGuidelines.md:7904
msgid "7904                int val = compute(x);"
msgstr""

# CppCoreGuidelines.md:7905
msgid "7905                cache->set(x, val);"
msgstr""

# CppCoreGuidelines.md:7906
msgid "7906                return val;"
msgstr""

# CppCoreGuidelines.md:7907
msgid "7907            }"
msgstr""

# CppCoreGuidelines.md:7908
msgid "7908            // ..."
msgstr""

# CppCoreGuidelines.md:7909
msgid "7909        private:"
msgstr""

# CppCoreGuidelines.md:7910
msgid "7910            unique_ptr<Cache> cache;"
msgstr""

# CppCoreGuidelines.md:7911
msgid "7911        };"
msgstr""

       
# CppCoreGuidelines.md:7912
msgid "7912    That solution is the most flexible, but requires explicit construction and destruction of `*cache`"
msgstr""

# CppCoreGuidelines.md:7913
msgid "7913    (most likely in the constructor and destructor of `X`)."
msgstr""

       
# CppCoreGuidelines.md:7914
msgid "7914    In any variant, we must guard against data races on the `cache` in multi-threaded code, possibly using a `std::mutex`."
msgstr""

       
# CppCoreGuidelines.md:7915
msgid "7915    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7916
msgid "7916    * Flag `const_cast`s."
msgstr""

# CppCoreGuidelines.md:7917
msgid "7917    * This rule is part of the [type-safety profile](#Pro-type-constcast) for the related Profile."
msgstr""

       
# CppCoreGuidelines.md:7918
msgid "7918    ### <a name=\"Res-range-checking\"></a>ES.55: Avoid the need for range checking"
msgstr""

       
# CppCoreGuidelines.md:7919
msgid "7919    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7920
msgid "7920    Constructs that cannot overflow do not overflow (and usually run faster):"
msgstr""

       
# CppCoreGuidelines.md:7921
msgid "7921    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7922
msgid "7922        for (auto& x : v)      // print all elements of v"
msgstr""

# CppCoreGuidelines.md:7923
msgid "7923            cout << x << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:7924
msgid "7924        auto p = find(v, x);   // find x in v"
msgstr""

       
# CppCoreGuidelines.md:7925
msgid "7925    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7926
msgid "7926    Look for explicit range checks and heuristically suggest alternatives."
msgstr""

       
# CppCoreGuidelines.md:7927
msgid "7927    ### <a name=\"Res-move\"></a>ES.56: Write `std::move()` only when you need to explicitly move an object to another scope"
msgstr""

       
# CppCoreGuidelines.md:7928
msgid "7928    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:7929
msgid "7929    We move, rather than copy, to avoid duplication and for improved performance."
msgstr""

       
# CppCoreGuidelines.md:7930
msgid "7930    A move typically leaves behind an empty object ([C.64](#Rc-move-semantic)), which can be surprising or even dangerous, so we try to avoid moving from lvalues (they might be accessed later)."
msgstr""

       
# CppCoreGuidelines.md:7931
msgid "7931    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:7932
msgid "7932    Moving is done implicitly when the source is an rvalue (e.g., value in a `return` treatment or a function result), so don't pointlessly complicate code in those cases by writing `move` explicitly. Instead, write short functions that return values, and both the function's return and the caller's accepting of the return will be optimized naturally."
msgstr""

       
# CppCoreGuidelines.md:7933
msgid "7933    In general, following the guidelines in this document (including not making variables' scopes needlessly large, writing short functions that return values, returning local variables) help eliminate most need for explicit `std::move`."
msgstr""

       
# CppCoreGuidelines.md:7934
msgid "7934    Explicit `move` is needed to explicitly move an object to another scope, notably to pass it to a \"sink\" function and in the implementations of the move operations themselves (move constructor, move assignment operator) and swap operations."
msgstr""

       
# CppCoreGuidelines.md:7935
msgid "7935    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7936
msgid "7936        void sink(X&& x);   // sink takes ownership of x"
msgstr""

       
# CppCoreGuidelines.md:7937
msgid "7937        void user()"
msgstr""

# CppCoreGuidelines.md:7938
msgid "7938        {"
msgstr""

# CppCoreGuidelines.md:7939
msgid "7939            X x;"
msgstr""

# CppCoreGuidelines.md:7940
msgid "7940            // error: cannot bind an lvalue to a rvalue reference"
msgstr""

# CppCoreGuidelines.md:7941
msgid "7941            sink(x);"
msgstr""

# CppCoreGuidelines.md:7942
msgid "7942            // OK: sink takes the contents of x, x must now be assumed to be empty"
msgstr""

# CppCoreGuidelines.md:7943
msgid "7943            sink(std::move(x));"
msgstr""

       
# CppCoreGuidelines.md:7944
msgid "7944            // ..."
msgstr""

       
# CppCoreGuidelines.md:7945
msgid "7945            // probably a mistake"
msgstr""

# CppCoreGuidelines.md:7946
msgid "7946            use(x);"
msgstr""

# CppCoreGuidelines.md:7947
msgid "7947        }"
msgstr""

       
# CppCoreGuidelines.md:7948
msgid "7948    Usually, a `std::move()` is used as an argument to a `&&` parameter."
msgstr""

# CppCoreGuidelines.md:7949
msgid "7949    And after you do that, assume the object has been moved from (see [C.64](#Rc-move-semantic)) and don't read its state again until you first set it to a new value."
msgstr""

       
# CppCoreGuidelines.md:7950
msgid "7950        void f() {"
msgstr""

# CppCoreGuidelines.md:7951
msgid "7951            string s1 = \"supercalifragilisticexpialidocious\";"
msgstr""

       
# CppCoreGuidelines.md:7952
msgid "7952            string s2 = s1;             // ok, takes a copy"
msgstr""

# CppCoreGuidelines.md:7953
msgid "7953            assert(s1 == \"supercalifragilisticexpialidocious\");  // ok"
msgstr""

       
# CppCoreGuidelines.md:7954
msgid "7954            // bad, if you want to keep using s1's value"
msgstr""

# CppCoreGuidelines.md:7955
msgid "7955            string s3 = move(s1);"
msgstr""

       
# CppCoreGuidelines.md:7956
msgid "7956            // bad, assert will likely fail, s1 likely changed"
msgstr""

# CppCoreGuidelines.md:7957
msgid "7957            assert(s1 == \"supercalifragilisticexpialidocious\");"
msgstr""

# CppCoreGuidelines.md:7958
msgid "7958        }"
msgstr""

       
# CppCoreGuidelines.md:7959
msgid "7959    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7960
msgid "7960        void sink(unique_ptr<widget> p);  // pass ownership of p to sink()"
msgstr""

       
# CppCoreGuidelines.md:7961
msgid "7961        void f() {"
msgstr""

# CppCoreGuidelines.md:7962
msgid "7962            auto w = make_unique<widget>();"
msgstr""

# CppCoreGuidelines.md:7963
msgid "7963            // ..."
msgstr""

# CppCoreGuidelines.md:7964
msgid "7964            sink(std::move(w));               // ok, give to sink()"
msgstr""

# CppCoreGuidelines.md:7965
msgid "7965            // ..."
msgstr""

# CppCoreGuidelines.md:7966
msgid "7966            sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it"
msgstr""

# CppCoreGuidelines.md:7967
msgid "7967        }"
msgstr""

       
# CppCoreGuidelines.md:7968
msgid "7968    ##### Notes"
msgstr""

       
# CppCoreGuidelines.md:7969
msgid "7969    `std::move()` is a cast to `&&` in disguise; it doesn't itself move anything, but marks a named object as a candidate that can be moved from."
msgstr""

# CppCoreGuidelines.md:7970
msgid "7970    The language already knows the common cases where objects can be moved from, especially when returning values from functions, so don't complicate code with redundant `std::move()`'s."
msgstr""

       
# CppCoreGuidelines.md:7971
msgid "7971    Never write `std::move()` just because you've heard \"it's more efficient.\""
msgstr""

# CppCoreGuidelines.md:7972
msgid "7972    In general, don't believe claims of \"efficiency\" without data (???)."
msgstr""

# CppCoreGuidelines.md:7973
msgid "7973    In general, don't complicate your code without reason (??)"
msgstr""

       
# CppCoreGuidelines.md:7974
msgid "7974    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7975
msgid "7975        vector<int> make_vector() {"
msgstr""

# CppCoreGuidelines.md:7976
msgid "7976            vector<int> result;"
msgstr""

# CppCoreGuidelines.md:7977
msgid "7977            // ... load result with data"
msgstr""

# CppCoreGuidelines.md:7978
msgid "7978            return std::move(result);       // bad; just write \"return result;\""
msgstr""

# CppCoreGuidelines.md:7979
msgid "7979        }"
msgstr""

       
# CppCoreGuidelines.md:7980
msgid "7980    Never write `return move(local_variable);`, because the language already knows the variable is a move candidate."
msgstr""

# CppCoreGuidelines.md:7981
msgid "7981    Writing `move` in this code won't help, and can actually be detrimental because on some compilers it interferes with RVO (the return value optimization) by creating an additional reference alias to the local variable."
msgstr""

       
       
# CppCoreGuidelines.md:7982
msgid "7982    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:7983
msgid "7983        vector<int> v = std::move(make_vector());   // bad; the std::move is entirely redundant"
msgstr""

       
# CppCoreGuidelines.md:7984
msgid "7984    Never write `move` on a returned value such as `x = move(f());` where `f` returns by value."
msgstr""

# CppCoreGuidelines.md:7985
msgid "7985    The language already knows that a returned value is a temporary object that can be moved from."
msgstr""

       
# CppCoreGuidelines.md:7986
msgid "7986    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:7987
msgid "7987        void mover(X&& x) {"
msgstr""

# CppCoreGuidelines.md:7988
msgid "7988            call_something(std::move(x));         // ok"
msgstr""

# CppCoreGuidelines.md:7989
msgid "7989            call_something(std::forward<X>(x));   // bad, don't std::forward an rvalue reference"
msgstr""

# CppCoreGuidelines.md:7990
msgid "7990            call_something(x);                    // suspicious, why not std::move?"
msgstr""

# CppCoreGuidelines.md:7991
msgid "7991        }"
msgstr""

       
# CppCoreGuidelines.md:7992
msgid "7992        template<class T>"
msgstr""

# CppCoreGuidelines.md:7993
msgid "7993        void forwarder(T&& t) {"
msgstr""

# CppCoreGuidelines.md:7994
msgid "7994            call_something(std::move(t));         // bad, don't std::move a forwarding reference"
msgstr""

# CppCoreGuidelines.md:7995
msgid "7995            call_something(std::forward<T>(t));   // ok"
msgstr""

# CppCoreGuidelines.md:7996
msgid "7996            call_something(t);                    // suspicious, why not std::forward?"
msgstr""

# CppCoreGuidelines.md:7997
msgid "7997        }"
msgstr""

       
# CppCoreGuidelines.md:7998
msgid "7998    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:7999
msgid "7999    * Flag use of `std::move(x)` where `x` is an rvalue or the language will already treat it as an rvalue, including `return std::move(local_variable);` and `std::move(f())` on a function that returns by value."
msgstr""

# CppCoreGuidelines.md:8000
msgid "8000    * Flag functions taking an `S&&` parameter if there is no `const S&` overload to take care of lvalues."
msgstr""

# CppCoreGuidelines.md:8001
msgid "8001    * Flag a `std::move`s argument passed to a parameter, except when the parameter type is one of the following: an `X&&` rvalue reference; a `T&&` forwarding reference where `T` is a template parameter type; or by value and the type is move-only."
msgstr""

# CppCoreGuidelines.md:8002
msgid "8002    * Flag when `std::move` is applied to a forwarding reference (`T&&` where `T` is a template parameter type). Use `std::forward` instead."
msgstr""

# CppCoreGuidelines.md:8003
msgid "8003    * Flag when `std::move` is applied to other than an rvalue reference. (More general case of the previous rule to cover the non-forwarding cases.)"
msgstr""

# CppCoreGuidelines.md:8004
msgid "8004    * Flag when `std::forward` is applied to an rvalue reference (`X&&` where `X` is a concrete type). Use `std::move` instead."
msgstr""

# CppCoreGuidelines.md:8005
msgid "8005    * Flag when `std::forward` is applied to other than a forwarding reference. (More general case of the previous rule to cover the non-moving cases.)"
msgstr""

# CppCoreGuidelines.md:8006
msgid "8006    * Flag when an object is potentially moved from and the next operation is a `const` operation; there should first be an intervening non-`const` operation, ideally assignment, to first reset the object's value."
msgstr""

       
# CppCoreGuidelines.md:8007
msgid "8007    ### <a name=\"Res-new\"></a>ES.60: Avoid `new` and `delete` outside resource management functions"
msgstr""

       
# CppCoreGuidelines.md:8008
msgid "8008    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8009
msgid "8009    Direct resource management in application code is error-prone and tedious."
msgstr""

       
# CppCoreGuidelines.md:8010
msgid "8010    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8011
msgid "8011    also known as \"No naked `new`!\""
msgstr""

       
# CppCoreGuidelines.md:8012
msgid "8012    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8013
msgid "8013        void f(int n)"
msgstr""

# CppCoreGuidelines.md:8014
msgid "8014        {"
msgstr""

# CppCoreGuidelines.md:8015
msgid "8015            auto p = new X[n];   // n default constructed Xs"
msgstr""

# CppCoreGuidelines.md:8016
msgid "8016            // ..."
msgstr""

# CppCoreGuidelines.md:8017
msgid "8017            delete[] p;"
msgstr""

# CppCoreGuidelines.md:8018
msgid "8018        }"
msgstr""

       
# CppCoreGuidelines.md:8019
msgid "8019    There can be code in the `...` part that causes the `delete` never to happen."
msgstr""

       
# CppCoreGuidelines.md:8020
msgid "8020    **See also**: [R: Resource management](#S-resource)"
msgstr""

       
# CppCoreGuidelines.md:8021
msgid "8021    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8022
msgid "8022    Flag naked `new`s and naked `delete`s."
msgstr""

       
# CppCoreGuidelines.md:8023
msgid "8023    ### <a name=\"Res-del\"></a>ES.61: Delete arrays using `delete[]` and non-arrays using `delete`"
msgstr""

       
# CppCoreGuidelines.md:8024
msgid "8024    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8025
msgid "8025    That's what the language requires and mistakes can lead to resource release errors and/or memory corruption."
msgstr""

       
# CppCoreGuidelines.md:8026
msgid "8026    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8027
msgid "8027        void f(int n)"
msgstr""

# CppCoreGuidelines.md:8028
msgid "8028        {"
msgstr""

# CppCoreGuidelines.md:8029
msgid "8029            auto p = new X[n];   // n default constructed Xs"
msgstr""

# CppCoreGuidelines.md:8030
msgid "8030            // ..."
msgstr""

# CppCoreGuidelines.md:8031
msgid "8031            delete p;   // error: just delete the object p, rather than delete the array p[]"
msgstr""

# CppCoreGuidelines.md:8032
msgid "8032        }"
msgstr""

       
# CppCoreGuidelines.md:8033
msgid "8033    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8034
msgid "8034    This example not only violates the [no naked `new` rule](#Res-new) as in the previous example, it has many more problems."
msgstr""

       
# CppCoreGuidelines.md:8035
msgid "8035    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8036
msgid "8036    * if the `new` and the `delete` is in the same scope, mistakes can be flagged."
msgstr""

# CppCoreGuidelines.md:8037
msgid "8037    * if the `new` and the `delete` are in a constructor/destructor pair, mistakes can be flagged."
msgstr""

       
# CppCoreGuidelines.md:8038
msgid "8038    ### <a name=\"Res-arr2\"></a>ES.62: Don't compare pointers into different arrays"
msgstr""

       
# CppCoreGuidelines.md:8039
msgid "8039    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8040
msgid "8040    The result of doing so is undefined."
msgstr""

       
# CppCoreGuidelines.md:8041
msgid "8041    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8042
msgid "8042        void f(int n)"
msgstr""

# CppCoreGuidelines.md:8043
msgid "8043        {"
msgstr""

# CppCoreGuidelines.md:8044
msgid "8044            int a1[7];"
msgstr""

# CppCoreGuidelines.md:8045
msgid "8045            int a2[9];"
msgstr""

# CppCoreGuidelines.md:8046
msgid "8046            if (&a1[5] < &a2[7]) {}       // bad: undefined"
msgstr""

# CppCoreGuidelines.md:8047
msgid "8047            if (0 < &a1[5] - &a2[7]) {}   // bad: undefined"
msgstr""

# CppCoreGuidelines.md:8048
msgid "8048        }"
msgstr""

       
# CppCoreGuidelines.md:8049
msgid "8049    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8050
msgid "8050    This example has many more problems."
msgstr""

       
# CppCoreGuidelines.md:8051
msgid "8051    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8052
msgid "8052    ???"
msgstr""

       
# CppCoreGuidelines.md:8053
msgid "8053    ### <a name=\"Res-slice\"></a>ES.63: Don't slice"
msgstr""

       
# CppCoreGuidelines.md:8054
msgid "8054    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8055
msgid "8055    Slicing -- that is, copying only part of an object using assignment or initialization -- most often leads to errors because"
msgstr""

# CppCoreGuidelines.md:8056
msgid "8056    the object was meant to be considered as a whole."
msgstr""

# CppCoreGuidelines.md:8057
msgid "8057    In the rare cases where the slicing was deliberate the code can be surprising."
msgstr""

       
# CppCoreGuidelines.md:8058
msgid "8058    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8059
msgid "8059        class Shape { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:8060
msgid "8060        class Circle : public Shape { /* ... */ Point c; int r; };"
msgstr""

       
# CppCoreGuidelines.md:8061
msgid "8061        Circle c {{0, 0}, 42};"
msgstr""

# CppCoreGuidelines.md:8062
msgid "8062        Shape s {c};    // copy Shape part of Circle"
msgstr""

       
# CppCoreGuidelines.md:8063
msgid "8063    The result will be meaningless because the center and radius will not be copied from `c` into `s`."
msgstr""

# CppCoreGuidelines.md:8064
msgid "8064    The first defense against this is to [define the base class `Shape` not to allow this](#Rc-copy-virtual)."
msgstr""

       
# CppCoreGuidelines.md:8065
msgid "8065    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:8066
msgid "8066    If you mean to slice, define an explicit operation to do so."
msgstr""

# CppCoreGuidelines.md:8067
msgid "8067    This saves readers from confusion."
msgstr""

# CppCoreGuidelines.md:8068
msgid "8068    For example:"
msgstr""

       
# CppCoreGuidelines.md:8069
msgid "8069        class Smiley : public Circle {"
msgstr""

# CppCoreGuidelines.md:8070
msgid "8070            public:"
msgstr""

# CppCoreGuidelines.md:8071
msgid "8071            Circle copy_circle();"
msgstr""

# CppCoreGuidelines.md:8072
msgid "8072            // ..."
msgstr""

# CppCoreGuidelines.md:8073
msgid "8073        };"
msgstr""

       
# CppCoreGuidelines.md:8074
msgid "8074        Smiley sm { /* ... */ };"
msgstr""

# CppCoreGuidelines.md:8075
msgid "8075        Circle c1 {sm};  // ideally prevented by the definition of Circle"
msgstr""

# CppCoreGuidelines.md:8076
msgid "8076        Circle c2 {sm.copy_circle()};"
msgstr""

       
# CppCoreGuidelines.md:8077
msgid "8077    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8078
msgid "8078    Warn against slicing."
msgstr""

       
# CppCoreGuidelines.md:8079
msgid "8079    ### <a name=\"Res-construct\"></a>ES.64: Use the `T{e}`notation for construction"
msgstr""

       
# CppCoreGuidelines.md:8080
msgid "8080    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8081
msgid "8081    The `T{e}` construction syntax makes it explicit that construction is desired."
msgstr""

# CppCoreGuidelines.md:8082
msgid "8082    The `T{e}` construction syntax doesn't allow narrowing."
msgstr""

# CppCoreGuidelines.md:8083
msgid "8083    `T{e}` is the only safe and general expression for constructing a value of type `T` from an expression `e`."
msgstr""

# CppCoreGuidelines.md:8084
msgid "8084    The casts notations `T(e)` and `(T)e` are neither safe nor general."
msgstr""

       
# CppCoreGuidelines.md:8085
msgid "8085    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8086
msgid "8086    For built-in types, the construction notation protects against narrowing and reinterpretation"
msgstr""

       
# CppCoreGuidelines.md:8087
msgid "8087        void use(char ch, int i, double d, char* p, long long lng)"
msgstr""

# CppCoreGuidelines.md:8088
msgid "8088        {"
msgstr""

# CppCoreGuidelines.md:8089
msgid "8089            int x1 = int{ch};     // OK, but redundant"
msgstr""

# CppCoreGuidelines.md:8090
msgid "8090            int x2 = int{d};      // error: double->int narrowing; use a cast if you need to"
msgstr""

# CppCoreGuidelines.md:8091
msgid "8091            int x3 = int{p};      // error: pointer to->int; use a reinterpret_cast if you really need to"
msgstr""

# CppCoreGuidelines.md:8092
msgid "8092            int x4 = int{lng};    // error: long long->int narrowing; use a cast if you need to"
msgstr""

       
# CppCoreGuidelines.md:8093
msgid "8093            int y1 = int(ch);     // OK, but redundant"
msgstr""

# CppCoreGuidelines.md:8094
msgid "8094            int y2 = int(d);      // bad: double->int narrowing; use a cast if you need to"
msgstr""

# CppCoreGuidelines.md:8095
msgid "8095            int y3 = int(p);      // bad: pointer to->int; use a reinterpret_cast if you really need to"
msgstr""

# CppCoreGuidelines.md:8096
msgid "8096            int y4 = int(lng);    // bad: long long->int narrowing; use a cast if you need to"
msgstr""

       
# CppCoreGuidelines.md:8097
msgid "8097            int z1 = (int)ch;     // OK, but redundant"
msgstr""

# CppCoreGuidelines.md:8098
msgid "8098            int z2 = (int)d;      // bad: double->int narrowing; use a cast if you need to"
msgstr""

# CppCoreGuidelines.md:8099
msgid "8099            int z3 = (int)p;      // bad: pointer to->int; use a reinterpret_cast if you really need to"
msgstr""

# CppCoreGuidelines.md:8100
msgid "8100            int z4 = (int)lng;    // bad: long long->int narrowing; use a cast if you need to"
msgstr""

# CppCoreGuidelines.md:8101
msgid "8101        }"
msgstr""

       
# CppCoreGuidelines.md:8102
msgid "8102    The integer to/from pointer conversions are implementation defined when using the `T(e)` or `(T)e` notations, and non-portable"
msgstr""

# CppCoreGuidelines.md:8103
msgid "8103    between platforms with different integer and pointer sizes."
msgstr""

       
# CppCoreGuidelines.md:8104
msgid "8104    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8105
msgid "8105    [Avoid casts](#Res-casts) (explicit type conversion) and if you must [prefer named casts](#Res-casts-named)."
msgstr""

       
# CppCoreGuidelines.md:8106
msgid "8106    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8107
msgid "8107    When unambiguous, the `T` can be left out of `T{e}`."
msgstr""

       
# CppCoreGuidelines.md:8108
msgid "8108        complex<double> f(complex<double>);"
msgstr""

       
# CppCoreGuidelines.md:8109
msgid "8109        auto z = f({2*pi, 1});"
msgstr""

       
# CppCoreGuidelines.md:8110
msgid "8110    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8111
msgid "8111    The construction notation is the most general [initializer notation](#Res-list)."
msgstr""

       
# CppCoreGuidelines.md:8112
msgid "8112    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:8113
msgid "8113    `std::vector` and other containers were defined before we had `{}` as a notation for construction."
msgstr""

# CppCoreGuidelines.md:8114
msgid "8114    Consider:"
msgstr""

       
# CppCoreGuidelines.md:8115
msgid "8115        vector<string> vs {10};                           // ten empty strings"
msgstr""

# CppCoreGuidelines.md:8116
msgid "8116        vector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten elements 1..10"
msgstr""

# CppCoreGuidelines.md:8117
msgid "8117        vector<int> vi2 {10};                             // one element with the value 10"
msgstr""

       
# CppCoreGuidelines.md:8118
msgid "8118    How do we get a `vector` of 10 default initialized `int`s?"
msgstr""

       
# CppCoreGuidelines.md:8119
msgid "8119        vector<int> v3(10); // ten elements with value 0"
msgstr""

       
# CppCoreGuidelines.md:8120
msgid "8120    The use of `()` rather than `{}` for number of elements is conventional (going back to the early 1980s), hard to change, but still"
msgstr""

# CppCoreGuidelines.md:8121
msgid "8121    a design error: for a container where the element type can be confused with the number of elements, we have an ambiguity that"
msgstr""

# CppCoreGuidelines.md:8122
msgid "8122    must be resolved."
msgstr""

# CppCoreGuidelines.md:8123
msgid "8123    The conventional resolution is to interpret `{10}` as a list of one element and use `(10)` to distinguish a size."
msgstr""

       
# CppCoreGuidelines.md:8124
msgid "8124    This mistake need not be repeated in new code."
msgstr""

# CppCoreGuidelines.md:8125
msgid "8125    We can define a type to represent the number of elements:"
msgstr""

       
# CppCoreGuidelines.md:8126
msgid "8126        struct Count { int n; };"
msgstr""

       
# CppCoreGuidelines.md:8127
msgid "8127        template<typename T>"
msgstr""

# CppCoreGuidelines.md:8128
msgid "8128        class Vector {"
msgstr""

# CppCoreGuidelines.md:8129
msgid "8129        public:"
msgstr""

# CppCoreGuidelines.md:8130
msgid "8130            Vector(Count n);                     // n default-initialized elements"
msgstr""

# CppCoreGuidelines.md:8131
msgid "8131            Vector(initializer_list<T> init);    // init.size() elements"
msgstr""

# CppCoreGuidelines.md:8132
msgid "8132            // ..."
msgstr""

# CppCoreGuidelines.md:8133
msgid "8133        };"
msgstr""

       
# CppCoreGuidelines.md:8134
msgid "8134        Vector<int> v1{10};"
msgstr""

# CppCoreGuidelines.md:8135
msgid "8135        Vector<int> v2{Count{10}};"
msgstr""

# CppCoreGuidelines.md:8136
msgid "8136        Vector<Count> v3{Count{10}};    // yes, there is still a very minor problem"
msgstr""

       
# CppCoreGuidelines.md:8137
msgid "8137    The main problem left is to find a suitable name for `Count`."
msgstr""

       
# CppCoreGuidelines.md:8138
msgid "8138    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8139
msgid "8139    Flag the C-style `(T)e` and functional-style `T(e)` casts."
msgstr""

       
       
# CppCoreGuidelines.md:8140
msgid "8140    ### <a name=\"Res-deref\"></a>ES.65: Don't dereference an invalid pointer"
msgstr""

       
# CppCoreGuidelines.md:8141
msgid "8141    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8142
msgid "8142    Dereferencing an invalid pointer, such as `nullptr`, is undefined behavior, typically leading to immediate crashes,"
msgstr""

# CppCoreGuidelines.md:8143
msgid "8143    wrong results, or memory corruption."
msgstr""

       
# CppCoreGuidelines.md:8144
msgid "8144    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8145
msgid "8145    This rule is an obvious and well-known language rule, but can be hard to follow."
msgstr""

# CppCoreGuidelines.md:8146
msgid "8146    It takes good coding style, library support, and static analysis to eliminate violations without major overhead."
msgstr""

# CppCoreGuidelines.md:8147
msgid "8147    This is a major part of the discussion of [C++'s resource- and type-safety model](#Stroustrup15)."
msgstr""

       
# CppCoreGuidelines.md:8148
msgid "8148    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:8149
msgid "8149    * Use [RAII](#Rr-raii) to avoid lifetime problems."
msgstr""

# CppCoreGuidelines.md:8150
msgid "8150    * Use [unique_ptr](#Rf-unique_ptr) to avoid lifetime problems."
msgstr""

# CppCoreGuidelines.md:8151
msgid "8151    * Use [shared_ptr](#Rf-shared_ptr) to avoid lifetime problems."
msgstr""

# CppCoreGuidelines.md:8152
msgid "8152    * Use [references](#Rf-ptr-ref) when `nullptr` isn't a possibility."
msgstr""

# CppCoreGuidelines.md:8153
msgid "8153    * Use [not_null](#Rf-not_null) to catch unexpected `nullptr` early."
msgstr""

# CppCoreGuidelines.md:8154
msgid "8154    * Use the [bounds profile](#SS-bounds) to avoid range errors."
msgstr""

       
       
# CppCoreGuidelines.md:8155
msgid "8155    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8156
msgid "8156        void f()"
msgstr""

# CppCoreGuidelines.md:8157
msgid "8157        {"
msgstr""

# CppCoreGuidelines.md:8158
msgid "8158            int x = 0;"
msgstr""

# CppCoreGuidelines.md:8159
msgid "8159            int* p = &x;"
msgstr""

       
# CppCoreGuidelines.md:8160
msgid "8160            if (condition()) {"
msgstr""

# CppCoreGuidelines.md:8161
msgid "8161                int y = 0;"
msgstr""

# CppCoreGuidelines.md:8162
msgid "8162                p = &y;"
msgstr""

# CppCoreGuidelines.md:8163
msgid "8163            } // invalidates p"
msgstr""

       
# CppCoreGuidelines.md:8164
msgid "8164            *p = 42;            // BAD, p might be invalid if the branch was taken"
msgstr""

# CppCoreGuidelines.md:8165
msgid "8165        }"
msgstr""

       
# CppCoreGuidelines.md:8166
msgid "8166    To resolve the problem, either extend the lifetime of the object the pointer is intended to refer to, or shorten the lifetime of the pointer (move the dereference to before the pointed-to object's lifetime ends)."
msgstr""

       
# CppCoreGuidelines.md:8167
msgid "8167        void f1()"
msgstr""

# CppCoreGuidelines.md:8168
msgid "8168        {"
msgstr""

# CppCoreGuidelines.md:8169
msgid "8169            int x = 0;"
msgstr""

# CppCoreGuidelines.md:8170
msgid "8170            int* p = &x;"
msgstr""

       
# CppCoreGuidelines.md:8171
msgid "8171            int y = 0;"
msgstr""

# CppCoreGuidelines.md:8172
msgid "8172            if (condition()) {"
msgstr""

# CppCoreGuidelines.md:8173
msgid "8173                p = &y;"
msgstr""

# CppCoreGuidelines.md:8174
msgid "8174            }"
msgstr""

       
# CppCoreGuidelines.md:8175
msgid "8175            *p = 42;            // OK, p points to x or y and both are still in scope"
msgstr""

# CppCoreGuidelines.md:8176
msgid "8176        }"
msgstr""

       
# CppCoreGuidelines.md:8177
msgid "8177    Unfortunately, most invalid pointer problems are harder to spot and harder to fix."
msgstr""

       
# CppCoreGuidelines.md:8178
msgid "8178    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8179
msgid "8179        void f(int* p)"
msgstr""

# CppCoreGuidelines.md:8180
msgid "8180        {"
msgstr""

# CppCoreGuidelines.md:8181
msgid "8181            int x = *p; // BAD: how do we know that p is valid?"
msgstr""

# CppCoreGuidelines.md:8182
msgid "8182        }"
msgstr""

       
# CppCoreGuidelines.md:8183
msgid "8183    There is a huge amount of such code."
msgstr""

# CppCoreGuidelines.md:8184
msgid "8184    Most works -- after lots of testing -- but in isolation it is impossible to tell whether `p` could be the `nullptr`."
msgstr""

# CppCoreGuidelines.md:8185
msgid "8185    Consequently, this is also a major source of errors."
msgstr""

# CppCoreGuidelines.md:8186
msgid "8186    There are many approaches to dealing with this potential problem:"
msgstr""

       
# CppCoreGuidelines.md:8187
msgid "8187        void f1(int* p) // deal with nullptr"
msgstr""

# CppCoreGuidelines.md:8188
msgid "8188        {"
msgstr""

# CppCoreGuidelines.md:8189
msgid "8189            if (!p) {"
msgstr""

# CppCoreGuidelines.md:8190
msgid "8190                // deal with nullptr (allocate, return, throw, make p point to something, whatever"
msgstr""

# CppCoreGuidelines.md:8191
msgid "8191            }"
msgstr""

# CppCoreGuidelines.md:8192
msgid "8192            int x = *p;"
msgstr""

# CppCoreGuidelines.md:8193
msgid "8193        }"
msgstr""

       
# CppCoreGuidelines.md:8194
msgid "8194    There are two potential problems with testing for `nullptr`:"
msgstr""

       
# CppCoreGuidelines.md:8195
msgid "8195    * it is not always obvious what to do what to do if we find `nullptr`"
msgstr""

# CppCoreGuidelines.md:8196
msgid "8196    * the test can be redundant and/or relatively expensive"
msgstr""

# CppCoreGuidelines.md:8197
msgid "8197    * it is not obvious if the test is to protect against a violation or part of the required logic."
msgstr""

       
       
# CppCoreGuidelines.md:8198
msgid "8198        void f2(int* p) // state that p is not supposed to be nullptr"
msgstr""

# CppCoreGuidelines.md:8199
msgid "8199        {"
msgstr""

# CppCoreGuidelines.md:8200
msgid "8200            assert(p);"
msgstr""

# CppCoreGuidelines.md:8201
msgid "8201            int x = *p;"
msgstr""

# CppCoreGuidelines.md:8202
msgid "8202        }"
msgstr""

       
# CppCoreGuidelines.md:8203
msgid "8203    This would carry a cost only when the assertion checking was enabled and would give a compiler/analyzer useful information."
msgstr""

# CppCoreGuidelines.md:8204
msgid "8204    This would work even better if/when C++ gets direct support for contracts:"
msgstr""

       
# CppCoreGuidelines.md:8205
msgid "8205        void f3(int* p) // state that p is not supposed to be nullptr"
msgstr""

# CppCoreGuidelines.md:8206
msgid "8206            [[expects: p]]"
msgstr""

# CppCoreGuidelines.md:8207
msgid "8207        {"
msgstr""

# CppCoreGuidelines.md:8208
msgid "8208            int x = *p;"
msgstr""

# CppCoreGuidelines.md:8209
msgid "8209        }"
msgstr""

       
# CppCoreGuidelines.md:8210
msgid "8210    Alternatively, we could use `gsl::not_null` to ensure that `p` is not the `nullptr`."
msgstr""

       
# CppCoreGuidelines.md:8211
msgid "8211        void f(not_null<int*> p)"
msgstr""

# CppCoreGuidelines.md:8212
msgid "8212        {"
msgstr""

# CppCoreGuidelines.md:8213
msgid "8213            int x = *p;"
msgstr""

# CppCoreGuidelines.md:8214
msgid "8214        }"
msgstr""

       
# CppCoreGuidelines.md:8215
msgid "8215    These remedies take care of `nullptr` only."
msgstr""

# CppCoreGuidelines.md:8216
msgid "8216    Remember that there are other ways of getting an invalid pointer."
msgstr""

       
# CppCoreGuidelines.md:8217
msgid "8217    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8218
msgid "8218        void f(int* p)  // old code, doesn't use owner"
msgstr""

# CppCoreGuidelines.md:8219
msgid "8219        {"
msgstr""

# CppCoreGuidelines.md:8220
msgid "8220            delete p;"
msgstr""

# CppCoreGuidelines.md:8221
msgid "8221        }"
msgstr""

       
# CppCoreGuidelines.md:8222
msgid "8222        void g()        // old code: uses naked new"
msgstr""

# CppCoreGuidelines.md:8223
msgid "8223        {"
msgstr""

# CppCoreGuidelines.md:8224
msgid "8224            auto q = new int{7};"
msgstr""

# CppCoreGuidelines.md:8225
msgid "8225            f(q);"
msgstr""

# CppCoreGuidelines.md:8226
msgid "8226            int x = *q; // BAD: dereferences invalid pointer"
msgstr""

# CppCoreGuidelines.md:8227
msgid "8227        }"
msgstr""

       
# CppCoreGuidelines.md:8228
msgid "8228    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8229
msgid "8229        void f()"
msgstr""

# CppCoreGuidelines.md:8230
msgid "8230        {"
msgstr""

# CppCoreGuidelines.md:8231
msgid "8231            vector<int> v(10);"
msgstr""

# CppCoreGuidelines.md:8232
msgid "8232            int* p = &v[5];"
msgstr""

# CppCoreGuidelines.md:8233
msgid "8233            v.push_back(99); // could reallocate v's elements"
msgstr""

# CppCoreGuidelines.md:8234
msgid "8234            int x = *p; // BAD: dereferences potentially invalid pointer"
msgstr""

# CppCoreGuidelines.md:8235
msgid "8235        }"
msgstr""

       
# CppCoreGuidelines.md:8236
msgid "8236    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8237
msgid "8237    This rule is part of the [lifetime safety profile](#SS-lifetime)"
msgstr""

       
# CppCoreGuidelines.md:8238
msgid "8238    * Flag a dereference of a pointer that points to an object that has gone out of scope"
msgstr""

# CppCoreGuidelines.md:8239
msgid "8239    * Flag a dereference of a pointer that may have been invalidated by assigning a `nullptr`"
msgstr""

# CppCoreGuidelines.md:8240
msgid "8240    * Flag a dereference of a pointer that may have been invalidated by a `delete`"
msgstr""

# CppCoreGuidelines.md:8241
msgid "8241    * Flag a dereference to a pointer to a container element that may have been invalidated by dereference"
msgstr""

       
       
# CppCoreGuidelines.md:8242
msgid "8242    ## ES.stmt: Statements"
msgstr""

       
# CppCoreGuidelines.md:8243
msgid "8243    Statements control the flow of control (except for function calls and exception throws, which are expressions)."
msgstr""

       
# CppCoreGuidelines.md:8244
msgid "8244    ### <a name=\"Res-switch-if\"></a>ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice"
msgstr""

       
# CppCoreGuidelines.md:8245
msgid "8245    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8246
msgid "8246    * Readability."
msgstr""

# CppCoreGuidelines.md:8247
msgid "8247    * Efficiency: A `switch` compares against constants and is usually better optimized than a series of tests in an `if`-`then`-`else` chain."
msgstr""

# CppCoreGuidelines.md:8248
msgid "8248    * A `switch` enables some heuristic consistency checking. For example, have all values of an `enum` been covered? If not, is there a `default`?"
msgstr""

       
# CppCoreGuidelines.md:8249
msgid "8249    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8250
msgid "8250        void use(int n)"
msgstr""

# CppCoreGuidelines.md:8251
msgid "8251        {"
msgstr""

# CppCoreGuidelines.md:8252
msgid "8252            switch (n) {   // good"
msgstr""

# CppCoreGuidelines.md:8253
msgid "8253            case 0:"
msgstr""

# CppCoreGuidelines.md:8254
msgid "8254                // ..."
msgstr""

# CppCoreGuidelines.md:8255
msgid "8255                break;"
msgstr""

# CppCoreGuidelines.md:8256
msgid "8256            case 7:"
msgstr""

# CppCoreGuidelines.md:8257
msgid "8257                // ..."
msgstr""

# CppCoreGuidelines.md:8258
msgid "8258                break;"
msgstr""

# CppCoreGuidelines.md:8259
msgid "8259            default:"
msgstr""

# CppCoreGuidelines.md:8260
msgid "8260                // ..."
msgstr""

# CppCoreGuidelines.md:8261
msgid "8261                break;"
msgstr""

# CppCoreGuidelines.md:8262
msgid "8262            }"
msgstr""

# CppCoreGuidelines.md:8263
msgid "8263        }"
msgstr""

       
# CppCoreGuidelines.md:8264
msgid "8264    rather than:"
msgstr""

       
# CppCoreGuidelines.md:8265
msgid "8265        void use2(int n)"
msgstr""

# CppCoreGuidelines.md:8266
msgid "8266        {"
msgstr""

# CppCoreGuidelines.md:8267
msgid "8267            if (n == 0)   // bad: if-then-else chain comparing against a set of constants"
msgstr""

# CppCoreGuidelines.md:8268
msgid "8268                // ..."
msgstr""

# CppCoreGuidelines.md:8269
msgid "8269            else if (n == 7)"
msgstr""

# CppCoreGuidelines.md:8270
msgid "8270                // ..."
msgstr""

# CppCoreGuidelines.md:8271
msgid "8271        }"
msgstr""

       
# CppCoreGuidelines.md:8272
msgid "8272    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8273
msgid "8273    Flag `if`-`then`-`else` chains that check against constants (only)."
msgstr""

       
# CppCoreGuidelines.md:8274
msgid "8274    ### <a name=\"Res-for-range\"></a>ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a choice"
msgstr""

       
# CppCoreGuidelines.md:8275
msgid "8275    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8276
msgid "8276    Readability. Error prevention. Efficiency."
msgstr""

       
# CppCoreGuidelines.md:8277
msgid "8277    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8278
msgid "8278        for (gsl::index i = 0; i < v.size(); ++i)   // bad"
msgstr""

# CppCoreGuidelines.md:8279
msgid "8279                cout << v[i] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8280
msgid "8280        for (auto p = v.begin(); p != v.end(); ++p)   // bad"
msgstr""

# CppCoreGuidelines.md:8281
msgid "8281            cout << *p << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8282
msgid "8282        for (auto& x : v)    // OK"
msgstr""

# CppCoreGuidelines.md:8283
msgid "8283            cout << x << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8284
msgid "8284        for (gsl::index i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for"
msgstr""

# CppCoreGuidelines.md:8285
msgid "8285            cout << v[i] + v[i - 1] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8286
msgid "8286        for (gsl::index i = 0; i < v.size(); ++i) // possible side effect: can't be a range-for"
msgstr""

# CppCoreGuidelines.md:8287
msgid "8287            cout << f(v, &v[i]) << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8288
msgid "8288        for (gsl::index i = 0; i < v.size(); ++i) { // body messes with loop variable: can't be a range-for"
msgstr""

# CppCoreGuidelines.md:8289
msgid "8289            if (i % 2 == 0)"
msgstr""

# CppCoreGuidelines.md:8290
msgid "8290                continue;   // skip even elements"
msgstr""

# CppCoreGuidelines.md:8291
msgid "8291            else"
msgstr""

# CppCoreGuidelines.md:8292
msgid "8292                cout << v[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8293
msgid "8293        }"
msgstr""

       
# CppCoreGuidelines.md:8294
msgid "8294    A human or a good static analyzer may determine that there really isn't a side effect on `v` in `f(v, &v[i])` so that the loop can be rewritten."
msgstr""

       
# CppCoreGuidelines.md:8295
msgid "8295    \"Messing with the loop variable\" in the body of a loop is typically best avoided."
msgstr""

       
# CppCoreGuidelines.md:8296
msgid "8296    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8297
msgid "8297    Don't use expensive copies of the loop variable of a range-`for` loop:"
msgstr""

       
# CppCoreGuidelines.md:8298
msgid "8298        for (string s : vs) // ..."
msgstr""

       
# CppCoreGuidelines.md:8299
msgid "8299    This will copy each elements of `vs` into `s`. Better:"
msgstr""

       
# CppCoreGuidelines.md:8300
msgid "8300        for (string& s : vs) // ..."
msgstr""

       
# CppCoreGuidelines.md:8301
msgid "8301    Better still, if the loop variable isn't modified or copied:"
msgstr""

       
# CppCoreGuidelines.md:8302
msgid "8302        for (const string& s : vs) // ..."
msgstr""

       
# CppCoreGuidelines.md:8303
msgid "8303    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8304
msgid "8304    Look at loops, if a traditional loop just looks at each element of a sequence, and there are no side effects on what it does with the elements, rewrite the loop to a ranged-`for` loop."
msgstr""

       
# CppCoreGuidelines.md:8305
msgid "8305    ### <a name=\"Res-for-while\"></a>ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious loop variable"
msgstr""

       
# CppCoreGuidelines.md:8306
msgid "8306    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8307
msgid "8307    Readability: the complete logic of the loop is visible \"up front\". The scope of the loop variable can be limited."
msgstr""

       
# CppCoreGuidelines.md:8308
msgid "8308    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8309
msgid "8309        for (gsl::index i = 0; i < vec.size(); i++) {"
msgstr""

# CppCoreGuidelines.md:8310
msgid "8310            // do work"
msgstr""

# CppCoreGuidelines.md:8311
msgid "8311        }"
msgstr""

       
# CppCoreGuidelines.md:8312
msgid "8312    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8313
msgid "8313        int i = 0;"
msgstr""

# CppCoreGuidelines.md:8314
msgid "8314        while (i < vec.size()) {"
msgstr""

# CppCoreGuidelines.md:8315
msgid "8315            // do work"
msgstr""

# CppCoreGuidelines.md:8316
msgid "8316            i++;"
msgstr""

# CppCoreGuidelines.md:8317
msgid "8317        }"
msgstr""

       
# CppCoreGuidelines.md:8318
msgid "8318    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8319
msgid "8319    ???"
msgstr""

       
# CppCoreGuidelines.md:8320
msgid "8320    ### <a name=\"Res-while-for\"></a>ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious loop variable"
msgstr""

       
# CppCoreGuidelines.md:8321
msgid "8321    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8322
msgid "8322    Readability."
msgstr""

       
# CppCoreGuidelines.md:8323
msgid "8323    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8324
msgid "8324        int events = 0;"
msgstr""

# CppCoreGuidelines.md:8325
msgid "8325        for (; wait_for_event(); ++events) {  // bad, confusing"
msgstr""

# CppCoreGuidelines.md:8326
msgid "8326            // ..."
msgstr""

# CppCoreGuidelines.md:8327
msgid "8327        }"
msgstr""

       
# CppCoreGuidelines.md:8328
msgid "8328    The \"event loop\" is misleading because the `events` counter has nothing to do with the loop condition (`wait_for_event()`)."
msgstr""

# CppCoreGuidelines.md:8329
msgid "8329    Better"
msgstr""

       
# CppCoreGuidelines.md:8330
msgid "8330        int events = 0;"
msgstr""

# CppCoreGuidelines.md:8331
msgid "8331        while (wait_for_event()) {      // better"
msgstr""

# CppCoreGuidelines.md:8332
msgid "8332            ++events;"
msgstr""

# CppCoreGuidelines.md:8333
msgid "8333            // ..."
msgstr""

# CppCoreGuidelines.md:8334
msgid "8334        }"
msgstr""

       
# CppCoreGuidelines.md:8335
msgid "8335    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8336
msgid "8336    Flag actions in `for`-initializers and `for`-increments that do not relate to the `for`-condition."
msgstr""

       
# CppCoreGuidelines.md:8337
msgid "8337    ### <a name=\"Res-for-init\"></a>ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement"
msgstr""

       
# CppCoreGuidelines.md:8338
msgid "8338    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8339
msgid "8339    Limit the loop variable visibility to the scope of the loop."
msgstr""

# CppCoreGuidelines.md:8340
msgid "8340    Avoid using the loop variable for other purposes after the loop."
msgstr""

       
# CppCoreGuidelines.md:8341
msgid "8341    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8342
msgid "8342        for (int i = 0; i < 100; ++i) {   // GOOD: i var is visible only inside the loop"
msgstr""

# CppCoreGuidelines.md:8343
msgid "8343            // ..."
msgstr""

# CppCoreGuidelines.md:8344
msgid "8344        }"
msgstr""

       
# CppCoreGuidelines.md:8345
msgid "8345    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:8346
msgid "8346        int j;                            // BAD: j is visible outside the loop"
msgstr""

# CppCoreGuidelines.md:8347
msgid "8347        for (j = 0; j < 100; ++j) {"
msgstr""

# CppCoreGuidelines.md:8348
msgid "8348            // ..."
msgstr""

# CppCoreGuidelines.md:8349
msgid "8349        }"
msgstr""

# CppCoreGuidelines.md:8350
msgid "8350        // j is still visible here and isn't needed"
msgstr""

       
# CppCoreGuidelines.md:8351
msgid "8351    **See also**: [Don't use a variable for two unrelated purposes](#Res-recycle)"
msgstr""

       
# CppCoreGuidelines.md:8352
msgid "8352    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8353
msgid "8353        for (string s; cin >> s; ) {"
msgstr""

# CppCoreGuidelines.md:8354
msgid "8354            cout << s << '\\n';"
msgstr""

# CppCoreGuidelines.md:8355
msgid "8355        }"
msgstr""

       
# CppCoreGuidelines.md:8356
msgid "8356    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8357
msgid "8357    Warn when a variable modified inside the `for`-statement is declared outside the loop and not being used outside the loop."
msgstr""

       
# CppCoreGuidelines.md:8358
msgid "8358    **Discussion**: Scoping the loop variable to the loop body also helps code optimizers greatly. Recognizing that the induction variable"
msgstr""

# CppCoreGuidelines.md:8359
msgid "8359    is only accessible in the loop body unblocks optimizations such as hoisting, strength reduction, loop-invariant code motion, etc."
msgstr""

       
# CppCoreGuidelines.md:8360
msgid "8360    ### <a name=\"Res-do\"></a>ES.75: Avoid `do`-statements"
msgstr""

       
# CppCoreGuidelines.md:8361
msgid "8361    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8362
msgid "8362    Readability, avoidance of errors."
msgstr""

# CppCoreGuidelines.md:8363
msgid "8363    The termination condition is at the end (where it can be overlooked) and the condition is not checked the first time through."
msgstr""

       
# CppCoreGuidelines.md:8364
msgid "8364    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8365
msgid "8365        int x;"
msgstr""

# CppCoreGuidelines.md:8366
msgid "8366        do {"
msgstr""

# CppCoreGuidelines.md:8367
msgid "8367            cin >> x;"
msgstr""

# CppCoreGuidelines.md:8368
msgid "8368            // ..."
msgstr""

# CppCoreGuidelines.md:8369
msgid "8369        } while (x < 0);"
msgstr""

       
# CppCoreGuidelines.md:8370
msgid "8370    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8371
msgid "8371    Yes, there are genuine examples where a `do`-statement is a clear statement of a solution, but also many bugs."
msgstr""

       
# CppCoreGuidelines.md:8372
msgid "8372    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8373
msgid "8373    Flag `do`-statements."
msgstr""

       
# CppCoreGuidelines.md:8374
msgid "8374    ### <a name=\"Res-goto\"></a>ES.76: Avoid `goto`"
msgstr""

       
# CppCoreGuidelines.md:8375
msgid "8375    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8376
msgid "8376    Readability, avoidance of errors. There are better control structures for humans; `goto` is for machine generated code."
msgstr""

       
# CppCoreGuidelines.md:8377
msgid "8377    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:8378
msgid "8378    Breaking out of a nested loop."
msgstr""

# CppCoreGuidelines.md:8379
msgid "8379    In that case, always jump forwards."
msgstr""

       
# CppCoreGuidelines.md:8380
msgid "8380        for (int i = 0; i < imax; ++i)"
msgstr""

# CppCoreGuidelines.md:8381
msgid "8381            for (int j = 0; j < jmax; ++j) {"
msgstr""

# CppCoreGuidelines.md:8382
msgid "8382                if (a[i][j] > elem_max) goto finished;"
msgstr""

# CppCoreGuidelines.md:8383
msgid "8383                // ..."
msgstr""

# CppCoreGuidelines.md:8384
msgid "8384            }"
msgstr""

# CppCoreGuidelines.md:8385
msgid "8385        finished:"
msgstr""

# CppCoreGuidelines.md:8386
msgid "8386        // ..."
msgstr""

       
# CppCoreGuidelines.md:8387
msgid "8387    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8388
msgid "8388    There is a fair amount of use of the C goto-exit idiom:"
msgstr""

       
# CppCoreGuidelines.md:8389
msgid "8389        void f()"
msgstr""

# CppCoreGuidelines.md:8390
msgid "8390        {"
msgstr""

# CppCoreGuidelines.md:8391
msgid "8391            // ..."
msgstr""

# CppCoreGuidelines.md:8392
msgid "8392                goto exit;"
msgstr""

# CppCoreGuidelines.md:8393
msgid "8393            // ..."
msgstr""

# CppCoreGuidelines.md:8394
msgid "8394                goto exit;"
msgstr""

# CppCoreGuidelines.md:8395
msgid "8395            // ..."
msgstr""

# CppCoreGuidelines.md:8396
msgid "8396        exit:"
msgstr""

# CppCoreGuidelines.md:8397
msgid "8397            // ... common cleanup code ..."
msgstr""

# CppCoreGuidelines.md:8398
msgid "8398        }"
msgstr""

       
# CppCoreGuidelines.md:8399
msgid "8399    This is an ad-hoc simulation of destructors."
msgstr""

# CppCoreGuidelines.md:8400
msgid "8400    Declare your resources with handles with destructors that clean up."
msgstr""

# CppCoreGuidelines.md:8401
msgid "8401    If for some reason you cannot handle all cleanup with destructors for the variables used,"
msgstr""

# CppCoreGuidelines.md:8402
msgid "8402    consider `gsl::finally()` as a cleaner and more reliable alternative to `goto exit`"
msgstr""

       
# CppCoreGuidelines.md:8403
msgid "8403    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8404
msgid "8404    * Flag `goto`. Better still flag all `goto`s that do not jump from a nested loop to the statement immediately after a nest of loops."
msgstr""

       
# CppCoreGuidelines.md:8405
msgid "8405    ### <a name=\"Res-continue\"></a>ES.77: Minimize the use of `break` and `continue` in loops"
msgstr""

       
# CppCoreGuidelines.md:8406
msgid "8406    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8407
msgid "8407     In a non-trivial loop body, it is easy to overlook a `break` or a `continue`."
msgstr""

       
# CppCoreGuidelines.md:8408
msgid "8408     A `break` in a loop has a dramatically different meaning than a `break` in a `switch`-statement"
msgstr""

# CppCoreGuidelines.md:8409
msgid "8409     (and you can have `switch`-statement in a loop and a loop in a `switch`-case)."
msgstr""

       
# CppCoreGuidelines.md:8410
msgid "8410    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8411
msgid "8411        ???"
msgstr""

       
# CppCoreGuidelines.md:8412
msgid "8412    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:8413
msgid "8413    Often, a loop that requires a `break` is a good candidate for a function (algorithm), in which case the `break` becomes a `return`."
msgstr""

       
# CppCoreGuidelines.md:8414
msgid "8414        ???"
msgstr""

       
# CppCoreGuidelines.md:8415
msgid "8415    Often. a loop that uses `continue` can equivalently and as clearly be expressed by an `if`-statement."
msgstr""

       
# CppCoreGuidelines.md:8416
msgid "8416        ???"
msgstr""

       
# CppCoreGuidelines.md:8417
msgid "8417    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8418
msgid "8418    If you really need to break out a loop, a `break` is typically better than alternatives such as [modifying the loop variable](#Res-loop-counter) or a [`goto`](#Res-goto):"
msgstr""

       
       
# CppCoreGuidelines.md:8419
msgid "8419    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8420
msgid "8420    ???"
msgstr""

       
# CppCoreGuidelines.md:8421
msgid "8421    ### <a name=\"Res-break\"></a>ES.78: Always end a non-empty `case` with a `break`"
msgstr""

       
# CppCoreGuidelines.md:8422
msgid "8422    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8423
msgid "8423     Accidentally leaving out a `break` is a fairly common bug."
msgstr""

# CppCoreGuidelines.md:8424
msgid "8424     A deliberate fallthrough is a maintenance hazard."
msgstr""

       
# CppCoreGuidelines.md:8425
msgid "8425    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8426
msgid "8426        switch (eventType) {"
msgstr""

# CppCoreGuidelines.md:8427
msgid "8427        case Information:"
msgstr""

# CppCoreGuidelines.md:8428
msgid "8428            update_status_bar();"
msgstr""

# CppCoreGuidelines.md:8429
msgid "8429            break;"
msgstr""

# CppCoreGuidelines.md:8430
msgid "8430        case Warning:"
msgstr""

# CppCoreGuidelines.md:8431
msgid "8431            write_event_log();"
msgstr""

# CppCoreGuidelines.md:8432
msgid "8432            // Bad - implicit fallthrough"
msgstr""

# CppCoreGuidelines.md:8433
msgid "8433        case Error:"
msgstr""

# CppCoreGuidelines.md:8434
msgid "8434            display_error_window();"
msgstr""

# CppCoreGuidelines.md:8435
msgid "8435            break;"
msgstr""

# CppCoreGuidelines.md:8436
msgid "8436        }"
msgstr""

       
# CppCoreGuidelines.md:8437
msgid "8437    It is easy to overlook the fallthrough. Be explicit:"
msgstr""

       
# CppCoreGuidelines.md:8438
msgid "8438        switch (eventType) {"
msgstr""

# CppCoreGuidelines.md:8439
msgid "8439        case Information:"
msgstr""

# CppCoreGuidelines.md:8440
msgid "8440            update_status_bar();"
msgstr""

# CppCoreGuidelines.md:8441
msgid "8441            break;"
msgstr""

# CppCoreGuidelines.md:8442
msgid "8442        case Warning:"
msgstr""

# CppCoreGuidelines.md:8443
msgid "8443            write_event_log();"
msgstr""

# CppCoreGuidelines.md:8444
msgid "8444            // fallthrough"
msgstr""

# CppCoreGuidelines.md:8445
msgid "8445        case Error:"
msgstr""

# CppCoreGuidelines.md:8446
msgid "8446            display_error_window();"
msgstr""

# CppCoreGuidelines.md:8447
msgid "8447            break;"
msgstr""

# CppCoreGuidelines.md:8448
msgid "8448        }"
msgstr""

       
# CppCoreGuidelines.md:8449
msgid "8449    In C++17, use a `[[fallthrough]]` annotation:"
msgstr""

       
# CppCoreGuidelines.md:8450
msgid "8450        switch (eventType) {"
msgstr""

# CppCoreGuidelines.md:8451
msgid "8451        case Information:"
msgstr""

# CppCoreGuidelines.md:8452
msgid "8452            update_status_bar();"
msgstr""

# CppCoreGuidelines.md:8453
msgid "8453            break;"
msgstr""

# CppCoreGuidelines.md:8454
msgid "8454        case Warning:"
msgstr""

# CppCoreGuidelines.md:8455
msgid "8455            write_event_log();"
msgstr""

# CppCoreGuidelines.md:8456
msgid "8456            [[fallthrough]];        // C++17"
msgstr""

# CppCoreGuidelines.md:8457
msgid "8457        case Error:"
msgstr""

# CppCoreGuidelines.md:8458
msgid "8458            display_error_window();"
msgstr""

# CppCoreGuidelines.md:8459
msgid "8459            break;"
msgstr""

# CppCoreGuidelines.md:8460
msgid "8460        }"
msgstr""

       
# CppCoreGuidelines.md:8461
msgid "8461    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8462
msgid "8462    Multiple case labels of a single statement is OK:"
msgstr""

       
# CppCoreGuidelines.md:8463
msgid "8463        switch (x) {"
msgstr""

# CppCoreGuidelines.md:8464
msgid "8464        case 'a':"
msgstr""

# CppCoreGuidelines.md:8465
msgid "8465        case 'b':"
msgstr""

# CppCoreGuidelines.md:8466
msgid "8466        case 'f':"
msgstr""

# CppCoreGuidelines.md:8467
msgid "8467            do_something(x);"
msgstr""

# CppCoreGuidelines.md:8468
msgid "8468            break;"
msgstr""

# CppCoreGuidelines.md:8469
msgid "8469        }"
msgstr""

       
# CppCoreGuidelines.md:8470
msgid "8470    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8471
msgid "8471    Flag all fallthroughs from non-empty `case`s."
msgstr""

       
# CppCoreGuidelines.md:8472
msgid "8472    ### <a name=\"Res-default\"></a>ES.79: Use `default` to handle common cases (only)"
msgstr""

       
# CppCoreGuidelines.md:8473
msgid "8473    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8474
msgid "8474     Code clarity."
msgstr""

# CppCoreGuidelines.md:8475
msgid "8475     Improved opportunities for error detection."
msgstr""

       
# CppCoreGuidelines.md:8476
msgid "8476    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8477
msgid "8477        enum E { a, b, c , d };"
msgstr""

       
# CppCoreGuidelines.md:8478
msgid "8478        void f1(E x)"
msgstr""

# CppCoreGuidelines.md:8479
msgid "8479        {"
msgstr""

# CppCoreGuidelines.md:8480
msgid "8480            switch (x) {"
msgstr""

# CppCoreGuidelines.md:8481
msgid "8481            case a:"
msgstr""

# CppCoreGuidelines.md:8482
msgid "8482                do_something();"
msgstr""

# CppCoreGuidelines.md:8483
msgid "8483                break;"
msgstr""

# CppCoreGuidelines.md:8484
msgid "8484            case b:"
msgstr""

# CppCoreGuidelines.md:8485
msgid "8485                do_something_else();"
msgstr""

# CppCoreGuidelines.md:8486
msgid "8486                break;"
msgstr""

# CppCoreGuidelines.md:8487
msgid "8487            default:"
msgstr""

# CppCoreGuidelines.md:8488
msgid "8488                take_the_default_action();"
msgstr""

# CppCoreGuidelines.md:8489
msgid "8489                break;"
msgstr""

# CppCoreGuidelines.md:8490
msgid "8490            }"
msgstr""

# CppCoreGuidelines.md:8491
msgid "8491        }"
msgstr""

       
# CppCoreGuidelines.md:8492
msgid "8492    Here it is clear that there is a default action and that cases `a` and `b` are special."
msgstr""

       
# CppCoreGuidelines.md:8493
msgid "8493    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8494
msgid "8494    But what if there is no default action and you mean to handle only specific cases?"
msgstr""

# CppCoreGuidelines.md:8495
msgid "8495    In that case, have an empty default or else it is impossible to know if you meant to handle all cases:"
msgstr""

       
# CppCoreGuidelines.md:8496
msgid "8496        void f2(E x)"
msgstr""

# CppCoreGuidelines.md:8497
msgid "8497        {"
msgstr""

# CppCoreGuidelines.md:8498
msgid "8498            switch (x) {"
msgstr""

# CppCoreGuidelines.md:8499
msgid "8499            case a:"
msgstr""

# CppCoreGuidelines.md:8500
msgid "8500                do_something();"
msgstr""

# CppCoreGuidelines.md:8501
msgid "8501                break;"
msgstr""

# CppCoreGuidelines.md:8502
msgid "8502            case b:"
msgstr""

# CppCoreGuidelines.md:8503
msgid "8503                do_something_else();"
msgstr""

# CppCoreGuidelines.md:8504
msgid "8504                break;"
msgstr""

# CppCoreGuidelines.md:8505
msgid "8505            default:"
msgstr""

# CppCoreGuidelines.md:8506
msgid "8506                // do nothing for the rest of the cases"
msgstr""

# CppCoreGuidelines.md:8507
msgid "8507                break;"
msgstr""

# CppCoreGuidelines.md:8508
msgid "8508            }"
msgstr""

# CppCoreGuidelines.md:8509
msgid "8509        }"
msgstr""

       
# CppCoreGuidelines.md:8510
msgid "8510    If you leave out the `default`, a maintainer and/or a compiler may reasonably assume that you intended to handle all cases:"
msgstr""

       
# CppCoreGuidelines.md:8511
msgid "8511        void f2(E x)"
msgstr""

# CppCoreGuidelines.md:8512
msgid "8512        {"
msgstr""

# CppCoreGuidelines.md:8513
msgid "8513            switch (x) {"
msgstr""

# CppCoreGuidelines.md:8514
msgid "8514            case a:"
msgstr""

# CppCoreGuidelines.md:8515
msgid "8515                do_something();"
msgstr""

# CppCoreGuidelines.md:8516
msgid "8516                break;"
msgstr""

# CppCoreGuidelines.md:8517
msgid "8517            case b:"
msgstr""

# CppCoreGuidelines.md:8518
msgid "8518            case c:"
msgstr""

# CppCoreGuidelines.md:8519
msgid "8519                do_something_else();"
msgstr""

# CppCoreGuidelines.md:8520
msgid "8520                break;"
msgstr""

# CppCoreGuidelines.md:8521
msgid "8521            }"
msgstr""

# CppCoreGuidelines.md:8522
msgid "8522        }"
msgstr""

       
# CppCoreGuidelines.md:8523
msgid "8523    Did you forget case `d` or deliberately leave it out?"
msgstr""

# CppCoreGuidelines.md:8524
msgid "8524    Forgetting a case typically happens when a case is added to an enumeration and the person doing so fails to add it to every"
msgstr""

# CppCoreGuidelines.md:8525
msgid "8525    switch over the enumerators."
msgstr""

       
# CppCoreGuidelines.md:8526
msgid "8526    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8527
msgid "8527    Flag `switch`-statements over an enumeration that don't handle all enumerators and do not have a `default`."
msgstr""

# CppCoreGuidelines.md:8528
msgid "8528    This may yield too many false positives in some code bases; if so, flag only `switch`es that handle most but not all cases"
msgstr""

# CppCoreGuidelines.md:8529
msgid "8529    (that was the strategy of the very first C++ compiler)."
msgstr""

       
# CppCoreGuidelines.md:8530
msgid "8530    ### <a name=\"Res-noname\"></a>ES.84: Don't (try to) declare a local variable with no name"
msgstr""

       
# CppCoreGuidelines.md:8531
msgid "8531    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8532
msgid "8532    There is no such thing."
msgstr""

# CppCoreGuidelines.md:8533
msgid "8533    What looks to a human like a variable without a name is to the compiler a statement consisting of a temporary that immediately goes out of scope."
msgstr""

# CppCoreGuidelines.md:8534
msgid "8534    To avoid unpleasant surprises."
msgstr""

       
# CppCoreGuidelines.md:8535
msgid "8535    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8536
msgid "8536        void f()"
msgstr""

# CppCoreGuidelines.md:8537
msgid "8537        {"
msgstr""

# CppCoreGuidelines.md:8538
msgid "8538            lock<mutex>{mx};   // Bad"
msgstr""

# CppCoreGuidelines.md:8539
msgid "8539            // ..."
msgstr""

# CppCoreGuidelines.md:8540
msgid "8540        }"
msgstr""

       
# CppCoreGuidelines.md:8541
msgid "8541    This declares an unnamed `lock` object that immediately goes out of scope at the point of the semicolon."
msgstr""

# CppCoreGuidelines.md:8542
msgid "8542    This is not an uncommon mistake."
msgstr""

# CppCoreGuidelines.md:8543
msgid "8543    In particular, this particular example can lead to hard-to find race conditions."
msgstr""

# CppCoreGuidelines.md:8544
msgid "8544    There are exceedingly clever uses of this \"idiom\", but they are far rarer than the mistakes."
msgstr""

       
# CppCoreGuidelines.md:8545
msgid "8545    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8546
msgid "8546    Unnamed function arguments are fine."
msgstr""

       
# CppCoreGuidelines.md:8547
msgid "8547    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8548
msgid "8548    Flag statements that are just a temporary"
msgstr""

       
# CppCoreGuidelines.md:8549
msgid "8549    ### <a name=\"Res-empty\"></a>ES.85: Make empty statements visible"
msgstr""

       
# CppCoreGuidelines.md:8550
msgid "8550    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8551
msgid "8551    Readability."
msgstr""

       
# CppCoreGuidelines.md:8552
msgid "8552    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8553
msgid "8553        for (i = 0; i < max; ++i);   // BAD: the empty statement is easily overlooked"
msgstr""

# CppCoreGuidelines.md:8554
msgid "8554        v[i] = f(v[i]);"
msgstr""

       
# CppCoreGuidelines.md:8555
msgid "8555        for (auto x : v) {           // better"
msgstr""

# CppCoreGuidelines.md:8556
msgid "8556            // nothing"
msgstr""

# CppCoreGuidelines.md:8557
msgid "8557        }"
msgstr""

# CppCoreGuidelines.md:8558
msgid "8558        v[i] = f(v[i]);"
msgstr""

       
# CppCoreGuidelines.md:8559
msgid "8559    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8560
msgid "8560    Flag empty statements that are not blocks and don't contain comments."
msgstr""

       
# CppCoreGuidelines.md:8561
msgid "8561    ### <a name=\"Res-loop-counter\"></a>ES.86: Avoid modifying loop control variables inside the body of raw for-loops"
msgstr""

       
# CppCoreGuidelines.md:8562
msgid "8562    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8563
msgid "8563    The loop control up front should enable correct reasoning about what is happening inside the loop. Modifying loop counters in both the iteration-expression and inside the body of the loop is a perennial source of surprises and bugs."
msgstr""

       
# CppCoreGuidelines.md:8564
msgid "8564    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8565
msgid "8565        for (int i = 0; i < 10; ++i) {"
msgstr""

# CppCoreGuidelines.md:8566
msgid "8566            // no updates to i -- ok"
msgstr""

# CppCoreGuidelines.md:8567
msgid "8567        }"
msgstr""

       
# CppCoreGuidelines.md:8568
msgid "8568        for (int i = 0; i < 10; ++i) {"
msgstr""

# CppCoreGuidelines.md:8569
msgid "8569            //"
msgstr""

# CppCoreGuidelines.md:8570
msgid "8570            if (/* something */) ++i; // BAD"
msgstr""

# CppCoreGuidelines.md:8571
msgid "8571            //"
msgstr""

# CppCoreGuidelines.md:8572
msgid "8572        }"
msgstr""

       
# CppCoreGuidelines.md:8573
msgid "8573        bool skip = false;"
msgstr""

# CppCoreGuidelines.md:8574
msgid "8574        for (int i = 0; i < 10; ++i) {"
msgstr""

# CppCoreGuidelines.md:8575
msgid "8575            if (skip) { skip = false; continue; }"
msgstr""

# CppCoreGuidelines.md:8576
msgid "8576            //"
msgstr""

# CppCoreGuidelines.md:8577
msgid "8577            if (/* something */) skip = true;  // Better: using two variable for two concepts."
msgstr""

# CppCoreGuidelines.md:8578
msgid "8578            //"
msgstr""

# CppCoreGuidelines.md:8579
msgid "8579        }"
msgstr""

       
# CppCoreGuidelines.md:8580
msgid "8580    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8581
msgid "8581    Flag variables that are potentially updated (have a non-`const` use) in both the loop control iteration-expression and the loop body."
msgstr""

       
       
# CppCoreGuidelines.md:8582
msgid "8582    ### <a name=\"Res-if\"></a>ES.87: Don't add redundant `==` or `!=` to conditions"
msgstr""

       
# CppCoreGuidelines.md:8583
msgid "8583    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8584
msgid "8584    Doing so avoids verbosity and eliminates some opportunities for mistakes."
msgstr""

# CppCoreGuidelines.md:8585
msgid "8585    Helps make style consistent and conventional."
msgstr""

       
# CppCoreGuidelines.md:8586
msgid "8586    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8587
msgid "8587    By definition, a condition in an `if`-statement, `while`-statement, or a `for`-statement selects between `true` and `false`."
msgstr""

# CppCoreGuidelines.md:8588
msgid "8588    A numeric value is compared to `0` and a pointer value to `nullptr`."
msgstr""

       
# CppCoreGuidelines.md:8589
msgid "8589        // These all mean \"if `p` is not `nullptr`\""
msgstr""

# CppCoreGuidelines.md:8590
msgid "8590        if (p) { ... }            // good"
msgstr""

# CppCoreGuidelines.md:8591
msgid "8591        if (p != 0) { ... }       // redundant `!=0`; bad: don't use 0 for pointers"
msgstr""

# CppCoreGuidelines.md:8592
msgid "8592        if (p != nullptr) { ... } // redundant `!=nullptr`, not recommended"
msgstr""

       
# CppCoreGuidelines.md:8593
msgid "8593    Often, `if (p)` is read as \"if `p` is valid\" which is a direct expression of the programmers intent,"
msgstr""

# CppCoreGuidelines.md:8594
msgid "8594    whereas `if (p != nullptr)` would be a long-winded workaround."
msgstr""

       
# CppCoreGuidelines.md:8595
msgid "8595    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8596
msgid "8596    This rule is especially useful when a declaration is used as a condition"
msgstr""

       
# CppCoreGuidelines.md:8597
msgid "8597        if (auto pc = dynamic_cast<Circle>(ps)) { ... } // execute is ps points to a kind of Circle, good"
msgstr""

       
# CppCoreGuidelines.md:8598
msgid "8598        if (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } // not recommended"
msgstr""

       
# CppCoreGuidelines.md:8599
msgid "8599    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8600
msgid "8600    Note that implicit conversions to bool are applied in conditions."
msgstr""

# CppCoreGuidelines.md:8601
msgid "8601    For example:"
msgstr""

       
# CppCoreGuidelines.md:8602
msgid "8602        for (string s; cin >> s; ) v.push_back(s);"
msgstr""

       
# CppCoreGuidelines.md:8603
msgid "8603    This invokes `istream`'s `operator bool()`."
msgstr""

       
# CppCoreGuidelines.md:8604
msgid "8604    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8605
msgid "8605    Explicit comparison of an integer to `0` is in general not redundant."
msgstr""

# CppCoreGuidelines.md:8606
msgid "8606    The reason is that (as opposed to pointers and Booleans) an integer often has more than two reasonable values."
msgstr""

# CppCoreGuidelines.md:8607
msgid "8607    Furthermore `0` (zero) is often used to indicate success."
msgstr""

# CppCoreGuidelines.md:8608
msgid "8608    Consequently, it is best to be specific about the comparison."
msgstr""

       
# CppCoreGuidelines.md:8609
msgid "8609        void f(int i)"
msgstr""

# CppCoreGuidelines.md:8610
msgid "8610        {"
msgstr""

# CppCoreGuidelines.md:8611
msgid "8611            if (i)            // suspect"
msgstr""

# CppCoreGuidelines.md:8612
msgid "8612            // ..."
msgstr""

# CppCoreGuidelines.md:8613
msgid "8613            if (i == success) // possibly better"
msgstr""

# CppCoreGuidelines.md:8614
msgid "8614            // ..."
msgstr""

# CppCoreGuidelines.md:8615
msgid "8615        }"
msgstr""

       
# CppCoreGuidelines.md:8616
msgid "8616    Always remember that an integer can have more than two values."
msgstr""

       
# CppCoreGuidelines.md:8617
msgid "8617    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8618
msgid "8618    It has been noted that"
msgstr""

       
# CppCoreGuidelines.md:8619
msgid "8619        if(strcmp(p1, p2)) { ... }   // are the two C-style strings equal? (mistake!)"
msgstr""

       
# CppCoreGuidelines.md:8620
msgid "8620    is a common beginners error."
msgstr""

# CppCoreGuidelines.md:8621
msgid "8621    If you use C-style strings, you must know the `<cstring>` functions well."
msgstr""

# CppCoreGuidelines.md:8622
msgid "8622    Being verbose and writing"
msgstr""

       
# CppCoreGuidelines.md:8623
msgid "8623        if(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings equal? (mistake!)"
msgstr""

       
# CppCoreGuidelines.md:8624
msgid "8624    would not in itself save you."
msgstr""

       
# CppCoreGuidelines.md:8625
msgid "8625    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8626
msgid "8626    The opposite condition is most easily expressed using a negation:"
msgstr""

       
# CppCoreGuidelines.md:8627
msgid "8627        // These all mean \"if `p` is `nullptr`\""
msgstr""

# CppCoreGuidelines.md:8628
msgid "8628        if (!p) { ... }           // good"
msgstr""

# CppCoreGuidelines.md:8629
msgid "8629        if (p == 0) { ... }       // redundant `== 0`; bad: don't use `0` for pointers"
msgstr""

# CppCoreGuidelines.md:8630
msgid "8630        if (p == nullptr) { ... } // redundant `== nullptr`, not recommended"
msgstr""

       
# CppCoreGuidelines.md:8631
msgid "8631    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8632
msgid "8632    Easy, just check for redundant use of `!=` and `==` in conditions."
msgstr""

       
       
       
# CppCoreGuidelines.md:8633
msgid "8633    ## <a name=\"SS-numbers\"></a>Arithmetic"
msgstr""

       
# CppCoreGuidelines.md:8634
msgid "8634    ### <a name=\"Res-mix\"></a>ES.100: Don't mix signed and unsigned arithmetic"
msgstr""

       
# CppCoreGuidelines.md:8635
msgid "8635    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8636
msgid "8636    Avoid wrong results."
msgstr""

       
# CppCoreGuidelines.md:8637
msgid "8637    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8638
msgid "8638        int x = -3;"
msgstr""

# CppCoreGuidelines.md:8639
msgid "8639        unsigned int y = 7;"
msgstr""

       
# CppCoreGuidelines.md:8640
msgid "8640        cout << x - y << '\\n';  // unsigned result, possibly 4294967286"
msgstr""

# CppCoreGuidelines.md:8641
msgid "8641        cout << x + y << '\\n';  // unsigned result: 4"
msgstr""

# CppCoreGuidelines.md:8642
msgid "8642        cout << x * y << '\\n';  // unsigned result, possibly 4294967275"
msgstr""

       
# CppCoreGuidelines.md:8643
msgid "8643    It is harder to spot the problem in more realistic examples."
msgstr""

       
# CppCoreGuidelines.md:8644
msgid "8644    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8645
msgid "8645    Unfortunately, C++ uses signed integers for array subscripts and the standard library uses unsigned integers for container subscripts."
msgstr""

# CppCoreGuidelines.md:8646
msgid "8646    This precludes consistency. Use `gsl::index` for subscripts; [see ES.107](#Res-subscripts)."
msgstr""

       
# CppCoreGuidelines.md:8647
msgid "8647    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8648
msgid "8648    * Compilers already know and sometimes warn."
msgstr""

# CppCoreGuidelines.md:8649
msgid "8649    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`."
msgstr""

       
       
# CppCoreGuidelines.md:8650
msgid "8650    ### <a name=\"Res-unsigned\"></a>ES.101: Use unsigned types for bit manipulation"
msgstr""

       
# CppCoreGuidelines.md:8651
msgid "8651    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8652
msgid "8652    Unsigned types support bit manipulation without surprises from sign bits."
msgstr""

       
# CppCoreGuidelines.md:8653
msgid "8653    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8654
msgid "8654        unsigned char x = 0b1010'1010;"
msgstr""

# CppCoreGuidelines.md:8655
msgid "8655        unsigned char y = ~x;   // y == 0b0101'0101;"
msgstr""

       
# CppCoreGuidelines.md:8656
msgid "8656    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8657
msgid "8657    Unsigned types can also be useful for modulo arithmetic."
msgstr""

# CppCoreGuidelines.md:8658
msgid "8658    However, if you want modulo arithmetic add"
msgstr""

# CppCoreGuidelines.md:8659
msgid "8659    comments as necessary noting the reliance on wraparound behavior, as such code"
msgstr""

# CppCoreGuidelines.md:8660
msgid "8660    can be surprising for many programmers."
msgstr""

       
# CppCoreGuidelines.md:8661
msgid "8661    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8662
msgid "8662    * Just about impossible in general because of the use of unsigned subscripts in the standard library"
msgstr""

# CppCoreGuidelines.md:8663
msgid "8663    * ???"
msgstr""

       
# CppCoreGuidelines.md:8664
msgid "8664    ### <a name=\"Res-signed\"></a>ES.102: Use signed types for arithmetic"
msgstr""

       
# CppCoreGuidelines.md:8665
msgid "8665    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8666
msgid "8666    Because most arithmetic is assumed to be signed;"
msgstr""

# CppCoreGuidelines.md:8667
msgid "8667    `x - y` yields a negative number when `y > x` except in the rare cases where you really want modulo arithmetic."
msgstr""

       
# CppCoreGuidelines.md:8668
msgid "8668    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8669
msgid "8669    Unsigned arithmetic can yield surprising results if you are not expecting it."
msgstr""

# CppCoreGuidelines.md:8670
msgid "8670    This is even more true for mixed signed and unsigned arithmetic."
msgstr""

       
# CppCoreGuidelines.md:8671
msgid "8671        template<typename T, typename T2>"
msgstr""

# CppCoreGuidelines.md:8672
msgid "8672        T subtract(T x, T2 y)"
msgstr""

# CppCoreGuidelines.md:8673
msgid "8673        {"
msgstr""

# CppCoreGuidelines.md:8674
msgid "8674            return x - y;"
msgstr""

# CppCoreGuidelines.md:8675
msgid "8675        }"
msgstr""

       
# CppCoreGuidelines.md:8676
msgid "8676        void test()"
msgstr""

# CppCoreGuidelines.md:8677
msgid "8677        {"
msgstr""

# CppCoreGuidelines.md:8678
msgid "8678            int s = 5;"
msgstr""

# CppCoreGuidelines.md:8679
msgid "8679            unsigned int us = 5;"
msgstr""

# CppCoreGuidelines.md:8680
msgid "8680            cout << subtract(s, 7) << '\\n';       // -2"
msgstr""

# CppCoreGuidelines.md:8681
msgid "8681            cout << subtract(us, 7u) << '\\n';     // 4294967294"
msgstr""

# CppCoreGuidelines.md:8682
msgid "8682            cout << subtract(s, 7u) << '\\n';      // -2"
msgstr""

# CppCoreGuidelines.md:8683
msgid "8683            cout << subtract(us, 7) << '\\n';      // 4294967294"
msgstr""

# CppCoreGuidelines.md:8684
msgid "8684            cout << subtract(s, us + 2) << '\\n';  // -2"
msgstr""

# CppCoreGuidelines.md:8685
msgid "8685            cout << subtract(us, s + 2) << '\\n';  // 4294967294"
msgstr""

# CppCoreGuidelines.md:8686
msgid "8686        }"
msgstr""

       
# CppCoreGuidelines.md:8687
msgid "8687    Here we have been very explicit about what's happening,"
msgstr""

# CppCoreGuidelines.md:8688
msgid "8688    but if you had seen `us - (s + 2)` or `s += 2; ...; us - s`, would you reliably have suspected that the result would print as `4294967294`?"
msgstr""

       
# CppCoreGuidelines.md:8689
msgid "8689    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:8690
msgid "8690    Use unsigned types if you really want modulo arithmetic - add"
msgstr""

# CppCoreGuidelines.md:8691
msgid "8691    comments as necessary noting the reliance on overflow behavior, as such code"
msgstr""

# CppCoreGuidelines.md:8692
msgid "8692    is going to be surprising for many programmers."
msgstr""

       
# CppCoreGuidelines.md:8693
msgid "8693    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8694
msgid "8694    The standard library uses unsigned types for subscripts."
msgstr""

# CppCoreGuidelines.md:8695
msgid "8695    The built-in array uses signed types for subscripts."
msgstr""

# CppCoreGuidelines.md:8696
msgid "8696    This makes surprises (and bugs) inevitable."
msgstr""

       
# CppCoreGuidelines.md:8697
msgid "8697        int a[10];"
msgstr""

# CppCoreGuidelines.md:8698
msgid "8698        for (int i = 0; i < 10; ++i) a[i] = i;"
msgstr""

# CppCoreGuidelines.md:8699
msgid "8699        vector<int> v(10);"
msgstr""

# CppCoreGuidelines.md:8700
msgid "8700        // compares signed to unsigned; some compilers warn, but we should not"
msgstr""

# CppCoreGuidelines.md:8701
msgid "8701        for (gsl::index i = 0; i < v.size(); ++i) v[i] = i;"
msgstr""

       
# CppCoreGuidelines.md:8702
msgid "8702        int a2[-2];         // error: negative size"
msgstr""

       
# CppCoreGuidelines.md:8703
msgid "8703        // OK, but the number of ints (4294967294) is so large that we should get an exception"
msgstr""

# CppCoreGuidelines.md:8704
msgid "8704        vector<int> v2(-2);"
msgstr""

       
# CppCoreGuidelines.md:8705
msgid "8705     Use `gsl::index` for subscripts; [see ES.107](#Res-subscripts)."
msgstr""

       
# CppCoreGuidelines.md:8706
msgid "8706    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8707
msgid "8707    * Flag mixed signed and unsigned arithmetic"
msgstr""

# CppCoreGuidelines.md:8708
msgid "8708    * Flag results of unsigned arithmetic assigned to or printed as signed."
msgstr""

# CppCoreGuidelines.md:8709
msgid "8709    * Flag unsigned literals (e.g. `-2`) used as container subscripts."
msgstr""

# CppCoreGuidelines.md:8710
msgid "8710    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`."
msgstr""

       
       
# CppCoreGuidelines.md:8711
msgid "8711    ### <a name=\"Res-overflow\"></a>ES.103: Don't overflow"
msgstr""

       
# CppCoreGuidelines.md:8712
msgid "8712    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8713
msgid "8713    Overflow usually makes your numeric algorithm meaningless."
msgstr""

# CppCoreGuidelines.md:8714
msgid "8714    Incrementing a value beyond a maximum value can lead to memory corruption and undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:8715
msgid "8715    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8716
msgid "8716        int a[10];"
msgstr""

# CppCoreGuidelines.md:8717
msgid "8717        a[10] = 7;   // bad"
msgstr""

       
# CppCoreGuidelines.md:8718
msgid "8718        int n = 0;"
msgstr""

# CppCoreGuidelines.md:8719
msgid "8719        while (n++ < 10)"
msgstr""

# CppCoreGuidelines.md:8720
msgid "8720            a[n - 1] = 9; // bad (twice)"
msgstr""

       
# CppCoreGuidelines.md:8721
msgid "8721    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8722
msgid "8722        int n = numeric_limits<int>::max();"
msgstr""

# CppCoreGuidelines.md:8723
msgid "8723        int m = n + 1;   // bad"
msgstr""

       
# CppCoreGuidelines.md:8724
msgid "8724    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8725
msgid "8725        int area(int h, int w) { return h * w; }"
msgstr""

       
# CppCoreGuidelines.md:8726
msgid "8726        auto a = area(10'000'000, 100'000'000);   // bad"
msgstr""

       
# CppCoreGuidelines.md:8727
msgid "8727    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:8728
msgid "8728    Use unsigned types if you really want modulo arithmetic."
msgstr""

       
# CppCoreGuidelines.md:8729
msgid "8729    **Alternative**: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type."
msgstr""

       
# CppCoreGuidelines.md:8730
msgid "8730    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8731
msgid "8731    ???"
msgstr""

       
# CppCoreGuidelines.md:8732
msgid "8732    ### <a name=\"Res-underflow\"></a>ES.104: Don't underflow"
msgstr""

       
# CppCoreGuidelines.md:8733
msgid "8733    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8734
msgid "8734    Decrementing a value beyond a minimum value can lead to memory corruption and undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:8735
msgid "8735    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8736
msgid "8736        int a[10];"
msgstr""

# CppCoreGuidelines.md:8737
msgid "8737        a[-2] = 7;   // bad"
msgstr""

       
# CppCoreGuidelines.md:8738
msgid "8738        int n = 101;"
msgstr""

# CppCoreGuidelines.md:8739
msgid "8739        while (n--)"
msgstr""

# CppCoreGuidelines.md:8740
msgid "8740            a[n - 1] = 9;   // bad (twice)"
msgstr""

       
# CppCoreGuidelines.md:8741
msgid "8741    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:8742
msgid "8742    Use unsigned types if you really want modulo arithmetic."
msgstr""

       
# CppCoreGuidelines.md:8743
msgid "8743    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8744
msgid "8744    ???"
msgstr""

       
# CppCoreGuidelines.md:8745
msgid "8745    ### <a name=\"Res-zero\"></a>ES.105: Don't divide by zero"
msgstr""

       
# CppCoreGuidelines.md:8746
msgid "8746    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8747
msgid "8747    The result is undefined and probably a crash."
msgstr""

       
# CppCoreGuidelines.md:8748
msgid "8748    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8749
msgid "8749    This also applies to `%`."
msgstr""

       
# CppCoreGuidelines.md:8750
msgid "8750    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:8751
msgid "8751        double divide(int a, int b) {"
msgstr""

# CppCoreGuidelines.md:8752
msgid "8752            // BAD, should be checked (e.g., in a precondition)"
msgstr""

# CppCoreGuidelines.md:8753
msgid "8753            return a / b;"
msgstr""

# CppCoreGuidelines.md:8754
msgid "8754        }"
msgstr""

       
# CppCoreGuidelines.md:8755
msgid "8755    ##### Example; good"
msgstr""

       
# CppCoreGuidelines.md:8756
msgid "8756        double divide(int a, int b) {"
msgstr""

# CppCoreGuidelines.md:8757
msgid "8757            // good, address via precondition (and replace with contracts once C++ gets them)"
msgstr""

# CppCoreGuidelines.md:8758
msgid "8758            Expects(b != 0);"
msgstr""

# CppCoreGuidelines.md:8759
msgid "8759            return a / b;"
msgstr""

# CppCoreGuidelines.md:8760
msgid "8760        }"
msgstr""

       
# CppCoreGuidelines.md:8761
msgid "8761        double divide(int a, int b) {"
msgstr""

# CppCoreGuidelines.md:8762
msgid "8762            // good, address via check"
msgstr""

# CppCoreGuidelines.md:8763
msgid "8763            return b ? a / b : quiet_NaN<double>();"
msgstr""

# CppCoreGuidelines.md:8764
msgid "8764        }"
msgstr""

       
# CppCoreGuidelines.md:8765
msgid "8765    **Alternative**: For critical applications that can afford some overhead, use a range-checked integer and/or floating-point type."
msgstr""

       
# CppCoreGuidelines.md:8766
msgid "8766    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8767
msgid "8767    * Flag division by an integral value that could be zero"
msgstr""

       
       
# CppCoreGuidelines.md:8768
msgid "8768    ### <a name=\"Res-nonnegative\"></a>ES.106: Don't try to avoid negative values by using `unsigned`"
msgstr""

       
# CppCoreGuidelines.md:8769
msgid "8769    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8770
msgid "8770    Choosing `unsigned` implies many changes to the usual behavior of integers, including modulo arithmetic,"
msgstr""

# CppCoreGuidelines.md:8771
msgid "8771    can suppress warnings related to overflow,"
msgstr""

# CppCoreGuidelines.md:8772
msgid "8772    and opens the door for errors related to signed/unsigned mixes."
msgstr""

# CppCoreGuidelines.md:8773
msgid "8773    Using `unsigned` doesn't actually eliminate the possibility of negative values."
msgstr""

       
# CppCoreGuidelines.md:8774
msgid "8774    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8775
msgid "8775        unsigned int u1 = -2;   // Valid: the value of u1 is 4294967294"
msgstr""

# CppCoreGuidelines.md:8776
msgid "8776        int i1 = -2;"
msgstr""

# CppCoreGuidelines.md:8777
msgid "8777        unsigned int u2 = i1;   // Valid: the value of u2 is 4294967294"
msgstr""

# CppCoreGuidelines.md:8778
msgid "8778        int i2 = u2;            // Valid: the value of i2 is -2"
msgstr""

       
# CppCoreGuidelines.md:8779
msgid "8779    These problems with such (perfectly legal) constructs are hard to spot in real code and are the source of many real-world errors."
msgstr""

# CppCoreGuidelines.md:8780
msgid "8780    Consider:"
msgstr""

       
# CppCoreGuidelines.md:8781
msgid "8781        unsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#Ri-expects)"
msgstr""

# CppCoreGuidelines.md:8782
msgid "8782        // ..."
msgstr""

# CppCoreGuidelines.md:8783
msgid "8783        int height;"
msgstr""

# CppCoreGuidelines.md:8784
msgid "8784        cin >> height;"
msgstr""

# CppCoreGuidelines.md:8785
msgid "8785        auto a = area(height, 2);   // if the input is -2 a becomes 4294967292"
msgstr""

       
# CppCoreGuidelines.md:8786
msgid "8786    Remember that `-1` when assigned to an `unsigned int` becomes the largest `unsigned int`."
msgstr""

# CppCoreGuidelines.md:8787
msgid "8787    Also, since unsigned arithmetic is modulo arithmetic the multiplication didn't overflow, it wrapped around."
msgstr""

       
# CppCoreGuidelines.md:8788
msgid "8788    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8789
msgid "8789        unsigned max = 100000;    // \"accidental typo\", I mean to say 10'000"
msgstr""

# CppCoreGuidelines.md:8790
msgid "8790        unsigned short x = 100;"
msgstr""

# CppCoreGuidelines.md:8791
msgid "8791        while (x < max) x += 100; // infinite loop"
msgstr""

       
# CppCoreGuidelines.md:8792
msgid "8792    Had `x` been a signed `short`, we could have warned about the undefined behavior upon overflow."
msgstr""

       
# CppCoreGuidelines.md:8793
msgid "8793    ##### Alternatives"
msgstr""

       
# CppCoreGuidelines.md:8794
msgid "8794    * use signed integers and check for `x >= 0`"
msgstr""

# CppCoreGuidelines.md:8795
msgid "8795    * use a positive integer type"
msgstr""

# CppCoreGuidelines.md:8796
msgid "8796    * use an integer subrange type"
msgstr""

# CppCoreGuidelines.md:8797
msgid "8797    * `Assert(-1 < x)`"
msgstr""

       
# CppCoreGuidelines.md:8798
msgid "8798    For example"
msgstr""

       
# CppCoreGuidelines.md:8799
msgid "8799        struct Positive {"
msgstr""

# CppCoreGuidelines.md:8800
msgid "8800            int val;"
msgstr""

# CppCoreGuidelines.md:8801
msgid "8801            Positive(int x) :val{x} { Assert(0 < x); }"
msgstr""

# CppCoreGuidelines.md:8802
msgid "8802            operator int() { return val; }"
msgstr""

# CppCoreGuidelines.md:8803
msgid "8803        };"
msgstr""

       
# CppCoreGuidelines.md:8804
msgid "8804        int f(Positive arg) { return arg; }"
msgstr""

       
# CppCoreGuidelines.md:8805
msgid "8805        int r1 = f(2);"
msgstr""

# CppCoreGuidelines.md:8806
msgid "8806        int r2 = f(-2);  // throws"
msgstr""

       
# CppCoreGuidelines.md:8807
msgid "8807    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8808
msgid "8808    ???"
msgstr""

       
# CppCoreGuidelines.md:8809
msgid "8809    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8810
msgid "8810    Hard: there is a lot of code using `unsigned` and we don't offer a practical positive number type."
msgstr""

       
       
# CppCoreGuidelines.md:8811
msgid "8811    ### <a name=\"Res-subscripts\"></a>ES.107: Don't use `unsigned` for subscripts, prefer `gsl::index`"
msgstr""

       
# CppCoreGuidelines.md:8812
msgid "8812    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8813
msgid "8813    To avoid signed/unsigned confusion."
msgstr""

# CppCoreGuidelines.md:8814
msgid "8814    To enable better optimization."
msgstr""

# CppCoreGuidelines.md:8815
msgid "8815    To enable better error detection."
msgstr""

# CppCoreGuidelines.md:8816
msgid "8816    To avoid the pitfalls with `auto` and `int`."
msgstr""

       
# CppCoreGuidelines.md:8817
msgid "8817    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8818
msgid "8818        vector<int> vec = /*...*/;"
msgstr""

       
# CppCoreGuidelines.md:8819
msgid "8819        for (int i = 0; i < vec.size(); i += 2)                    // may not be big enough"
msgstr""

# CppCoreGuidelines.md:8820
msgid "8820            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8821
msgid "8821        for (unsigned i = 0; i < vec.size(); i += 2)               // risk wraparound"
msgstr""

# CppCoreGuidelines.md:8822
msgid "8822            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8823
msgid "8823        for (auto i = 0; i < vec.size(); i += 2)                   // may not be big enough"
msgstr""

# CppCoreGuidelines.md:8824
msgid "8824            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8825
msgid "8825        for (vector<int>::size_type i = 0; i < vec.size(); i += 2) // verbose"
msgstr""

# CppCoreGuidelines.md:8826
msgid "8826            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8827
msgid "8827        for (auto i = vec.size()-1; i >= 0; i -= 2)                // bug"
msgstr""

# CppCoreGuidelines.md:8828
msgid "8828            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8829
msgid "8829        for (int i = vec.size()-1; i >= 0; i -= 2)                 // may not be big enough"
msgstr""

# CppCoreGuidelines.md:8830
msgid "8830            cout << vec[i] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8831
msgid "8831    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:8832
msgid "8832        vector<int> vec = /*...*/;"
msgstr""

       
# CppCoreGuidelines.md:8833
msgid "8833        for (gsl::index i = 0; i < vec.size(); i += 2)             // ok"
msgstr""

# CppCoreGuidelines.md:8834
msgid "8834            cout << vec[i] << '\\n';"
msgstr""

# CppCoreGuidelines.md:8835
msgid "8835        for (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // ok"
msgstr""

# CppCoreGuidelines.md:8836
msgid "8836            cout << vec[i] << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:8837
msgid "8837    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8838
msgid "8838    The built-in array uses signed subscripts."
msgstr""

# CppCoreGuidelines.md:8839
msgid "8839    The standard-library containers use unsigned subscripts."
msgstr""

# CppCoreGuidelines.md:8840
msgid "8840    Thus, no perfect and fully compatible solution is possible (unless and until the standard-library containers change to use signed subscripts someday in the future)."
msgstr""

# CppCoreGuidelines.md:8841
msgid "8841    Given the known problems with unsigned and signed/unsigned mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed by `gsl::index`."
msgstr""

       
# CppCoreGuidelines.md:8842
msgid "8842    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8843
msgid "8843        template<typename T>"
msgstr""

# CppCoreGuidelines.md:8844
msgid "8844        struct My_container {"
msgstr""

# CppCoreGuidelines.md:8845
msgid "8845        public:"
msgstr""

# CppCoreGuidelines.md:8846
msgid "8846            // ..."
msgstr""

# CppCoreGuidelines.md:8847
msgid "8847            T& operator[](gsl::index i);    // not unsigned"
msgstr""

# CppCoreGuidelines.md:8848
msgid "8848            // ..."
msgstr""

# CppCoreGuidelines.md:8849
msgid "8849        };"
msgstr""

       
# CppCoreGuidelines.md:8850
msgid "8850    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8851
msgid "8851        ??? demonstrate improved code generation and potential for error detection ???"
msgstr""

       
# CppCoreGuidelines.md:8852
msgid "8852    ##### Alternatives"
msgstr""

       
# CppCoreGuidelines.md:8853
msgid "8853    Alternatives for users"
msgstr""

       
# CppCoreGuidelines.md:8854
msgid "8854    * use algorithms"
msgstr""

# CppCoreGuidelines.md:8855
msgid "8855    * use range-for"
msgstr""

# CppCoreGuidelines.md:8856
msgid "8856    * use iterators/pointers"
msgstr""

       
# CppCoreGuidelines.md:8857
msgid "8857    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:8858
msgid "8858    * Very tricky as long as the standard-library containers get it wrong."
msgstr""

# CppCoreGuidelines.md:8859
msgid "8859    * (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one of the arguments is `sizeof` or a call to container `.size()` and the other is `ptrdiff_t`."
msgstr""

       
       
       
       
# CppCoreGuidelines.md:8860
msgid "8860    # <a name=\"S-performance\"></a>Per: Performance"
msgstr""

       
# CppCoreGuidelines.md:8861
msgid "8861    ??? should this section be in the main guide???"
msgstr""

       
# CppCoreGuidelines.md:8862
msgid "8862    This section contains rules for people who need high performance or low-latency."
msgstr""

# CppCoreGuidelines.md:8863
msgid "8863    That is, these are rules that relate to how to use as little time and as few resources as possible to achieve a task in a predictably short time."
msgstr""

# CppCoreGuidelines.md:8864
msgid "8864    The rules in this section are more restrictive and intrusive than what is needed for many (most) applications."
msgstr""

# CppCoreGuidelines.md:8865
msgid "8865    Do not blindly try to follow them in general code: achieving the goals of low latency requires extra work."
msgstr""

       
# CppCoreGuidelines.md:8866
msgid "8866    Performance rule summary:"
msgstr""

       
# CppCoreGuidelines.md:8867
msgid "8867    * [Per.1: Don't optimize without reason](#Rper-reason)"
msgstr""

# CppCoreGuidelines.md:8868
msgid "8868    * [Per.2: Don't optimize prematurely](#Rper-Knuth)"
msgstr""

# CppCoreGuidelines.md:8869
msgid "8869    * [Per.3: Don't optimize something that's not performance critical](#Rper-critical)"
msgstr""

# CppCoreGuidelines.md:8870
msgid "8870    * [Per.4: Don't assume that complicated code is necessarily faster than simple code](#Rper-simple)"
msgstr""

# CppCoreGuidelines.md:8871
msgid "8871    * [Per.5: Don't assume that low-level code is necessarily faster than high-level code](#Rper-low)"
msgstr""

# CppCoreGuidelines.md:8872
msgid "8872    * [Per.6: Don't make claims about performance without measurements](#Rper-measure)"
msgstr""

# CppCoreGuidelines.md:8873
msgid "8873    * [Per.7: Design to enable optimization](#Rper-efficiency)"
msgstr""

# CppCoreGuidelines.md:8874
msgid "8874    * [Per.10: Rely on the static type system](#Rper-type)"
msgstr""

# CppCoreGuidelines.md:8875
msgid "8875    * [Per.11: Move computation from run time to compile time](#Rper-Comp)"
msgstr""

# CppCoreGuidelines.md:8876
msgid "8876    * [Per.12: Eliminate redundant aliases](#Rper-alias)"
msgstr""

# CppCoreGuidelines.md:8877
msgid "8877    * [Per.13: Eliminate redundant indirections](#Rper-indirect)"
msgstr""

# CppCoreGuidelines.md:8878
msgid "8878    * [Per.14: Minimize the number of allocations and deallocations](#Rper-alloc)"
msgstr""

# CppCoreGuidelines.md:8879
msgid "8879    * [Per.15: Do not allocate on a critical branch](#Rper-alloc0)"
msgstr""

# CppCoreGuidelines.md:8880
msgid "8880    * [Per.16: Use compact data structures](#Rper-compact)"
msgstr""

# CppCoreGuidelines.md:8881
msgid "8881    * [Per.17: Declare the most used member of a time-critical struct first](#Rper-struct)"
msgstr""

# CppCoreGuidelines.md:8882
msgid "8882    * [Per.18: Space is time](#Rper-space)"
msgstr""

# CppCoreGuidelines.md:8883
msgid "8883    * [Per.19: Access memory predictably](#Rper-access)"
msgstr""

# CppCoreGuidelines.md:8884
msgid "8884    * [Per.30: Avoid context switches on the critical path](#Rper-context)"
msgstr""

       
# CppCoreGuidelines.md:8885
msgid "8885    ### <a name=\"Rper-reason\"></a>Per.1: Don't optimize without reason"
msgstr""

       
# CppCoreGuidelines.md:8886
msgid "8886    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8887
msgid "8887    If there is no need for optimization, the main result of the effort will be more errors and higher maintenance costs."
msgstr""

       
# CppCoreGuidelines.md:8888
msgid "8888    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8889
msgid "8889    Some people optimize out of habit or because it's fun."
msgstr""

       
# CppCoreGuidelines.md:8890
msgid "8890    ???"
msgstr""

       
# CppCoreGuidelines.md:8891
msgid "8891    ### <a name=\"Rper-Knuth\"></a>Per.2: Don't optimize prematurely"
msgstr""

       
# CppCoreGuidelines.md:8892
msgid "8892    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8893
msgid "8893    Elaborately optimized code is usually larger and harder to change than unoptimized code."
msgstr""

       
# CppCoreGuidelines.md:8894
msgid "8894    ???"
msgstr""

       
# CppCoreGuidelines.md:8895
msgid "8895    ### <a name=\"Rper-critical\"></a>Per.3: Don't optimize something that's not performance critical"
msgstr""

       
# CppCoreGuidelines.md:8896
msgid "8896    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8897
msgid "8897    Optimizing a non-performance-critical part of a program has no effect on system performance."
msgstr""

       
# CppCoreGuidelines.md:8898
msgid "8898    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8899
msgid "8899    If your program spends most of its time waiting for the web or for a human, optimization of in-memory computation is probably useless."
msgstr""

       
# CppCoreGuidelines.md:8900
msgid "8900    Put another way: If your program spends 4% of its processing time doing"
msgstr""

# CppCoreGuidelines.md:8901
msgid "8901    computation A and 40% of its time doing computation B, a 50% improvement on A is"
msgstr""

# CppCoreGuidelines.md:8902
msgid "8902    only as impactful as a 5% improvement on B. (If you don't even know how much"
msgstr""

# CppCoreGuidelines.md:8903
msgid "8903    time is spent on A or B, see <a href=\"#Rper-reason\">Per.1</a> and <a"
msgstr""

# CppCoreGuidelines.md:8904
msgid "8904    href=\"#Rper-Knuth\">Per.2</a>.)"
msgstr""

       
# CppCoreGuidelines.md:8905
msgid "8905    ### <a name=\"Rper-simple\"></a>Per.4: Don't assume that complicated code is necessarily faster than simple code"
msgstr""

       
# CppCoreGuidelines.md:8906
msgid "8906    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8907
msgid "8907    Simple code can be very fast. Optimizers sometimes do marvels with simple code"
msgstr""

       
# CppCoreGuidelines.md:8908
msgid "8908    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:8909
msgid "8909        // clear expression of intent, fast execution"
msgstr""

       
# CppCoreGuidelines.md:8910
msgid "8910        vector<uint8_t> v(100000);"
msgstr""

       
# CppCoreGuidelines.md:8911
msgid "8911        for (auto& c : v)"
msgstr""

# CppCoreGuidelines.md:8912
msgid "8912            c = ~c;"
msgstr""

       
# CppCoreGuidelines.md:8913
msgid "8913    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:8914
msgid "8914        // intended to be faster, but is actually slower"
msgstr""

       
# CppCoreGuidelines.md:8915
msgid "8915        vector<uint8_t> v(100000);"
msgstr""

       
# CppCoreGuidelines.md:8916
msgid "8916        for (size_t i = 0; i < v.size(); i += sizeof(uint64_t))"
msgstr""

# CppCoreGuidelines.md:8917
msgid "8917        {"
msgstr""

# CppCoreGuidelines.md:8918
msgid "8918            uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);"
msgstr""

# CppCoreGuidelines.md:8919
msgid "8919            quad_word = ~quad_word;"
msgstr""

# CppCoreGuidelines.md:8920
msgid "8920        }"
msgstr""

       
# CppCoreGuidelines.md:8921
msgid "8921    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8922
msgid "8922    ???"
msgstr""

       
# CppCoreGuidelines.md:8923
msgid "8923    ???"
msgstr""

       
# CppCoreGuidelines.md:8924
msgid "8924    ### <a name=\"Rper-low\"></a>Per.5: Don't assume that low-level code is necessarily faster than high-level code"
msgstr""

       
# CppCoreGuidelines.md:8925
msgid "8925    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8926
msgid "8926    Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code."
msgstr""

       
# CppCoreGuidelines.md:8927
msgid "8927    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8928
msgid "8928    ???"
msgstr""

       
# CppCoreGuidelines.md:8929
msgid "8929    ???"
msgstr""

       
# CppCoreGuidelines.md:8930
msgid "8930    ### <a name=\"Rper-measure\"></a>Per.6: Don't make claims about performance without measurements"
msgstr""

       
# CppCoreGuidelines.md:8931
msgid "8931    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8932
msgid "8932    The field of performance is littered with myth and bogus folklore."
msgstr""

# CppCoreGuidelines.md:8933
msgid "8933    Modern hardware and optimizers defy naive assumptions; even experts are regularly surprised."
msgstr""

       
# CppCoreGuidelines.md:8934
msgid "8934    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8935
msgid "8935    Getting good performance measurements can be hard and require specialized tools."
msgstr""

       
# CppCoreGuidelines.md:8936
msgid "8936    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8937
msgid "8937    A few simple microbenchmarks using Unix `time` or the standard-library `<chrono>` can help dispel the most obvious myths."
msgstr""

# CppCoreGuidelines.md:8938
msgid "8938    If you can't measure your complete system accurately, at least try to measure a few of your key operations and algorithms."
msgstr""

# CppCoreGuidelines.md:8939
msgid "8939    A profiler can help tell you which parts of your system are performance critical."
msgstr""

# CppCoreGuidelines.md:8940
msgid "8940    Often, you will be surprised."
msgstr""

       
# CppCoreGuidelines.md:8941
msgid "8941    ???"
msgstr""

       
# CppCoreGuidelines.md:8942
msgid "8942    ### <a name=\"Rper-efficiency\"></a>Per.7: Design to enable optimization"
msgstr""

       
# CppCoreGuidelines.md:8943
msgid "8943    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:8944
msgid "8944    Because we often need to optimize the initial design."
msgstr""

# CppCoreGuidelines.md:8945
msgid "8945    Because a design that ignore the possibility of later improvement is hard to change."
msgstr""

       
# CppCoreGuidelines.md:8946
msgid "8946    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:8947
msgid "8947    From the C (and C++) standard:"
msgstr""

       
# CppCoreGuidelines.md:8948
msgid "8948        void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));"
msgstr""

       
# CppCoreGuidelines.md:8949
msgid "8949    When did you even want to sort memory?"
msgstr""

# CppCoreGuidelines.md:8950
msgid "8950    Really, we sort sequences of elements, typically stored in containers."
msgstr""

# CppCoreGuidelines.md:8951
msgid "8951    A call to `qsort` throws away much useful information (e.g., the element type), forces the user to repeat information"
msgstr""

# CppCoreGuidelines.md:8952
msgid "8952    already known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare `double`s)."
msgstr""

# CppCoreGuidelines.md:8953
msgid "8953    This implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization."
msgstr""

       
# CppCoreGuidelines.md:8954
msgid "8954        double data[100];"
msgstr""

# CppCoreGuidelines.md:8955
msgid "8955        // ... fill a ..."
msgstr""

       
# CppCoreGuidelines.md:8956
msgid "8956        // 100 chunks of memory of sizeof(double) starting at"
msgstr""

# CppCoreGuidelines.md:8957
msgid "8957        // address data using the order defined by compare_doubles"
msgstr""

# CppCoreGuidelines.md:8958
msgid "8958        qsort(data, 100, sizeof(double), compare_doubles);"
msgstr""

       
# CppCoreGuidelines.md:8959
msgid "8959    From the point of view of interface design is that `qsort` throws away useful information."
msgstr""

       
# CppCoreGuidelines.md:8960
msgid "8960    We can do better (in C++98)"
msgstr""

       
# CppCoreGuidelines.md:8961
msgid "8961        template<typename Iter>"
msgstr""

# CppCoreGuidelines.md:8962
msgid "8962            void sort(Iter b, Iter e);  // sort [b:e)"
msgstr""

       
# CppCoreGuidelines.md:8963
msgid "8963        sort(data, data + 100);"
msgstr""

       
# CppCoreGuidelines.md:8964
msgid "8964    Here, we use the compiler's knowledge about the size of the array, the type of elements, and how to compare `double`s."
msgstr""

       
# CppCoreGuidelines.md:8965
msgid "8965    With C++11 plus [concepts](#SS-concepts), we can do better still"
msgstr""

       
# CppCoreGuidelines.md:8966
msgid "8966        // Sortable specifies that c must be a"
msgstr""

# CppCoreGuidelines.md:8967
msgid "8967        // random-access sequence of elements comparable with <"
msgstr""

# CppCoreGuidelines.md:8968
msgid "8968        void sort(Sortable& c);"
msgstr""

       
# CppCoreGuidelines.md:8969
msgid "8969        sort(c);"
msgstr""

       
# CppCoreGuidelines.md:8970
msgid "8970    The key is to pass sufficient information for a good implementation to be chosen."
msgstr""

# CppCoreGuidelines.md:8971
msgid "8971    In this, the `sort` interfaces shown here still have a weakness:"
msgstr""

# CppCoreGuidelines.md:8972
msgid "8972    They implicitly rely on the element type having less-than (`<`) defined."
msgstr""

# CppCoreGuidelines.md:8973
msgid "8973    To complete the interface, we need a second version that accepts a comparison criteria:"
msgstr""

       
# CppCoreGuidelines.md:8974
msgid "8974        // compare elements of c using p"
msgstr""

# CppCoreGuidelines.md:8975
msgid "8975        void sort(Sortable& c, Predicate<Value_type<Sortable>> p);"
msgstr""

       
# CppCoreGuidelines.md:8976
msgid "8976    The standard-library specification of `sort` offers those two versions,"
msgstr""

# CppCoreGuidelines.md:8977
msgid "8977    but the semantics is expressed in English rather than code using concepts."
msgstr""

       
# CppCoreGuidelines.md:8978
msgid "8978    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:8979
msgid "8979    Premature optimization is said to be [the root of all evil](#Rper-Knuth), but that's not a reason to despise performance."
msgstr""

# CppCoreGuidelines.md:8980
msgid "8980    It is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement."
msgstr""

# CppCoreGuidelines.md:8981
msgid "8981    Aim to build a set of habits that by default results in efficient, maintainable, and optimizable code."
msgstr""

# CppCoreGuidelines.md:8982
msgid "8982    In particular, when you write a function that is not a one-off implementation detail, consider"
msgstr""

       
# CppCoreGuidelines.md:8983
msgid "8983    * Information passing:"
msgstr""

# CppCoreGuidelines.md:8984
msgid "8984    Prefer clean [interfaces](#S-interfaces) carrying sufficient information for later improvement of implementation."
msgstr""

# CppCoreGuidelines.md:8985
msgid "8985    Note that information flows into and out of an implementation through the interfaces we provide."
msgstr""

# CppCoreGuidelines.md:8986
msgid "8986    * Compact data: By default, [use compact data](#Rper-compact), such as `std::vector` and [access it in a systematic fashion](#Rper-access)."
msgstr""

# CppCoreGuidelines.md:8987
msgid "8987    If you think you need a linked structure, try to craft the interface so that this structure isn't seen by users."
msgstr""

# CppCoreGuidelines.md:8988
msgid "8988    * Function argument passing and return:"
msgstr""

# CppCoreGuidelines.md:8989
msgid "8989    Distinguish between mutable and non-mutable data."
msgstr""

# CppCoreGuidelines.md:8990
msgid "8990    Don't impose a resource management burden on your users."
msgstr""

# CppCoreGuidelines.md:8991
msgid "8991    Don't impose spurious run-time indirections on your users."
msgstr""

# CppCoreGuidelines.md:8992
msgid "8992    Use [conventional ways](#Rf-conventional) of passing information through an interface;"
msgstr""

# CppCoreGuidelines.md:8993
msgid "8993    unconventional and/or \"optimized\" ways of passing data can seriously complicate later reimplementation."
msgstr""

# CppCoreGuidelines.md:8994
msgid "8994    * Abstraction:"
msgstr""

# CppCoreGuidelines.md:8995
msgid "8995    Don't overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later"
msgstr""

# CppCoreGuidelines.md:8996
msgid "8996    (using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess."
msgstr""

# CppCoreGuidelines.md:8997
msgid "8997    Generalize from concrete examples, preserving performance as we generalize."
msgstr""

# CppCoreGuidelines.md:8998
msgid "8998    Do not generalize based on mere speculation about future needs."
msgstr""

# CppCoreGuidelines.md:8999
msgid "8999    The ideal is zero-overhead generalization."
msgstr""

# CppCoreGuidelines.md:9000
msgid "9000    * Libraries:"
msgstr""

# CppCoreGuidelines.md:9001
msgid "9001    Use libraries with good interfaces."
msgstr""

# CppCoreGuidelines.md:9002
msgid "9002    If no library is available build one yourself and imitate the interface style from a good library."
msgstr""

# CppCoreGuidelines.md:9003
msgid "9003    The [standard library](#S-stdlib) is a good first place to look for inspiration."
msgstr""

# CppCoreGuidelines.md:9004
msgid "9004    * Isolation:"
msgstr""

# CppCoreGuidelines.md:9005
msgid "9005    Isolate your code from messy and/or old-style code by providing an interface of your choosing to it."
msgstr""

# CppCoreGuidelines.md:9006
msgid "9006    This is sometimes called \"providing a wrapper\" for the useful/necessary but messy code."
msgstr""

# CppCoreGuidelines.md:9007
msgid "9007    Don't let bad designs \"bleed into\" your code."
msgstr""

       
# CppCoreGuidelines.md:9008
msgid "9008    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9009
msgid "9009    Consider:"
msgstr""

       
# CppCoreGuidelines.md:9010
msgid "9010        template <class ForwardIterator, class T>"
msgstr""

# CppCoreGuidelines.md:9011
msgid "9011        bool binary_search(ForwardIterator first, ForwardIterator last, const T& val);"
msgstr""

       
# CppCoreGuidelines.md:9012
msgid "9012    `binary_search(begin(c), end(c), 7)` will tell you whether `7` is in `c` or not."
msgstr""

# CppCoreGuidelines.md:9013
msgid "9013    However, it will not tell you where that `7` is or whether there are more than one `7`."
msgstr""

       
# CppCoreGuidelines.md:9014
msgid "9014    Sometimes, just passing the minimal amount of information back (here, `true` or `false`) is sufficient, but a good interface passes"
msgstr""

# CppCoreGuidelines.md:9015
msgid "9015    needed information back to the caller. Therefore, the standard library also offers"
msgstr""

       
# CppCoreGuidelines.md:9016
msgid "9016        template <class ForwardIterator, class T>"
msgstr""

# CppCoreGuidelines.md:9017
msgid "9017        ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);"
msgstr""

       
# CppCoreGuidelines.md:9018
msgid "9018    `lower_bound` returns an iterator to the first match if any, otherwise to the first element greater than `val`, or `last` if no such element is found."
msgstr""

       
# CppCoreGuidelines.md:9019
msgid "9019    However, `lower_bound` still doesn't return enough information for all uses, so the standard library also offers"
msgstr""

       
# CppCoreGuidelines.md:9020
msgid "9020        template <class ForwardIterator, class T>"
msgstr""

# CppCoreGuidelines.md:9021
msgid "9021        pair<ForwardIterator, ForwardIterator>"
msgstr""

# CppCoreGuidelines.md:9022
msgid "9022        equal_range(ForwardIterator first, ForwardIterator last, const T& val);"
msgstr""

       
# CppCoreGuidelines.md:9023
msgid "9023    `equal_range` returns a `pair` of iterators specifying the first and one beyond last match."
msgstr""

       
# CppCoreGuidelines.md:9024
msgid "9024        auto r = equal_range(begin(c), end(c), 7);"
msgstr""

# CppCoreGuidelines.md:9025
msgid "9025        for (auto p = r.first(); p != r.second(), ++p)"
msgstr""

# CppCoreGuidelines.md:9026
msgid "9026            cout << *p << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:9027
msgid "9027    Obviously, these three interfaces are implemented by the same basic code."
msgstr""

# CppCoreGuidelines.md:9028
msgid "9028    They are simply three ways of presenting the basic binary search algorithm to users,"
msgstr""

# CppCoreGuidelines.md:9029
msgid "9029    ranging from the simplest (\"make simple things simple!\")"
msgstr""

# CppCoreGuidelines.md:9030
msgid "9030    to returning complete, but not always needed, information (\"don't hide useful information\")."
msgstr""

# CppCoreGuidelines.md:9031
msgid "9031    Naturally, crafting such a set of interfaces requires experience and domain knowledge."
msgstr""

       
# CppCoreGuidelines.md:9032
msgid "9032    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9033
msgid "9033    Do not simply craft the interface to match the first implementation and the first use case you think of."
msgstr""

# CppCoreGuidelines.md:9034
msgid "9034    Once your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy."
msgstr""

       
# CppCoreGuidelines.md:9035
msgid "9035    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9036
msgid "9036    A need for efficiency does not imply a need for [low-level code](#Rper-low)."
msgstr""

# CppCoreGuidelines.md:9037
msgid "9037    High-level code does not imply slow or bloated."
msgstr""

       
# CppCoreGuidelines.md:9038
msgid "9038    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9039
msgid "9039    Things have costs."
msgstr""

# CppCoreGuidelines.md:9040
msgid "9040    Don't be paranoid about costs (modern computers really are very fast),"
msgstr""

# CppCoreGuidelines.md:9041
msgid "9041    but have a rough idea of the order of magnitude of cost of what you use."
msgstr""

# CppCoreGuidelines.md:9042
msgid "9042    For example, have a rough idea of the cost of"
msgstr""

# CppCoreGuidelines.md:9043
msgid "9043    a memory access,"
msgstr""

# CppCoreGuidelines.md:9044
msgid "9044    a function call,"
msgstr""

# CppCoreGuidelines.md:9045
msgid "9045    a string comparison,"
msgstr""

# CppCoreGuidelines.md:9046
msgid "9046    a system call,"
msgstr""

# CppCoreGuidelines.md:9047
msgid "9047    a disk access,"
msgstr""

# CppCoreGuidelines.md:9048
msgid "9048    and a message through a network."
msgstr""

       
# CppCoreGuidelines.md:9049
msgid "9049    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9050
msgid "9050    If you can only think of one implementation, you probably don't have something for which you can devise a stable interface."
msgstr""

# CppCoreGuidelines.md:9051
msgid "9051    Maybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider."
msgstr""

# CppCoreGuidelines.md:9052
msgid "9052    One question that can be useful is"
msgstr""

# CppCoreGuidelines.md:9053
msgid "9053    \"what interface would be needed if this operation should be implemented using multiple threads? be vectorized?\""
msgstr""

       
# CppCoreGuidelines.md:9054
msgid "9054    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9055
msgid "9055    This rule does not contradict the [Don't optimize prematurely](#Rper-Knuth) rule."
msgstr""

# CppCoreGuidelines.md:9056
msgid "9056    It complements it encouraging developers enable later - appropriate and non-premature - optimization, if and where needed."
msgstr""

       
# CppCoreGuidelines.md:9057
msgid "9057    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9058
msgid "9058    Tricky."
msgstr""

# CppCoreGuidelines.md:9059
msgid "9059    Maybe looking for `void*` function arguments will find examples of interfaces that hinder later optimization."
msgstr""

       
# CppCoreGuidelines.md:9060
msgid "9060    ### <a name=\"Rper-type\"></a>Per.10: Rely on the static type system"
msgstr""

       
# CppCoreGuidelines.md:9061
msgid "9061    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9062
msgid "9062    Type violations, weak types (e.g. `void*`s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code."
msgstr""

       
# CppCoreGuidelines.md:9063
msgid "9063    ???"
msgstr""

       
# CppCoreGuidelines.md:9064
msgid "9064    ### <a name=\"Rper-Comp\"></a>Per.11: Move computation from run time to compile time"
msgstr""

       
# CppCoreGuidelines.md:9065
msgid "9065    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9066
msgid "9066    To decrease code size and run time."
msgstr""

# CppCoreGuidelines.md:9067
msgid "9067    To avoid data races by using constants."
msgstr""

# CppCoreGuidelines.md:9068
msgid "9068    To catch errors at compile time (and thus eliminate the need for error-handling code)."
msgstr""

       
# CppCoreGuidelines.md:9069
msgid "9069    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9070
msgid "9070        double square(double d) { return d*d; }"
msgstr""

# CppCoreGuidelines.md:9071
msgid "9071        static double s2 = square(2);    // old-style: dynamic initialization"
msgstr""

       
# CppCoreGuidelines.md:9072
msgid "9072        constexpr double ntimes(double d, int n)   // assume 0 <= n"
msgstr""

# CppCoreGuidelines.md:9073
msgid "9073        {"
msgstr""

# CppCoreGuidelines.md:9074
msgid "9074                double m = 1;"
msgstr""

# CppCoreGuidelines.md:9075
msgid "9075                while (n--) m *= d;"
msgstr""

# CppCoreGuidelines.md:9076
msgid "9076                return m;"
msgstr""

# CppCoreGuidelines.md:9077
msgid "9077        }"
msgstr""

# CppCoreGuidelines.md:9078
msgid "9078        constexpr double s3 {ntimes(2, 3)};  // modern-style: compile-time initialization"
msgstr""

       
# CppCoreGuidelines.md:9079
msgid "9079    Code like the initialization of `s2` isn't uncommon, especially for initialization that's a bit more complicated than `square()`."
msgstr""

# CppCoreGuidelines.md:9080
msgid "9080    However, compared to the initialization of `s3` there are two problems:"
msgstr""

       
# CppCoreGuidelines.md:9081
msgid "9081    * we suffer the overhead of a function call at run time"
msgstr""

# CppCoreGuidelines.md:9082
msgid "9082    * `s2` just might be accessed by another thread before the initialization happens."
msgstr""

       
# CppCoreGuidelines.md:9083
msgid "9083    Note: you can't have a data race on a constant."
msgstr""

       
# CppCoreGuidelines.md:9084
msgid "9084    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9085
msgid "9085    Consider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap."
msgstr""

       
# CppCoreGuidelines.md:9086
msgid "9086        constexpr int on_stack_max = 20;"
msgstr""

       
# CppCoreGuidelines.md:9087
msgid "9087        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9088
msgid "9088        struct Scoped {     // store a T in Scoped"
msgstr""

# CppCoreGuidelines.md:9089
msgid "9089                // ..."
msgstr""

# CppCoreGuidelines.md:9090
msgid "9090            T obj;"
msgstr""

# CppCoreGuidelines.md:9091
msgid "9091        };"
msgstr""

       
# CppCoreGuidelines.md:9092
msgid "9092        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9093
msgid "9093        struct On_heap {    // store a T on the free store"
msgstr""

# CppCoreGuidelines.md:9094
msgid "9094                // ..."
msgstr""

# CppCoreGuidelines.md:9095
msgid "9095                T* objp;"
msgstr""

# CppCoreGuidelines.md:9096
msgid "9096        };"
msgstr""

       
# CppCoreGuidelines.md:9097
msgid "9097        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9098
msgid "9098        using Handle = typename std::conditional<(sizeof(T) <= on_stack_max),"
msgstr""

# CppCoreGuidelines.md:9099
msgid "9099                            Scoped<T>,      // first alternative"
msgstr""

# CppCoreGuidelines.md:9100
msgid "9100                            On_heap<T>      // second alternative"
msgstr""

# CppCoreGuidelines.md:9101
msgid "9101                       >::type;"
msgstr""

       
# CppCoreGuidelines.md:9102
msgid "9102        void f()"
msgstr""

# CppCoreGuidelines.md:9103
msgid "9103        {"
msgstr""

# CppCoreGuidelines.md:9104
msgid "9104            Handle<double> v1;                   // the double goes on the stack"
msgstr""

# CppCoreGuidelines.md:9105
msgid "9105            Handle<std::array<double, 200>> v2;  // the array goes on the free store"
msgstr""

# CppCoreGuidelines.md:9106
msgid "9106            // ..."
msgstr""

# CppCoreGuidelines.md:9107
msgid "9107        }"
msgstr""

       
# CppCoreGuidelines.md:9108
msgid "9108    Assume that `Scoped` and `On_heap` provide compatible user interfaces."
msgstr""

# CppCoreGuidelines.md:9109
msgid "9109    Here we compute the optimal type to use at compile time."
msgstr""

# CppCoreGuidelines.md:9110
msgid "9110    There are similar techniques for selecting the optimal function to call."
msgstr""

       
# CppCoreGuidelines.md:9111
msgid "9111    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9112
msgid "9112    The ideal is {not} to try execute everything at compile time."
msgstr""

# CppCoreGuidelines.md:9113
msgid "9113    Obviously, most computations depend on inputs so they can't be moved to compile time,"
msgstr""

# CppCoreGuidelines.md:9114
msgid "9114    but beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times"
msgstr""

# CppCoreGuidelines.md:9115
msgid "9115    and complicate debugging."
msgstr""

# CppCoreGuidelines.md:9116
msgid "9116    It is even possible to slow down code by compile-time computation."
msgstr""

# CppCoreGuidelines.md:9117
msgid "9117    This is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations it is possible to render the instruction cache less effective."
msgstr""

       
# CppCoreGuidelines.md:9118
msgid "9118    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9119
msgid "9119    * Look for simple functions that might be constexpr (but are not)."
msgstr""

# CppCoreGuidelines.md:9120
msgid "9120    * Look for functions called with all constant-expression arguments."
msgstr""

# CppCoreGuidelines.md:9121
msgid "9121    * Look for macros that could be constexpr."
msgstr""

       
# CppCoreGuidelines.md:9122
msgid "9122    ### <a name=\"Rper-alias\"></a>Per.12: Eliminate redundant aliases"
msgstr""

       
# CppCoreGuidelines.md:9123
msgid "9123    ???"
msgstr""

       
# CppCoreGuidelines.md:9124
msgid "9124    ### <a name=\"Rper-indirect\"></a>Per.13: Eliminate redundant indirections"
msgstr""

       
# CppCoreGuidelines.md:9125
msgid "9125    ???"
msgstr""

       
# CppCoreGuidelines.md:9126
msgid "9126    ### <a name=\"Rper-alloc\"></a>Per.14: Minimize the number of allocations and deallocations"
msgstr""

       
# CppCoreGuidelines.md:9127
msgid "9127    ???"
msgstr""

       
# CppCoreGuidelines.md:9128
msgid "9128    ### <a name=\"Rper-alloc0\"></a>Per.15: Do not allocate on a critical branch"
msgstr""

       
# CppCoreGuidelines.md:9129
msgid "9129    ???"
msgstr""

       
# CppCoreGuidelines.md:9130
msgid "9130    ### <a name=\"Rper-compact\"></a>Per.16: Use compact data structures"
msgstr""

       
# CppCoreGuidelines.md:9131
msgid "9131    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9132
msgid "9132    Performance is typically dominated by memory access times."
msgstr""

       
# CppCoreGuidelines.md:9133
msgid "9133    ???"
msgstr""

       
# CppCoreGuidelines.md:9134
msgid "9134    ### <a name=\"Rper-struct\"></a>Per.17: Declare the most used member of a time-critical struct first"
msgstr""

       
# CppCoreGuidelines.md:9135
msgid "9135    ???"
msgstr""

       
# CppCoreGuidelines.md:9136
msgid "9136    ### <a name=\"Rper-space\"></a>Per.18: Space is time"
msgstr""

       
# CppCoreGuidelines.md:9137
msgid "9137    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9138
msgid "9138    Performance is typically dominated by memory access times."
msgstr""

       
# CppCoreGuidelines.md:9139
msgid "9139    ???"
msgstr""

       
# CppCoreGuidelines.md:9140
msgid "9140    ### <a name=\"Rper-access\"></a>Per.19: Access memory predictably"
msgstr""

       
# CppCoreGuidelines.md:9141
msgid "9141    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9142
msgid "9142    Performance is very sensitive to cache performance and cache algorithms favor simple (usually linear) access to adjacent data."
msgstr""

       
# CppCoreGuidelines.md:9143
msgid "9143    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9144
msgid "9144        int matrix[rows][cols];"
msgstr""

       
# CppCoreGuidelines.md:9145
msgid "9145        // bad"
msgstr""

# CppCoreGuidelines.md:9146
msgid "9146        for (int c = 0; c < cols; ++c)"
msgstr""

# CppCoreGuidelines.md:9147
msgid "9147            for (int r = 0; r < rows; ++r)"
msgstr""

# CppCoreGuidelines.md:9148
msgid "9148                sum += matrix[r][c];"
msgstr""

       
# CppCoreGuidelines.md:9149
msgid "9149        // good"
msgstr""

# CppCoreGuidelines.md:9150
msgid "9150        for (int r = 0; r < rows; ++r)"
msgstr""

# CppCoreGuidelines.md:9151
msgid "9151            for (int c = 0; c < cols; ++c)"
msgstr""

# CppCoreGuidelines.md:9152
msgid "9152                sum += matrix[r][c];"
msgstr""

       
# CppCoreGuidelines.md:9153
msgid "9153    ### <a name=\"Rper-context\"></a>Per.30: Avoid context switches on the critical path"
msgstr""

       
# CppCoreGuidelines.md:9154
msgid "9154    ???"
msgstr""

       
# CppCoreGuidelines.md:9155
msgid "9155    # <a name=\"S-concurrency\"></a>CP: Concurrency and parallelism"
msgstr""

       
# CppCoreGuidelines.md:9156
msgid "9156    We often want our computers to do many tasks at the same time (or at least make them appear to do them at the same time)."
msgstr""

# CppCoreGuidelines.md:9157
msgid "9157    The reasons for doing so varies (e.g., wanting to wait for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities)"
msgstr""

# CppCoreGuidelines.md:9158
msgid "9158    and so does the basic facilities for expressing concurrency and parallelism."
msgstr""

# CppCoreGuidelines.md:9159
msgid "9159    Here, we articulate a few general principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism."
msgstr""

       
# CppCoreGuidelines.md:9160
msgid "9160    The core machine support for concurrent and parallel programming is the thread."
msgstr""

# CppCoreGuidelines.md:9161
msgid "9161    Threads allow you to run multiple instances of your program independently, while sharing"
msgstr""

# CppCoreGuidelines.md:9162
msgid "9162    the same memory. Concurrent programming is tricky for many reasons, most"
msgstr""

# CppCoreGuidelines.md:9163
msgid "9163    importantly that it is undefined behavior to read data in one thread after it"
msgstr""

# CppCoreGuidelines.md:9164
msgid "9164    was written by another thread, if there is no proper synchronization between"
msgstr""

# CppCoreGuidelines.md:9165
msgid "9165    those threads. Making existing single-threaded code execute concurrently can be"
msgstr""

# CppCoreGuidelines.md:9166
msgid "9166    as trivial as adding `std::async` or `std::thread` strategically, or it can"
msgstr""

# CppCoreGuidelines.md:9167
msgid "9167    necessitate a full rewrite, depending on whether the original code was written"
msgstr""

# CppCoreGuidelines.md:9168
msgid "9168    in a thread-friendly way."
msgstr""

       
# CppCoreGuidelines.md:9169
msgid "9169    The concurrency/parallelism rules in this document are designed with three goals"
msgstr""

# CppCoreGuidelines.md:9170
msgid "9170    in mind:"
msgstr""

       
# CppCoreGuidelines.md:9171
msgid "9171    * To help you write code that is amenable to being used in a threaded"
msgstr""

# CppCoreGuidelines.md:9172
msgid "9172      environment"
msgstr""

# CppCoreGuidelines.md:9173
msgid "9173    * To show clean, safe ways to use the threading primitives offered by the"
msgstr""

# CppCoreGuidelines.md:9174
msgid "9174      standard library"
msgstr""

# CppCoreGuidelines.md:9175
msgid "9175    * To offer guidance on what to do when concurrency and parallelism aren't giving"
msgstr""

# CppCoreGuidelines.md:9176
msgid "9176      you the performance gains you need"
msgstr""

       
# CppCoreGuidelines.md:9177
msgid "9177    It is also important to note that concurrency in C++ is an unfinished"
msgstr""

# CppCoreGuidelines.md:9178
msgid "9178    story. C++11 introduced many core concurrency primitives, C++14 improved on"
msgstr""

# CppCoreGuidelines.md:9179
msgid "9179    them, and it seems that there is much interest in making the writing of"
msgstr""

# CppCoreGuidelines.md:9180
msgid "9180    concurrent programs in C++ even easier. We expect some of the library-related"
msgstr""

# CppCoreGuidelines.md:9181
msgid "9181    guidance here to change significantly over time."
msgstr""

       
# CppCoreGuidelines.md:9182
msgid "9182    This section needs a lot of work (obviously)."
msgstr""

# CppCoreGuidelines.md:9183
msgid "9183    Please note that we start with rules for relative non-experts."
msgstr""

# CppCoreGuidelines.md:9184
msgid "9184    Real experts must wait a bit;"
msgstr""

# CppCoreGuidelines.md:9185
msgid "9185    contributions are welcome,"
msgstr""

# CppCoreGuidelines.md:9186
msgid "9186    but please think about the majority of programmers who are struggling to get their concurrent programs correct and performant."
msgstr""

       
# CppCoreGuidelines.md:9187
msgid "9187    Concurrency and parallelism rule summary:"
msgstr""

       
# CppCoreGuidelines.md:9188
msgid "9188    * [CP.1: Assume that your code will run as part of a multi-threaded program](#Rconc-multi)"
msgstr""

# CppCoreGuidelines.md:9189
msgid "9189    * [CP.2: Avoid data races](#Rconc-races)"
msgstr""

# CppCoreGuidelines.md:9190
msgid "9190    * [CP.3: Minimize explicit sharing of writable data](#Rconc-data)"
msgstr""

# CppCoreGuidelines.md:9191
msgid "9191    * [CP.4: Think in terms of tasks, rather than threads](#Rconc-task)"
msgstr""

# CppCoreGuidelines.md:9192
msgid "9192    * [CP.8: Don't try to use `volatile` for synchronization](#Rconc-volatile)"
msgstr""

# CppCoreGuidelines.md:9193
msgid "9193    * [CP.9: Whenever feasible use tools to validate your concurrent code](#Rconc-tools)"
msgstr""

       
# CppCoreGuidelines.md:9194
msgid "9194    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:9195
msgid "9195    * [CP.con: Concurrency](#SScp-con)"
msgstr""

# CppCoreGuidelines.md:9196
msgid "9196    * [CP.par: Parallelism](#SScp-par)"
msgstr""

# CppCoreGuidelines.md:9197
msgid "9197    * [CP.mess: Message passing](#SScp-mess)"
msgstr""

# CppCoreGuidelines.md:9198
msgid "9198    * [CP.vec: Vectorization](#SScp-vec)"
msgstr""

# CppCoreGuidelines.md:9199
msgid "9199    * [CP.free: Lock-free programming](#SScp-free)"
msgstr""

# CppCoreGuidelines.md:9200
msgid "9200    * [CP.etc: Etc. concurrency rules](#SScp-etc)"
msgstr""

       
# CppCoreGuidelines.md:9201
msgid "9201    ### <a name=\"Rconc-multi\"></a>CP.1: Assume that your code will run as part of a multi-threaded program"
msgstr""

       
# CppCoreGuidelines.md:9202
msgid "9202    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9203
msgid "9203    It is hard to be certain that concurrency isn't used now or will be sometime in the future."
msgstr""

# CppCoreGuidelines.md:9204
msgid "9204    Code gets reused."
msgstr""

# CppCoreGuidelines.md:9205
msgid "9205    Libraries using threads may be used from some other part of the program."
msgstr""

# CppCoreGuidelines.md:9206
msgid "9206    Note that this applies most urgently to library code and least urgently to stand-alone applications."
msgstr""

# CppCoreGuidelines.md:9207
msgid "9207    However, thanks to the magic of cut-and-paste, code fragments can turn up in unexpected places."
msgstr""

       
# CppCoreGuidelines.md:9208
msgid "9208    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9209
msgid "9209        double cached_computation(double x)"
msgstr""

# CppCoreGuidelines.md:9210
msgid "9210        {"
msgstr""

# CppCoreGuidelines.md:9211
msgid "9211            static double cached_x = 0.0;"
msgstr""

# CppCoreGuidelines.md:9212
msgid "9212            static double cached_result = COMPUTATION_OF_ZERO;"
msgstr""

# CppCoreGuidelines.md:9213
msgid "9213            double result;"
msgstr""

       
# CppCoreGuidelines.md:9214
msgid "9214            if (cached_x == x)"
msgstr""

# CppCoreGuidelines.md:9215
msgid "9215                return cached_result;"
msgstr""

# CppCoreGuidelines.md:9216
msgid "9216            result = computation(x);"
msgstr""

# CppCoreGuidelines.md:9217
msgid "9217            cached_x = x;"
msgstr""

# CppCoreGuidelines.md:9218
msgid "9218            cached_result = result;"
msgstr""

# CppCoreGuidelines.md:9219
msgid "9219            return result;"
msgstr""

# CppCoreGuidelines.md:9220
msgid "9220        }"
msgstr""

       
# CppCoreGuidelines.md:9221
msgid "9221    Although `cached_computation` works perfectly in a single-threaded environment, in a multi-threaded environment the two `static` variables result in data races and thus undefined behavior."
msgstr""

       
# CppCoreGuidelines.md:9222
msgid "9222    There are several ways that this example could be made safe for a multi-threaded environment:"
msgstr""

       
# CppCoreGuidelines.md:9223
msgid "9223    * Delegate concurrency concerns upwards to the caller."
msgstr""

# CppCoreGuidelines.md:9224
msgid "9224    * Mark the `static` variables as `thread_local` (which might make caching less effective)."
msgstr""

# CppCoreGuidelines.md:9225
msgid "9225    * Implement concurrency control, for example, protecting the two `static` variables with a `static` lock (which might reduce performance)."
msgstr""

# CppCoreGuidelines.md:9226
msgid "9226    * Have the caller provide the memory to be used for the cache, thereby delegating both memory allocation and concurrency concerns upwards to the caller."
msgstr""

# CppCoreGuidelines.md:9227
msgid "9227    * Refuse to build and/or run in a multi-threaded environment."
msgstr""

# CppCoreGuidelines.md:9228
msgid "9228    * Provide two implementations, one which is used in single-threaded environments and another which is used in multi-threaded environments."
msgstr""

       
# CppCoreGuidelines.md:9229
msgid "9229    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:9230
msgid "9230    Code that is never run in a multi-threaded environment."
msgstr""

       
# CppCoreGuidelines.md:9231
msgid "9231    Be careful: there are many examples where code that was \"known\" to never run in a multi-threaded program"
msgstr""

# CppCoreGuidelines.md:9232
msgid "9232    was run as part of a multi-threaded program. Often years later."
msgstr""

# CppCoreGuidelines.md:9233
msgid "9233    Typically, such programs lead to a painful effort to remove data races."
msgstr""

# CppCoreGuidelines.md:9234
msgid "9234    Therefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early."
msgstr""

       
# CppCoreGuidelines.md:9235
msgid "9235    ### <a name=\"Rconc-races\"></a>CP.2: Avoid data races"
msgstr""

       
# CppCoreGuidelines.md:9236
msgid "9236    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9237
msgid "9237    Unless you do, nothing is guaranteed to work and subtle errors will persist."
msgstr""

       
# CppCoreGuidelines.md:9238
msgid "9238    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9239
msgid "9239    In a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non-`const` operation), you have a data race."
msgstr""

# CppCoreGuidelines.md:9240
msgid "9240    For further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency."
msgstr""

       
# CppCoreGuidelines.md:9241
msgid "9241    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9242
msgid "9242    There are many examples of data races that exist, some of which are running in"
msgstr""

# CppCoreGuidelines.md:9243
msgid "9243    production software at this very moment. One very simple example:"
msgstr""

       
# CppCoreGuidelines.md:9244
msgid "9244        int get_id() {"
msgstr""

# CppCoreGuidelines.md:9245
msgid "9245          static int id = 1;"
msgstr""

# CppCoreGuidelines.md:9246
msgid "9246          return id++;"
msgstr""

# CppCoreGuidelines.md:9247
msgid "9247        }"
msgstr""

       
# CppCoreGuidelines.md:9248
msgid "9248    The increment here is an example of a data race. This can go wrong in many ways,"
msgstr""

# CppCoreGuidelines.md:9249
msgid "9249    including:"
msgstr""

       
# CppCoreGuidelines.md:9250
msgid "9250    * Thread A loads the value of `id`, the OS context switches A out for some"
msgstr""

# CppCoreGuidelines.md:9251
msgid "9251      period, during which other threads create hundreds of IDs. Thread A is then"
msgstr""

# CppCoreGuidelines.md:9252
msgid "9252      allowed to run again, and `id` is written back to that location as A's read of"
msgstr""

# CppCoreGuidelines.md:9253
msgid "9253      `id` plus one."
msgstr""

# CppCoreGuidelines.md:9254
msgid "9254    * Thread A and B load `id` and increment it simultaneously.  They both get the"
msgstr""

# CppCoreGuidelines.md:9255
msgid "9255      same ID."
msgstr""

       
# CppCoreGuidelines.md:9256
msgid "9256    Local static variables are a common source of data races."
msgstr""

       
# CppCoreGuidelines.md:9257
msgid "9257    ##### Example, bad:"
msgstr""

       
# CppCoreGuidelines.md:9258
msgid "9258        void f(fstream&  fs, regex pat)"
msgstr""

# CppCoreGuidelines.md:9259
msgid "9259        {"
msgstr""

# CppCoreGuidelines.md:9260
msgid "9260            array<double, max> buf;"
msgstr""

# CppCoreGuidelines.md:9261
msgid "9261            int sz = read_vec(fs, buf, max);            // read from fs into buf"
msgstr""

# CppCoreGuidelines.md:9262
msgid "9262            gsl::span<double> s {buf};"
msgstr""

# CppCoreGuidelines.md:9263
msgid "9263            // ..."
msgstr""

# CppCoreGuidelines.md:9264
msgid "9264            auto h1 = async([&]{ sort(par, s); });     // spawn a task to sort"
msgstr""

# CppCoreGuidelines.md:9265
msgid "9265            // ..."
msgstr""

# CppCoreGuidelines.md:9266
msgid "9266            auto h2 = async([&]{ return find_all(buf, sz, pat); });   // spawn a task to find matches"
msgstr""

# CppCoreGuidelines.md:9267
msgid "9267            // ..."
msgstr""

# CppCoreGuidelines.md:9268
msgid "9268        }"
msgstr""

       
# CppCoreGuidelines.md:9269
msgid "9269    Here, we have a (nasty) data race on the elements of `buf` (`sort` will both read and write)."
msgstr""

# CppCoreGuidelines.md:9270
msgid "9270    All data races are nasty."
msgstr""

# CppCoreGuidelines.md:9271
msgid "9271    Here, we managed to get a data race on data on the stack."
msgstr""

# CppCoreGuidelines.md:9272
msgid "9272    Not all data races are as easy to spot as this one."
msgstr""

       
# CppCoreGuidelines.md:9273
msgid "9273    ##### Example, bad:"
msgstr""

       
# CppCoreGuidelines.md:9274
msgid "9274        // code not controlled by a lock"
msgstr""

       
# CppCoreGuidelines.md:9275
msgid "9275        unsigned val;"
msgstr""

       
# CppCoreGuidelines.md:9276
msgid "9276        if (val < 5) {"
msgstr""

# CppCoreGuidelines.md:9277
msgid "9277            // ... other thread can change val here ..."
msgstr""

# CppCoreGuidelines.md:9278
msgid "9278            switch (val) {"
msgstr""

# CppCoreGuidelines.md:9279
msgid "9279            case 0: // ..."
msgstr""

# CppCoreGuidelines.md:9280
msgid "9280            case 1: // ..."
msgstr""

# CppCoreGuidelines.md:9281
msgid "9281            case 2: // ..."
msgstr""

# CppCoreGuidelines.md:9282
msgid "9282            case 3: // ..."
msgstr""

# CppCoreGuidelines.md:9283
msgid "9283            case 4: // ..."
msgstr""

# CppCoreGuidelines.md:9284
msgid "9284            }"
msgstr""

# CppCoreGuidelines.md:9285
msgid "9285        }"
msgstr""

       
# CppCoreGuidelines.md:9286
msgid "9286    Now, a compiler that does not know that `val` can change will  most likely implement that `switch` using a jump table with five entries."
msgstr""

# CppCoreGuidelines.md:9287
msgid "9287    Then, a `val` outside the `[0..4]` range will cause a jump to an address that could be anywhere in the program, and execution would proceed there."
msgstr""

# CppCoreGuidelines.md:9288
msgid "9288    Really, \"all bets are off\" if you get a data race."
msgstr""

# CppCoreGuidelines.md:9289
msgid "9289    Actually, it can be worse still: by looking at the generated code you may be able to determine where the stray jump will go for a given value;"
msgstr""

# CppCoreGuidelines.md:9290
msgid "9290    this can be a security risk."
msgstr""

       
# CppCoreGuidelines.md:9291
msgid "9291    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9292
msgid "9292    Some is possible, do at least something."
msgstr""

# CppCoreGuidelines.md:9293
msgid "9293    There are commercial and open-source tools that try to address this problem,"
msgstr""

# CppCoreGuidelines.md:9294
msgid "9294    but be aware that solutions have costs and blind spots."
msgstr""

# CppCoreGuidelines.md:9295
msgid "9295    Static tools often have many false positives and run-time tools often have a significant cost."
msgstr""

# CppCoreGuidelines.md:9296
msgid "9296    We hope for better tools."
msgstr""

# CppCoreGuidelines.md:9297
msgid "9297    Using multiple tools can catch more problems than a single one."
msgstr""

       
# CppCoreGuidelines.md:9298
msgid "9298    There are other ways you can mitigate the chance of data races:"
msgstr""

       
# CppCoreGuidelines.md:9299
msgid "9299    * Avoid global data"
msgstr""

# CppCoreGuidelines.md:9300
msgid "9300    * Avoid `static` variables"
msgstr""

# CppCoreGuidelines.md:9301
msgid "9301    * More use of value types on the stack (and don't pass pointers around too much)"
msgstr""

# CppCoreGuidelines.md:9302
msgid "9302    * More use of immutable data (literals, `constexpr`, and `const`)"
msgstr""

       
# CppCoreGuidelines.md:9303
msgid "9303    ### <a name=\"Rconc-data\"></a>CP.3: Minimize explicit sharing of writable data"
msgstr""

       
# CppCoreGuidelines.md:9304
msgid "9304    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9305
msgid "9305    If you don't share writable data, you can't have a data race."
msgstr""

# CppCoreGuidelines.md:9306
msgid "9306    The less sharing you do, the less chance you have to forget to synchronize access (and get data races)."
msgstr""

# CppCoreGuidelines.md:9307
msgid "9307    The less sharing you do, the less chance you have to wait on a lock (so performance can improve)."
msgstr""

       
# CppCoreGuidelines.md:9308
msgid "9308    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9309
msgid "9309        bool validate(const vector<Reading>&);"
msgstr""

# CppCoreGuidelines.md:9310
msgid "9310        Graph<Temp_node> temperature_gradiants(const vector<Reading>&);"
msgstr""

# CppCoreGuidelines.md:9311
msgid "9311        Image altitude_map(const vector<Reading>&);"
msgstr""

# CppCoreGuidelines.md:9312
msgid "9312        // ..."
msgstr""

       
# CppCoreGuidelines.md:9313
msgid "9313        void process_readings(const vector<Reading>& surface_readings)"
msgstr""

# CppCoreGuidelines.md:9314
msgid "9314        {"
msgstr""

# CppCoreGuidelines.md:9315
msgid "9315            auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; });"
msgstr""

# CppCoreGuidelines.md:9316
msgid "9316            auto h2 = async([&] { return temperature_gradiants(surface_readings); });"
msgstr""

# CppCoreGuidelines.md:9317
msgid "9317            auto h3 = async([&] { return altitude_map(surface_readings); });"
msgstr""

# CppCoreGuidelines.md:9318
msgid "9318            // ..."
msgstr""

# CppCoreGuidelines.md:9319
msgid "9319            h1.get();"
msgstr""

# CppCoreGuidelines.md:9320
msgid "9320            auto v2 = h2.get();"
msgstr""

# CppCoreGuidelines.md:9321
msgid "9321            auto v3 = h3.get();"
msgstr""

# CppCoreGuidelines.md:9322
msgid "9322            // ..."
msgstr""

# CppCoreGuidelines.md:9323
msgid "9323        }"
msgstr""

       
# CppCoreGuidelines.md:9324
msgid "9324    Without those `const`s, we would have to review every asynchronously invoked function for potential data races on `surface_readings`."
msgstr""

# CppCoreGuidelines.md:9325
msgid "9325    Making `surface_readings` be `const` (with respect to this function) allow reasoning using only the function body."
msgstr""

       
# CppCoreGuidelines.md:9326
msgid "9326    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9327
msgid "9327    Immutable data can be safely and efficiently shared."
msgstr""

# CppCoreGuidelines.md:9328
msgid "9328    No locking is needed: You can't have a data race on a constant."
msgstr""

# CppCoreGuidelines.md:9329
msgid "9329    See also [CP.mess: Message Passing](#SScp-mess) and [CP.31: prefer pass by value](#Rconc-data-by-value)."
msgstr""

       
# CppCoreGuidelines.md:9330
msgid "9330    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9331
msgid "9331    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9332
msgid "9332    ### <a name=\"Rconc-task\"></a>CP.4: Think in terms of tasks, rather than threads"
msgstr""

       
# CppCoreGuidelines.md:9333
msgid "9333    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9334
msgid "9334    A `thread` is an implementation concept, a way of thinking about the machine."
msgstr""

# CppCoreGuidelines.md:9335
msgid "9335    A task is an application notion, something you'd like to do, preferably concurrently with other tasks."
msgstr""

# CppCoreGuidelines.md:9336
msgid "9336    Application concepts are easier to reason about."
msgstr""

       
# CppCoreGuidelines.md:9337
msgid "9337    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9338
msgid "9338        void some_fun() {"
msgstr""

# CppCoreGuidelines.md:9339
msgid "9339            std::string  msg, msg2;"
msgstr""

# CppCoreGuidelines.md:9340
msgid "9340            std::thread publisher([&] { msg = \"Hello\"; });       // bad: less expressive"
msgstr""

# CppCoreGuidelines.md:9341
msgid "9341                                                                 //      and more error-prone"
msgstr""

# CppCoreGuidelines.md:9342
msgid "9342            auto pubtask = std::async([&] { msg2 = \"Hello\"; });  // OK"
msgstr""

# CppCoreGuidelines.md:9343
msgid "9343            // ..."
msgstr""

# CppCoreGuidelines.md:9344
msgid "9344            publisher.join();"
msgstr""

# CppCoreGuidelines.md:9345
msgid "9345        }"
msgstr""

       
# CppCoreGuidelines.md:9346
msgid "9346    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9347
msgid "9347    With the exception of `async()`, the standard-library facilities are low-level, machine-oriented, threads-and-lock level."
msgstr""

# CppCoreGuidelines.md:9348
msgid "9348    This is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance."
msgstr""

# CppCoreGuidelines.md:9349
msgid "9349    This is a potent argument for using higher level, more applications-oriented libraries (if possibly, built on top of standard-library facilities)."
msgstr""

       
# CppCoreGuidelines.md:9350
msgid "9350    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9351
msgid "9351    ???"
msgstr""

       
# CppCoreGuidelines.md:9352
msgid "9352    ### <a name=\"Rconc-volatile\"></a>CP.8: Don't try to use `volatile` for synchronization"
msgstr""

       
# CppCoreGuidelines.md:9353
msgid "9353    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9354
msgid "9354    In C++, unlike some other languages, `volatile` does not provide atomicity, does not synchronize between threads,"
msgstr""

# CppCoreGuidelines.md:9355
msgid "9355    and does not prevent instruction reordering (neither compiler nor hardware)."
msgstr""

# CppCoreGuidelines.md:9356
msgid "9356    It simply has nothing to do with concurrency."
msgstr""

       
# CppCoreGuidelines.md:9357
msgid "9357    ##### Example, bad:"
msgstr""

       
# CppCoreGuidelines.md:9358
msgid "9358        int free_slots = max_slots; // current source of memory for objects"
msgstr""

       
# CppCoreGuidelines.md:9359
msgid "9359        Pool* use()"
msgstr""

# CppCoreGuidelines.md:9360
msgid "9360        {"
msgstr""

# CppCoreGuidelines.md:9361
msgid "9361            if (int n = free_slots--) return &pool[n];"
msgstr""

# CppCoreGuidelines.md:9362
msgid "9362        }"
msgstr""

       
# CppCoreGuidelines.md:9363
msgid "9363    Here we have a problem:"
msgstr""

# CppCoreGuidelines.md:9364
msgid "9364    This is perfectly good code in a single-threaded program, but have two threads execute this and"
msgstr""

# CppCoreGuidelines.md:9365
msgid "9365    there is a race condition on `free_slots` so that two threads might get the same value and `free_slots`."
msgstr""

# CppCoreGuidelines.md:9366
msgid "9366    That's (obviously) a bad data race, so people trained in other languages may try to fix it like this:"
msgstr""

       
# CppCoreGuidelines.md:9367
msgid "9367        volatile int free_slots = max_slots; // current source of memory for objects"
msgstr""

       
# CppCoreGuidelines.md:9368
msgid "9368        Pool* use()"
msgstr""

# CppCoreGuidelines.md:9369
msgid "9369        {"
msgstr""

# CppCoreGuidelines.md:9370
msgid "9370            if (int n = free_slots--) return &pool[n];"
msgstr""

# CppCoreGuidelines.md:9371
msgid "9371        }"
msgstr""

       
# CppCoreGuidelines.md:9372
msgid "9372    This has no effect on synchronization: The data race is still there!"
msgstr""

       
# CppCoreGuidelines.md:9373
msgid "9373    The C++ mechanism for this is `atomic` types:"
msgstr""

       
# CppCoreGuidelines.md:9374
msgid "9374        atomic<int> free_slots = max_slots; // current source of memory for objects"
msgstr""

       
# CppCoreGuidelines.md:9375
msgid "9375        Pool* use()"
msgstr""

# CppCoreGuidelines.md:9376
msgid "9376        {"
msgstr""

# CppCoreGuidelines.md:9377
msgid "9377            if (int n = free_slots--) return &pool[n];"
msgstr""

# CppCoreGuidelines.md:9378
msgid "9378        }"
msgstr""

       
# CppCoreGuidelines.md:9379
msgid "9379    Now the `--` operation is atomic,"
msgstr""

# CppCoreGuidelines.md:9380
msgid "9380    rather than a read-increment-write sequence where another thread might get in-between the individual operations."
msgstr""

       
# CppCoreGuidelines.md:9381
msgid "9381    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:9382
msgid "9382    Use `atomic` types where you might have used `volatile` in some other language."
msgstr""

# CppCoreGuidelines.md:9383
msgid "9383    Use a `mutex` for more complicated examples."
msgstr""

       
# CppCoreGuidelines.md:9384
msgid "9384    ##### See also"
msgstr""

       
# CppCoreGuidelines.md:9385
msgid "9385    [(rare) proper uses of `volatile`](#Rconc-volatile2)"
msgstr""

       
# CppCoreGuidelines.md:9386
msgid "9386    ### <a name=\"Rconc-tools\"></a>CP.9: Whenever feasible use tools to validate your concurrent code"
msgstr""

       
# CppCoreGuidelines.md:9387
msgid "9387    Experience shows that concurrent code is exceptionally hard to get right"
msgstr""

# CppCoreGuidelines.md:9388
msgid "9388    and that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors"
msgstr""

# CppCoreGuidelines.md:9389
msgid "9389    than they are at finding errors in sequential code."
msgstr""

# CppCoreGuidelines.md:9390
msgid "9390    Subtle concurrency errors can have dramatically bad effects, including memory corruption and deadlocks."
msgstr""

       
# CppCoreGuidelines.md:9391
msgid "9391    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9392
msgid "9392        ???"
msgstr""

       
# CppCoreGuidelines.md:9393
msgid "9393    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9394
msgid "9394    Thread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks."
msgstr""

# CppCoreGuidelines.md:9395
msgid "9395    There are many tools \"out there\", both commercial and open-source tools, both research and production tools."
msgstr""

# CppCoreGuidelines.md:9396
msgid "9396    Unfortunately people's needs and constraints differ so dramatically that we cannot make specific recommendations,"
msgstr""

# CppCoreGuidelines.md:9397
msgid "9397    but we can mention:"
msgstr""

       
# CppCoreGuidelines.md:9398
msgid "9398    * Static enforcement tools: both [clang](http://clang.llvm.org/docs/ThreadSafetyAnalysis.html)"
msgstr""

# CppCoreGuidelines.md:9399
msgid "9399    and some older versions of [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation)"
msgstr""

# CppCoreGuidelines.md:9400
msgid "9400    have some support for static annotation of thread safety properties."
msgstr""

# CppCoreGuidelines.md:9401
msgid "9401    Consistent use of this technique turns many classes of thread-safety errors into compile-time errors."
msgstr""

# CppCoreGuidelines.md:9402
msgid "9402    The annotations are generally local (marking a particular member variable as guarded by a particular mutex),"
msgstr""

# CppCoreGuidelines.md:9403
msgid "9403    and are usually easy to learn. However, as with many static tools, it can often present false negatives;"
msgstr""

# CppCoreGuidelines.md:9404
msgid "9404    cases that should have been caught but were allowed."
msgstr""

       
# CppCoreGuidelines.md:9405
msgid "9405    * dynamic enforcement tools: Clang's [Thread Sanitizer](http://clang.llvm.org/docs/ThreadSanitizer.html) (aka TSAN)"
msgstr""

# CppCoreGuidelines.md:9406
msgid "9406    is a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access,"
msgstr""

# CppCoreGuidelines.md:9407
msgid "9407    absolutely identifying data races in a given execution of your binary."
msgstr""

# CppCoreGuidelines.md:9408
msgid "9408    The cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x)."
msgstr""

# CppCoreGuidelines.md:9409
msgid "9409    Dynamic tools like this are best when applied to integration tests, canary pushes, or unittests that operate on multiple threads."
msgstr""

# CppCoreGuidelines.md:9410
msgid "9410    Workload matters: When TSAN identifies a problem, it is effectively always an actual data race,"
msgstr""

# CppCoreGuidelines.md:9411
msgid "9411    but it can only identify races seen in a given execution."
msgstr""

       
# CppCoreGuidelines.md:9412
msgid "9412    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9413
msgid "9413    It is up to an application builder to choose which support tools are valuable for a particular applications."
msgstr""

       
# CppCoreGuidelines.md:9414
msgid "9414    ## <a name=\"SScp-con\"></a>CP.con: Concurrency"
msgstr""

       
# CppCoreGuidelines.md:9415
msgid "9415    This section focuses on relatively ad-hoc uses of multiple threads communicating through shared data."
msgstr""

       
# CppCoreGuidelines.md:9416
msgid "9416    * For parallel algorithms, see [parallelism](#SScp-par)"
msgstr""

# CppCoreGuidelines.md:9417
msgid "9417    * For inter-task communication without explicit sharing, see [messaging](#SScp-mess)"
msgstr""

# CppCoreGuidelines.md:9418
msgid "9418    * For vector parallel code, see [vectorization](#SScp-vec)"
msgstr""

# CppCoreGuidelines.md:9419
msgid "9419    * For lock-free programming, see [lock free](#SScp-free)"
msgstr""

       
# CppCoreGuidelines.md:9420
msgid "9420    Concurrency rule summary:"
msgstr""

       
# CppCoreGuidelines.md:9421
msgid "9421    * [CP.20: Use RAII, never plain `lock()`/`unlock()`](#Rconc-raii)"
msgstr""

# CppCoreGuidelines.md:9422
msgid "9422    * [CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es](#Rconc-lock)"
msgstr""

# CppCoreGuidelines.md:9423
msgid "9423    * [CP.22: Never call unknown code while holding a lock (e.g., a callback)](#Rconc-unknown)"
msgstr""

# CppCoreGuidelines.md:9424
msgid "9424    * [CP.23: Think of a joining `thread` as a scoped container](#Rconc-join)"
msgstr""

# CppCoreGuidelines.md:9425
msgid "9425    * [CP.24: Think of a `thread` as a global container](#Rconc-detach)"
msgstr""

# CppCoreGuidelines.md:9426
msgid "9426    * [CP.25: Prefer `gsl::joining_thread` over `std::thread`](#Rconc-joining_thread)"
msgstr""

# CppCoreGuidelines.md:9427
msgid "9427    * [CP.26: Don't `detach()` a thread](#Rconc-detached_thread)"
msgstr""

# CppCoreGuidelines.md:9428
msgid "9428    * [CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer](#Rconc-data-by-value)"
msgstr""

# CppCoreGuidelines.md:9429
msgid "9429    * [CP.32: To share ownership between unrelated `thread`s use `shared_ptr`](#Rconc-shared)"
msgstr""

# CppCoreGuidelines.md:9430
msgid "9430    * [CP.40: Minimize context switching](#Rconc-switch)"
msgstr""

# CppCoreGuidelines.md:9431
msgid "9431    * [CP.41: Minimize thread creation and destruction](#Rconc-create)"
msgstr""

# CppCoreGuidelines.md:9432
msgid "9432    * [CP.42: Don't `wait` without a condition](#Rconc-wait)"
msgstr""

# CppCoreGuidelines.md:9433
msgid "9433    * [CP.43: Minimize time spent in a critical section](#Rconc-time)"
msgstr""

# CppCoreGuidelines.md:9434
msgid "9434    * [CP.44: Remember to name your `lock_guard`s and `unique_lock`s](#Rconc-name)"
msgstr""

# CppCoreGuidelines.md:9435
msgid "9435    * [CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible](#Rconc-mutex)"
msgstr""

# CppCoreGuidelines.md:9436
msgid "9436    * ??? when to use a spinlock"
msgstr""

# CppCoreGuidelines.md:9437
msgid "9437    * ??? when to use `try_lock()`"
msgstr""

# CppCoreGuidelines.md:9438
msgid "9438    * ??? when to prefer `lock_guard` over `unique_lock`"
msgstr""

# CppCoreGuidelines.md:9439
msgid "9439    * ??? Time multiplexing"
msgstr""

# CppCoreGuidelines.md:9440
msgid "9440    * ??? when/how to use `new thread`"
msgstr""

       
# CppCoreGuidelines.md:9441
msgid "9441    ### <a name=\"Rconc-raii\"></a>CP.20: Use RAII, never plain `lock()`/`unlock()`"
msgstr""

       
# CppCoreGuidelines.md:9442
msgid "9442    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9443
msgid "9443    Avoids nasty errors from unreleased locks."
msgstr""

       
# CppCoreGuidelines.md:9444
msgid "9444    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9445
msgid "9445        mutex mtx;"
msgstr""

       
# CppCoreGuidelines.md:9446
msgid "9446        void do_stuff()"
msgstr""

# CppCoreGuidelines.md:9447
msgid "9447        {"
msgstr""

# CppCoreGuidelines.md:9448
msgid "9448            mtx.lock();"
msgstr""

# CppCoreGuidelines.md:9449
msgid "9449            // ... do stuff ..."
msgstr""

# CppCoreGuidelines.md:9450
msgid "9450            mtx.unlock();"
msgstr""

# CppCoreGuidelines.md:9451
msgid "9451        }"
msgstr""

       
# CppCoreGuidelines.md:9452
msgid "9452    Sooner or later, someone will forget the `mtx.unlock()`, place a `return` in the `... do stuff ...`, throw an exception, or something."
msgstr""

       
# CppCoreGuidelines.md:9453
msgid "9453        mutex mtx;"
msgstr""

       
# CppCoreGuidelines.md:9454
msgid "9454        void do_stuff()"
msgstr""

# CppCoreGuidelines.md:9455
msgid "9455        {"
msgstr""

# CppCoreGuidelines.md:9456
msgid "9456            unique_lock<mutex> lck {mtx};"
msgstr""

# CppCoreGuidelines.md:9457
msgid "9457            // ... do stuff ..."
msgstr""

# CppCoreGuidelines.md:9458
msgid "9458        }"
msgstr""

       
# CppCoreGuidelines.md:9459
msgid "9459    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9460
msgid "9460    Flag calls of member `lock()` and `unlock()`.  ???"
msgstr""

       
       
# CppCoreGuidelines.md:9461
msgid "9461    ### <a name=\"Rconc-lock\"></a>CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es"
msgstr""

       
# CppCoreGuidelines.md:9462
msgid "9462    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9463
msgid "9463    To avoid deadlocks on multiple `mutex`es."
msgstr""

       
# CppCoreGuidelines.md:9464
msgid "9464    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9465
msgid "9465    This is asking for deadlock:"
msgstr""

       
# CppCoreGuidelines.md:9466
msgid "9466        // thread 1"
msgstr""

# CppCoreGuidelines.md:9467
msgid "9467        lock_guard<mutex> lck1(m1);"
msgstr""

# CppCoreGuidelines.md:9468
msgid "9468        lock_guard<mutex> lck2(m2);"
msgstr""

       
# CppCoreGuidelines.md:9469
msgid "9469        // thread 2"
msgstr""

# CppCoreGuidelines.md:9470
msgid "9470        lock_guard<mutex> lck2(m2);"
msgstr""

# CppCoreGuidelines.md:9471
msgid "9471        lock_guard<mutex> lck1(m1);"
msgstr""

       
# CppCoreGuidelines.md:9472
msgid "9472    Instead, use `lock()`:"
msgstr""

       
# CppCoreGuidelines.md:9473
msgid "9473        // thread 1"
msgstr""

# CppCoreGuidelines.md:9474
msgid "9474        lock(m1, m2);"
msgstr""

# CppCoreGuidelines.md:9475
msgid "9475        lock_guard<mutex> lck1(m1, adopt_lock);"
msgstr""

# CppCoreGuidelines.md:9476
msgid "9476        lock_guard<mutex> lck2(m2, adopt_lock);"
msgstr""

       
# CppCoreGuidelines.md:9477
msgid "9477        // thread 2"
msgstr""

# CppCoreGuidelines.md:9478
msgid "9478        lock(m2, m1);"
msgstr""

# CppCoreGuidelines.md:9479
msgid "9479        lock_guard<mutex> lck2(m2, adopt_lock);"
msgstr""

# CppCoreGuidelines.md:9480
msgid "9480        lock_guard<mutex> lck1(m1, adopt_lock);"
msgstr""

       
# CppCoreGuidelines.md:9481
msgid "9481    or (better, but C++17 only):"
msgstr""

       
# CppCoreGuidelines.md:9482
msgid "9482        // thread 1"
msgstr""

# CppCoreGuidelines.md:9483
msgid "9483        scoped_lock<mutex, mutex> lck1(m1, m2);"
msgstr""

       
# CppCoreGuidelines.md:9484
msgid "9484        // thread 2"
msgstr""

# CppCoreGuidelines.md:9485
msgid "9485        scoped_lock<mutex, mutex> lck2(m2, m1);"
msgstr""

       
# CppCoreGuidelines.md:9486
msgid "9486    Here, the writers of `thread1` and `thread2` are still not agreeing on the order of the `mutex`es, but order no longer matters."
msgstr""

       
# CppCoreGuidelines.md:9487
msgid "9487    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9488
msgid "9488    In real code, `mutex`es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition."
msgstr""

# CppCoreGuidelines.md:9489
msgid "9489    In real code, `mutex`es are not always conveniently acquired on consecutive lines."
msgstr""

       
# CppCoreGuidelines.md:9490
msgid "9490    In C++17 it's possible to write plain"
msgstr""

       
# CppCoreGuidelines.md:9491
msgid "9491        lock_guard lck1(m1, adopt_lock);"
msgstr""

       
# CppCoreGuidelines.md:9492
msgid "9492    and have the `mutex` type deduced."
msgstr""

       
# CppCoreGuidelines.md:9493
msgid "9493    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9494
msgid "9494    Detect the acquisition of multiple `mutex`es."
msgstr""

# CppCoreGuidelines.md:9495
msgid "9495    This is undecidable in general, but catching common simple examples (like the one above) is easy."
msgstr""

       
       
# CppCoreGuidelines.md:9496
msgid "9496    ### <a name=\"Rconc-unknown\"></a>CP.22: Never call unknown code while holding a lock (e.g., a callback)"
msgstr""

       
# CppCoreGuidelines.md:9497
msgid "9497    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9498
msgid "9498    If you don't know what a piece of code does, you are risking deadlock."
msgstr""

       
# CppCoreGuidelines.md:9499
msgid "9499    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9500
msgid "9500        void do_this(Foo* p)"
msgstr""

# CppCoreGuidelines.md:9501
msgid "9501        {"
msgstr""

# CppCoreGuidelines.md:9502
msgid "9502            lock_guard<mutex> lck {my_mutex};"
msgstr""

# CppCoreGuidelines.md:9503
msgid "9503            // ... do something ..."
msgstr""

# CppCoreGuidelines.md:9504
msgid "9504            p->act(my_data);"
msgstr""

# CppCoreGuidelines.md:9505
msgid "9505            // ..."
msgstr""

# CppCoreGuidelines.md:9506
msgid "9506        }"
msgstr""

       
# CppCoreGuidelines.md:9507
msgid "9507    If you don't know what `Foo::act` does (maybe it is a virtual function invoking a derived class member of a class not yet written),"
msgstr""

# CppCoreGuidelines.md:9508
msgid "9508    it may call `do_this` (recursively) and cause a deadlock on `my_mutex`."
msgstr""

# CppCoreGuidelines.md:9509
msgid "9509    Maybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling `do_this`."
msgstr""

       
# CppCoreGuidelines.md:9510
msgid "9510    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9511
msgid "9511    A common example of the \"calling unknown code\" problem is a call to a function that tries to gain locked access to the same object."
msgstr""

# CppCoreGuidelines.md:9512
msgid "9512    Such problem can often be solved by using a `recursive_mutex`. For example:"
msgstr""

       
# CppCoreGuidelines.md:9513
msgid "9513        recursive_mutex my_mutex;"
msgstr""

       
# CppCoreGuidelines.md:9514
msgid "9514        template<typename Action>"
msgstr""

# CppCoreGuidelines.md:9515
msgid "9515        void do_something(Action f)"
msgstr""

# CppCoreGuidelines.md:9516
msgid "9516        {"
msgstr""

# CppCoreGuidelines.md:9517
msgid "9517            unique_lock<recursive_mutex> lck {my_mutex};"
msgstr""

# CppCoreGuidelines.md:9518
msgid "9518            // ... do something ..."
msgstr""

# CppCoreGuidelines.md:9519
msgid "9519            f(this);    // f will do something to *this"
msgstr""

# CppCoreGuidelines.md:9520
msgid "9520            // ..."
msgstr""

# CppCoreGuidelines.md:9521
msgid "9521        }"
msgstr""

       
# CppCoreGuidelines.md:9522
msgid "9522    If, as it is likely, `f()` invokes operations on `*this`, we must make sure that the object's invariant holds before the call."
msgstr""

       
# CppCoreGuidelines.md:9523
msgid "9523    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9524
msgid "9524    * Flag calling a virtual function with a non-recursive `mutex` held"
msgstr""

# CppCoreGuidelines.md:9525
msgid "9525    * Flag calling a callback with a non-recursive `mutex` held"
msgstr""

       
       
# CppCoreGuidelines.md:9526
msgid "9526    ### <a name=\"Rconc-join\"></a>CP.23: Think of a joining `thread` as a scoped container"
msgstr""

       
# CppCoreGuidelines.md:9527
msgid "9527    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9528
msgid "9528    To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`."
msgstr""

# CppCoreGuidelines.md:9529
msgid "9529    If a `thread` joins, we can safely pass pointers to objects in the scope of the `thread` and its enclosing scopes."
msgstr""

       
# CppCoreGuidelines.md:9530
msgid "9530    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9531
msgid "9531        void f(int* p)"
msgstr""

# CppCoreGuidelines.md:9532
msgid "9532        {"
msgstr""

# CppCoreGuidelines.md:9533
msgid "9533            // ..."
msgstr""

# CppCoreGuidelines.md:9534
msgid "9534            *p = 99;"
msgstr""

# CppCoreGuidelines.md:9535
msgid "9535            // ..."
msgstr""

# CppCoreGuidelines.md:9536
msgid "9536        }"
msgstr""

# CppCoreGuidelines.md:9537
msgid "9537        int glob = 33;"
msgstr""

       
# CppCoreGuidelines.md:9538
msgid "9538        void some_fct(int* p)"
msgstr""

# CppCoreGuidelines.md:9539
msgid "9539        {"
msgstr""

# CppCoreGuidelines.md:9540
msgid "9540            int x = 77;"
msgstr""

# CppCoreGuidelines.md:9541
msgid "9541            joining_thread t0(f, &x);           // OK"
msgstr""

# CppCoreGuidelines.md:9542
msgid "9542            joining_thread t1(f, p);            // OK"
msgstr""

# CppCoreGuidelines.md:9543
msgid "9543            joining_thread t2(f, &glob);        // OK"
msgstr""

# CppCoreGuidelines.md:9544
msgid "9544            auto q = make_unique<int>(99);"
msgstr""

# CppCoreGuidelines.md:9545
msgid "9545            joining_thread t3(f, q.get());      // OK"
msgstr""

# CppCoreGuidelines.md:9546
msgid "9546            // ..."
msgstr""

# CppCoreGuidelines.md:9547
msgid "9547        }"
msgstr""

       
# CppCoreGuidelines.md:9548
msgid "9548    A `gsl::joining_thread` is a `std::thread` with a destructor that joins and that cannot be `detached()`."
msgstr""

# CppCoreGuidelines.md:9549
msgid "9549    By \"OK\" we mean that the object will be in scope (\"live\") for as long as a `thread` can use the pointer to it."
msgstr""

# CppCoreGuidelines.md:9550
msgid "9550    The fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;"
msgstr""

# CppCoreGuidelines.md:9551
msgid "9551    these `thread`s can be seen as just a function object called from `some_fct`."
msgstr""

       
# CppCoreGuidelines.md:9552
msgid "9552    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9553
msgid "9553    Ensure that `joining_thread`s don't `detach()`."
msgstr""

# CppCoreGuidelines.md:9554
msgid "9554    After that, the usual lifetime and ownership (for local objects) enforcement applies."
msgstr""

       
# CppCoreGuidelines.md:9555
msgid "9555    ### <a name=\"Rconc-detach\"></a>CP.24: Think of a `thread` as a global container"
msgstr""

       
# CppCoreGuidelines.md:9556
msgid "9556    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9557
msgid "9557    To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`."
msgstr""

# CppCoreGuidelines.md:9558
msgid "9558    If a `thread` is detached, we can safely pass pointers to static and free store objects (only)."
msgstr""

       
# CppCoreGuidelines.md:9559
msgid "9559    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9560
msgid "9560        void f(int* p)"
msgstr""

# CppCoreGuidelines.md:9561
msgid "9561        {"
msgstr""

# CppCoreGuidelines.md:9562
msgid "9562            // ..."
msgstr""

# CppCoreGuidelines.md:9563
msgid "9563            *p = 99;"
msgstr""

# CppCoreGuidelines.md:9564
msgid "9564            // ..."
msgstr""

# CppCoreGuidelines.md:9565
msgid "9565        }"
msgstr""

       
# CppCoreGuidelines.md:9566
msgid "9566        int glob = 33;"
msgstr""

       
# CppCoreGuidelines.md:9567
msgid "9567        void some_fct(int* p)"
msgstr""

# CppCoreGuidelines.md:9568
msgid "9568        {"
msgstr""

# CppCoreGuidelines.md:9569
msgid "9569            int x = 77;"
msgstr""

# CppCoreGuidelines.md:9570
msgid "9570            std::thread t0(f, &x);           // bad"
msgstr""

# CppCoreGuidelines.md:9571
msgid "9571            std::thread t1(f, p);            // bad"
msgstr""

# CppCoreGuidelines.md:9572
msgid "9572            std::thread t2(f, &glob);        // OK"
msgstr""

# CppCoreGuidelines.md:9573
msgid "9573            auto q = make_unique<int>(99);"
msgstr""

# CppCoreGuidelines.md:9574
msgid "9574            std::thread t3(f, q.get());      // bad"
msgstr""

# CppCoreGuidelines.md:9575
msgid "9575            // ..."
msgstr""

# CppCoreGuidelines.md:9576
msgid "9576            t0.detach();"
msgstr""

# CppCoreGuidelines.md:9577
msgid "9577            t1.detach();"
msgstr""

# CppCoreGuidelines.md:9578
msgid "9578            t2.detach();"
msgstr""

# CppCoreGuidelines.md:9579
msgid "9579            t3.detach();"
msgstr""

# CppCoreGuidelines.md:9580
msgid "9580            // ..."
msgstr""

# CppCoreGuidelines.md:9581
msgid "9581        }"
msgstr""

       
# CppCoreGuidelines.md:9582
msgid "9582    By \"OK\" we mean that the object will be in scope (\"live\") for as long as a `thread` can use the pointers to it."
msgstr""

# CppCoreGuidelines.md:9583
msgid "9583    By \"bad\" we mean that a `thread` may use a pointer after the pointed-to object is destroyed."
msgstr""

# CppCoreGuidelines.md:9584
msgid "9584    The fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;"
msgstr""

# CppCoreGuidelines.md:9585
msgid "9585    these `thread`s can be seen as just a function object called from `some_fct`."
msgstr""

       
# CppCoreGuidelines.md:9586
msgid "9586    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9587
msgid "9587    Even objects with static storage duration can be problematic if used from detached threads: if the"
msgstr""

# CppCoreGuidelines.md:9588
msgid "9588    thread continues until the end of the program, it might be running concurrently with the destruction"
msgstr""

# CppCoreGuidelines.md:9589
msgid "9589    of objects with static storage duration, and thus accesses to such objects might race."
msgstr""

       
# CppCoreGuidelines.md:9590
msgid "9590    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9591
msgid "9591    This rule is redundant if you [don't `detach()`](#Rconc-detached_thread) and [use `gsl::joining_thread`](#Rconc-joining_thread)."
msgstr""

# CppCoreGuidelines.md:9592
msgid "9592    However, converting code to follow those guidelines could be difficult and even impossible for third-party libraries."
msgstr""

# CppCoreGuidelines.md:9593
msgid "9593    In such cases, the rule becomes essential for lifetime safety and type safety."
msgstr""

       
       
# CppCoreGuidelines.md:9594
msgid "9594    In general, it is undecidable whether a `detach()` is executed for a `thread`, but simple common cases are easily detected."
msgstr""

# CppCoreGuidelines.md:9595
msgid "9595    If we cannot prove that a `thread` does not `detach()`, we must assume that it does and that it outlives the scope in which it was constructed;"
msgstr""

# CppCoreGuidelines.md:9596
msgid "9596    After that, the usual lifetime and ownership (for global objects) enforcement applies."
msgstr""

       
# CppCoreGuidelines.md:9597
msgid "9597    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9598
msgid "9598    Flag attempts to pass local variables to a thread that might `detach()`."
msgstr""

       
# CppCoreGuidelines.md:9599
msgid "9599    ### <a name=\"Rconc-joining_thread\"></a>CP.25: Prefer `gsl::joining_thread` over `std::thread`"
msgstr""

       
# CppCoreGuidelines.md:9600
msgid "9600    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9601
msgid "9601    A `joining_thread` is a thread that joins at the end of its scope."
msgstr""

# CppCoreGuidelines.md:9602
msgid "9602    Detached threads are hard to monitor."
msgstr""

# CppCoreGuidelines.md:9603
msgid "9603    It is harder to ensure absence of errors in detached threads (and potentially detached threads)"
msgstr""

       
# CppCoreGuidelines.md:9604
msgid "9604    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9605
msgid "9605        void f() { std::cout << \"Hello \"; }"
msgstr""

       
# CppCoreGuidelines.md:9606
msgid "9606        struct F {"
msgstr""

# CppCoreGuidelines.md:9607
msgid "9607            void operator()() { std::cout << \"parallel world \"; }"
msgstr""

# CppCoreGuidelines.md:9608
msgid "9608        };"
msgstr""

       
# CppCoreGuidelines.md:9609
msgid "9609        int main()"
msgstr""

# CppCoreGuidelines.md:9610
msgid "9610        {"
msgstr""

# CppCoreGuidelines.md:9611
msgid "9611            std::thread t1{f};      // f() executes in separate thread"
msgstr""

# CppCoreGuidelines.md:9612
msgid "9612            std::thread t2{F()};    // F()() executes in separate thread"
msgstr""

# CppCoreGuidelines.md:9613
msgid "9613        }  // spot the bugs"
msgstr""

       
# CppCoreGuidelines.md:9614
msgid "9614    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9615
msgid "9615        void f() { std::cout << \"Hello \"; }"
msgstr""

       
# CppCoreGuidelines.md:9616
msgid "9616        struct F {"
msgstr""

# CppCoreGuidelines.md:9617
msgid "9617            void operator()() { std::cout << \"parallel world \"; }"
msgstr""

# CppCoreGuidelines.md:9618
msgid "9618        };"
msgstr""

       
# CppCoreGuidelines.md:9619
msgid "9619        int main()"
msgstr""

# CppCoreGuidelines.md:9620
msgid "9620        {"
msgstr""

# CppCoreGuidelines.md:9621
msgid "9621            std::thread t1{f};      // f() executes in separate thread"
msgstr""

# CppCoreGuidelines.md:9622
msgid "9622            std::thread t2{F()};    // F()() executes in separate thread"
msgstr""

       
# CppCoreGuidelines.md:9623
msgid "9623            t1.join();"
msgstr""

# CppCoreGuidelines.md:9624
msgid "9624            t2.join();"
msgstr""

# CppCoreGuidelines.md:9625
msgid "9625        }  // one bad bug left"
msgstr""

       
       
# CppCoreGuidelines.md:9626
msgid "9626    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9627
msgid "9627    The code determining whether to `join()` or `detach()` may be complicated and even decided in the thread of functions called from it or functions called by the function that creates a thread:"
msgstr""

       
# CppCoreGuidelines.md:9628
msgid "9628        void tricky(thread* t, int n)"
msgstr""

# CppCoreGuidelines.md:9629
msgid "9629        {"
msgstr""

# CppCoreGuidelines.md:9630
msgid "9630            // ..."
msgstr""

# CppCoreGuidelines.md:9631
msgid "9631            if (is_odd(n))"
msgstr""

# CppCoreGuidelines.md:9632
msgid "9632                t->detach();"
msgstr""

# CppCoreGuidelines.md:9633
msgid "9633            // ..."
msgstr""

# CppCoreGuidelines.md:9634
msgid "9634        }"
msgstr""

       
# CppCoreGuidelines.md:9635
msgid "9635        void use(int n)"
msgstr""

# CppCoreGuidelines.md:9636
msgid "9636        {"
msgstr""

# CppCoreGuidelines.md:9637
msgid "9637            thread t { tricky, this, n };"
msgstr""

# CppCoreGuidelines.md:9638
msgid "9638            // ..."
msgstr""

# CppCoreGuidelines.md:9639
msgid "9639            // ... should I join here? ..."
msgstr""

# CppCoreGuidelines.md:9640
msgid "9640        }"
msgstr""

       
# CppCoreGuidelines.md:9641
msgid "9641    This seriously complicates lifetime analysis, and in not too unlikely cases makes lifetime analysis impossible."
msgstr""

# CppCoreGuidelines.md:9642
msgid "9642    This implies that we cannot safely refer to local objects in `use()` from the thread or refer to local objects in the thread from `use()`."
msgstr""

       
# CppCoreGuidelines.md:9643
msgid "9643    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9644
msgid "9644    Make \"immortal threads\" globals, put them in an enclosing scope, or put them on the free store rather than `detach()`."
msgstr""

# CppCoreGuidelines.md:9645
msgid "9645    [don't `detach`](#Rconc-detached_thread)."
msgstr""

       
# CppCoreGuidelines.md:9646
msgid "9646    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9647
msgid "9647    Because of old code and third party libraries using `std::thread` this rule can be hard to introduce."
msgstr""

       
# CppCoreGuidelines.md:9648
msgid "9648    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9649
msgid "9649    Flag uses of `std::thread`:"
msgstr""

       
# CppCoreGuidelines.md:9650
msgid "9650    * Suggest use of `gsl::joining_thread`."
msgstr""

# CppCoreGuidelines.md:9651
msgid "9651    * Suggest [\"exporting ownership\"](#Rconc-detached_thread) to an enclosing scope if it detaches."
msgstr""

# CppCoreGuidelines.md:9652
msgid "9652    * Seriously warn if it is not obvious whether if joins of detaches."
msgstr""

       
# CppCoreGuidelines.md:9653
msgid "9653    ### <a name=\"Rconc-detached_thread\"></a>CP.26: Don't `detach()` a thread"
msgstr""

       
# CppCoreGuidelines.md:9654
msgid "9654    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9655
msgid "9655    Often, the need to outlive the scope of its creation is inherent in the `thread`s task,"
msgstr""

# CppCoreGuidelines.md:9656
msgid "9656    but implementing that idea by `detach` makes it harder to monitor and communicate with the detached thread."
msgstr""

# CppCoreGuidelines.md:9657
msgid "9657    In particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected."
msgstr""

       
# CppCoreGuidelines.md:9658
msgid "9658    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9659
msgid "9659        void heartbeat();"
msgstr""

       
# CppCoreGuidelines.md:9660
msgid "9660        void use()"
msgstr""

# CppCoreGuidelines.md:9661
msgid "9661        {"
msgstr""

# CppCoreGuidelines.md:9662
msgid "9662            std::thread t(heartbeat);             // don't join; heartbeat is meant to run forever"
msgstr""

# CppCoreGuidelines.md:9663
msgid "9663            t.detach();"
msgstr""

# CppCoreGuidelines.md:9664
msgid "9664            // ..."
msgstr""

# CppCoreGuidelines.md:9665
msgid "9665        }"
msgstr""

       
# CppCoreGuidelines.md:9666
msgid "9666    This is a reasonable use of a thread, for which `detach()` is commonly used."
msgstr""

# CppCoreGuidelines.md:9667
msgid "9667    There are problems, though."
msgstr""

# CppCoreGuidelines.md:9668
msgid "9668    How do we monitor the detached thread to see if it is alive?"
msgstr""

# CppCoreGuidelines.md:9669
msgid "9669    Something might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed."
msgstr""

# CppCoreGuidelines.md:9670
msgid "9670    So, we need to communicate with the heartbeat thread"
msgstr""

# CppCoreGuidelines.md:9671
msgid "9671    (e.g., through a stream of messages or notification events using a `condition_variable`)."
msgstr""

       
# CppCoreGuidelines.md:9672
msgid "9672    An alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation)."
msgstr""

# CppCoreGuidelines.md:9673
msgid "9673    For example:"
msgstr""

       
# CppCoreGuidelines.md:9674
msgid "9674        void heartbeat();"
msgstr""

       
# CppCoreGuidelines.md:9675
msgid "9675        gsl::joining_thread t(heartbeat);             // heartbeat is meant to run \"forever\""
msgstr""

       
# CppCoreGuidelines.md:9676
msgid "9676    This heartbeat will (barring error, hardware problems, etc.) run for as long as the program does."
msgstr""

       
# CppCoreGuidelines.md:9677
msgid "9677    Sometimes, we need to separate the point of creation from the point of ownership:"
msgstr""

       
# CppCoreGuidelines.md:9678
msgid "9678        void heartbeat();"
msgstr""

       
# CppCoreGuidelines.md:9679
msgid "9679        unique_ptr<gsl::joining_thread> tick_tock {nullptr};"
msgstr""

       
# CppCoreGuidelines.md:9680
msgid "9680        void use()"
msgstr""

# CppCoreGuidelines.md:9681
msgid "9681        {"
msgstr""

# CppCoreGuidelines.md:9682
msgid "9682            // heartbeat is meant to run as long as tick_tock lives"
msgstr""

# CppCoreGuidelines.md:9683
msgid "9683            tick_tock = make_unique<gsl::joining_thread>(heartbeat);"
msgstr""

# CppCoreGuidelines.md:9684
msgid "9684            // ..."
msgstr""

# CppCoreGuidelines.md:9685
msgid "9685        }"
msgstr""

       
# CppCoreGuidelines.md:9686
msgid "9686    #### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9687
msgid "9687    Flag `detach()`."
msgstr""

       
       
# CppCoreGuidelines.md:9688
msgid "9688    ### <a name=\"Rconc-data-by-value\"></a>CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer"
msgstr""

       
# CppCoreGuidelines.md:9689
msgid "9689    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9690
msgid "9690    Copying a small amount of data is cheaper to copy and access than to share it using some locking mechanism."
msgstr""

# CppCoreGuidelines.md:9691
msgid "9691    Copying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races."
msgstr""

       
# CppCoreGuidelines.md:9692
msgid "9692    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9693
msgid "9693    Defining \"small amount\" precisely is impossible."
msgstr""

       
# CppCoreGuidelines.md:9694
msgid "9694    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9695
msgid "9695        string modify1(string);"
msgstr""

# CppCoreGuidelines.md:9696
msgid "9696        void modify2(string&);"
msgstr""

       
# CppCoreGuidelines.md:9697
msgid "9697        void fct(string& s)"
msgstr""

# CppCoreGuidelines.md:9698
msgid "9698        {"
msgstr""

# CppCoreGuidelines.md:9699
msgid "9699            auto res = async(modify1, s);"
msgstr""

# CppCoreGuidelines.md:9700
msgid "9700            async(modify2, s);"
msgstr""

# CppCoreGuidelines.md:9701
msgid "9701        }"
msgstr""

       
# CppCoreGuidelines.md:9702
msgid "9702    The call of `modify1` involves copying two `string` values; the call of `modify2` does not."
msgstr""

# CppCoreGuidelines.md:9703
msgid "9703    On the other hand, the implementation of `modify1` is exactly as we would have written it for single-threaded code,"
msgstr""

# CppCoreGuidelines.md:9704
msgid "9704    whereas the implementation of `modify2` will need some form of locking to avoid data races."
msgstr""

# CppCoreGuidelines.md:9705
msgid "9705    If the string is short (say 10 characters), the call of `modify1` can be surprisingly fast;"
msgstr""

# CppCoreGuidelines.md:9706
msgid "9706    essentially all the cost is in the `thread` switch. If the string is long (say 1,000,000 characters), copying it twice"
msgstr""

# CppCoreGuidelines.md:9707
msgid "9707    is probably not a good idea."
msgstr""

       
# CppCoreGuidelines.md:9708
msgid "9708    Note that this argument has nothing to do with `async` as such. It applies equally to considerations about whether to use"
msgstr""

# CppCoreGuidelines.md:9709
msgid "9709    message passing or shared memory."
msgstr""

       
# CppCoreGuidelines.md:9710
msgid "9710    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9711
msgid "9711    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9712
msgid "9712    ### <a name=\"Rconc-shared\"></a>CP.32: To share ownership between unrelated `thread`s use `shared_ptr`"
msgstr""

       
# CppCoreGuidelines.md:9713
msgid "9713    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9714
msgid "9714    If threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other)"
msgstr""

# CppCoreGuidelines.md:9715
msgid "9715    and they need to share free store memory that needs to be deleted, a `shared_ptr` (or equivalent) is the only"
msgstr""

# CppCoreGuidelines.md:9716
msgid "9716    safe way to ensure proper deletion."
msgstr""

       
# CppCoreGuidelines.md:9717
msgid "9717    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9718
msgid "9718        ???"
msgstr""

       
# CppCoreGuidelines.md:9719
msgid "9719    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9720
msgid "9720    * A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion."
msgstr""

# CppCoreGuidelines.md:9721
msgid "9721    * An object on free store that is never to be deleted can be shared."
msgstr""

# CppCoreGuidelines.md:9722
msgid "9722    * An object owned by one thread can be safely shared with another as long as that second thread doesn't outlive the owner."
msgstr""

       
# CppCoreGuidelines.md:9723
msgid "9723    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9724
msgid "9724    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9725
msgid "9725    ### <a name=\"Rconc-switch\"></a>CP.40: Minimize context switching"
msgstr""

       
# CppCoreGuidelines.md:9726
msgid "9726    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9727
msgid "9727    Context switches are expensive."
msgstr""

       
# CppCoreGuidelines.md:9728
msgid "9728    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9729
msgid "9729        ???"
msgstr""

       
# CppCoreGuidelines.md:9730
msgid "9730    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9731
msgid "9731    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9732
msgid "9732    ### <a name=\"Rconc-create\"></a>CP.41: Minimize thread creation and destruction"
msgstr""

       
# CppCoreGuidelines.md:9733
msgid "9733    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9734
msgid "9734    Thread creation is expensive."
msgstr""

       
# CppCoreGuidelines.md:9735
msgid "9735    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9736
msgid "9736        void worker(Message m)"
msgstr""

# CppCoreGuidelines.md:9737
msgid "9737        {"
msgstr""

# CppCoreGuidelines.md:9738
msgid "9738            // process"
msgstr""

# CppCoreGuidelines.md:9739
msgid "9739        }"
msgstr""

       
# CppCoreGuidelines.md:9740
msgid "9740        void master(istream& is)"
msgstr""

# CppCoreGuidelines.md:9741
msgid "9741        {"
msgstr""

# CppCoreGuidelines.md:9742
msgid "9742            for (Message m; is >> m; )"
msgstr""

# CppCoreGuidelines.md:9743
msgid "9743                run_list.push_back(new thread(worker, m));"
msgstr""

# CppCoreGuidelines.md:9744
msgid "9744        }"
msgstr""

       
# CppCoreGuidelines.md:9745
msgid "9745    This spawns a `thread` per message, and the `run_list` is presumably managed to destroy those tasks once they are finished."
msgstr""

       
# CppCoreGuidelines.md:9746
msgid "9746    Instead, we could have a set of pre-created worker threads processing the messages"
msgstr""

       
# CppCoreGuidelines.md:9747
msgid "9747        Sync_queue<Message> work;"
msgstr""

       
# CppCoreGuidelines.md:9748
msgid "9748        void master(istream& is)"
msgstr""

# CppCoreGuidelines.md:9749
msgid "9749        {"
msgstr""

# CppCoreGuidelines.md:9750
msgid "9750            for (Message m; is >> m; )"
msgstr""

# CppCoreGuidelines.md:9751
msgid "9751                work.put(m);"
msgstr""

# CppCoreGuidelines.md:9752
msgid "9752        }"
msgstr""

       
# CppCoreGuidelines.md:9753
msgid "9753        void worker()"
msgstr""

# CppCoreGuidelines.md:9754
msgid "9754        {"
msgstr""

# CppCoreGuidelines.md:9755
msgid "9755            for (Message m; m = work.get(); ) {"
msgstr""

# CppCoreGuidelines.md:9756
msgid "9756                // process"
msgstr""

# CppCoreGuidelines.md:9757
msgid "9757            }"
msgstr""

# CppCoreGuidelines.md:9758
msgid "9758        }"
msgstr""

       
# CppCoreGuidelines.md:9759
msgid "9759        void workers()  // set up worker threads (specifically 4 worker threads)"
msgstr""

# CppCoreGuidelines.md:9760
msgid "9760        {"
msgstr""

# CppCoreGuidelines.md:9761
msgid "9761            joining_thread w1 {worker};"
msgstr""

# CppCoreGuidelines.md:9762
msgid "9762            joining_thread w2 {worker};"
msgstr""

# CppCoreGuidelines.md:9763
msgid "9763            joining_thread w3 {worker};"
msgstr""

# CppCoreGuidelines.md:9764
msgid "9764            joining_thread w4 {worker};"
msgstr""

# CppCoreGuidelines.md:9765
msgid "9765        }"
msgstr""

       
# CppCoreGuidelines.md:9766
msgid "9766    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9767
msgid "9767    If your system has a good thread pool, use it."
msgstr""

# CppCoreGuidelines.md:9768
msgid "9768    If your system has a good message queue, use it."
msgstr""

       
# CppCoreGuidelines.md:9769
msgid "9769    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9770
msgid "9770    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9771
msgid "9771    ### <a name=\"Rconc-wait\"></a>CP.42: Don't `wait` without a condition"
msgstr""

       
# CppCoreGuidelines.md:9772
msgid "9772    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9773
msgid "9773    A `wait` without a condition can miss a wakeup or wake up simply to find that there is no work to do."
msgstr""

       
# CppCoreGuidelines.md:9774
msgid "9774    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9775
msgid "9775        std::condition_variable cv;"
msgstr""

# CppCoreGuidelines.md:9776
msgid "9776        std::mutex mx;"
msgstr""

       
# CppCoreGuidelines.md:9777
msgid "9777        void thread1()"
msgstr""

# CppCoreGuidelines.md:9778
msgid "9778        {"
msgstr""

# CppCoreGuidelines.md:9779
msgid "9779            while (true) {"
msgstr""

# CppCoreGuidelines.md:9780
msgid "9780                // do some work ..."
msgstr""

# CppCoreGuidelines.md:9781
msgid "9781                std::unique_lock<std::mutex> lock(mx);"
msgstr""

# CppCoreGuidelines.md:9782
msgid "9782                cv.notify_one();    // wake other thread"
msgstr""

# CppCoreGuidelines.md:9783
msgid "9783            }"
msgstr""

# CppCoreGuidelines.md:9784
msgid "9784        }"
msgstr""

       
# CppCoreGuidelines.md:9785
msgid "9785        void thread2()"
msgstr""

# CppCoreGuidelines.md:9786
msgid "9786        {"
msgstr""

# CppCoreGuidelines.md:9787
msgid "9787            while (true) {"
msgstr""

# CppCoreGuidelines.md:9788
msgid "9788                std::unique_lock<std::mutex> lock(mx);"
msgstr""

# CppCoreGuidelines.md:9789
msgid "9789                cv.wait(lock);    // might block forever"
msgstr""

# CppCoreGuidelines.md:9790
msgid "9790                // do work ..."
msgstr""

# CppCoreGuidelines.md:9791
msgid "9791            }"
msgstr""

# CppCoreGuidelines.md:9792
msgid "9792        }"
msgstr""

       
# CppCoreGuidelines.md:9793
msgid "9793    Here, if some other `thread` consumes `thread1`'s notification, `thread2` can wait forever."
msgstr""

       
# CppCoreGuidelines.md:9794
msgid "9794    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9795
msgid "9795        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9796
msgid "9796        class Sync_queue {"
msgstr""

# CppCoreGuidelines.md:9797
msgid "9797        public:"
msgstr""

# CppCoreGuidelines.md:9798
msgid "9798            void put(const T& val);"
msgstr""

# CppCoreGuidelines.md:9799
msgid "9799            void put(T&& val);"
msgstr""

# CppCoreGuidelines.md:9800
msgid "9800            void get(T& val);"
msgstr""

# CppCoreGuidelines.md:9801
msgid "9801        private:"
msgstr""

# CppCoreGuidelines.md:9802
msgid "9802            mutex mtx;"
msgstr""

# CppCoreGuidelines.md:9803
msgid "9803            condition_variable cond;    // this controls access"
msgstr""

# CppCoreGuidelines.md:9804
msgid "9804            list<T> q;"
msgstr""

# CppCoreGuidelines.md:9805
msgid "9805        };"
msgstr""

       
# CppCoreGuidelines.md:9806
msgid "9806        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9807
msgid "9807        void Sync_queue<T>::put(const T& val)"
msgstr""

# CppCoreGuidelines.md:9808
msgid "9808        {"
msgstr""

# CppCoreGuidelines.md:9809
msgid "9809            lock_guard<mutex> lck(mtx);"
msgstr""

# CppCoreGuidelines.md:9810
msgid "9810            q.push_back(val);"
msgstr""

# CppCoreGuidelines.md:9811
msgid "9811            cond.notify_one();"
msgstr""

# CppCoreGuidelines.md:9812
msgid "9812        }"
msgstr""

       
# CppCoreGuidelines.md:9813
msgid "9813        template<typename T>"
msgstr""

# CppCoreGuidelines.md:9814
msgid "9814        void Sync_queue<T>::get(T& val)"
msgstr""

# CppCoreGuidelines.md:9815
msgid "9815        {"
msgstr""

# CppCoreGuidelines.md:9816
msgid "9816            unique_lock<mutex> lck(mtx);"
msgstr""

# CppCoreGuidelines.md:9817
msgid "9817            cond.wait(lck, [this]{ return !q.empty(); });    // prevent spurious wakeup"
msgstr""

# CppCoreGuidelines.md:9818
msgid "9818            val = q.front();"
msgstr""

# CppCoreGuidelines.md:9819
msgid "9819            q.pop_front();"
msgstr""

# CppCoreGuidelines.md:9820
msgid "9820        }"
msgstr""

       
# CppCoreGuidelines.md:9821
msgid "9821    Now if the queue is empty when a thread executing `get()` wakes up (e.g., because another thread has gotten to `get()` before it),"
msgstr""

# CppCoreGuidelines.md:9822
msgid "9822    it will immediately go back to sleep, waiting."
msgstr""

       
# CppCoreGuidelines.md:9823
msgid "9823    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9824
msgid "9824    Flag all `wait`s without conditions."
msgstr""

       
       
# CppCoreGuidelines.md:9825
msgid "9825    ### <a name=\"Rconc-time\"></a>CP.43: Minimize time spent in a critical section"
msgstr""

       
# CppCoreGuidelines.md:9826
msgid "9826    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9827
msgid "9827    The less time is spent with a `mutex` taken, the less chance that another `thread` has to wait,"
msgstr""

# CppCoreGuidelines.md:9828
msgid "9828    and `thread` suspension and resumption are expensive."
msgstr""

       
# CppCoreGuidelines.md:9829
msgid "9829    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9830
msgid "9830        void do_something() // bad"
msgstr""

# CppCoreGuidelines.md:9831
msgid "9831        {"
msgstr""

# CppCoreGuidelines.md:9832
msgid "9832            unique_lock<mutex> lck(my_lock);"
msgstr""

# CppCoreGuidelines.md:9833
msgid "9833            do0();  // preparation: does not need lock"
msgstr""

# CppCoreGuidelines.md:9834
msgid "9834            do1();  // transaction: needs locking"
msgstr""

# CppCoreGuidelines.md:9835
msgid "9835            do2();  // cleanup: does not need locking"
msgstr""

# CppCoreGuidelines.md:9836
msgid "9836        }"
msgstr""

       
# CppCoreGuidelines.md:9837
msgid "9837    Here, we are holding the lock for longer than necessary:"
msgstr""

# CppCoreGuidelines.md:9838
msgid "9838    We should not have taken the lock before we needed it and should have released it again before starting the cleanup."
msgstr""

# CppCoreGuidelines.md:9839
msgid "9839    We could rewrite this to"
msgstr""

       
# CppCoreGuidelines.md:9840
msgid "9840        void do_something() // bad"
msgstr""

# CppCoreGuidelines.md:9841
msgid "9841        {"
msgstr""

# CppCoreGuidelines.md:9842
msgid "9842            do0();  // preparation: does not need lock"
msgstr""

# CppCoreGuidelines.md:9843
msgid "9843            my_lock.lock();"
msgstr""

# CppCoreGuidelines.md:9844
msgid "9844            do1();  // transaction: needs locking"
msgstr""

# CppCoreGuidelines.md:9845
msgid "9845            my_lock.unlock();"
msgstr""

# CppCoreGuidelines.md:9846
msgid "9846            do2();  // cleanup: does not need locking"
msgstr""

# CppCoreGuidelines.md:9847
msgid "9847        }"
msgstr""

       
# CppCoreGuidelines.md:9848
msgid "9848    But that compromises safety and violates the [use RAII](#Rconc-raii) rule."
msgstr""

# CppCoreGuidelines.md:9849
msgid "9849    Instead, add a block for the critical section:"
msgstr""

       
# CppCoreGuidelines.md:9850
msgid "9850        void do_something() // OK"
msgstr""

# CppCoreGuidelines.md:9851
msgid "9851        {"
msgstr""

# CppCoreGuidelines.md:9852
msgid "9852            do0();  // preparation: does not need lock"
msgstr""

# CppCoreGuidelines.md:9853
msgid "9853            {"
msgstr""

# CppCoreGuidelines.md:9854
msgid "9854                unique_lock<mutex> lck(my_lock);"
msgstr""

# CppCoreGuidelines.md:9855
msgid "9855                do1();  // transaction: needs locking"
msgstr""

# CppCoreGuidelines.md:9856
msgid "9856            }"
msgstr""

# CppCoreGuidelines.md:9857
msgid "9857            do2();  // cleanup: does not need locking"
msgstr""

# CppCoreGuidelines.md:9858
msgid "9858        }"
msgstr""

       
# CppCoreGuidelines.md:9859
msgid "9859    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9860
msgid "9860    Impossible in general."
msgstr""

# CppCoreGuidelines.md:9861
msgid "9861    Flag \"naked\" `lock()` and `unlock()`."
msgstr""

       
       
# CppCoreGuidelines.md:9862
msgid "9862    ### <a name=\"Rconc-name\"></a>CP.44: Remember to name your `lock_guard`s and `unique_lock`s"
msgstr""

       
# CppCoreGuidelines.md:9863
msgid "9863    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9864
msgid "9864    An unnamed local objects is a temporary that immediately goes out of scope."
msgstr""

       
# CppCoreGuidelines.md:9865
msgid "9865    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9866
msgid "9866        unique_lock<mutex>(m1);"
msgstr""

# CppCoreGuidelines.md:9867
msgid "9867        lock_guard<mutex> {m2};"
msgstr""

# CppCoreGuidelines.md:9868
msgid "9868        lock(m1, m2);"
msgstr""

       
# CppCoreGuidelines.md:9869
msgid "9869    This looks innocent enough, but it isn't."
msgstr""

       
# CppCoreGuidelines.md:9870
msgid "9870    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9871
msgid "9871    Flag all unnamed `lock_guard`s and `unique_lock`s."
msgstr""

       
       
       
# CppCoreGuidelines.md:9872
msgid "9872    ### <a name=\"Rconc-mutex\"></a>CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible"
msgstr""

       
# CppCoreGuidelines.md:9873
msgid "9873    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9874
msgid "9874    It should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked."
msgstr""

       
# CppCoreGuidelines.md:9875
msgid "9875    Using a `synchronized_value<T>` ensures that the data has a mutex, and the right mutex is locked when the data is accessed."
msgstr""

# CppCoreGuidelines.md:9876
msgid "9876    See the [WG21 proposal](http://wg21.link/p0290)) to add `synchronized_value` to a future TS or revision of the C++ standard."
msgstr""

       
# CppCoreGuidelines.md:9877
msgid "9877    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9878
msgid "9878        struct Record {"
msgstr""

# CppCoreGuidelines.md:9879
msgid "9879            std::mutex m;   // take this mutex before accessing other members"
msgstr""

# CppCoreGuidelines.md:9880
msgid "9880            // ..."
msgstr""

# CppCoreGuidelines.md:9881
msgid "9881        };"
msgstr""

       
# CppCoreGuidelines.md:9882
msgid "9882        class MyClass {"
msgstr""

# CppCoreGuidelines.md:9883
msgid "9883            struct DataRecord {"
msgstr""

# CppCoreGuidelines.md:9884
msgid "9884               // ..."
msgstr""

# CppCoreGuidelines.md:9885
msgid "9885            };"
msgstr""

# CppCoreGuidelines.md:9886
msgid "9886            synchronized_value<DataRecord> data; // Protect the data with a mutex"
msgstr""

# CppCoreGuidelines.md:9887
msgid "9887        };"
msgstr""

       
# CppCoreGuidelines.md:9888
msgid "9888    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9889
msgid "9889    ??? Possible?"
msgstr""

       
       
# CppCoreGuidelines.md:9890
msgid "9890    ## <a name=\"SScp-par\"></a>CP.par: Parallelism"
msgstr""

       
# CppCoreGuidelines.md:9891
msgid "9891    By \"parallelism\" we refer to performing a task (more or less) simultaneously (\"in parallel with\") on many data items."
msgstr""

       
# CppCoreGuidelines.md:9892
msgid "9892    Parallelism rule summary:"
msgstr""

       
# CppCoreGuidelines.md:9893
msgid "9893    * ???"
msgstr""

# CppCoreGuidelines.md:9894
msgid "9894    * ???"
msgstr""

# CppCoreGuidelines.md:9895
msgid "9895    * Where appropriate, prefer the standard-library parallel algorithms"
msgstr""

# CppCoreGuidelines.md:9896
msgid "9896    * Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation"
msgstr""

       
       
       
# CppCoreGuidelines.md:9897
msgid "9897    ## <a name=\"SScp-mess\"></a>CP.mess: Message passing"
msgstr""

       
# CppCoreGuidelines.md:9898
msgid "9898    The standard-library facilities are quite low-level, focused on the needs of close-to the hardware critical programming using `thread`s, `mutex`es, `atomic` types, etc."
msgstr""

# CppCoreGuidelines.md:9899
msgid "9899    Most people shouldn't work at this level: it's error-prone and development is slow."
msgstr""

# CppCoreGuidelines.md:9900
msgid "9900    If possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization."
msgstr""

# CppCoreGuidelines.md:9901
msgid "9901    This section looks at passing messages so that a programmer doesn't have to do explicit synchronization."
msgstr""

       
# CppCoreGuidelines.md:9902
msgid "9902    Message passing rules summary:"
msgstr""

       
# CppCoreGuidelines.md:9903
msgid "9903    * [CP.60: Use a `future` to return a value from a concurrent task](#Rconc-future)"
msgstr""

# CppCoreGuidelines.md:9904
msgid "9904    * [CP.61: Use a `async()` to spawn a concurrent task](#Rconc-async)"
msgstr""

# CppCoreGuidelines.md:9905
msgid "9905    * message queues"
msgstr""

# CppCoreGuidelines.md:9906
msgid "9906    * messaging libraries"
msgstr""

       
# CppCoreGuidelines.md:9907
msgid "9907    ???? should there be a \"use X rather than `std::async`\" where X is something that would use a better specified thread pool?"
msgstr""

       
# CppCoreGuidelines.md:9908
msgid "9908    ??? Is `std::async` worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., `std::accumulate` (with the additional precondition of commutativity), or merge sort?"
msgstr""

       
       
# CppCoreGuidelines.md:9909
msgid "9909    ### <a name=\"Rconc-future\"></a>CP.60: Use a `future` to return a value from a concurrent task"
msgstr""

       
# CppCoreGuidelines.md:9910
msgid "9910    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9911
msgid "9911    A `future` preserves the usual function call return semantics for asynchronous tasks."
msgstr""

# CppCoreGuidelines.md:9912
msgid "9912    The is no explicit locking and both correct (value) return and error (exception) return are handled simply."
msgstr""

       
# CppCoreGuidelines.md:9913
msgid "9913    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9914
msgid "9914        ???"
msgstr""

       
# CppCoreGuidelines.md:9915
msgid "9915    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9916
msgid "9916    ???"
msgstr""

       
# CppCoreGuidelines.md:9917
msgid "9917    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9918
msgid "9918    ???"
msgstr""

       
# CppCoreGuidelines.md:9919
msgid "9919    ### <a name=\"Rconc-async\"></a>CP.61: Use a `async()` to spawn a concurrent task"
msgstr""

       
# CppCoreGuidelines.md:9920
msgid "9920    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9921
msgid "9921    A `future` preserves the usual function call return semantics for asynchronous tasks."
msgstr""

# CppCoreGuidelines.md:9922
msgid "9922    The is no explicit locking and both correct (value) return and error (exception) return are handled simply."
msgstr""

       
# CppCoreGuidelines.md:9923
msgid "9923    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:9924
msgid "9924        ???"
msgstr""

       
# CppCoreGuidelines.md:9925
msgid "9925    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9926
msgid "9926    Unfortunately, `async()` is not perfect."
msgstr""

# CppCoreGuidelines.md:9927
msgid "9927    For example, there is no guarantee that a thread pool is used to minimize thread construction."
msgstr""

# CppCoreGuidelines.md:9928
msgid "9928    In fact, most current `async()` implementations don't."
msgstr""

# CppCoreGuidelines.md:9929
msgid "9929    However, `async()` is simple and logically correct so until something better comes along"
msgstr""

# CppCoreGuidelines.md:9930
msgid "9930    and unless you really need to optimize for many asynchronous tasks, stick with `async()`."
msgstr""

       
# CppCoreGuidelines.md:9931
msgid "9931    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9932
msgid "9932    ???"
msgstr""

       
       
# CppCoreGuidelines.md:9933
msgid "9933    ## <a name=\"SScp-vec\"></a>CP.vec: Vectorization"
msgstr""

       
# CppCoreGuidelines.md:9934
msgid "9934    Vectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization."
msgstr""

# CppCoreGuidelines.md:9935
msgid "9935    An operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel."
msgstr""

# CppCoreGuidelines.md:9936
msgid "9936    Vectorization has the interesting property of often requiring no non-local changes to a program."
msgstr""

# CppCoreGuidelines.md:9937
msgid "9937    However, vectorization works best with simple data structures and with algorithms specifically crafted to enable it."
msgstr""

       
# CppCoreGuidelines.md:9938
msgid "9938    Vectorization rule summary:"
msgstr""

       
# CppCoreGuidelines.md:9939
msgid "9939    * ???"
msgstr""

# CppCoreGuidelines.md:9940
msgid "9940    * ???"
msgstr""

       
# CppCoreGuidelines.md:9941
msgid "9941    ## <a name=\"SScp-free\"></a>CP.free: Lock-free programming"
msgstr""

       
# CppCoreGuidelines.md:9942
msgid "9942    Synchronization using `mutex`es and `condition_variable`s can be relatively expensive."
msgstr""

# CppCoreGuidelines.md:9943
msgid "9943    Furthermore, it can lead to deadlock."
msgstr""

# CppCoreGuidelines.md:9944
msgid "9944    For performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level \"lock-free\" facilities"
msgstr""

# CppCoreGuidelines.md:9945
msgid "9945    that rely on briefly gaining exclusive (\"atomic\") access to memory."
msgstr""

# CppCoreGuidelines.md:9946
msgid "9946    Lock-free programming is also used to implement higher-level concurrency mechanisms, such as `thread`s and `mutex`es."
msgstr""

       
# CppCoreGuidelines.md:9947
msgid "9947    Lock-free programming rule summary:"
msgstr""

       
# CppCoreGuidelines.md:9948
msgid "9948    * [CP.100: Don't use lock-free programming unless you absolutely have to](#Rconc-lockfree)"
msgstr""

# CppCoreGuidelines.md:9949
msgid "9949    * [CP.101: Distrust your hardware/compiler combination](#Rconc-distrust)"
msgstr""

# CppCoreGuidelines.md:9950
msgid "9950    * [CP.102: Carefully study the literature](#Rconc-literature)"
msgstr""

# CppCoreGuidelines.md:9951
msgid "9951    * how/when to use atomics"
msgstr""

# CppCoreGuidelines.md:9952
msgid "9952    * avoid starvation"
msgstr""

# CppCoreGuidelines.md:9953
msgid "9953    * use a lock-free data structure rather than hand-crafting specific lock-free access"
msgstr""

# CppCoreGuidelines.md:9954
msgid "9954    * [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double)"
msgstr""

# CppCoreGuidelines.md:9955
msgid "9955    * [CP.111: Use a conventional pattern if you really need double-checked locking](#Rconc-double-pattern)"
msgstr""

# CppCoreGuidelines.md:9956
msgid "9956    * how/when to compare and swap"
msgstr""

       
       
# CppCoreGuidelines.md:9957
msgid "9957    ### <a name=\"Rconc-lockfree\"></a>CP.100: Don't use lock-free programming unless you absolutely have to"
msgstr""

       
# CppCoreGuidelines.md:9958
msgid "9958    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9959
msgid "9959    It's error-prone and requires expert level knowledge of language features, machine architecture, and data structures."
msgstr""

       
# CppCoreGuidelines.md:9960
msgid "9960    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:9961
msgid "9961        extern atomic<Link*> head;        // the shared head of a linked list"
msgstr""

       
# CppCoreGuidelines.md:9962
msgid "9962        Link* nh = new Link(data, nullptr);    // make a link ready for insertion"
msgstr""

# CppCoreGuidelines.md:9963
msgid "9963        Link* h = head.load();                 // read the shared head of the list"
msgstr""

       
# CppCoreGuidelines.md:9964
msgid "9964        do {"
msgstr""

# CppCoreGuidelines.md:9965
msgid "9965            if (h->data <= data) break;        // if so, insert elsewhere"
msgstr""

# CppCoreGuidelines.md:9966
msgid "9966            nh->next = h;                      // next element is the previous head"
msgstr""

# CppCoreGuidelines.md:9967
msgid "9967        } while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h"
msgstr""

       
# CppCoreGuidelines.md:9968
msgid "9968    Spot the bug."
msgstr""

# CppCoreGuidelines.md:9969
msgid "9969    It would be really hard to find through testing."
msgstr""

# CppCoreGuidelines.md:9970
msgid "9970    Read up on the ABA problem."
msgstr""

       
# CppCoreGuidelines.md:9971
msgid "9971    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:9972
msgid "9972    [Atomic variables](#???) can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default."
msgstr""

       
# CppCoreGuidelines.md:9973
msgid "9973    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9974
msgid "9974    Higher-level concurrency mechanisms, such as `thread`s and `mutex`es are implemented using lock-free programming."
msgstr""

       
# CppCoreGuidelines.md:9975
msgid "9975    **Alternative**: Use lock-free data structures implemented by others as part of some library."
msgstr""

       
       
# CppCoreGuidelines.md:9976
msgid "9976    ### <a name=\"Rconc-distrust\"></a>CP.101: Distrust your hardware/compiler combination"
msgstr""

       
# CppCoreGuidelines.md:9977
msgid "9977    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9978
msgid "9978    The low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among"
msgstr""

# CppCoreGuidelines.md:9979
msgid "9979    the areas where the most subtle portability problems occur."
msgstr""

# CppCoreGuidelines.md:9980
msgid "9980    If you are doing lock-free programming for performance, you need to check for regressions."
msgstr""

       
# CppCoreGuidelines.md:9981
msgid "9981    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:9982
msgid "9982    Instruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models)."
msgstr""

# CppCoreGuidelines.md:9983
msgid "9983    Experience, (semi)formal models and model checking can be useful."
msgstr""

# CppCoreGuidelines.md:9984
msgid "9984    Testing - often to an extreme extent - is essential."
msgstr""

# CppCoreGuidelines.md:9985
msgid "9985    \"Don't fly too close to the sun.\""
msgstr""

       
# CppCoreGuidelines.md:9986
msgid "9986    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:9987
msgid "9987    Have strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries."
msgstr""

       
       
# CppCoreGuidelines.md:9988
msgid "9988    ### <a name=\"Rconc-literature\"></a>CP.102: Carefully study the literature"
msgstr""

       
# CppCoreGuidelines.md:9989
msgid "9989    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:9990
msgid "9990    With the exception of atomics and a few use standard patterns, lock-free programming is really an expert-only topic."
msgstr""

# CppCoreGuidelines.md:9991
msgid "9991    Become an expert before shipping lock-free code for others to use."
msgstr""

       
# CppCoreGuidelines.md:9992
msgid "9992    ##### References"
msgstr""

       
# CppCoreGuidelines.md:9993
msgid "9993    * Anthony Williams: C++ concurrency in action. Manning Publications."
msgstr""

# CppCoreGuidelines.md:9994
msgid "9994    * Boehm, Adve, You Don't Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012."
msgstr""

# CppCoreGuidelines.md:9995
msgid "9995    * Boehm, \"Threads Basics\", HPL TR 2009-259."
msgstr""

# CppCoreGuidelines.md:9996
msgid "9996    * Adve, Boehm, \"Memory Models: A Case for Rethinking Parallel Languages and Hardware\", Communications of the ACM, August 2010."
msgstr""

# CppCoreGuidelines.md:9997
msgid "9997    * Boehm, Adve, \"Foundations of the C++ Concurrency Memory Model\", PLDI 08."
msgstr""

# CppCoreGuidelines.md:9998
msgid "9998    * Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, \"Mathematizing C++ Concurrency\", POPL 2011."
msgstr""

# CppCoreGuidelines.md:9999
msgid "9999    * Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010."
msgstr""

# CppCoreGuidelines.md:10000
msgid "10000    * Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA'09. October 2009"
msgstr""

# CppCoreGuidelines.md:10001
msgid "10001    * Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009."
msgstr""

       
       
# CppCoreGuidelines.md:10002
msgid "10002    ### <a name=\"Rconc-double\"></a>CP.110: Do not write your own double-checked locking for initialization"
msgstr""

       
# CppCoreGuidelines.md:10003
msgid "10003    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10004
msgid "10004    Since C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization."
msgstr""

       
# CppCoreGuidelines.md:10005
msgid "10005    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10006
msgid "10006    Example with std::call_once."
msgstr""

       
# CppCoreGuidelines.md:10007
msgid "10007        void f()"
msgstr""

# CppCoreGuidelines.md:10008
msgid "10008        {"
msgstr""

# CppCoreGuidelines.md:10009
msgid "10009            static std::once_flag my_once_flag;"
msgstr""

# CppCoreGuidelines.md:10010
msgid "10010            std::call_once(my_once_flag, []()"
msgstr""

# CppCoreGuidelines.md:10011
msgid "10011            {"
msgstr""

# CppCoreGuidelines.md:10012
msgid "10012                // do this only once"
msgstr""

# CppCoreGuidelines.md:10013
msgid "10013            });"
msgstr""

# CppCoreGuidelines.md:10014
msgid "10014            // ..."
msgstr""

# CppCoreGuidelines.md:10015
msgid "10015        }"
msgstr""

       
# CppCoreGuidelines.md:10016
msgid "10016    Example with thread-safe static local variables of C++11."
msgstr""

       
# CppCoreGuidelines.md:10017
msgid "10017        void f()"
msgstr""

# CppCoreGuidelines.md:10018
msgid "10018        {"
msgstr""

# CppCoreGuidelines.md:10019
msgid "10019            // Assuming the compiler is compliant with C++11"
msgstr""

# CppCoreGuidelines.md:10020
msgid "10020            static My_class my_object; // Constructor called only once"
msgstr""

# CppCoreGuidelines.md:10021
msgid "10021            // ..."
msgstr""

# CppCoreGuidelines.md:10022
msgid "10022        }"
msgstr""

       
# CppCoreGuidelines.md:10023
msgid "10023        class My_class"
msgstr""

# CppCoreGuidelines.md:10024
msgid "10024        {"
msgstr""

# CppCoreGuidelines.md:10025
msgid "10025        public:"
msgstr""

# CppCoreGuidelines.md:10026
msgid "10026            My_class()"
msgstr""

# CppCoreGuidelines.md:10027
msgid "10027            {"
msgstr""

# CppCoreGuidelines.md:10028
msgid "10028                // do this only once"
msgstr""

# CppCoreGuidelines.md:10029
msgid "10029            }"
msgstr""

# CppCoreGuidelines.md:10030
msgid "10030        };"
msgstr""

       
# CppCoreGuidelines.md:10031
msgid "10031    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10032
msgid "10032    ??? Is it possible to detect the idiom?"
msgstr""

       
       
# CppCoreGuidelines.md:10033
msgid "10033    ### <a name=\"Rconc-double-pattern\"></a>CP.111: Use a conventional pattern if you really need double-checked locking"
msgstr""

       
# CppCoreGuidelines.md:10034
msgid "10034    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10035
msgid "10035    Double-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double) and [CP.100: Don't use lock-free programming unless you absolutely have to](#Rconc-lockfree), then do it in a conventional pattern."
msgstr""

       
# CppCoreGuidelines.md:10036
msgid "10036    The uses of the double-checked locking pattern that are not in violation of [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double) arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse."
msgstr""

       
# CppCoreGuidelines.md:10037
msgid "10037    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:10038
msgid "10038    The use of volatile does not make the first check thread-safe, see also [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-volatile2)"
msgstr""

       
# CppCoreGuidelines.md:10039
msgid "10039        mutex action_mutex;"
msgstr""

# CppCoreGuidelines.md:10040
msgid "10040        volatile bool action_needed;"
msgstr""

       
# CppCoreGuidelines.md:10041
msgid "10041        if (action_needed) {"
msgstr""

# CppCoreGuidelines.md:10042
msgid "10042            std::lock_guard<std::mutex> lock(action_mutex);"
msgstr""

# CppCoreGuidelines.md:10043
msgid "10043            if (action_needed) {"
msgstr""

# CppCoreGuidelines.md:10044
msgid "10044                take_action();"
msgstr""

# CppCoreGuidelines.md:10045
msgid "10045                action_needed = false;"
msgstr""

# CppCoreGuidelines.md:10046
msgid "10046            }"
msgstr""

# CppCoreGuidelines.md:10047
msgid "10047        }"
msgstr""

       
# CppCoreGuidelines.md:10048
msgid "10048    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:10049
msgid "10049        mutex action_mutex;"
msgstr""

# CppCoreGuidelines.md:10050
msgid "10050        atomic<bool> action_needed;"
msgstr""

       
# CppCoreGuidelines.md:10051
msgid "10051        if (action_needed) {"
msgstr""

# CppCoreGuidelines.md:10052
msgid "10052            std::lock_guard<std::mutex> lock(action_mutex);"
msgstr""

# CppCoreGuidelines.md:10053
msgid "10053            if (action_needed) {"
msgstr""

# CppCoreGuidelines.md:10054
msgid "10054                take_action();"
msgstr""

# CppCoreGuidelines.md:10055
msgid "10055                action_needed = false;"
msgstr""

# CppCoreGuidelines.md:10056
msgid "10056            }"
msgstr""

# CppCoreGuidelines.md:10057
msgid "10057        }"
msgstr""

       
# CppCoreGuidelines.md:10058
msgid "10058    Fine-tuned memory order may be beneficial where acquire load is more efficient than sequentially-consistent load"
msgstr""

       
# CppCoreGuidelines.md:10059
msgid "10059        mutex action_mutex;"
msgstr""

# CppCoreGuidelines.md:10060
msgid "10060        atomic<bool> action_needed;"
msgstr""

       
# CppCoreGuidelines.md:10061
msgid "10061        if (action_needed.load(memory_order_acquire)) {"
msgstr""

# CppCoreGuidelines.md:10062
msgid "10062            lock_guard<std::mutex> lock(action_mutex);"
msgstr""

# CppCoreGuidelines.md:10063
msgid "10063            if (action_needed.load(memory_order_relaxed)) {"
msgstr""

# CppCoreGuidelines.md:10064
msgid "10064                take_action();"
msgstr""

# CppCoreGuidelines.md:10065
msgid "10065                action_needed.store(false, memory_order_release);"
msgstr""

# CppCoreGuidelines.md:10066
msgid "10066            }"
msgstr""

# CppCoreGuidelines.md:10067
msgid "10067        }"
msgstr""

       
# CppCoreGuidelines.md:10068
msgid "10068    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10069
msgid "10069    ??? Is it possible to detect the idiom?"
msgstr""

       
       
# CppCoreGuidelines.md:10070
msgid "10070    ## <a name=\"SScp-etc\"></a>CP.etc: Etc. concurrency rules"
msgstr""

       
# CppCoreGuidelines.md:10071
msgid "10071    These rules defy simple categorization:"
msgstr""

       
# CppCoreGuidelines.md:10072
msgid "10072    * [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-volatile2)"
msgstr""

# CppCoreGuidelines.md:10073
msgid "10073    * [CP.201: ??? Signals](#Rconc-signal)"
msgstr""

       
# CppCoreGuidelines.md:10074
msgid "10074    ### <a name=\"Rconc-volatile2\"></a>CP.200: Use `volatile` only to talk to non-C++ memory"
msgstr""

       
# CppCoreGuidelines.md:10075
msgid "10075    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10076
msgid "10076    `volatile` is used to refer to objects that are shared with \"non-C++\" code or hardware that does not follow the C++ memory model."
msgstr""

       
# CppCoreGuidelines.md:10077
msgid "10077    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10078
msgid "10078        const volatile long clock;"
msgstr""

       
# CppCoreGuidelines.md:10079
msgid "10079    This describes a register constantly updated by a clock circuit."
msgstr""

# CppCoreGuidelines.md:10080
msgid "10080    `clock` is `volatile` because its value will change without any action from the C++ program that uses it."
msgstr""

# CppCoreGuidelines.md:10081
msgid "10081    For example, reading `clock` twice will often yield two different values, so the optimizer had better not optimize away the second read in this code:"
msgstr""

       
# CppCoreGuidelines.md:10082
msgid "10082        long t1 = clock;"
msgstr""

# CppCoreGuidelines.md:10083
msgid "10083        // ... no use of clock here ..."
msgstr""

# CppCoreGuidelines.md:10084
msgid "10084        long t2 = clock;"
msgstr""

       
# CppCoreGuidelines.md:10085
msgid "10085    `clock` is `const` because the program should not try to write to `clock`."
msgstr""

       
# CppCoreGuidelines.md:10086
msgid "10086    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10087
msgid "10087    Unless you are writing the lowest level code manipulating hardware directly, consider `volatile` an esoteric feature that is best avoided."
msgstr""

       
# CppCoreGuidelines.md:10088
msgid "10088    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10089
msgid "10089    Usually C++ code receives `volatile` memory that is owned Elsewhere (hardware or another language):"
msgstr""

       
# CppCoreGuidelines.md:10090
msgid "10090        int volatile* vi = get_hardware_memory_location();"
msgstr""

# CppCoreGuidelines.md:10091
msgid "10091            // note: we get a pointer to someone else's memory here"
msgstr""

# CppCoreGuidelines.md:10092
msgid "10092            // volatile says \"treat this with extra respect\""
msgstr""

       
# CppCoreGuidelines.md:10093
msgid "10093    Sometimes C++ code allocates the `volatile` memory and shares it with \"elsewhere\" (hardware or another language) by deliberately escaping a pointer:"
msgstr""

       
# CppCoreGuidelines.md:10094
msgid "10094        static volatile long vl;"
msgstr""

# CppCoreGuidelines.md:10095
msgid "10095        please_use_this(&vl);   // escape a reference to this to \"elsewhere\" (not C++)"
msgstr""

       
# CppCoreGuidelines.md:10096
msgid "10096    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:10097
msgid "10097    `volatile` local variables are nearly always wrong -- how can they be shared with other languages or hardware if they're ephemeral?"
msgstr""

# CppCoreGuidelines.md:10098
msgid "10098    The same applies almost as strongly to member variables, for the same reason."
msgstr""

       
# CppCoreGuidelines.md:10099
msgid "10099        void f() {"
msgstr""

# CppCoreGuidelines.md:10100
msgid "10100            volatile int i = 0; // bad, volatile local variable"
msgstr""

# CppCoreGuidelines.md:10101
msgid "10101            // etc."
msgstr""

# CppCoreGuidelines.md:10102
msgid "10102        }"
msgstr""

       
# CppCoreGuidelines.md:10103
msgid "10103        class My_type {"
msgstr""

# CppCoreGuidelines.md:10104
msgid "10104            volatile int i = 0; // suspicious, volatile member variable"
msgstr""

# CppCoreGuidelines.md:10105
msgid "10105            // etc."
msgstr""

# CppCoreGuidelines.md:10106
msgid "10106        };"
msgstr""

       
# CppCoreGuidelines.md:10107
msgid "10107    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10108
msgid "10108    In C++, unlike in some other languages, `volatile` has [nothing to do with synchronization](#Rconc-volatile)."
msgstr""

       
# CppCoreGuidelines.md:10109
msgid "10109    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10110
msgid "10110    * Flag `volatile T` local and member variables; almost certainly you intended to use `atomic<T>` instead."
msgstr""

# CppCoreGuidelines.md:10111
msgid "10111    * ???"
msgstr""

       
# CppCoreGuidelines.md:10112
msgid "10112    ### <a name=\"Rconc-signal\"></a>CP.201: ??? Signals"
msgstr""

       
# CppCoreGuidelines.md:10113
msgid "10113    ???UNIX signal handling???. May be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably \"not at all\")"
msgstr""

       
       
# CppCoreGuidelines.md:10114
msgid "10114    # <a name=\"S-errors\"></a>E: Error handling"
msgstr""

       
# CppCoreGuidelines.md:10115
msgid "10115    Error handling involves:"
msgstr""

       
# CppCoreGuidelines.md:10116
msgid "10116    * Detecting an error"
msgstr""

# CppCoreGuidelines.md:10117
msgid "10117    * Transmitting information about an error to some handler code"
msgstr""

# CppCoreGuidelines.md:10118
msgid "10118    * Preserve the state of a program in a valid state"
msgstr""

# CppCoreGuidelines.md:10119
msgid "10119    * Avoid resource leaks"
msgstr""

       
# CppCoreGuidelines.md:10120
msgid "10120    It is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly \"get out\" in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors.  Untested and rarely executed error-handling code is itself the source of many bugs."
msgstr""

       
# CppCoreGuidelines.md:10121
msgid "10121    The rules are designed to help avoid several kinds of errors:"
msgstr""

       
# CppCoreGuidelines.md:10122
msgid "10122    * Type violations (e.g., misuse of `union`s and casts)"
msgstr""

# CppCoreGuidelines.md:10123
msgid "10123    * Resource leaks (including memory leaks)"
msgstr""

# CppCoreGuidelines.md:10124
msgid "10124    * Bounds errors"
msgstr""

# CppCoreGuidelines.md:10125
msgid "10125    * Lifetime errors (e.g., accessing an object after is has been `delete`d)"
msgstr""

# CppCoreGuidelines.md:10126
msgid "10126    * Complexity errors (logical errors made likely by overly complex expression of ideas)"
msgstr""

# CppCoreGuidelines.md:10127
msgid "10127    * Interface errors (e.g., an unexpected value is passed through an interface)"
msgstr""

       
# CppCoreGuidelines.md:10128
msgid "10128    Error-handling rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10129
msgid "10129    * [E.1: Develop an error-handling strategy early in a design](#Re-design)"
msgstr""

# CppCoreGuidelines.md:10130
msgid "10130    * [E.2: Throw an exception to signal that a function can't perform its assigned task](#Re-throw)"
msgstr""

# CppCoreGuidelines.md:10131
msgid "10131    * [E.3: Use exceptions for error handling only](#Re-errors)"
msgstr""

# CppCoreGuidelines.md:10132
msgid "10132    * [E.4: Design your error-handling strategy around invariants](#Re-design-invariants)"
msgstr""

# CppCoreGuidelines.md:10133
msgid "10133    * [E.5: Let a constructor establish an invariant, and throw if it cannot](#Re-invariant)"
msgstr""

# CppCoreGuidelines.md:10134
msgid "10134    * [E.6: Use RAII to prevent leaks](#Re-raii)"
msgstr""

# CppCoreGuidelines.md:10135
msgid "10135    * [E.7: State your preconditions](#Re-precondition)"
msgstr""

# CppCoreGuidelines.md:10136
msgid "10136    * [E.8: State your postconditions](#Re-postcondition)"
msgstr""

       
# CppCoreGuidelines.md:10137
msgid "10137    * [E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable](#Re-noexcept)"
msgstr""

# CppCoreGuidelines.md:10138
msgid "10138    * [E.13: Never throw while being the direct owner of an object](#Re-never-throw)"
msgstr""

# CppCoreGuidelines.md:10139
msgid "10139    * [E.14: Use purpose-designed user-defined types as exceptions (not built-in types)](#Re-exception-types)"
msgstr""

# CppCoreGuidelines.md:10140
msgid "10140    * [E.15: Catch exceptions from a hierarchy by reference](#Re-exception-ref)"
msgstr""

# CppCoreGuidelines.md:10141
msgid "10141    * [E.16: Destructors, deallocation, and `swap` must never fail](#Re-never-fail)"
msgstr""

# CppCoreGuidelines.md:10142
msgid "10142    * [E.17: Don't try to catch every exception in every function](#Re-not-always)"
msgstr""

# CppCoreGuidelines.md:10143
msgid "10143    * [E.18: Minimize the use of explicit `try`/`catch`](#Re-catch)"
msgstr""

# CppCoreGuidelines.md:10144
msgid "10144    * [E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available](#Re-finally)"
msgstr""

       
# CppCoreGuidelines.md:10145
msgid "10145    * [E.25: If you can't throw exceptions, simulate RAII for resource management](#Re-no-throw-raii)"
msgstr""

# CppCoreGuidelines.md:10146
msgid "10146    * [E.26: If you can't throw exceptions, consider failing fast](#Re-no-throw-crash)"
msgstr""

# CppCoreGuidelines.md:10147
msgid "10147    * [E.27: If you can't throw exceptions, use error codes systematically](#Re-no-throw-codes)"
msgstr""

# CppCoreGuidelines.md:10148
msgid "10148    * [E.28: Avoid error handling based on global state (e.g. `errno`)](#Re-no-throw)"
msgstr""

       
# CppCoreGuidelines.md:10149
msgid "10149    * [E.30: Don't use exception specifications](#Re-specifications)"
msgstr""

# CppCoreGuidelines.md:10150
msgid "10150    * [E.31: Properly order your `catch`-clauses](#Re_catch)"
msgstr""

       
# CppCoreGuidelines.md:10151
msgid "10151    ### <a name=\"Re-design\"></a>E.1: Develop an error-handling strategy early in a design"
msgstr""

       
# CppCoreGuidelines.md:10152
msgid "10152    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10153
msgid "10153    A consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system."
msgstr""

       
# CppCoreGuidelines.md:10154
msgid "10154    ### <a name=\"Re-throw\"></a>E.2: Throw an exception to signal that a function can't perform its assigned task"
msgstr""

       
# CppCoreGuidelines.md:10155
msgid "10155    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10156
msgid "10156    To make error handling systematic, robust, and non-repetitive."
msgstr""

       
# CppCoreGuidelines.md:10157
msgid "10157    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10158
msgid "10158        struct Foo {"
msgstr""

# CppCoreGuidelines.md:10159
msgid "10159            vector<Thing> v;"
msgstr""

# CppCoreGuidelines.md:10160
msgid "10160            File_handle f;"
msgstr""

# CppCoreGuidelines.md:10161
msgid "10161            string s;"
msgstr""

# CppCoreGuidelines.md:10162
msgid "10162        };"
msgstr""

       
# CppCoreGuidelines.md:10163
msgid "10163        void use()"
msgstr""

# CppCoreGuidelines.md:10164
msgid "10164        {"
msgstr""

# CppCoreGuidelines.md:10165
msgid "10165            Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {\"my_file\", \"r\"}, \"Here we go!\"};"
msgstr""

# CppCoreGuidelines.md:10166
msgid "10166            // ..."
msgstr""

# CppCoreGuidelines.md:10167
msgid "10167        }"
msgstr""

       
# CppCoreGuidelines.md:10168
msgid "10168    Here, `vector` and `string`s constructors may not be able to allocate sufficient memory for their elements, `vector`s constructor may not be able copy the `Thing`s in its initializer list, and `File_handle` may not be able to open the required file."
msgstr""

# CppCoreGuidelines.md:10169
msgid "10169    In each case, they throw an exception for `use()`'s caller to handle."
msgstr""

# CppCoreGuidelines.md:10170
msgid "10170    If `use()` could handle the failure to construct `bar` it can take control using `try`/`catch`."
msgstr""

# CppCoreGuidelines.md:10171
msgid "10171    In either case, `Foo`'s constructor correctly destroys constructed members before passing control to whatever tried to create a `Foo`."
msgstr""

# CppCoreGuidelines.md:10172
msgid "10172    Note that there is no return value that could contain an error code."
msgstr""

       
# CppCoreGuidelines.md:10173
msgid "10173    The `File_handle` constructor might be defined like this:"
msgstr""

       
# CppCoreGuidelines.md:10174
msgid "10174        File_handle::File_handle(const string& name, const string& mode)"
msgstr""

# CppCoreGuidelines.md:10175
msgid "10175            :f{fopen(name.c_str(), mode.c_str())}"
msgstr""

# CppCoreGuidelines.md:10176
msgid "10176        {"
msgstr""

# CppCoreGuidelines.md:10177
msgid "10177            if (!f)"
msgstr""

# CppCoreGuidelines.md:10178
msgid "10178                throw runtime_error{\"File_handle: could not open \" + name + \" as \" + mode};"
msgstr""

# CppCoreGuidelines.md:10179
msgid "10179        }"
msgstr""

       
# CppCoreGuidelines.md:10180
msgid "10180    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10181
msgid "10181    It is often said that exceptions are meant to signal exceptional events and failures."
msgstr""

# CppCoreGuidelines.md:10182
msgid "10182    However, that's a bit circular because \"what is exceptional?\""
msgstr""

# CppCoreGuidelines.md:10183
msgid "10183    Examples:"
msgstr""

       
# CppCoreGuidelines.md:10184
msgid "10184    * A precondition that cannot be met"
msgstr""

# CppCoreGuidelines.md:10185
msgid "10185    * A constructor that cannot construct an object (failure to establish its class's [invariant](#Rc-struct))"
msgstr""

# CppCoreGuidelines.md:10186
msgid "10186    * An out-of-range error (e.g., `v[v.size()] = 7`)"
msgstr""

# CppCoreGuidelines.md:10187
msgid "10187    * Inability to acquire a resource (e.g., the network is down)"
msgstr""

       
# CppCoreGuidelines.md:10188
msgid "10188    In contrast, termination of an ordinary loop is not exceptional."
msgstr""

# CppCoreGuidelines.md:10189
msgid "10189    Unless the loop was meant to be infinite, termination is normal and expected."
msgstr""

       
# CppCoreGuidelines.md:10190
msgid "10190    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10191
msgid "10191    Don't use a `throw` as simply an alternative way of returning a value from a function."
msgstr""

       
# CppCoreGuidelines.md:10192
msgid "10192    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:10193
msgid "10193    Some systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a `throw`."
msgstr""

       
# CppCoreGuidelines.md:10194
msgid "10194    **See also**: [RAII](#Re-raii)"
msgstr""

       
# CppCoreGuidelines.md:10195
msgid "10195    **See also**: [discussion](#Sd-noexcept)"
msgstr""

       
# CppCoreGuidelines.md:10196
msgid "10196    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10197
msgid "10197    Before deciding that you cannot afford or don't like exception-based error handling, have a look at the [alternatives](#Re-no-throw-raii);"
msgstr""

# CppCoreGuidelines.md:10198
msgid "10198    they have their own complexities and problems."
msgstr""

# CppCoreGuidelines.md:10199
msgid "10199    Also, as far as possible, measure before making claims about efficiency."
msgstr""

       
# CppCoreGuidelines.md:10200
msgid "10200    ### <a name=\"Re-errors\"></a>E.3: Use exceptions for error handling only"
msgstr""

       
# CppCoreGuidelines.md:10201
msgid "10201    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10202
msgid "10202    To keep error handling separated from \"ordinary code.\""
msgstr""

# CppCoreGuidelines.md:10203
msgid "10203    C++ implementations tend to be optimized based on the assumption that exceptions are rare."
msgstr""

       
# CppCoreGuidelines.md:10204
msgid "10204    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:10205
msgid "10205        // don't: exception not used for error handling"
msgstr""

# CppCoreGuidelines.md:10206
msgid "10206        int find_index(vector<string>& vec, const string& x)"
msgstr""

# CppCoreGuidelines.md:10207
msgid "10207        {"
msgstr""

# CppCoreGuidelines.md:10208
msgid "10208            try {"
msgstr""

# CppCoreGuidelines.md:10209
msgid "10209                for (gsl::index i = 0; i < vec.size(); ++i)"
msgstr""

# CppCoreGuidelines.md:10210
msgid "10210                    if (vec[i] == x) throw i;  // found x"
msgstr""

# CppCoreGuidelines.md:10211
msgid "10211            } catch (int i) {"
msgstr""

# CppCoreGuidelines.md:10212
msgid "10212                return i;"
msgstr""

# CppCoreGuidelines.md:10213
msgid "10213            }"
msgstr""

# CppCoreGuidelines.md:10214
msgid "10214            return -1;   // not found"
msgstr""

# CppCoreGuidelines.md:10215
msgid "10215        }"
msgstr""

       
# CppCoreGuidelines.md:10216
msgid "10216    This is more complicated and most likely runs much slower than the obvious alternative."
msgstr""

# CppCoreGuidelines.md:10217
msgid "10217    There is nothing exceptional about finding a value in a `vector`."
msgstr""

       
# CppCoreGuidelines.md:10218
msgid "10218    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10219
msgid "10219    Would need to be heuristic."
msgstr""

# CppCoreGuidelines.md:10220
msgid "10220    Look for exception values \"leaked\" out of `catch` clauses."
msgstr""

       
# CppCoreGuidelines.md:10221
msgid "10221    ### <a name=\"Re-design-invariants\"></a>E.4: Design your error-handling strategy around invariants"
msgstr""

       
# CppCoreGuidelines.md:10222
msgid "10222    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10223
msgid "10223    To use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state."
msgstr""

       
# CppCoreGuidelines.md:10224
msgid "10224    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10225
msgid "10225    An [invariant](#Rc-struct) is logical condition for the members of an object that a constructor must establish for the public member functions to assume."
msgstr""

       
# CppCoreGuidelines.md:10226
msgid "10226    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10227
msgid "10227    ???"
msgstr""

       
# CppCoreGuidelines.md:10228
msgid "10228    ### <a name=\"Re-invariant\"></a>E.5: Let a constructor establish an invariant, and throw if it cannot"
msgstr""

       
# CppCoreGuidelines.md:10229
msgid "10229    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10230
msgid "10230    Leaving an object without its invariant established is asking for trouble."
msgstr""

# CppCoreGuidelines.md:10231
msgid "10231    Not all member functions can be called."
msgstr""

       
# CppCoreGuidelines.md:10232
msgid "10232    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10233
msgid "10233        class Vector {  // very simplified vector of doubles"
msgstr""

# CppCoreGuidelines.md:10234
msgid "10234            // if elem != nullptr then elem points to sz doubles"
msgstr""

# CppCoreGuidelines.md:10235
msgid "10235        public:"
msgstr""

# CppCoreGuidelines.md:10236
msgid "10236            Vector() : elem{nullptr}, sz{0}{}"
msgstr""

# CppCoreGuidelines.md:10237
msgid "10237            Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ }"
msgstr""

# CppCoreGuidelines.md:10238
msgid "10238            ~Vector() { delete [] elem; }"
msgstr""

# CppCoreGuidelines.md:10239
msgid "10239            double& operator[](int s) { return elem[s]; }"
msgstr""

# CppCoreGuidelines.md:10240
msgid "10240            // ..."
msgstr""

# CppCoreGuidelines.md:10241
msgid "10241        private:"
msgstr""

# CppCoreGuidelines.md:10242
msgid "10242            owner<double*> elem;"
msgstr""

# CppCoreGuidelines.md:10243
msgid "10243            int sz;"
msgstr""

# CppCoreGuidelines.md:10244
msgid "10244        };"
msgstr""

       
# CppCoreGuidelines.md:10245
msgid "10245    The class invariant - here stated as a comment - is established by the constructors."
msgstr""

# CppCoreGuidelines.md:10246
msgid "10246    `new` throws if it cannot allocate the required memory."
msgstr""

# CppCoreGuidelines.md:10247
msgid "10247    The operators, notably the subscript operator, relies on the invariant."
msgstr""

       
# CppCoreGuidelines.md:10248
msgid "10248    **See also**: [If a constructor cannot construct a valid object, throw an exception](#Rc-throw)"
msgstr""

       
# CppCoreGuidelines.md:10249
msgid "10249    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10250
msgid "10250    Flag classes with `private` state without a constructor (public, protected, or private)."
msgstr""

       
# CppCoreGuidelines.md:10251
msgid "10251    ### <a name=\"Re-raii\"></a>E.6: Use RAII to prevent leaks"
msgstr""

       
# CppCoreGuidelines.md:10252
msgid "10252    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10253
msgid "10253    Leaks are typically unacceptable."
msgstr""

# CppCoreGuidelines.md:10254
msgid "10254    Manual resource release is error-prone."
msgstr""

# CppCoreGuidelines.md:10255
msgid "10255    RAII (\"Resource Acquisition Is Initialization\") is the simplest, most systematic way of preventing leaks."
msgstr""

       
# CppCoreGuidelines.md:10256
msgid "10256    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10257
msgid "10257        void f1(int i)   // Bad: possibly leak"
msgstr""

# CppCoreGuidelines.md:10258
msgid "10258        {"
msgstr""

# CppCoreGuidelines.md:10259
msgid "10259            int* p = new int[12];"
msgstr""

# CppCoreGuidelines.md:10260
msgid "10260            // ..."
msgstr""

# CppCoreGuidelines.md:10261
msgid "10261            if (i < 17) throw Bad{\"in f()\", i};"
msgstr""

# CppCoreGuidelines.md:10262
msgid "10262            // ..."
msgstr""

# CppCoreGuidelines.md:10263
msgid "10263        }"
msgstr""

       
# CppCoreGuidelines.md:10264
msgid "10264    We could carefully release the resource before the throw:"
msgstr""

       
# CppCoreGuidelines.md:10265
msgid "10265        void f2(int i)   // Clumsy and error-prone: explicit release"
msgstr""

# CppCoreGuidelines.md:10266
msgid "10266        {"
msgstr""

# CppCoreGuidelines.md:10267
msgid "10267            int* p = new int[12];"
msgstr""

# CppCoreGuidelines.md:10268
msgid "10268            // ..."
msgstr""

# CppCoreGuidelines.md:10269
msgid "10269            if (i < 17) {"
msgstr""

# CppCoreGuidelines.md:10270
msgid "10270                delete[] p;"
msgstr""

# CppCoreGuidelines.md:10271
msgid "10271                throw Bad{\"in f()\", i};"
msgstr""

# CppCoreGuidelines.md:10272
msgid "10272            }"
msgstr""

# CppCoreGuidelines.md:10273
msgid "10273            // ..."
msgstr""

# CppCoreGuidelines.md:10274
msgid "10274        }"
msgstr""

       
# CppCoreGuidelines.md:10275
msgid "10275    This is verbose. In larger code with multiple possible `throw`s explicit releases become repetitive and error-prone."
msgstr""

       
# CppCoreGuidelines.md:10276
msgid "10276        void f3(int i)   // OK: resource management done by a handle (but see below)"
msgstr""

# CppCoreGuidelines.md:10277
msgid "10277        {"
msgstr""

# CppCoreGuidelines.md:10278
msgid "10278            auto p = make_unique<int[]>(12);"
msgstr""

# CppCoreGuidelines.md:10279
msgid "10279            // ..."
msgstr""

# CppCoreGuidelines.md:10280
msgid "10280            if (i < 17) throw Bad{\"in f()\", i};"
msgstr""

# CppCoreGuidelines.md:10281
msgid "10281            // ..."
msgstr""

# CppCoreGuidelines.md:10282
msgid "10282        }"
msgstr""

       
# CppCoreGuidelines.md:10283
msgid "10283    Note that this works even when the `throw` is implicit because it happened in a called function:"
msgstr""

       
# CppCoreGuidelines.md:10284
msgid "10284        void f4(int i)   // OK: resource management done by a handle (but see below)"
msgstr""

# CppCoreGuidelines.md:10285
msgid "10285        {"
msgstr""

# CppCoreGuidelines.md:10286
msgid "10286            auto p = make_unique<int[]>(12);"
msgstr""

# CppCoreGuidelines.md:10287
msgid "10287            // ..."
msgstr""

# CppCoreGuidelines.md:10288
msgid "10288            helper(i);   // may throw"
msgstr""

# CppCoreGuidelines.md:10289
msgid "10289            // ..."
msgstr""

# CppCoreGuidelines.md:10290
msgid "10290        }"
msgstr""

       
# CppCoreGuidelines.md:10291
msgid "10291    Unless you really need pointer semantics, use a local resource object:"
msgstr""

       
# CppCoreGuidelines.md:10292
msgid "10292        void f5(int i)   // OK: resource management done by local object"
msgstr""

# CppCoreGuidelines.md:10293
msgid "10293        {"
msgstr""

# CppCoreGuidelines.md:10294
msgid "10294            vector<int> v(12);"
msgstr""

# CppCoreGuidelines.md:10295
msgid "10295            // ..."
msgstr""

# CppCoreGuidelines.md:10296
msgid "10296            helper(i);   // may throw"
msgstr""

# CppCoreGuidelines.md:10297
msgid "10297            // ..."
msgstr""

# CppCoreGuidelines.md:10298
msgid "10298        }"
msgstr""

       
# CppCoreGuidelines.md:10299
msgid "10299    That's even simpler and safer, and often more efficient."
msgstr""

       
# CppCoreGuidelines.md:10300
msgid "10300    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10301
msgid "10301    If there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible,"
msgstr""

# CppCoreGuidelines.md:10302
msgid "10302    as a last resort, cleanup actions can be represented by a [`final_action`](#Re-finally) object."
msgstr""

       
# CppCoreGuidelines.md:10303
msgid "10303    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10304
msgid "10304    But what do we do if we are writing a program where exceptions cannot be used?"
msgstr""

# CppCoreGuidelines.md:10305
msgid "10305    First challenge that assumption; there are many anti-exceptions myths around."
msgstr""

# CppCoreGuidelines.md:10306
msgid "10306    We know of only a few good reasons:"
msgstr""

       
# CppCoreGuidelines.md:10307
msgid "10307    * We are on a system so small that the exception support would eat up most of our 2K memory."
msgstr""

# CppCoreGuidelines.md:10308
msgid "10308    * We are in a hard-real-time system and we don't have tools that guarantee us that an exception is handled within the required time."
msgstr""

# CppCoreGuidelines.md:10309
msgid "10309    * We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways"
msgstr""

# CppCoreGuidelines.md:10310
msgid "10310      (in particular without a recognizable ownership strategy) so that exceptions could cause leaks."
msgstr""

# CppCoreGuidelines.md:10311
msgid "10311    * Our implementation of the C++ exception mechanisms is unreasonably poor"
msgstr""

# CppCoreGuidelines.md:10312
msgid "10312    (slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.)."
msgstr""

# CppCoreGuidelines.md:10313
msgid "10313    Complain to your implementation purveyor; if no user complains, no improvement will happen."
msgstr""

# CppCoreGuidelines.md:10314
msgid "10314    * We get fired if we challenge our manager's ancient wisdom."
msgstr""

       
# CppCoreGuidelines.md:10315
msgid "10315    Only the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail."
msgstr""

# CppCoreGuidelines.md:10316
msgid "10316    When exceptions cannot be used, simulate RAII."
msgstr""

# CppCoreGuidelines.md:10317
msgid "10317    That is, systematically check that objects are valid after construction and still release all resources in the destructor."
msgstr""

# CppCoreGuidelines.md:10318
msgid "10318    One strategy is to add a `valid()` operation to every resource handle:"
msgstr""

       
# CppCoreGuidelines.md:10319
msgid "10319        void f()"
msgstr""

# CppCoreGuidelines.md:10320
msgid "10320        {"
msgstr""

# CppCoreGuidelines.md:10321
msgid "10321            vector<string> vs(100);   // not std::vector: valid() added"
msgstr""

# CppCoreGuidelines.md:10322
msgid "10322            if (!vs.valid()) {"
msgstr""

# CppCoreGuidelines.md:10323
msgid "10323                // handle error or exit"
msgstr""

# CppCoreGuidelines.md:10324
msgid "10324            }"
msgstr""

       
# CppCoreGuidelines.md:10325
msgid "10325            ifstream fs(\"foo\");   // not std::ifstream: valid() added"
msgstr""

# CppCoreGuidelines.md:10326
msgid "10326            if (!fs.valid()) {"
msgstr""

# CppCoreGuidelines.md:10327
msgid "10327                // handle error or exit"
msgstr""

# CppCoreGuidelines.md:10328
msgid "10328            }"
msgstr""

       
# CppCoreGuidelines.md:10329
msgid "10329            // ..."
msgstr""

# CppCoreGuidelines.md:10330
msgid "10330        } // destructors clean up as usual"
msgstr""

       
# CppCoreGuidelines.md:10331
msgid "10331    Obviously, this increases the size of the code, doesn't allow for implicit propagation of \"exceptions\" (`valid()` checks), and `valid()` checks can be forgotten."
msgstr""

# CppCoreGuidelines.md:10332
msgid "10332    Prefer to use exceptions."
msgstr""

       
# CppCoreGuidelines.md:10333
msgid "10333    **See also**: [Use of `noexcept`](#Se-noexcept)"
msgstr""

       
# CppCoreGuidelines.md:10334
msgid "10334    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10335
msgid "10335    ???"
msgstr""

       
# CppCoreGuidelines.md:10336
msgid "10336    ### <a name=\"Re-precondition\"></a>E.7: State your preconditions"
msgstr""

       
# CppCoreGuidelines.md:10337
msgid "10337    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10338
msgid "10338    To avoid interface errors."
msgstr""

       
# CppCoreGuidelines.md:10339
msgid "10339    **See also**: [precondition rule](#Ri-pre)"
msgstr""

       
# CppCoreGuidelines.md:10340
msgid "10340    ### <a name=\"Re-postcondition\"></a>E.8: State your postconditions"
msgstr""

       
# CppCoreGuidelines.md:10341
msgid "10341    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10342
msgid "10342    To avoid interface errors."
msgstr""

       
# CppCoreGuidelines.md:10343
msgid "10343    **See also**: [postcondition rule](#Ri-post)"
msgstr""

       
# CppCoreGuidelines.md:10344
msgid "10344    ### <a name=\"Re-noexcept\"></a>E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable"
msgstr""

       
# CppCoreGuidelines.md:10345
msgid "10345    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10346
msgid "10346    To make error handling systematic, robust, and efficient."
msgstr""

       
# CppCoreGuidelines.md:10347
msgid "10347    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10348
msgid "10348        double compute(double d) noexcept"
msgstr""

# CppCoreGuidelines.md:10349
msgid "10349        {"
msgstr""

# CppCoreGuidelines.md:10350
msgid "10350            return log(sqrt(d <= 0 ? 1 : d));"
msgstr""

# CppCoreGuidelines.md:10351
msgid "10351        }"
msgstr""

       
# CppCoreGuidelines.md:10352
msgid "10352    Here, we know that `compute` will not throw because it is composed out of operations that don't throw."
msgstr""

# CppCoreGuidelines.md:10353
msgid "10353    By declaring `compute` to be `noexcept`, we give the compiler and human readers information that can make it easier for them to understand and manipulate `compute`."
msgstr""

       
# CppCoreGuidelines.md:10354
msgid "10354    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10355
msgid "10355    Many standard-library functions are `noexcept` including all the standard-library functions \"inherited\" from the C Standard Library."
msgstr""

       
# CppCoreGuidelines.md:10356
msgid "10356    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10357
msgid "10357        vector<double> munge(const vector<double>& v) noexcept"
msgstr""

# CppCoreGuidelines.md:10358
msgid "10358        {"
msgstr""

# CppCoreGuidelines.md:10359
msgid "10359            vector<double> v2(v.size());"
msgstr""

# CppCoreGuidelines.md:10360
msgid "10360            // ... do something ..."
msgstr""

# CppCoreGuidelines.md:10361
msgid "10361        }"
msgstr""

       
# CppCoreGuidelines.md:10362
msgid "10362    The `noexcept` here states that I am not willing or able to handle the situation where I cannot construct the local `vector`."
msgstr""

# CppCoreGuidelines.md:10363
msgid "10363    That is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I'm willing to crash the program if it happens."
msgstr""

       
# CppCoreGuidelines.md:10364
msgid "10364    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10365
msgid "10365    Do not use traditional [exception-specifications](#Re-specifications)."
msgstr""

       
# CppCoreGuidelines.md:10366
msgid "10366    ##### See also"
msgstr""

       
# CppCoreGuidelines.md:10367
msgid "10367    [discussion](#Sd-noexcept)."
msgstr""

       
# CppCoreGuidelines.md:10368
msgid "10368    ### <a name=\"Re-never-throw\"></a>E.13: Never throw while being the direct owner of an object"
msgstr""

       
# CppCoreGuidelines.md:10369
msgid "10369    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10370
msgid "10370    That would be a leak."
msgstr""

       
# CppCoreGuidelines.md:10371
msgid "10371    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10372
msgid "10372        void leak(int x)   // don't: may leak"
msgstr""

# CppCoreGuidelines.md:10373
msgid "10373        {"
msgstr""

# CppCoreGuidelines.md:10374
msgid "10374            auto p = new int{7};"
msgstr""

# CppCoreGuidelines.md:10375
msgid "10375            if (x < 0) throw Get_me_out_of_here{};  // may leak *p"
msgstr""

# CppCoreGuidelines.md:10376
msgid "10376            // ..."
msgstr""

# CppCoreGuidelines.md:10377
msgid "10377            delete p;   // we may never get here"
msgstr""

# CppCoreGuidelines.md:10378
msgid "10378        }"
msgstr""

       
# CppCoreGuidelines.md:10379
msgid "10379    One way of avoiding such problems is to use resource handles consistently:"
msgstr""

       
# CppCoreGuidelines.md:10380
msgid "10380        void no_leak(int x)"
msgstr""

# CppCoreGuidelines.md:10381
msgid "10381        {"
msgstr""

# CppCoreGuidelines.md:10382
msgid "10382            auto p = make_unique<int>(7);"
msgstr""

# CppCoreGuidelines.md:10383
msgid "10383            if (x < 0) throw Get_me_out_of_here{};  // will delete *p if necessary"
msgstr""

# CppCoreGuidelines.md:10384
msgid "10384            // ..."
msgstr""

# CppCoreGuidelines.md:10385
msgid "10385            // no need for delete p"
msgstr""

# CppCoreGuidelines.md:10386
msgid "10386        }"
msgstr""

       
# CppCoreGuidelines.md:10387
msgid "10387    Another solution (often better) would be to use a local variable to eliminate explicit use of pointers:"
msgstr""

       
# CppCoreGuidelines.md:10388
msgid "10388        void no_leak_simplified(int x)"
msgstr""

# CppCoreGuidelines.md:10389
msgid "10389        {"
msgstr""

# CppCoreGuidelines.md:10390
msgid "10390            vector<int> v(7);"
msgstr""

# CppCoreGuidelines.md:10391
msgid "10391            // ..."
msgstr""

# CppCoreGuidelines.md:10392
msgid "10392        }"
msgstr""

       
# CppCoreGuidelines.md:10393
msgid "10393    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10394
msgid "10394    If you have local \"things\" that requires cleanup, but is not represented by an object with a destructor, such cleanup must"
msgstr""

# CppCoreGuidelines.md:10395
msgid "10395    also be done before a `throw`."
msgstr""

# CppCoreGuidelines.md:10396
msgid "10396    Sometimes, [`finally()`](#Re-finally) can make such unsystematic cleanup a bit more manageable."
msgstr""

       
# CppCoreGuidelines.md:10397
msgid "10397    ### <a name=\"Re-exception-types\"></a>E.14: Use purpose-designed user-defined types as exceptions (not built-in types)"
msgstr""

       
# CppCoreGuidelines.md:10398
msgid "10398    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10399
msgid "10399    A user-defined type is unlikely to clash with other people's exceptions."
msgstr""

       
# CppCoreGuidelines.md:10400
msgid "10400    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10401
msgid "10401        void my_code()"
msgstr""

# CppCoreGuidelines.md:10402
msgid "10402        {"
msgstr""

# CppCoreGuidelines.md:10403
msgid "10403            // ..."
msgstr""

# CppCoreGuidelines.md:10404
msgid "10404            throw Moonphase_error{};"
msgstr""

# CppCoreGuidelines.md:10405
msgid "10405            // ..."
msgstr""

# CppCoreGuidelines.md:10406
msgid "10406        }"
msgstr""

       
# CppCoreGuidelines.md:10407
msgid "10407        void your_code()"
msgstr""

# CppCoreGuidelines.md:10408
msgid "10408        {"
msgstr""

# CppCoreGuidelines.md:10409
msgid "10409            try {"
msgstr""

# CppCoreGuidelines.md:10410
msgid "10410                // ..."
msgstr""

# CppCoreGuidelines.md:10411
msgid "10411                my_code();"
msgstr""

# CppCoreGuidelines.md:10412
msgid "10412                // ..."
msgstr""

# CppCoreGuidelines.md:10413
msgid "10413            }"
msgstr""

# CppCoreGuidelines.md:10414
msgid "10414            catch(const Bufferpool_exhausted&) {"
msgstr""

# CppCoreGuidelines.md:10415
msgid "10415                // ..."
msgstr""

# CppCoreGuidelines.md:10416
msgid "10416            }"
msgstr""

# CppCoreGuidelines.md:10417
msgid "10417        }"
msgstr""

       
# CppCoreGuidelines.md:10418
msgid "10418    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:10419
msgid "10419        void my_code()     // Don't"
msgstr""

# CppCoreGuidelines.md:10420
msgid "10420        {"
msgstr""

# CppCoreGuidelines.md:10421
msgid "10421            // ..."
msgstr""

# CppCoreGuidelines.md:10422
msgid "10422            throw 7;       // 7 means \"moon in the 4th quarter\""
msgstr""

# CppCoreGuidelines.md:10423
msgid "10423            // ..."
msgstr""

# CppCoreGuidelines.md:10424
msgid "10424        }"
msgstr""

       
# CppCoreGuidelines.md:10425
msgid "10425        void your_code()   // Don't"
msgstr""

# CppCoreGuidelines.md:10426
msgid "10426        {"
msgstr""

# CppCoreGuidelines.md:10427
msgid "10427            try {"
msgstr""

# CppCoreGuidelines.md:10428
msgid "10428                // ..."
msgstr""

# CppCoreGuidelines.md:10429
msgid "10429                my_code();"
msgstr""

# CppCoreGuidelines.md:10430
msgid "10430                // ..."
msgstr""

# CppCoreGuidelines.md:10431
msgid "10431            }"
msgstr""

# CppCoreGuidelines.md:10432
msgid "10432            catch(int i) {  // i == 7 means \"input buffer too small\""
msgstr""

# CppCoreGuidelines.md:10433
msgid "10433                // ..."
msgstr""

# CppCoreGuidelines.md:10434
msgid "10434            }"
msgstr""

# CppCoreGuidelines.md:10435
msgid "10435        }"
msgstr""

       
# CppCoreGuidelines.md:10436
msgid "10436    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10437
msgid "10437    The standard-library classes derived from `exception` should be used only as base classes or for exceptions that require only \"generic\" handling. Like built-in types, their use could clash with other people's use of them."
msgstr""

       
# CppCoreGuidelines.md:10438
msgid "10438    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:10439
msgid "10439        void my_code()   // Don't"
msgstr""

# CppCoreGuidelines.md:10440
msgid "10440        {"
msgstr""

# CppCoreGuidelines.md:10441
msgid "10441            // ..."
msgstr""

# CppCoreGuidelines.md:10442
msgid "10442            throw runtime_error{\"moon in the 4th quarter\"};"
msgstr""

# CppCoreGuidelines.md:10443
msgid "10443            // ..."
msgstr""

# CppCoreGuidelines.md:10444
msgid "10444        }"
msgstr""

       
# CppCoreGuidelines.md:10445
msgid "10445        void your_code()   // Don't"
msgstr""

# CppCoreGuidelines.md:10446
msgid "10446        {"
msgstr""

# CppCoreGuidelines.md:10447
msgid "10447            try {"
msgstr""

# CppCoreGuidelines.md:10448
msgid "10448                // ..."
msgstr""

# CppCoreGuidelines.md:10449
msgid "10449                my_code();"
msgstr""

# CppCoreGuidelines.md:10450
msgid "10450                // ..."
msgstr""

# CppCoreGuidelines.md:10451
msgid "10451            }"
msgstr""

# CppCoreGuidelines.md:10452
msgid "10452            catch(const runtime_error&) {   // runtime_error means \"input buffer too small\""
msgstr""

# CppCoreGuidelines.md:10453
msgid "10453                // ..."
msgstr""

# CppCoreGuidelines.md:10454
msgid "10454            }"
msgstr""

# CppCoreGuidelines.md:10455
msgid "10455        }"
msgstr""

       
# CppCoreGuidelines.md:10456
msgid "10456    **See also**: [Discussion](#Sd-???)"
msgstr""

       
# CppCoreGuidelines.md:10457
msgid "10457    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10458
msgid "10458    Catch `throw` and `catch` of a built-in type. Maybe warn about `throw` and `catch` using a standard-library `exception` type. Obviously, exceptions derived from the `std::exception` hierarchy are fine."
msgstr""

       
# CppCoreGuidelines.md:10459
msgid "10459    ### <a name=\"Re-exception-ref\"></a>E.15: Catch exceptions from a hierarchy by reference"
msgstr""

       
# CppCoreGuidelines.md:10460
msgid "10460    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10461
msgid "10461    To prevent slicing."
msgstr""

       
# CppCoreGuidelines.md:10462
msgid "10462    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10463
msgid "10463        void f()"
msgstr""

# CppCoreGuidelines.md:10464
msgid "10464        {"
msgstr""

# CppCoreGuidelines.md:10465
msgid "10465            try {"
msgstr""

# CppCoreGuidelines.md:10466
msgid "10466                // ..."
msgstr""

# CppCoreGuidelines.md:10467
msgid "10467            }"
msgstr""

# CppCoreGuidelines.md:10468
msgid "10468            catch (exception e) {   // don't: may slice"
msgstr""

# CppCoreGuidelines.md:10469
msgid "10469                // ..."
msgstr""

# CppCoreGuidelines.md:10470
msgid "10470            }"
msgstr""

# CppCoreGuidelines.md:10471
msgid "10471        }"
msgstr""

       
# CppCoreGuidelines.md:10472
msgid "10472    Instead, use a reference:"
msgstr""

       
# CppCoreGuidelines.md:10473
msgid "10473        catch (exception& e) { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:10474
msgid "10474    of - typically better still - a `const` reference:"
msgstr""

       
# CppCoreGuidelines.md:10475
msgid "10475        catch (const exception& e) { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:10476
msgid "10476    Most handlers do not modify their exception and in general we [recommend use of `const`](#Res-const)."
msgstr""

       
# CppCoreGuidelines.md:10477
msgid "10477    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10478
msgid "10478    To rethrow a caught exception use `throw;` not `throw e;`. Using `throw e;` would throw a new copy of `e` (sliced to the static type `std::exception`) instead of rethrowing the original exception of type `std::runtime_error`. (But keep [Don't try to catch every exception in every function](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Re-not-always) and [Minimize the use of explicit `try`/`catch`](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Re-catch) in mind.)"
msgstr""

       
# CppCoreGuidelines.md:10479
msgid "10479    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10480
msgid "10480    Flag by-value exceptions if their types are part of a hierarchy (could require whole-program analysis to be perfect)."
msgstr""

       
# CppCoreGuidelines.md:10481
msgid "10481    ### <a name=\"Re-never-fail\"></a>E.16: Destructors, deallocation, and `swap` must never fail"
msgstr""

       
# CppCoreGuidelines.md:10482
msgid "10482    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10483
msgid "10483    We don't know how to write reliable programs if a destructor, a swap, or a memory deallocation fails; that is, if it exits by an exception or simply doesn't perform its required action."
msgstr""

       
# CppCoreGuidelines.md:10484
msgid "10484    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:10485
msgid "10485        class Connection {"
msgstr""

# CppCoreGuidelines.md:10486
msgid "10486            // ..."
msgstr""

# CppCoreGuidelines.md:10487
msgid "10487        public:"
msgstr""

# CppCoreGuidelines.md:10488
msgid "10488            ~Connection()   // Don't: very bad destructor"
msgstr""

# CppCoreGuidelines.md:10489
msgid "10489            {"
msgstr""

# CppCoreGuidelines.md:10490
msgid "10490                if (cannot_disconnect()) throw I_give_up{information};"
msgstr""

# CppCoreGuidelines.md:10491
msgid "10491                // ..."
msgstr""

# CppCoreGuidelines.md:10492
msgid "10492            }"
msgstr""

# CppCoreGuidelines.md:10493
msgid "10493        };"
msgstr""

       
# CppCoreGuidelines.md:10494
msgid "10494    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10495
msgid "10495    Many have tried to write reliable code violating this rule for examples, such as a network connection that \"refuses to close\"."
msgstr""

# CppCoreGuidelines.md:10496
msgid "10496    To the best of our knowledge nobody has found a general way of doing this."
msgstr""

# CppCoreGuidelines.md:10497
msgid "10497    Occasionally, for very specific examples, you can get away with setting some state for future cleanup."
msgstr""

# CppCoreGuidelines.md:10498
msgid "10498    For example, we might put a socket that does not want to close on a \"bad socket\" list,"
msgstr""

# CppCoreGuidelines.md:10499
msgid "10499    to be examined by a regular sweep of the system state."
msgstr""

# CppCoreGuidelines.md:10500
msgid "10500    Every example we have seen of this is error-prone, specialized, and often buggy."
msgstr""

       
# CppCoreGuidelines.md:10501
msgid "10501    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10502
msgid "10502    The standard library assumes that destructors, deallocation functions (e.g., `operator delete`), and `swap` do not throw. If they do, basic standard-library invariants are broken."
msgstr""

       
# CppCoreGuidelines.md:10503
msgid "10503    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10504
msgid "10504    Deallocation functions, including `operator delete`, must be `noexcept`. `swap` functions must be `noexcept`."
msgstr""

# CppCoreGuidelines.md:10505
msgid "10505    Most destructors are implicitly `noexcept` by default."
msgstr""

# CppCoreGuidelines.md:10506
msgid "10506    Also, [make move operations `noexcept`](#Rc-move-noexcept)."
msgstr""

       
# CppCoreGuidelines.md:10507
msgid "10507    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10508
msgid "10508    Catch destructors, deallocation operations, and `swap`s that `throw`."
msgstr""

# CppCoreGuidelines.md:10509
msgid "10509    Catch such operations that are not `noexcept`."
msgstr""

       
# CppCoreGuidelines.md:10510
msgid "10510    **See also**: [discussion](#Sd-never-fail)"
msgstr""

       
# CppCoreGuidelines.md:10511
msgid "10511    ### <a name=\"Re-not-always\"></a>E.17: Don't try to catch every exception in every function"
msgstr""

       
# CppCoreGuidelines.md:10512
msgid "10512    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10513
msgid "10513    Catching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste."
msgstr""

# CppCoreGuidelines.md:10514
msgid "10514    Let an exception propagate until it reaches a function that can handle it."
msgstr""

# CppCoreGuidelines.md:10515
msgid "10515    Let cleanup actions on the unwinding path be handled by [RAII](#Re-raii)."
msgstr""

       
# CppCoreGuidelines.md:10516
msgid "10516    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:10517
msgid "10517        void f()   // bad"
msgstr""

# CppCoreGuidelines.md:10518
msgid "10518        {"
msgstr""

# CppCoreGuidelines.md:10519
msgid "10519            try {"
msgstr""

# CppCoreGuidelines.md:10520
msgid "10520                // ..."
msgstr""

# CppCoreGuidelines.md:10521
msgid "10521            }"
msgstr""

# CppCoreGuidelines.md:10522
msgid "10522            catch (...) {"
msgstr""

# CppCoreGuidelines.md:10523
msgid "10523                // no action"
msgstr""

# CppCoreGuidelines.md:10524
msgid "10524                throw;   // propagate exception"
msgstr""

# CppCoreGuidelines.md:10525
msgid "10525            }"
msgstr""

# CppCoreGuidelines.md:10526
msgid "10526        }"
msgstr""

       
# CppCoreGuidelines.md:10527
msgid "10527    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10528
msgid "10528    * Flag nested try-blocks."
msgstr""

# CppCoreGuidelines.md:10529
msgid "10529    * Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define \"too high\")"
msgstr""

       
# CppCoreGuidelines.md:10530
msgid "10530    ### <a name=\"Re-catch\"></a>E.18: Minimize the use of explicit `try`/`catch`"
msgstr""

       
# CppCoreGuidelines.md:10531
msgid "10531    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10532
msgid "10532     `try`/`catch` is verbose and non-trivial uses error-prone."
msgstr""

# CppCoreGuidelines.md:10533
msgid "10533     `try`/`catch` can be a sign of unsystematic and/or low-level resource management or error handling."
msgstr""

       
# CppCoreGuidelines.md:10534
msgid "10534    ##### Example, Bad"
msgstr""

       
# CppCoreGuidelines.md:10535
msgid "10535        void f(zstring s)"
msgstr""

# CppCoreGuidelines.md:10536
msgid "10536        {"
msgstr""

# CppCoreGuidelines.md:10537
msgid "10537            Gadget* p;"
msgstr""

# CppCoreGuidelines.md:10538
msgid "10538            try {"
msgstr""

# CppCoreGuidelines.md:10539
msgid "10539                p = new Gadget(s);"
msgstr""

# CppCoreGuidelines.md:10540
msgid "10540                // ..."
msgstr""

# CppCoreGuidelines.md:10541
msgid "10541                delete p;"
msgstr""

# CppCoreGuidelines.md:10542
msgid "10542            }"
msgstr""

# CppCoreGuidelines.md:10543
msgid "10543            catch (Gadget_construction_failure) {"
msgstr""

# CppCoreGuidelines.md:10544
msgid "10544                delete p;"
msgstr""

# CppCoreGuidelines.md:10545
msgid "10545                throw;"
msgstr""

# CppCoreGuidelines.md:10546
msgid "10546            }"
msgstr""

# CppCoreGuidelines.md:10547
msgid "10547        }"
msgstr""

       
# CppCoreGuidelines.md:10548
msgid "10548    This code is messy."
msgstr""

# CppCoreGuidelines.md:10549
msgid "10549    There could be a leak from the naked pointer in the `try` block."
msgstr""

# CppCoreGuidelines.md:10550
msgid "10550    Not all exceptions are handled."
msgstr""

# CppCoreGuidelines.md:10551
msgid "10551    `deleting` an object that failed to construct is almost certainly a mistake."
msgstr""

# CppCoreGuidelines.md:10552
msgid "10552    Better:"
msgstr""

       
# CppCoreGuidelines.md:10553
msgid "10553        void f2(zstring s)"
msgstr""

# CppCoreGuidelines.md:10554
msgid "10554        {"
msgstr""

# CppCoreGuidelines.md:10555
msgid "10555            Gadget g {s};"
msgstr""

# CppCoreGuidelines.md:10556
msgid "10556        }"
msgstr""

       
# CppCoreGuidelines.md:10557
msgid "10557    ##### Alternatives"
msgstr""

       
# CppCoreGuidelines.md:10558
msgid "10558    * proper resource handles and [RAII](#Re-raii)"
msgstr""

# CppCoreGuidelines.md:10559
msgid "10559    * [`finally`](#Re-finally)"
msgstr""

       
# CppCoreGuidelines.md:10560
msgid "10560    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10561
msgid "10561    ??? hard, needs a heuristic"
msgstr""

       
# CppCoreGuidelines.md:10562
msgid "10562    ### <a name=\"Re-finally\"></a>E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available"
msgstr""

       
# CppCoreGuidelines.md:10563
msgid "10563    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10564
msgid "10564    `finally` is less verbose and harder to get wrong than `try`/`catch`."
msgstr""

       
# CppCoreGuidelines.md:10565
msgid "10565    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10566
msgid "10566        void f(int n)"
msgstr""

# CppCoreGuidelines.md:10567
msgid "10567        {"
msgstr""

# CppCoreGuidelines.md:10568
msgid "10568            void* p = malloc(1, n);"
msgstr""

# CppCoreGuidelines.md:10569
msgid "10569            auto _ = finally([p] { free(p); });"
msgstr""

# CppCoreGuidelines.md:10570
msgid "10570            // ..."
msgstr""

# CppCoreGuidelines.md:10571
msgid "10571        }"
msgstr""

       
# CppCoreGuidelines.md:10572
msgid "10572    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10573
msgid "10573    `finally` is not as messy as `try`/`catch`, but it is still ad-hoc."
msgstr""

# CppCoreGuidelines.md:10574
msgid "10574    Prefer [proper resource management objects](#Re-raii)."
msgstr""

# CppCoreGuidelines.md:10575
msgid "10575    Consider `finally` a last resort."
msgstr""

       
# CppCoreGuidelines.md:10576
msgid "10576    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10577
msgid "10577    Use of `finally` is a systematic and reasonably clean alternative to the old [`goto exit;` technique](#Re-no-throw-codes)"
msgstr""

# CppCoreGuidelines.md:10578
msgid "10578    for dealing with cleanup where resource management is not systematic."
msgstr""

       
# CppCoreGuidelines.md:10579
msgid "10579    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10580
msgid "10580    Heuristic: Detect `goto exit;`"
msgstr""

       
# CppCoreGuidelines.md:10581
msgid "10581    ### <a name=\"Re-no-throw-raii\"></a>E.25: If you can't throw exceptions, simulate RAII for resource management"
msgstr""

       
# CppCoreGuidelines.md:10582
msgid "10582    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10583
msgid "10583    Even without exceptions, [RAII](#Re-raii) is usually the best and most systematic way of dealing with resources."
msgstr""

       
# CppCoreGuidelines.md:10584
msgid "10584    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10585
msgid "10585    Error handling using exceptions is the only complete and systematic way of handling non-local errors in C++."
msgstr""

# CppCoreGuidelines.md:10586
msgid "10586    In particular, non-intrusively signaling failure to construct an object requires an exception."
msgstr""

# CppCoreGuidelines.md:10587
msgid "10587    Signaling errors in a way that cannot be ignored requires exceptions."
msgstr""

# CppCoreGuidelines.md:10588
msgid "10588    If you can't use exceptions, simulate their use as best you can."
msgstr""

       
# CppCoreGuidelines.md:10589
msgid "10589    A lot of fear of exceptions is misguided."
msgstr""

# CppCoreGuidelines.md:10590
msgid "10590    When used for exceptional circumstances in code that is not littered with pointers and complicated control structures,"
msgstr""

# CppCoreGuidelines.md:10591
msgid "10591    exception handling is almost always affordable (in time and space) and almost always leads to better code."
msgstr""

# CppCoreGuidelines.md:10592
msgid "10592    This, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems."
msgstr""

# CppCoreGuidelines.md:10593
msgid "10593    There are also cases where the problems above do not apply, but exceptions cannot be used for other reasons."
msgstr""

# CppCoreGuidelines.md:10594
msgid "10594    Some hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer."
msgstr""

# CppCoreGuidelines.md:10595
msgid "10595    In the absence of appropriate time estimation tools, this is hard to guarantee for exceptions."
msgstr""

# CppCoreGuidelines.md:10596
msgid "10596    Such systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory."
msgstr""

       
# CppCoreGuidelines.md:10597
msgid "10597    So, the primary guideline for error handling is \"use exceptions and [RAII](#Re-raii).\""
msgstr""

# CppCoreGuidelines.md:10598
msgid "10598    This section deals with the cases where you either do not have an efficient implementation of exceptions,"
msgstr""

# CppCoreGuidelines.md:10599
msgid "10599    or have such a rat's nest of old-style code"
msgstr""

# CppCoreGuidelines.md:10600
msgid "10600    (e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes)"
msgstr""

# CppCoreGuidelines.md:10601
msgid "10601    that it is infeasible to introduce simple and systematic exception handling."
msgstr""

       
# CppCoreGuidelines.md:10602
msgid "10602    Before condemning exceptions or complaining too much about their cost, consider examples of the use of [error codes](#Re-no-throw-codes)."
msgstr""

# CppCoreGuidelines.md:10603
msgid "10603    Consider the cost and complexity of the use of error codes."
msgstr""

# CppCoreGuidelines.md:10604
msgid "10604    If performance is your worry, measure."
msgstr""

       
# CppCoreGuidelines.md:10605
msgid "10605    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10606
msgid "10606    Assume you wanted to write"
msgstr""

       
# CppCoreGuidelines.md:10607
msgid "10607        void func(zstring arg)"
msgstr""

# CppCoreGuidelines.md:10608
msgid "10608        {"
msgstr""

# CppCoreGuidelines.md:10609
msgid "10609            Gadget g {arg};"
msgstr""

# CppCoreGuidelines.md:10610
msgid "10610            // ..."
msgstr""

# CppCoreGuidelines.md:10611
msgid "10611        }"
msgstr""

       
# CppCoreGuidelines.md:10612
msgid "10612    If the `gadget` isn't correctly constructed, `func` exits with an exception."
msgstr""

# CppCoreGuidelines.md:10613
msgid "10613    If we cannot throw an exception, we can simulate this RAII style of resource handling by adding a `valid()` member function to `Gadget`:"
msgstr""

       
# CppCoreGuidelines.md:10614
msgid "10614        error_indicator func(zstring arg)"
msgstr""

# CppCoreGuidelines.md:10615
msgid "10615        {"
msgstr""

# CppCoreGuidelines.md:10616
msgid "10616            Gadget g {arg};"
msgstr""

# CppCoreGuidelines.md:10617
msgid "10617            if (!g.valid()) return gadget_construction_error;"
msgstr""

# CppCoreGuidelines.md:10618
msgid "10618            // ..."
msgstr""

# CppCoreGuidelines.md:10619
msgid "10619            return 0;   // zero indicates \"good\""
msgstr""

# CppCoreGuidelines.md:10620
msgid "10620        }"
msgstr""

       
# CppCoreGuidelines.md:10621
msgid "10621    The problem is of course that the caller now has to remember to test the return value."
msgstr""

       
# CppCoreGuidelines.md:10622
msgid "10622    **See also**: [Discussion](#Sd-???)"
msgstr""

       
# CppCoreGuidelines.md:10623
msgid "10623    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10624
msgid "10624    Possible (only) for specific versions of this idea: e.g., test for systematic test of `valid()` after resource handle construction"
msgstr""

       
# CppCoreGuidelines.md:10625
msgid "10625    ### <a name=\"Re-no-throw-crash\"></a>E.26: If you can't throw exceptions, consider failing fast"
msgstr""

       
# CppCoreGuidelines.md:10626
msgid "10626    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10627
msgid "10627    If you can't do a good job at recovering, at least you can get out before too much consequential damage is done."
msgstr""

       
# CppCoreGuidelines.md:10628
msgid "10628    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr""

       
# CppCoreGuidelines.md:10629
msgid "10629    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10630
msgid "10630    If you cannot be systematic about error handling, consider \"crashing\" as a response to any error that cannot be handled locally."
msgstr""

# CppCoreGuidelines.md:10631
msgid "10631    That is, if you cannot recover from an error in the context of the function that detected it, call `abort()`, `quick_exit()`,"
msgstr""

# CppCoreGuidelines.md:10632
msgid "10632    or a similar function that will trigger some sort of system restart."
msgstr""

       
# CppCoreGuidelines.md:10633
msgid "10633    In systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway,"
msgstr""

# CppCoreGuidelines.md:10634
msgid "10634    say from hardware failures."
msgstr""

# CppCoreGuidelines.md:10635
msgid "10635    In such cases, \"crashing\" is simply leaving error handling to the next level of the system."
msgstr""

       
# CppCoreGuidelines.md:10636
msgid "10636    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10637
msgid "10637        void f(int n)"
msgstr""

# CppCoreGuidelines.md:10638
msgid "10638        {"
msgstr""

# CppCoreGuidelines.md:10639
msgid "10639            // ..."
msgstr""

# CppCoreGuidelines.md:10640
msgid "10640            p = static_cast<X*>(malloc(n, X));"
msgstr""

# CppCoreGuidelines.md:10641
msgid "10641            if (!p) abort();     // abort if memory is exhausted"
msgstr""

# CppCoreGuidelines.md:10642
msgid "10642            // ..."
msgstr""

# CppCoreGuidelines.md:10643
msgid "10643        }"
msgstr""

       
# CppCoreGuidelines.md:10644
msgid "10644    Most programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to"
msgstr""

       
# CppCoreGuidelines.md:10645
msgid "10645        void f(int n)"
msgstr""

# CppCoreGuidelines.md:10646
msgid "10646        {"
msgstr""

# CppCoreGuidelines.md:10647
msgid "10647            // ..."
msgstr""

# CppCoreGuidelines.md:10648
msgid "10648            p = new X[n];    // throw if memory is exhausted (by default, terminate)"
msgstr""

# CppCoreGuidelines.md:10649
msgid "10649            // ..."
msgstr""

# CppCoreGuidelines.md:10650
msgid "10650        }"
msgstr""

       
# CppCoreGuidelines.md:10651
msgid "10651    Typically, it is a good idea to log the reason for the \"crash\" before exiting."
msgstr""

       
# CppCoreGuidelines.md:10652
msgid "10652    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10653
msgid "10653    Awkward"
msgstr""

       
# CppCoreGuidelines.md:10654
msgid "10654    ### <a name=\"Re-no-throw-codes\"></a>E.27: If you can't throw exceptions, use error codes systematically"
msgstr""

       
# CppCoreGuidelines.md:10655
msgid "10655    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10656
msgid "10656    Systematic use of any error-handling strategy minimizes the chance of forgetting to handle an error."
msgstr""

       
# CppCoreGuidelines.md:10657
msgid "10657    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr""

       
# CppCoreGuidelines.md:10658
msgid "10658    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10659
msgid "10659    There are several issues to be addressed:"
msgstr""

       
# CppCoreGuidelines.md:10660
msgid "10660    * how do you transmit an error indicator from out of a function?"
msgstr""

# CppCoreGuidelines.md:10661
msgid "10661    * how do you release all resources from a function before doing an error exit?"
msgstr""

# CppCoreGuidelines.md:10662
msgid "10662    * What do you use as an error indicator?"
msgstr""

       
# CppCoreGuidelines.md:10663
msgid "10663    In general, returning an error indicator implies returning two values: The result and an error indicator."
msgstr""

# CppCoreGuidelines.md:10664
msgid "10664    The error indicator can be part of the object, e.g. an object can have a `valid()` indicator"
msgstr""

# CppCoreGuidelines.md:10665
msgid "10665    or a pair of values can be returned."
msgstr""

       
# CppCoreGuidelines.md:10666
msgid "10666    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10667
msgid "10667        Gadget make_gadget(int n)"
msgstr""

# CppCoreGuidelines.md:10668
msgid "10668        {"
msgstr""

# CppCoreGuidelines.md:10669
msgid "10669            // ..."
msgstr""

# CppCoreGuidelines.md:10670
msgid "10670        }"
msgstr""

       
# CppCoreGuidelines.md:10671
msgid "10671        void user()"
msgstr""

# CppCoreGuidelines.md:10672
msgid "10672        {"
msgstr""

# CppCoreGuidelines.md:10673
msgid "10673            Gadget g = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10674
msgid "10674            if (!g.valid()) {"
msgstr""

# CppCoreGuidelines.md:10675
msgid "10675                    // error handling"
msgstr""

# CppCoreGuidelines.md:10676
msgid "10676            }"
msgstr""

# CppCoreGuidelines.md:10677
msgid "10677            // ..."
msgstr""

# CppCoreGuidelines.md:10678
msgid "10678        }"
msgstr""

       
# CppCoreGuidelines.md:10679
msgid "10679    This approach fits with [simulated RAII resource management](#Re-no-throw-raii)."
msgstr""

# CppCoreGuidelines.md:10680
msgid "10680    The `valid()` function could return an `error_indicator` (e.g. a member of an `error_indicator` enumeration)."
msgstr""

       
# CppCoreGuidelines.md:10681
msgid "10681    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10682
msgid "10682    What if we cannot or do not want to modify the `Gadget` type?"
msgstr""

# CppCoreGuidelines.md:10683
msgid "10683    In that case, we must return a pair of values."
msgstr""

# CppCoreGuidelines.md:10684
msgid "10684    For example:"
msgstr""

       
# CppCoreGuidelines.md:10685
msgid "10685        std::pair<Gadget, error_indicator> make_gadget(int n)"
msgstr""

# CppCoreGuidelines.md:10686
msgid "10686        {"
msgstr""

# CppCoreGuidelines.md:10687
msgid "10687            // ..."
msgstr""

# CppCoreGuidelines.md:10688
msgid "10688        }"
msgstr""

       
# CppCoreGuidelines.md:10689
msgid "10689        void user()"
msgstr""

# CppCoreGuidelines.md:10690
msgid "10690        {"
msgstr""

# CppCoreGuidelines.md:10691
msgid "10691            auto r = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10692
msgid "10692            if (!r.second) {"
msgstr""

# CppCoreGuidelines.md:10693
msgid "10693                    // error handling"
msgstr""

# CppCoreGuidelines.md:10694
msgid "10694            }"
msgstr""

# CppCoreGuidelines.md:10695
msgid "10695            Gadget& g = r.first;"
msgstr""

# CppCoreGuidelines.md:10696
msgid "10696            // ..."
msgstr""

# CppCoreGuidelines.md:10697
msgid "10697        }"
msgstr""

       
# CppCoreGuidelines.md:10698
msgid "10698    As shown, `std::pair` is a possible return type."
msgstr""

# CppCoreGuidelines.md:10699
msgid "10699    Some people prefer a specific type."
msgstr""

# CppCoreGuidelines.md:10700
msgid "10700    For example:"
msgstr""

       
# CppCoreGuidelines.md:10701
msgid "10701        Gval make_gadget(int n)"
msgstr""

# CppCoreGuidelines.md:10702
msgid "10702        {"
msgstr""

# CppCoreGuidelines.md:10703
msgid "10703            // ..."
msgstr""

# CppCoreGuidelines.md:10704
msgid "10704        }"
msgstr""

       
# CppCoreGuidelines.md:10705
msgid "10705        void user()"
msgstr""

# CppCoreGuidelines.md:10706
msgid "10706        {"
msgstr""

# CppCoreGuidelines.md:10707
msgid "10707            auto r = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10708
msgid "10708            if (!r.err) {"
msgstr""

# CppCoreGuidelines.md:10709
msgid "10709                    // error handling"
msgstr""

# CppCoreGuidelines.md:10710
msgid "10710            }"
msgstr""

# CppCoreGuidelines.md:10711
msgid "10711            Gadget& g = r.val;"
msgstr""

# CppCoreGuidelines.md:10712
msgid "10712            // ..."
msgstr""

# CppCoreGuidelines.md:10713
msgid "10713        }"
msgstr""

       
# CppCoreGuidelines.md:10714
msgid "10714    One reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic `first` and `second`"
msgstr""

# CppCoreGuidelines.md:10715
msgid "10715    and to avoid confusion with other uses of `std::pair`."
msgstr""

       
# CppCoreGuidelines.md:10716
msgid "10716    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10717
msgid "10717    In general, you must clean up before an error exit."
msgstr""

# CppCoreGuidelines.md:10718
msgid "10718    This can be messy:"
msgstr""

       
# CppCoreGuidelines.md:10719
msgid "10719        std::pair<int, error_indicator> user()"
msgstr""

# CppCoreGuidelines.md:10720
msgid "10720        {"
msgstr""

# CppCoreGuidelines.md:10721
msgid "10721            Gadget g1 = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10722
msgid "10722            if (!g1.valid()) {"
msgstr""

# CppCoreGuidelines.md:10723
msgid "10723                    return {0, g1_error};"
msgstr""

# CppCoreGuidelines.md:10724
msgid "10724            }"
msgstr""

       
# CppCoreGuidelines.md:10725
msgid "10725            Gadget g2 = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10726
msgid "10726            if (!g2.valid()) {"
msgstr""

# CppCoreGuidelines.md:10727
msgid "10727                    cleanup(g1);"
msgstr""

# CppCoreGuidelines.md:10728
msgid "10728                    return {0, g2_error};"
msgstr""

# CppCoreGuidelines.md:10729
msgid "10729            }"
msgstr""

       
# CppCoreGuidelines.md:10730
msgid "10730            // ..."
msgstr""

       
# CppCoreGuidelines.md:10731
msgid "10731            if (all_foobar(g1, g2)) {"
msgstr""

# CppCoreGuidelines.md:10732
msgid "10732                cleanup(g1);"
msgstr""

# CppCoreGuidelines.md:10733
msgid "10733                cleanup(g2);"
msgstr""

# CppCoreGuidelines.md:10734
msgid "10734                return {0, foobar_error};"
msgstr""

# CppCoreGuidelines.md:10735
msgid "10735            // ..."
msgstr""

       
# CppCoreGuidelines.md:10736
msgid "10736            cleanup(g1);"
msgstr""

# CppCoreGuidelines.md:10737
msgid "10737            cleanup(g2);"
msgstr""

# CppCoreGuidelines.md:10738
msgid "10738            return {res, 0};"
msgstr""

# CppCoreGuidelines.md:10739
msgid "10739        }"
msgstr""

       
# CppCoreGuidelines.md:10740
msgid "10740    Simulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors."
msgstr""

# CppCoreGuidelines.md:10741
msgid "10741    A not uncommon technique is to gather cleanup at the end of the function to avoid repetition:"
msgstr""

       
# CppCoreGuidelines.md:10742
msgid "10742        std::pair<int, error_indicator> user()"
msgstr""

# CppCoreGuidelines.md:10743
msgid "10743        {"
msgstr""

# CppCoreGuidelines.md:10744
msgid "10744            error_indicator err = 0;"
msgstr""

       
# CppCoreGuidelines.md:10745
msgid "10745            Gadget g1 = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10746
msgid "10746            if (!g1.valid()) {"
msgstr""

# CppCoreGuidelines.md:10747
msgid "10747                    err = g1_error;"
msgstr""

# CppCoreGuidelines.md:10748
msgid "10748                    goto exit;"
msgstr""

# CppCoreGuidelines.md:10749
msgid "10749            }"
msgstr""

       
# CppCoreGuidelines.md:10750
msgid "10750            Gadget g2 = make_gadget(17);"
msgstr""

# CppCoreGuidelines.md:10751
msgid "10751            if (!g2.valid()) {"
msgstr""

# CppCoreGuidelines.md:10752
msgid "10752                    err = g2_error;"
msgstr""

# CppCoreGuidelines.md:10753
msgid "10753                    goto exit;"
msgstr""

# CppCoreGuidelines.md:10754
msgid "10754            }"
msgstr""

       
# CppCoreGuidelines.md:10755
msgid "10755            if (all_foobar(g1, g2)) {"
msgstr""

# CppCoreGuidelines.md:10756
msgid "10756                err = foobar_error;"
msgstr""

# CppCoreGuidelines.md:10757
msgid "10757                goto exit;"
msgstr""

# CppCoreGuidelines.md:10758
msgid "10758            }"
msgstr""

# CppCoreGuidelines.md:10759
msgid "10759            // ..."
msgstr""

       
# CppCoreGuidelines.md:10760
msgid "10760        exit:"
msgstr""

# CppCoreGuidelines.md:10761
msgid "10761          if (g1.valid()) cleanup(g1);"
msgstr""

# CppCoreGuidelines.md:10762
msgid "10762          if (g2.valid()) cleanup(g2);"
msgstr""

# CppCoreGuidelines.md:10763
msgid "10763          return {res, err};"
msgstr""

# CppCoreGuidelines.md:10764
msgid "10764        }"
msgstr""

       
# CppCoreGuidelines.md:10765
msgid "10765    The larger the function, the more tempting this technique becomes."
msgstr""

# CppCoreGuidelines.md:10766
msgid "10766    `finally` can [ease the pain a bit](#Re-finally)."
msgstr""

# CppCoreGuidelines.md:10767
msgid "10767    Also, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically."
msgstr""

       
# CppCoreGuidelines.md:10768
msgid "10768    We [prefer exception-based error handling](#Re-throw) and recommend [keeping functions short](#Rf-single)."
msgstr""

       
# CppCoreGuidelines.md:10769
msgid "10769    **See also**: [Discussion](#Sd-???)"
msgstr""

       
# CppCoreGuidelines.md:10770
msgid "10770    **See also**: [Returning multiple values](#Rf-out-multi)"
msgstr""

       
# CppCoreGuidelines.md:10771
msgid "10771    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10772
msgid "10772    Awkward."
msgstr""

       
# CppCoreGuidelines.md:10773
msgid "10773    ### <a name=\"Re-no-throw\"></a>E.28: Avoid error handling based on global state (e.g. `errno`)"
msgstr""

       
# CppCoreGuidelines.md:10774
msgid "10774    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10775
msgid "10775    Global state is hard to manage and it is easy to forget to check it."
msgstr""

# CppCoreGuidelines.md:10776
msgid "10776    When did you last test the return value of `printf()`?"
msgstr""

       
# CppCoreGuidelines.md:10777
msgid "10777    **See also**: [Simulating RAII](#Re-no-throw-raii)"
msgstr""

       
# CppCoreGuidelines.md:10778
msgid "10778    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:10779
msgid "10779        ???"
msgstr""

       
# CppCoreGuidelines.md:10780
msgid "10780    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10781
msgid "10781    C-style error handling is based on the global variable `errno`, so it is essentially impossible to avoid this style completely."
msgstr""

       
# CppCoreGuidelines.md:10782
msgid "10782    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10783
msgid "10783    Awkward."
msgstr""

       
       
# CppCoreGuidelines.md:10784
msgid "10784    ### <a name=\"Re-specifications\"></a>E.30: Don't use exception specifications"
msgstr""

       
# CppCoreGuidelines.md:10785
msgid "10785    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10786
msgid "10786    Exception specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard."
msgstr""

       
# CppCoreGuidelines.md:10787
msgid "10787    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10788
msgid "10788        int use(int arg)"
msgstr""

# CppCoreGuidelines.md:10789
msgid "10789            throw(X, Y)"
msgstr""

# CppCoreGuidelines.md:10790
msgid "10790        {"
msgstr""

# CppCoreGuidelines.md:10791
msgid "10791            // ..."
msgstr""

# CppCoreGuidelines.md:10792
msgid "10792            auto x = f(arg);"
msgstr""

# CppCoreGuidelines.md:10793
msgid "10793            // ..."
msgstr""

# CppCoreGuidelines.md:10794
msgid "10794        }"
msgstr""

       
# CppCoreGuidelines.md:10795
msgid "10795    If `f()` throws an exception different from `X` and `Y` the unexpected handler is invoked, which by default terminates."
msgstr""

# CppCoreGuidelines.md:10796
msgid "10796    That's OK, but say that we have checked that this cannot happen and `f` is changed to throw a new exception `Z`,"
msgstr""

# CppCoreGuidelines.md:10797
msgid "10797    we now have a crash on our hands unless we change `use()` (and re-test everything)."
msgstr""

# CppCoreGuidelines.md:10798
msgid "10798    The snag is that `f()` may be in a library we do not control and the new exception is not anything that `use()` can do"
msgstr""

# CppCoreGuidelines.md:10799
msgid "10799    anything about or is in any way interested in."
msgstr""

# CppCoreGuidelines.md:10800
msgid "10800    We can change `use()` to pass `Z` through, but now `use()`'s callers probably needs to be modified."
msgstr""

# CppCoreGuidelines.md:10801
msgid "10801    This quickly becomes unmanageable."
msgstr""

# CppCoreGuidelines.md:10802
msgid "10802    Alternatively, we can add a `try`-`catch` to `use()` to map `Z` into an acceptable exception."
msgstr""

# CppCoreGuidelines.md:10803
msgid "10803    This too, quickly becomes unmanageable."
msgstr""

# CppCoreGuidelines.md:10804
msgid "10804    Note that changes to the set of exceptions often happens at the lowest level of a system"
msgstr""

# CppCoreGuidelines.md:10805
msgid "10805    (e.g., because of changes to a network library or some middleware), so changes \"bubble up\" through long call chains."
msgstr""

# CppCoreGuidelines.md:10806
msgid "10806    In a large code base, this could mean that nobody could update to a new version of a library until the last user was modified."
msgstr""

# CppCoreGuidelines.md:10807
msgid "10807    If `use()` is part of a library, it may not be possible to update it because a change could affect unknown clients."
msgstr""

       
# CppCoreGuidelines.md:10808
msgid "10808    The policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years."
msgstr""

       
# CppCoreGuidelines.md:10809
msgid "10809    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10810
msgid "10810    No. This would not be any better had exception specifications been statically enforced."
msgstr""

# CppCoreGuidelines.md:10811
msgid "10811    For example, see [Stroustrup94](#Stroustrup94)."
msgstr""

       
# CppCoreGuidelines.md:10812
msgid "10812    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10813
msgid "10813    If no exception may be thrown, use [`noexcept`](#Re-noexcept) or its equivalent `throw()`."
msgstr""

       
# CppCoreGuidelines.md:10814
msgid "10814    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10815
msgid "10815    Flag every exception specification."
msgstr""

       
# CppCoreGuidelines.md:10816
msgid "10816    ### <a name=\"Re_catch\"></a>E.31: Properly order your `catch`-clauses"
msgstr""

       
# CppCoreGuidelines.md:10817
msgid "10817    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10818
msgid "10818    `catch`-clauses are evaluated in the order they appear and one clause can hide another."
msgstr""

       
# CppCoreGuidelines.md:10819
msgid "10819    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10820
msgid "10820        void f()"
msgstr""

# CppCoreGuidelines.md:10821
msgid "10821        {"
msgstr""

# CppCoreGuidelines.md:10822
msgid "10822            // ..."
msgstr""

# CppCoreGuidelines.md:10823
msgid "10823            try {"
msgstr""

# CppCoreGuidelines.md:10824
msgid "10824                    // ..."
msgstr""

# CppCoreGuidelines.md:10825
msgid "10825            }"
msgstr""

# CppCoreGuidelines.md:10826
msgid "10826            catch (Base& b) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:10827
msgid "10827            catch (Derived& d) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:10828
msgid "10828            catch (...) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:10829
msgid "10829            catch (std::exception& e){ /* ... */ }"
msgstr""

# CppCoreGuidelines.md:10830
msgid "10830        }"
msgstr""

       
# CppCoreGuidelines.md:10831
msgid "10831    If `Derived`is derived from `Base` the `Derived`-handler will never be invoked."
msgstr""

# CppCoreGuidelines.md:10832
msgid "10832    The \"catch everything\" handler ensured that the `std::exception`-handler will never be invoked."
msgstr""

       
# CppCoreGuidelines.md:10833
msgid "10833    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10834
msgid "10834    Flag all \"hiding handlers\"."
msgstr""

       
# CppCoreGuidelines.md:10835
msgid "10835    # <a name=\"S-const\"></a>Con: Constants and immutability"
msgstr""

       
# CppCoreGuidelines.md:10836
msgid "10836    You can't have a race condition on a constant."
msgstr""

# CppCoreGuidelines.md:10837
msgid "10837    It is easier to reason about a program when many of the objects cannot change their values."
msgstr""

# CppCoreGuidelines.md:10838
msgid "10838    Interfaces that promises \"no change\" of objects passed as arguments greatly increase readability."
msgstr""

       
# CppCoreGuidelines.md:10839
msgid "10839    Constant rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10840
msgid "10840    * [Con.1: By default, make objects immutable](#Rconst-immutable)"
msgstr""

# CppCoreGuidelines.md:10841
msgid "10841    * [Con.2: By default, make member functions `const`](#Rconst-fct)"
msgstr""

# CppCoreGuidelines.md:10842
msgid "10842    * [Con.3: By default, pass pointers and references to `const`s](#Rconst-ref)"
msgstr""

# CppCoreGuidelines.md:10843
msgid "10843    * [Con.4: Use `const` to define objects with values that do not change after construction](#Rconst-const)"
msgstr""

# CppCoreGuidelines.md:10844
msgid "10844    * [Con.5: Use `constexpr` for values that can be computed at compile time](#Rconst-constexpr)"
msgstr""

       
# CppCoreGuidelines.md:10845
msgid "10845    ### <a name=\"Rconst-immutable\"></a>Con.1: By default, make objects immutable"
msgstr""

       
# CppCoreGuidelines.md:10846
msgid "10846    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10847
msgid "10847    Immutable objects are easier to reason about, so make objects non-`const` only when there is a need to change their value."
msgstr""

# CppCoreGuidelines.md:10848
msgid "10848    Prevents accidental or hard-to-notice change of value."
msgstr""

       
# CppCoreGuidelines.md:10849
msgid "10849    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10850
msgid "10850        for (const int i : c) cout << i << '\\n';    // just reading: const"
msgstr""

       
# CppCoreGuidelines.md:10851
msgid "10851        for (int i : c) cout << i << '\\n';          // BAD: just reading"
msgstr""

       
# CppCoreGuidelines.md:10852
msgid "10852    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:10853
msgid "10853    Function arguments are rarely mutated, but also rarely declared const."
msgstr""

# CppCoreGuidelines.md:10854
msgid "10854    To avoid confusion and lots of false positives, don't enforce this rule for function arguments."
msgstr""

       
# CppCoreGuidelines.md:10855
msgid "10855        void f(const char* const p); // pedantic"
msgstr""

# CppCoreGuidelines.md:10856
msgid "10856        void g(const int i);        // pedantic"
msgstr""

       
# CppCoreGuidelines.md:10857
msgid "10857    Note that function parameter is a local variable so changes to it are local."
msgstr""

       
# CppCoreGuidelines.md:10858
msgid "10858    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10859
msgid "10859    * Flag non-`const` variables that are not modified (except for parameters to avoid many false positives)"
msgstr""

       
# CppCoreGuidelines.md:10860
msgid "10860    ### <a name=\"Rconst-fct\"></a>Con.2: By default, make member functions `const`"
msgstr""

       
# CppCoreGuidelines.md:10861
msgid "10861    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10862
msgid "10862    A member function should be marked `const` unless it changes the object's observable state."
msgstr""

# CppCoreGuidelines.md:10863
msgid "10863    This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities."
msgstr""

       
# CppCoreGuidelines.md:10864
msgid "10864    ##### Example; bad"
msgstr""

       
# CppCoreGuidelines.md:10865
msgid "10865        class Point {"
msgstr""

# CppCoreGuidelines.md:10866
msgid "10866            int x, y;"
msgstr""

# CppCoreGuidelines.md:10867
msgid "10867        public:"
msgstr""

# CppCoreGuidelines.md:10868
msgid "10868            int getx() { return x; }    // BAD, should be const as it doesn't modify the object's state"
msgstr""

# CppCoreGuidelines.md:10869
msgid "10869            // ..."
msgstr""

# CppCoreGuidelines.md:10870
msgid "10870        };"
msgstr""

       
# CppCoreGuidelines.md:10871
msgid "10871        void f(const Point& pt) {"
msgstr""

# CppCoreGuidelines.md:10872
msgid "10872            int x = pt.getx();          // ERROR, doesn't compile because getx was not marked const"
msgstr""

# CppCoreGuidelines.md:10873
msgid "10873        }"
msgstr""

       
# CppCoreGuidelines.md:10874
msgid "10874    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10875
msgid "10875    It is not inherently bad to pass a pointer or reference to non-`const`,"
msgstr""

# CppCoreGuidelines.md:10876
msgid "10876    but that should be done only when the called function is supposed to modify the object."
msgstr""

# CppCoreGuidelines.md:10877
msgid "10877    A reader of code must assume that a function that takes a \"plain\" `T*` or `T&` will modify the object referred to."
msgstr""

# CppCoreGuidelines.md:10878
msgid "10878    If it doesn't now, it might do so later without forcing recompilation."
msgstr""

       
# CppCoreGuidelines.md:10879
msgid "10879    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10880
msgid "10880    There are code/libraries that are offer functions that declare a`T*` even though"
msgstr""

# CppCoreGuidelines.md:10881
msgid "10881    those function do not modify that `T`."
msgstr""

# CppCoreGuidelines.md:10882
msgid "10882    This is a problem for people modernizing code."
msgstr""

# CppCoreGuidelines.md:10883
msgid "10883    You can"
msgstr""

       
# CppCoreGuidelines.md:10884
msgid "10884    * update the library to be `const`-correct; preferred long-term solution"
msgstr""

# CppCoreGuidelines.md:10885
msgid "10885    * \"cast away `const`\"; [best avoided](#Res-casts-const)"
msgstr""

# CppCoreGuidelines.md:10886
msgid "10886    * provide a wrapper function"
msgstr""

       
# CppCoreGuidelines.md:10887
msgid "10887    Example:"
msgstr""

       
# CppCoreGuidelines.md:10888
msgid "10888        void f(int* p);   // old code: f() does not modify `*p`"
msgstr""

# CppCoreGuidelines.md:10889
msgid "10889        void f(const int* p) { f(const_cast<int*>(p)); } // wrapper"
msgstr""

       
# CppCoreGuidelines.md:10890
msgid "10890    Note that this wrapper solution is a patch that should be used only when the declaration of `f()` cannot be modified,"
msgstr""

# CppCoreGuidelines.md:10891
msgid "10891    e.g. because it is in a library that you cannot modify."
msgstr""

       
# CppCoreGuidelines.md:10892
msgid "10892    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10893
msgid "10893    A `const` member function can modify the value of an object that is `mutable` or accessed through a pointer member."
msgstr""

# CppCoreGuidelines.md:10894
msgid "10894    A common use is to maintain a cache rather than repeatedly do a complicated computation."
msgstr""

# CppCoreGuidelines.md:10895
msgid "10895    For example, here is a `Date` that caches (mnemonizes) its string representation to simplify repeated uses:"
msgstr""

       
# CppCoreGuidelines.md:10896
msgid "10896        class Date {"
msgstr""

# CppCoreGuidelines.md:10897
msgid "10897        public:"
msgstr""

# CppCoreGuidelines.md:10898
msgid "10898            // ..."
msgstr""

# CppCoreGuidelines.md:10899
msgid "10899            const string& string_ref() const"
msgstr""

# CppCoreGuidelines.md:10900
msgid "10900            {"
msgstr""

# CppCoreGuidelines.md:10901
msgid "10901                if (string_val == \"\") compute_string_rep();"
msgstr""

# CppCoreGuidelines.md:10902
msgid "10902                return string_val;"
msgstr""

# CppCoreGuidelines.md:10903
msgid "10903            }"
msgstr""

# CppCoreGuidelines.md:10904
msgid "10904            // ..."
msgstr""

# CppCoreGuidelines.md:10905
msgid "10905        private:"
msgstr""

# CppCoreGuidelines.md:10906
msgid "10906            void compute_string_rep() const;    // compute string representation and place it in string_val"
msgstr""

# CppCoreGuidelines.md:10907
msgid "10907            mutable string string_val;"
msgstr""

# CppCoreGuidelines.md:10908
msgid "10908            // ..."
msgstr""

# CppCoreGuidelines.md:10909
msgid "10909        };"
msgstr""

       
# CppCoreGuidelines.md:10910
msgid "10910    Another way of saying this is that `const`ness is not transitive."
msgstr""

# CppCoreGuidelines.md:10911
msgid "10911    It is possible for a `const` member function to change the value of `mutable` members and the value of objects accessed"
msgstr""

# CppCoreGuidelines.md:10912
msgid "10912    through non-`const` pointers."
msgstr""

# CppCoreGuidelines.md:10913
msgid "10913    It is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants)"
msgstr""

# CppCoreGuidelines.md:10914
msgid "10914    it offers to its users."
msgstr""

       
# CppCoreGuidelines.md:10915
msgid "10915    **See also**: [Pimpl](#Ri-pimpl)"
msgstr""

       
# CppCoreGuidelines.md:10916
msgid "10916    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10917
msgid "10917    * Flag a member function that is not marked `const`, but that does not perform a non-`const` operation on any member variable."
msgstr""

       
# CppCoreGuidelines.md:10918
msgid "10918    ### <a name=\"Rconst-ref\"></a>Con.3: By default, pass pointers and references to `const`s"
msgstr""

       
# CppCoreGuidelines.md:10919
msgid "10919    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10920
msgid "10920     To avoid a called function unexpectedly changing the value."
msgstr""

# CppCoreGuidelines.md:10921
msgid "10921     It's far easier to reason about programs when called functions don't modify state."
msgstr""

       
# CppCoreGuidelines.md:10922
msgid "10922    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10923
msgid "10923        void f(char* p);        // does f modify *p? (assume it does)"
msgstr""

# CppCoreGuidelines.md:10924
msgid "10924        void g(const char* p);  // g does not modify *p"
msgstr""

       
# CppCoreGuidelines.md:10925
msgid "10925    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10926
msgid "10926    It is not inherently bad to pass a pointer or reference to non-`const`,"
msgstr""

# CppCoreGuidelines.md:10927
msgid "10927    but that should be done only when the called function is supposed to modify the object."
msgstr""

       
# CppCoreGuidelines.md:10928
msgid "10928    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10929
msgid "10929    [Do not cast away `const`](#Res-casts-const)."
msgstr""

       
# CppCoreGuidelines.md:10930
msgid "10930    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10931
msgid "10931    * Flag function that does not modify an object passed by  pointer or reference to non-`const`"
msgstr""

# CppCoreGuidelines.md:10932
msgid "10932    * Flag a function that (using a cast) modifies an object passed by pointer or reference to `const`"
msgstr""

       
# CppCoreGuidelines.md:10933
msgid "10933    ### <a name=\"Rconst-const\"></a>Con.4: Use `const` to define objects with values that do not change after construction"
msgstr""

       
# CppCoreGuidelines.md:10934
msgid "10934    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10935
msgid "10935     Prevent surprises from unexpectedly changed object values."
msgstr""

       
# CppCoreGuidelines.md:10936
msgid "10936    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10937
msgid "10937        void f()"
msgstr""

# CppCoreGuidelines.md:10938
msgid "10938        {"
msgstr""

# CppCoreGuidelines.md:10939
msgid "10939            int x = 7;"
msgstr""

# CppCoreGuidelines.md:10940
msgid "10940            const int y = 9;"
msgstr""

       
# CppCoreGuidelines.md:10941
msgid "10941            for (;;) {"
msgstr""

# CppCoreGuidelines.md:10942
msgid "10942                // ..."
msgstr""

# CppCoreGuidelines.md:10943
msgid "10943            }"
msgstr""

# CppCoreGuidelines.md:10944
msgid "10944            // ..."
msgstr""

# CppCoreGuidelines.md:10945
msgid "10945        }"
msgstr""

       
# CppCoreGuidelines.md:10946
msgid "10946    As `x` is not `const`, we must assume that it is modified somewhere in the loop."
msgstr""

       
# CppCoreGuidelines.md:10947
msgid "10947    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10948
msgid "10948    * Flag unmodified non-`const` variables."
msgstr""

       
# CppCoreGuidelines.md:10949
msgid "10949    ### <a name=\"Rconst-constexpr\"></a>Con.5: Use `constexpr` for values that can be computed at compile time"
msgstr""

       
# CppCoreGuidelines.md:10950
msgid "10950    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:10951
msgid "10951    Better performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions."
msgstr""

       
# CppCoreGuidelines.md:10952
msgid "10952    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:10953
msgid "10953        double x = f(2);            // possible run-time evaluation"
msgstr""

# CppCoreGuidelines.md:10954
msgid "10954        const double y = f(2);      // possible run-time evaluation"
msgstr""

# CppCoreGuidelines.md:10955
msgid "10955        constexpr double z = f(2);  // error unless f(2) can be evaluated at compile time"
msgstr""

       
# CppCoreGuidelines.md:10956
msgid "10956    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:10957
msgid "10957    See F.4."
msgstr""

       
# CppCoreGuidelines.md:10958
msgid "10958    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:10959
msgid "10959    * Flag `const` definitions with constant expression initializers."
msgstr""

       
# CppCoreGuidelines.md:10960
msgid "10960    # <a name=\"S-templates\"></a>T: Templates and generic programming"
msgstr""

       
# CppCoreGuidelines.md:10961
msgid "10961    Generic programming is programming using types and algorithms parameterized by types, values, and algorithms."
msgstr""

# CppCoreGuidelines.md:10962
msgid "10962    In C++, generic programming is supported by the `template` language mechanisms."
msgstr""

       
# CppCoreGuidelines.md:10963
msgid "10963    Arguments to generic functions are characterized by sets of requirements on the argument types and values involved."
msgstr""

# CppCoreGuidelines.md:10964
msgid "10964    In C++, these requirements are expressed by compile-time predicates called concepts."
msgstr""

       
# CppCoreGuidelines.md:10965
msgid "10965    Templates can also be used for meta-programming; that is, programs that compose code at compile time."
msgstr""

       
# CppCoreGuidelines.md:10966
msgid "10966    A central notion in generic programming is \"concepts\"; that is, requirements on template arguments presented as compile-time predicates."
msgstr""

# CppCoreGuidelines.md:10967
msgid "10967    \"Concepts\" are defined in an ISO Technical specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:10968
msgid "10968    A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)"
msgstr""

# CppCoreGuidelines.md:10969
msgid "10969    Concepts are supported in GCC 6.1 and later."
msgstr""

# CppCoreGuidelines.md:10970
msgid "10970    Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only."
msgstr""

# CppCoreGuidelines.md:10971
msgid "10971    If you use GCC 6.1 or later, you can uncomment them."
msgstr""

       
# CppCoreGuidelines.md:10972
msgid "10972    Template use rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10973
msgid "10973    * [T.1: Use templates to raise the level of abstraction of code](#Rt-raise)"
msgstr""

# CppCoreGuidelines.md:10974
msgid "10974    * [T.2: Use templates to express algorithms that apply to many argument types](#Rt-algo)"
msgstr""

# CppCoreGuidelines.md:10975
msgid "10975    * [T.3: Use templates to express containers and ranges](#Rt-cont)"
msgstr""

# CppCoreGuidelines.md:10976
msgid "10976    * [T.4: Use templates to express syntax tree manipulation](#Rt-expr)"
msgstr""

# CppCoreGuidelines.md:10977
msgid "10977    * [T.5: Combine generic and OO techniques to amplify their strengths, not their costs](#Rt-generic-oo)"
msgstr""

       
# CppCoreGuidelines.md:10978
msgid "10978    Concept use rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10979
msgid "10979    * [T.10: Specify concepts for all template arguments](#Rt-concepts)"
msgstr""

# CppCoreGuidelines.md:10980
msgid "10980    * [T.11: Whenever possible use standard concepts](#Rt-std-concepts)"
msgstr""

# CppCoreGuidelines.md:10981
msgid "10981    * [T.12: Prefer concept names over `auto` for local variables](#Rt-auto)"
msgstr""

# CppCoreGuidelines.md:10982
msgid "10982    * [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#Rt-shorthand)"
msgstr""

# CppCoreGuidelines.md:10983
msgid "10983    * ???"
msgstr""

       
# CppCoreGuidelines.md:10984
msgid "10984    Concept definition rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10985
msgid "10985    * [T.20: Avoid \"concepts\" without meaningful semantics](#Rt-low)"
msgstr""

# CppCoreGuidelines.md:10986
msgid "10986    * [T.21: Require a complete set of operations for a concept](#Rt-complete)"
msgstr""

# CppCoreGuidelines.md:10987
msgid "10987    * [T.22: Specify axioms for concepts](#Rt-axiom)"
msgstr""

# CppCoreGuidelines.md:10988
msgid "10988    * [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#Rt-refine)"
msgstr""

# CppCoreGuidelines.md:10989
msgid "10989    * [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#Rt-tag)"
msgstr""

# CppCoreGuidelines.md:10990
msgid "10990    * [T.25: Avoid complementary constraints](#Rt-not)"
msgstr""

# CppCoreGuidelines.md:10991
msgid "10991    * [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#Rt-use)"
msgstr""

# CppCoreGuidelines.md:10992
msgid "10992    * [T.30: Use concept negation (`!C<T>`) sparingly to express a minor difference](#Rt-not)"
msgstr""

# CppCoreGuidelines.md:10993
msgid "10993    * [T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to express alternatives](#Rt-or)"
msgstr""

# CppCoreGuidelines.md:10994
msgid "10994    * ???"
msgstr""

       
# CppCoreGuidelines.md:10995
msgid "10995    Template interface rule summary:"
msgstr""

       
# CppCoreGuidelines.md:10996
msgid "10996    * [T.40: Use function objects to pass operations to algorithms](#Rt-fo)"
msgstr""

# CppCoreGuidelines.md:10997
msgid "10997    * [T.41: Require only essential properties in a template's concepts](#Rt-essential)"
msgstr""

# CppCoreGuidelines.md:10998
msgid "10998    * [T.42: Use template aliases to simplify notation and hide implementation details](#Rt-alias)"
msgstr""

# CppCoreGuidelines.md:10999
msgid "10999    * [T.43: Prefer `using` over `typedef` for defining aliases](#Rt-using)"
msgstr""

# CppCoreGuidelines.md:11000
msgid "11000    * [T.44: Use function templates to deduce class template argument types (where feasible)](#Rt-deduce)"
msgstr""

# CppCoreGuidelines.md:11001
msgid "11001    * [T.46: Require template arguments to be at least `Regular` or `SemiRegular`](#Rt-regular)"
msgstr""

# CppCoreGuidelines.md:11002
msgid "11002    * [T.47: Avoid highly visible unconstrained templates with common names](#Rt-visible)"
msgstr""

# CppCoreGuidelines.md:11003
msgid "11003    * [T.48: If your compiler does not support concepts, fake them with `enable_if`](#Rt-concept-def)"
msgstr""

# CppCoreGuidelines.md:11004
msgid "11004    * [T.49: Where possible, avoid type-erasure](#Rt-erasure)"
msgstr""

       
# CppCoreGuidelines.md:11005
msgid "11005    Template definition rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11006
msgid "11006    * [T.60: Minimize a template's context dependencies](#Rt-depend)"
msgstr""

# CppCoreGuidelines.md:11007
msgid "11007    * [T.61: Do not over-parameterize members (SCARY)](#Rt-scary)"
msgstr""

# CppCoreGuidelines.md:11008
msgid "11008    * [T.62: Place non-dependent class template members in a non-templated base class](#Rt-nondependent)"
msgstr""

# CppCoreGuidelines.md:11009
msgid "11009    * [T.64: Use specialization to provide alternative implementations of class templates](#Rt-specialization)"
msgstr""

# CppCoreGuidelines.md:11010
msgid "11010    * [T.65: Use tag dispatch to provide alternative implementations of functions](#Rt-tag-dispatch)"
msgstr""

# CppCoreGuidelines.md:11011
msgid "11011    * [T.67: Use specialization to provide alternative implementations for irregular types](#Rt-specialization2)"
msgstr""

# CppCoreGuidelines.md:11012
msgid "11012    * [T.68: Use `{}` rather than `()` within templates to avoid ambiguities](#Rt-cast)"
msgstr""

# CppCoreGuidelines.md:11013
msgid "11013    * [T.69: Inside a template, don't make an unqualified nonmember function call unless you intend it to be a customization point](#Rt-customization)"
msgstr""

       
# CppCoreGuidelines.md:11014
msgid "11014    Template and hierarchy rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11015
msgid "11015    * [T.80: Do not naively templatize a class hierarchy](#Rt-hier)"
msgstr""

# CppCoreGuidelines.md:11016
msgid "11016    * [T.81: Do not mix hierarchies and arrays](#Rt-array) // ??? somewhere in \"hierarchies\""
msgstr""

# CppCoreGuidelines.md:11017
msgid "11017    * [T.82: Linearize a hierarchy when virtual functions are undesirable](#Rt-linear)"
msgstr""

# CppCoreGuidelines.md:11018
msgid "11018    * [T.83: Do not declare a member function template virtual](#Rt-virtual)"
msgstr""

# CppCoreGuidelines.md:11019
msgid "11019    * [T.84: Use a non-template core implementation to provide an ABI-stable interface](#Rt-abi)"
msgstr""

# CppCoreGuidelines.md:11020
msgid "11020    * [T.??: ????](#Rt-???)"
msgstr""

       
# CppCoreGuidelines.md:11021
msgid "11021    Variadic template rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11022
msgid "11022    * [T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types](#Rt-variadic)"
msgstr""

# CppCoreGuidelines.md:11023
msgid "11023    * [T.101: ??? How to pass arguments to a variadic template ???](#Rt-variadic-pass)"
msgstr""

# CppCoreGuidelines.md:11024
msgid "11024    * [T.102: ??? How to process arguments to a variadic template ???](#Rt-variadic-process)"
msgstr""

# CppCoreGuidelines.md:11025
msgid "11025    * [T.103: Don't use variadic templates for homogeneous argument lists](#Rt-variadic-not)"
msgstr""

# CppCoreGuidelines.md:11026
msgid "11026    * [T.??: ????](#Rt-???)"
msgstr""

       
# CppCoreGuidelines.md:11027
msgid "11027    Metaprogramming rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11028
msgid "11028    * [T.120: Use template metaprogramming only when you really need to](#Rt-metameta)"
msgstr""

# CppCoreGuidelines.md:11029
msgid "11029    * [T.121: Use template metaprogramming primarily to emulate concepts](#Rt-emulate)"
msgstr""

# CppCoreGuidelines.md:11030
msgid "11030    * [T.122: Use templates (usually template aliases) to compute types at compile time](#Rt-tmp)"
msgstr""

# CppCoreGuidelines.md:11031
msgid "11031    * [T.123: Use `constexpr` functions to compute values at compile time](#Rt-fct)"
msgstr""

# CppCoreGuidelines.md:11032
msgid "11032    * [T.124: Prefer to use standard-library TMP facilities](#Rt-std-tmp)"
msgstr""

# CppCoreGuidelines.md:11033
msgid "11033    * [T.125: If you need to go beyond the standard-library TMP facilities, use an existing library](#Rt-lib)"
msgstr""

# CppCoreGuidelines.md:11034
msgid "11034    * [T.??: ????](#Rt-???)"
msgstr""

       
# CppCoreGuidelines.md:11035
msgid "11035    Other template rules summary:"
msgstr""

       
# CppCoreGuidelines.md:11036
msgid "11036    * [T.140: Name all operations with potential for reuse](#Rt-name)"
msgstr""

# CppCoreGuidelines.md:11037
msgid "11037    * [T.141: Use an unnamed lambda if you need a simple function object in one place only](#Rt-lambda)"
msgstr""

# CppCoreGuidelines.md:11038
msgid "11038    * [T.142: Use template variables to simplify notation](#Rt-var)"
msgstr""

# CppCoreGuidelines.md:11039
msgid "11039    * [T.143: Don't write unintentionally nongeneric code](#Rt-nongeneric)"
msgstr""

# CppCoreGuidelines.md:11040
msgid "11040    * [T.144: Don't specialize function templates](#Rt-specialize-function)"
msgstr""

# CppCoreGuidelines.md:11041
msgid "11041    * [T.150: Check that a class matches a concept using `static_assert`](#Rt-check-class)"
msgstr""

# CppCoreGuidelines.md:11042
msgid "11042    * [T.??: ????](#Rt-???)"
msgstr""

       
# CppCoreGuidelines.md:11043
msgid "11043    ## <a name=\"SS-GP\"></a>T.gp: Generic programming"
msgstr""

       
# CppCoreGuidelines.md:11044
msgid "11044    Generic programming is programming using types and algorithms parameterized by types, values, and algorithms."
msgstr""

       
# CppCoreGuidelines.md:11045
msgid "11045    ### <a name=\"Rt-raise\"></a>T.1: Use templates to raise the level of abstraction of code"
msgstr""

       
# CppCoreGuidelines.md:11046
msgid "11046    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11047
msgid "11047    Generality. Reuse. Efficiency. Encourages consistent definition of user types."
msgstr""

       
# CppCoreGuidelines.md:11048
msgid "11048    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:11049
msgid "11049    Conceptually, the following requirements are wrong because what we want of `T` is more than just the very low-level concepts of \"can be incremented\" or \"can be added\":"
msgstr""

       
# CppCoreGuidelines.md:11050
msgid "11050        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11051
msgid "11051            // requires Incrementable<T>"
msgstr""

# CppCoreGuidelines.md:11052
msgid "11052        T sum1(vector<T>& v, T s)"
msgstr""

# CppCoreGuidelines.md:11053
msgid "11053        {"
msgstr""

# CppCoreGuidelines.md:11054
msgid "11054            for (auto x : v) s += x;"
msgstr""

# CppCoreGuidelines.md:11055
msgid "11055            return s;"
msgstr""

# CppCoreGuidelines.md:11056
msgid "11056        }"
msgstr""

       
# CppCoreGuidelines.md:11057
msgid "11057        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11058
msgid "11058            // requires Simple_number<T>"
msgstr""

# CppCoreGuidelines.md:11059
msgid "11059        T sum2(vector<T>& v, T s)"
msgstr""

# CppCoreGuidelines.md:11060
msgid "11060        {"
msgstr""

# CppCoreGuidelines.md:11061
msgid "11061            for (auto x : v) s = s + x;"
msgstr""

# CppCoreGuidelines.md:11062
msgid "11062            return s;"
msgstr""

# CppCoreGuidelines.md:11063
msgid "11063        }"
msgstr""

       
# CppCoreGuidelines.md:11064
msgid "11064    Assuming that `Incrementable` does not support `+` and `Simple_number` does not support `+=`, we have overconstrained implementers of `sum1` and `sum2`."
msgstr""

# CppCoreGuidelines.md:11065
msgid "11065    And, in this case, missed an opportunity for a generalization."
msgstr""

       
# CppCoreGuidelines.md:11066
msgid "11066    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11067
msgid "11067        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11068
msgid "11068            // requires Arithmetic<T>"
msgstr""

# CppCoreGuidelines.md:11069
msgid "11069        T sum(vector<T>& v, T s)"
msgstr""

# CppCoreGuidelines.md:11070
msgid "11070        {"
msgstr""

# CppCoreGuidelines.md:11071
msgid "11071            for (auto x : v) s += x;"
msgstr""

# CppCoreGuidelines.md:11072
msgid "11072            return s;"
msgstr""

# CppCoreGuidelines.md:11073
msgid "11073        }"
msgstr""

       
# CppCoreGuidelines.md:11074
msgid "11074    Assuming that `Arithmetic` requires both `+` and `+=`, we have constrained the user of `sum` to provide a complete arithmetic type."
msgstr""

# CppCoreGuidelines.md:11075
msgid "11075    That is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any `Arithmetic` type"
msgstr""

# CppCoreGuidelines.md:11076
msgid "11076    can be used for a wide variety of algorithms."
msgstr""

       
# CppCoreGuidelines.md:11077
msgid "11077    For additional generality and reusability, we could also use a more general `Container` or `Range` concept instead of committing to only one container, `vector`."
msgstr""

       
# CppCoreGuidelines.md:11078
msgid "11078    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11079
msgid "11079    If we define a template to require exactly the operations required for a single implementation of a single algorithm"
msgstr""

# CppCoreGuidelines.md:11080
msgid "11080    (e.g., requiring just `+=` rather than also `=` and `+`) and only those, we have overconstrained maintainers."
msgstr""

# CppCoreGuidelines.md:11081
msgid "11081    We aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept."
msgstr""

       
# CppCoreGuidelines.md:11082
msgid "11082    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11083
msgid "11083    Templates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates)"
msgstr""

# CppCoreGuidelines.md:11084
msgid "11084    is to efficiently generalize operations/algorithms over a set of types with similar semantic properties."
msgstr""

       
# CppCoreGuidelines.md:11085
msgid "11085    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11086
msgid "11086    The `requires` in the comments are uses of `concepts`."
msgstr""

# CppCoreGuidelines.md:11087
msgid "11087    \"Concepts\" are defined in an ISO Technical specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:11088
msgid "11088    Concepts are supported in GCC 6.1 and later."
msgstr""

# CppCoreGuidelines.md:11089
msgid "11089    Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only."
msgstr""

# CppCoreGuidelines.md:11090
msgid "11090    If you use GCC 6.1 or later, you can uncomment them."
msgstr""

       
# CppCoreGuidelines.md:11091
msgid "11091    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11092
msgid "11092    * Flag algorithms with \"overly simple\" requirements, such as direct use of specific operators without a concept."
msgstr""

# CppCoreGuidelines.md:11093
msgid "11093    * Do not flag the definition of the \"overly simple\" concepts themselves; they may simply be building blocks for more useful concepts."
msgstr""

       
# CppCoreGuidelines.md:11094
msgid "11094    ### <a name=\"Rt-algo\"></a>T.2: Use templates to express algorithms that apply to many argument types"
msgstr""

       
# CppCoreGuidelines.md:11095
msgid "11095    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11096
msgid "11096    Generality. Minimizing the amount of source code. Interoperability. Reuse."
msgstr""

       
# CppCoreGuidelines.md:11097
msgid "11097    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11098
msgid "11098    That's the foundation of the STL. A single `find` algorithm easily works with any kind of input range:"
msgstr""

       
# CppCoreGuidelines.md:11099
msgid "11099        template<typename Iter, typename Val>"
msgstr""

# CppCoreGuidelines.md:11100
msgid "11100            // requires Input_iterator<Iter>"
msgstr""

# CppCoreGuidelines.md:11101
msgid "11101            //       && Equality_comparable<Value_type<Iter>, Val>"
msgstr""

# CppCoreGuidelines.md:11102
msgid "11102        Iter find(Iter b, Iter e, Val v)"
msgstr""

# CppCoreGuidelines.md:11103
msgid "11103        {"
msgstr""

# CppCoreGuidelines.md:11104
msgid "11104            // ..."
msgstr""

# CppCoreGuidelines.md:11105
msgid "11105        }"
msgstr""

       
# CppCoreGuidelines.md:11106
msgid "11106    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11107
msgid "11107    Don't use a template unless you have a realistic need for more than one template argument type."
msgstr""

# CppCoreGuidelines.md:11108
msgid "11108    Don't overabstract."
msgstr""

       
# CppCoreGuidelines.md:11109
msgid "11109    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11110
msgid "11110    ??? tough, probably needs a human"
msgstr""

       
# CppCoreGuidelines.md:11111
msgid "11111    ### <a name=\"Rt-cont\"></a>T.3: Use templates to express containers and ranges"
msgstr""

       
# CppCoreGuidelines.md:11112
msgid "11112    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11113
msgid "11113    Containers need an element type, and expressing that as a template argument is general, reusable, and type safe."
msgstr""

# CppCoreGuidelines.md:11114
msgid "11114    It also avoids brittle or inefficient workarounds. Convention: That's the way the STL does it."
msgstr""

       
# CppCoreGuidelines.md:11115
msgid "11115    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11116
msgid "11116        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11117
msgid "11117            // requires Regular<T>"
msgstr""

# CppCoreGuidelines.md:11118
msgid "11118        class Vector {"
msgstr""

# CppCoreGuidelines.md:11119
msgid "11119            // ..."
msgstr""

# CppCoreGuidelines.md:11120
msgid "11120            T* elem;   // points to sz Ts"
msgstr""

# CppCoreGuidelines.md:11121
msgid "11121            int sz;"
msgstr""

# CppCoreGuidelines.md:11122
msgid "11122        };"
msgstr""

       
# CppCoreGuidelines.md:11123
msgid "11123        Vector<double> v(10);"
msgstr""

# CppCoreGuidelines.md:11124
msgid "11124        v[7] = 9.9;"
msgstr""

       
# CppCoreGuidelines.md:11125
msgid "11125    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:11126
msgid "11126        class Container {"
msgstr""

# CppCoreGuidelines.md:11127
msgid "11127            // ..."
msgstr""

# CppCoreGuidelines.md:11128
msgid "11128            void* elem;   // points to size elements of some type"
msgstr""

# CppCoreGuidelines.md:11129
msgid "11129            int sz;"
msgstr""

# CppCoreGuidelines.md:11130
msgid "11130        };"
msgstr""

       
# CppCoreGuidelines.md:11131
msgid "11131        Container c(10, sizeof(double));"
msgstr""

# CppCoreGuidelines.md:11132
msgid "11132        ((double*) c.elem)[7] = 9.9;"
msgstr""

       
# CppCoreGuidelines.md:11133
msgid "11133    This doesn't directly express the intent of the programmer and hides the structure of the program from the type system and optimizer."
msgstr""

       
# CppCoreGuidelines.md:11134
msgid "11134    Hiding the `void*` behind macros simply obscures the problems and introduces new opportunities for confusion."
msgstr""

       
# CppCoreGuidelines.md:11135
msgid "11135    **Exceptions**: If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that."
msgstr""

# CppCoreGuidelines.md:11136
msgid "11136    See [Stable base](#Rt-abi)."
msgstr""

       
# CppCoreGuidelines.md:11137
msgid "11137    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11138
msgid "11138    * Flag uses of `void*`s and casts outside low-level implementation code"
msgstr""

       
# CppCoreGuidelines.md:11139
msgid "11139    ### <a name=\"Rt-expr\"></a>T.4: Use templates to express syntax tree manipulation"
msgstr""

       
# CppCoreGuidelines.md:11140
msgid "11140    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11141
msgid "11141     ???"
msgstr""

       
# CppCoreGuidelines.md:11142
msgid "11142    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11143
msgid "11143        ???"
msgstr""

       
# CppCoreGuidelines.md:11144
msgid "11144    **Exceptions**: ???"
msgstr""

       
# CppCoreGuidelines.md:11145
msgid "11145    ### <a name=\"Rt-generic-oo\"></a>T.5: Combine generic and OO techniques to amplify their strengths, not their costs"
msgstr""

       
# CppCoreGuidelines.md:11146
msgid "11146    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11147
msgid "11147    Generic and OO techniques are complementary."
msgstr""

       
# CppCoreGuidelines.md:11148
msgid "11148    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11149
msgid "11149    Static helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces."
msgstr""

       
# CppCoreGuidelines.md:11150
msgid "11150        class Command {"
msgstr""

# CppCoreGuidelines.md:11151
msgid "11151            // pure virtual functions"
msgstr""

# CppCoreGuidelines.md:11152
msgid "11152        };"
msgstr""

       
# CppCoreGuidelines.md:11153
msgid "11153        // implementations"
msgstr""

# CppCoreGuidelines.md:11154
msgid "11154        template</*...*/>"
msgstr""

# CppCoreGuidelines.md:11155
msgid "11155        class ConcreteCommand : public Command {"
msgstr""

# CppCoreGuidelines.md:11156
msgid "11156            // implement virtuals"
msgstr""

# CppCoreGuidelines.md:11157
msgid "11157        };"
msgstr""

       
# CppCoreGuidelines.md:11158
msgid "11158    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11159
msgid "11159    Dynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout."
msgstr""

# CppCoreGuidelines.md:11160
msgid "11160    Examples include type erasure as with `std::shared_ptr`'s deleter (but [don't overuse type erasure](#Rt-erasure))."
msgstr""

       
# CppCoreGuidelines.md:11161
msgid "11161    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11162
msgid "11162    In a class template, nonvirtual functions are only instantiated if they're used -- but virtual functions are instantiated every time."
msgstr""

# CppCoreGuidelines.md:11163
msgid "11163    This can bloat code size, and may overconstrain a generic type by instantiating functionality that is never needed."
msgstr""

# CppCoreGuidelines.md:11164
msgid "11164    Avoid this, even though the standard-library facets made this mistake."
msgstr""

       
# CppCoreGuidelines.md:11165
msgid "11165    ##### See also"
msgstr""

       
# CppCoreGuidelines.md:11166
msgid "11166    * ref ???"
msgstr""

# CppCoreGuidelines.md:11167
msgid "11167    * ref ???"
msgstr""

# CppCoreGuidelines.md:11168
msgid "11168    * ref ???"
msgstr""

       
# CppCoreGuidelines.md:11169
msgid "11169    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11170
msgid "11170    See the reference to more specific rules."
msgstr""

       
# CppCoreGuidelines.md:11171
msgid "11171    ## <a name=\"SS-concepts\"></a>T.concepts: Concept rules"
msgstr""

       
# CppCoreGuidelines.md:11172
msgid "11172    Concepts is a facility for specifying requirements for template arguments."
msgstr""

# CppCoreGuidelines.md:11173
msgid "11173    It is an [ISO technical specification](#Ref-conceptsTS), but currently supported only by GCC."
msgstr""

# CppCoreGuidelines.md:11174
msgid "11174    Concepts are, however, crucial in the thinking about generic programming and the basis of much work on future C++ libraries"
msgstr""

# CppCoreGuidelines.md:11175
msgid "11175    (standard and other)."
msgstr""

       
# CppCoreGuidelines.md:11176
msgid "11176    This section assumes concept support"
msgstr""

       
# CppCoreGuidelines.md:11177
msgid "11177    Concept use rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11178
msgid "11178    * [T.10: Specify concepts for all template arguments](#Rt-concepts)"
msgstr""

# CppCoreGuidelines.md:11179
msgid "11179    * [T.11: Whenever possible use standard concepts](#Rt-std-concepts)"
msgstr""

# CppCoreGuidelines.md:11180
msgid "11180    * [T.12: Prefer concept names over `auto`](#Rt-auto)"
msgstr""

# CppCoreGuidelines.md:11181
msgid "11181    * [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#Rt-shorthand)"
msgstr""

# CppCoreGuidelines.md:11182
msgid "11182    * ???"
msgstr""

       
# CppCoreGuidelines.md:11183
msgid "11183    Concept definition rule summary:"
msgstr""

       
# CppCoreGuidelines.md:11184
msgid "11184    * [T.20: Avoid \"concepts\" without meaningful semantics](#Rt-low)"
msgstr""

# CppCoreGuidelines.md:11185
msgid "11185    * [T.21: Require a complete set of operations for a concept](#Rt-complete)"
msgstr""

# CppCoreGuidelines.md:11186
msgid "11186    * [T.22: Specify axioms for concepts](#Rt-axiom)"
msgstr""

# CppCoreGuidelines.md:11187
msgid "11187    * [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#Rt-refine)"
msgstr""

# CppCoreGuidelines.md:11188
msgid "11188    * [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#Rt-tag)"
msgstr""

# CppCoreGuidelines.md:11189
msgid "11189    * [T.25: Avoid complimentary constraints](#Rt-not)"
msgstr""

# CppCoreGuidelines.md:11190
msgid "11190    * [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#Rt-use)"
msgstr""

# CppCoreGuidelines.md:11191
msgid "11191    * ???"
msgstr""

       
# CppCoreGuidelines.md:11192
msgid "11192    ## <a name=\"SS-concept-use\"></a>T.con-use: Concept use"
msgstr""

       
# CppCoreGuidelines.md:11193
msgid "11193    ### <a name=\"Rt-concepts\"></a>T.10: Specify concepts for all template arguments"
msgstr""

       
# CppCoreGuidelines.md:11194
msgid "11194    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11195
msgid "11195    Correctness and readability."
msgstr""

# CppCoreGuidelines.md:11196
msgid "11196    The assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template."
msgstr""

# CppCoreGuidelines.md:11197
msgid "11197    A concept dramatically improves documentation and error handling for the template."
msgstr""

# CppCoreGuidelines.md:11198
msgid "11198    Specifying concepts for template arguments is a powerful design tool."
msgstr""

       
# CppCoreGuidelines.md:11199
msgid "11199    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11200
msgid "11200        template<typename Iter, typename Val>"
msgstr""

# CppCoreGuidelines.md:11201
msgid "11201        //    requires Input_iterator<Iter>"
msgstr""

# CppCoreGuidelines.md:11202
msgid "11202        //             && Equality_comparable<Value_type<Iter>, Val>"
msgstr""

# CppCoreGuidelines.md:11203
msgid "11203        Iter find(Iter b, Iter e, Val v)"
msgstr""

# CppCoreGuidelines.md:11204
msgid "11204        {"
msgstr""

# CppCoreGuidelines.md:11205
msgid "11205            // ..."
msgstr""

# CppCoreGuidelines.md:11206
msgid "11206        }"
msgstr""

       
# CppCoreGuidelines.md:11207
msgid "11207    or equivalently and more succinctly:"
msgstr""

       
# CppCoreGuidelines.md:11208
msgid "11208        template<Input_iterator Iter, typename Val>"
msgstr""

# CppCoreGuidelines.md:11209
msgid "11209        //    requires Equality_comparable<Value_type<Iter>, Val>"
msgstr""

# CppCoreGuidelines.md:11210
msgid "11210        Iter find(Iter b, Iter e, Val v)"
msgstr""

# CppCoreGuidelines.md:11211
msgid "11211        {"
msgstr""

# CppCoreGuidelines.md:11212
msgid "11212            // ..."
msgstr""

# CppCoreGuidelines.md:11213
msgid "11213        }"
msgstr""

       
# CppCoreGuidelines.md:11214
msgid "11214    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11215
msgid "11215    \"Concepts\" are defined in an ISO Technical specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:11216
msgid "11216    A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)"
msgstr""

# CppCoreGuidelines.md:11217
msgid "11217    Concepts are supported in GCC 6.1 and later."
msgstr""

# CppCoreGuidelines.md:11218
msgid "11218    Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only."
msgstr""

# CppCoreGuidelines.md:11219
msgid "11219    If you use GCC 6.1 or later, you can uncomment them:"
msgstr""

       
# CppCoreGuidelines.md:11220
msgid "11220        template<typename Iter, typename Val>"
msgstr""

# CppCoreGuidelines.md:11221
msgid "11221            requires Input_iterator<Iter>"
msgstr""

# CppCoreGuidelines.md:11222
msgid "11222                   && Equality_comparable<Value_type<Iter>, Val>"
msgstr""

# CppCoreGuidelines.md:11223
msgid "11223        Iter find(Iter b, Iter e, Val v)"
msgstr""

# CppCoreGuidelines.md:11224
msgid "11224        {"
msgstr""

# CppCoreGuidelines.md:11225
msgid "11225            // ..."
msgstr""

# CppCoreGuidelines.md:11226
msgid "11226        }"
msgstr""

       
# CppCoreGuidelines.md:11227
msgid "11227    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11228
msgid "11228    Plain `typename` (or `auto`) is the least constraining concept."
msgstr""

# CppCoreGuidelines.md:11229
msgid "11229    It should be used only rarely when nothing more than \"it's a type\" can be assumed."
msgstr""

# CppCoreGuidelines.md:11230
msgid "11230    This is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking."
msgstr""

       
# CppCoreGuidelines.md:11231
msgid "11231    **References**: TC++PL4, Palo Alto TR, Sutton"
msgstr""

       
# CppCoreGuidelines.md:11232
msgid "11232    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11233
msgid "11233    Flag template type arguments without concepts"
msgstr""

       
# CppCoreGuidelines.md:11234
msgid "11234    ### <a name=\"Rt-std-concepts\"></a>T.11: Whenever possible use standard concepts"
msgstr""

       
# CppCoreGuidelines.md:11235
msgid "11235    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11236
msgid "11236     \"Standard\" concepts (as provided by the [GSL](#S-GSL) and the [Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf), and hopefully soon the ISO standard itself)"
msgstr""

# CppCoreGuidelines.md:11237
msgid "11237    saves us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improves interoperability."
msgstr""

       
# CppCoreGuidelines.md:11238
msgid "11238    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11239
msgid "11239    Unless you are creating a new generic library, most of the concepts you need will already be defined by the standard library."
msgstr""

       
# CppCoreGuidelines.md:11240
msgid "11240    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11241
msgid "11241        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11242
msgid "11242            // don't define this: Sortable is in the GSL"
msgstr""

# CppCoreGuidelines.md:11243
msgid "11243        concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>;"
msgstr""

       
# CppCoreGuidelines.md:11244
msgid "11244        void sort(Ordered_container& s);"
msgstr""

       
# CppCoreGuidelines.md:11245
msgid "11245    This `Ordered_container` is quite plausible, but it is very similar to the `Sortable` concept in the GSL (and the Range TS)."
msgstr""

# CppCoreGuidelines.md:11246
msgid "11246    Is it better? Is it right? Does it accurately reflect the standard's requirements for `sort`?"
msgstr""

# CppCoreGuidelines.md:11247
msgid "11247    It is better and simpler just to use `Sortable`:"
msgstr""

       
# CppCoreGuidelines.md:11248
msgid "11248        void sort(Sortable& s);   // better"
msgstr""

       
# CppCoreGuidelines.md:11249
msgid "11249    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11250
msgid "11250    The set of \"standard\" concepts is evolving as we approach an ISO standard including concepts."
msgstr""

       
# CppCoreGuidelines.md:11251
msgid "11251    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11252
msgid "11252    Designing a useful concept is challenging."
msgstr""

       
# CppCoreGuidelines.md:11253
msgid "11253    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11254
msgid "11254    Hard."
msgstr""

       
# CppCoreGuidelines.md:11255
msgid "11255    * Look for unconstrained arguments, templates that use \"unusual\"/non-standard concepts, templates that use \"homebrew\" concepts without axioms."
msgstr""

# CppCoreGuidelines.md:11256
msgid "11256    * Develop a concept-discovery tool (e.g., see [an early experiment](http://www.stroustrup.com/sle2010_webversion.pdf))."
msgstr""

       
# CppCoreGuidelines.md:11257
msgid "11257    ### <a name=\"Rt-auto\"></a>T.12: Prefer concept names over `auto` for local variables"
msgstr""

       
# CppCoreGuidelines.md:11258
msgid "11258    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11259
msgid "11259     `auto` is the weakest concept. Concept names convey more meaning than just `auto`."
msgstr""

       
# CppCoreGuidelines.md:11260
msgid "11260    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11261
msgid "11261        vector<string> v{ \"abc\", \"xyz\" };"
msgstr""

# CppCoreGuidelines.md:11262
msgid "11262        auto& x = v.front();     // bad"
msgstr""

# CppCoreGuidelines.md:11263
msgid "11263        String& s = v.front();   // good (String is a GSL concept)"
msgstr""

       
# CppCoreGuidelines.md:11264
msgid "11264    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11265
msgid "11265    * ???"
msgstr""

       
# CppCoreGuidelines.md:11266
msgid "11266    ### <a name=\"Rt-shorthand\"></a>T.13: Prefer the shorthand notation for simple, single-type argument concepts"
msgstr""

       
# CppCoreGuidelines.md:11267
msgid "11267    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11268
msgid "11268    Readability. Direct expression of an idea."
msgstr""

       
# CppCoreGuidelines.md:11269
msgid "11269    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11270
msgid "11270    To say \"`T` is `Sortable`\":"
msgstr""

       
# CppCoreGuidelines.md:11271
msgid "11271        template<typename T>       // Correct but verbose: \"The parameter is"
msgstr""

# CppCoreGuidelines.md:11272
msgid "11272        //    requires Sortable<T>   // of type T which is the name of a type"
msgstr""

# CppCoreGuidelines.md:11273
msgid "11273        void sort(T&);             // that is Sortable\""
msgstr""

       
# CppCoreGuidelines.md:11274
msgid "11274        template<Sortable T>       // Better (assuming support for concepts): \"The parameter is of type T"
msgstr""

# CppCoreGuidelines.md:11275
msgid "11275        void sort(T&);             // which is Sortable\""
msgstr""

       
# CppCoreGuidelines.md:11276
msgid "11276        void sort(Sortable&);      // Best (assuming support for concepts): \"The parameter is Sortable\""
msgstr""

       
# CppCoreGuidelines.md:11277
msgid "11277    The shorter versions better match the way we speak. Note that many templates don't need to use the `template` keyword."
msgstr""

       
# CppCoreGuidelines.md:11278
msgid "11278    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11279
msgid "11279    \"Concepts\" are defined in an ISO Technical specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:11280
msgid "11280    A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)"
msgstr""

# CppCoreGuidelines.md:11281
msgid "11281    Concepts are supported in GCC 6.1 and later."
msgstr""

# CppCoreGuidelines.md:11282
msgid "11282    Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only."
msgstr""

# CppCoreGuidelines.md:11283
msgid "11283    If you use a compiler that supports concepts (e.g., GCC 6.1 or later), you can remove the `//`."
msgstr""

       
# CppCoreGuidelines.md:11284
msgid "11284    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11285
msgid "11285    * Not feasible in the short term when people convert from the `<typename T>` and `<class T`> notation."
msgstr""

# CppCoreGuidelines.md:11286
msgid "11286    * Later, flag declarations that first introduces a typename and then constrains it with a simple, single-type-argument concept."
msgstr""

       
# CppCoreGuidelines.md:11287
msgid "11287    ## <a name=\"SS-concepts-def\"></a>T.concepts.def: Concept definition rules"
msgstr""

       
# CppCoreGuidelines.md:11288
msgid "11288    Defining good concepts is non-trivial."
msgstr""

# CppCoreGuidelines.md:11289
msgid "11289    Concepts are meant to represent fundamental concepts in an application domain (hence the name \"concepts\")."
msgstr""

# CppCoreGuidelines.md:11290
msgid "11290    Similarly throwing together a set of syntactic constraints to be used for a the arguments for a single class or algorithm is not what concepts were designed for"
msgstr""

# CppCoreGuidelines.md:11291
msgid "11291    and will not give the full benefits of the mechanism."
msgstr""

       
# CppCoreGuidelines.md:11292
msgid "11292    Obviously, defining concepts will be most useful for code that can use an implementation (e.g., GCC 6.1 or later),"
msgstr""

# CppCoreGuidelines.md:11293
msgid "11293    but defining concepts is in itself a useful design technique and help catch conceptual errors and clean up the concepts (sic!) of an implementation."
msgstr""

       
# CppCoreGuidelines.md:11294
msgid "11294    ### <a name=\"Rt-low\"></a>T.20: Avoid \"concepts\" without meaningful semantics"
msgstr""

       
# CppCoreGuidelines.md:11295
msgid "11295    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11296
msgid "11296    Concepts are meant to express semantic notions, such as \"a number\", \"a range\" of elements, and \"totally ordered.\""
msgstr""

# CppCoreGuidelines.md:11297
msgid "11297    Simple constraints, such as \"has a `+` operator\" and \"has a `>` operator\" cannot be meaningfully specified in isolation"
msgstr""

# CppCoreGuidelines.md:11298
msgid "11298    and should be used only as building blocks for meaningful concepts, rather than in user code."
msgstr""

       
# CppCoreGuidelines.md:11299
msgid "11299    ##### Example, bad (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11300
msgid "11300        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11301
msgid "11301        concept Addable = has_plus<T>;    // bad; insufficient"
msgstr""

       
# CppCoreGuidelines.md:11302
msgid "11302        template<Addable N> auto algo(const N& a, const N& b) // use two numbers"
msgstr""

# CppCoreGuidelines.md:11303
msgid "11303        {"
msgstr""

# CppCoreGuidelines.md:11304
msgid "11304            // ..."
msgstr""

# CppCoreGuidelines.md:11305
msgid "11305            return a + b;"
msgstr""

# CppCoreGuidelines.md:11306
msgid "11306        }"
msgstr""

       
# CppCoreGuidelines.md:11307
msgid "11307        int x = 7;"
msgstr""

# CppCoreGuidelines.md:11308
msgid "11308        int y = 9;"
msgstr""

# CppCoreGuidelines.md:11309
msgid "11309        auto z = algo(x, y);   // z = 16"
msgstr""

       
# CppCoreGuidelines.md:11310
msgid "11310        string xx = \"7\";"
msgstr""

# CppCoreGuidelines.md:11311
msgid "11311        string yy = \"9\";"
msgstr""

# CppCoreGuidelines.md:11312
msgid "11312        auto zz = algo(xx, yy);   // zz = \"79\""
msgstr""

       
# CppCoreGuidelines.md:11313
msgid "11313    Maybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types."
msgstr""

# CppCoreGuidelines.md:11314
msgid "11314    This `Addable` violates the mathematical rule that addition is supposed to be commutative: `a+b == b+a`."
msgstr""

       
# CppCoreGuidelines.md:11315
msgid "11315    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11316
msgid "11316    The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint."
msgstr""

       
# CppCoreGuidelines.md:11317
msgid "11317    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11318
msgid "11318        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11319
msgid "11319        // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules"
msgstr""

# CppCoreGuidelines.md:11320
msgid "11320        concept Number = has_plus<T>"
msgstr""

# CppCoreGuidelines.md:11321
msgid "11321                         && has_minus<T>"
msgstr""

# CppCoreGuidelines.md:11322
msgid "11322                         && has_multiply<T>"
msgstr""

# CppCoreGuidelines.md:11323
msgid "11323                         && has_divide<T>;"
msgstr""

       
# CppCoreGuidelines.md:11324
msgid "11324        template<Number N> auto algo(const N& a, const N& b)"
msgstr""

# CppCoreGuidelines.md:11325
msgid "11325        {"
msgstr""

# CppCoreGuidelines.md:11326
msgid "11326            // ..."
msgstr""

# CppCoreGuidelines.md:11327
msgid "11327            return a + b;"
msgstr""

# CppCoreGuidelines.md:11328
msgid "11328        }"
msgstr""

       
# CppCoreGuidelines.md:11329
msgid "11329        int x = 7;"
msgstr""

# CppCoreGuidelines.md:11330
msgid "11330        int y = 9;"
msgstr""

# CppCoreGuidelines.md:11331
msgid "11331        auto z = algo(x, y);   // z = 16"
msgstr""

       
# CppCoreGuidelines.md:11332
msgid "11332        string xx = \"7\";"
msgstr""

# CppCoreGuidelines.md:11333
msgid "11333        string yy = \"9\";"
msgstr""

# CppCoreGuidelines.md:11334
msgid "11334        auto zz = algo(xx, yy);   // error: string is not a Number"
msgstr""

       
# CppCoreGuidelines.md:11335
msgid "11335    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11336
msgid "11336    Concepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept."
msgstr""

       
# CppCoreGuidelines.md:11337
msgid "11337    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11338
msgid "11338    * Flag single-operation `concepts` when used outside the definition of other `concepts`."
msgstr""

# CppCoreGuidelines.md:11339
msgid "11339    * Flag uses of `enable_if` that appears to simulate single-operation `concepts`."
msgstr""

       
       
# CppCoreGuidelines.md:11340
msgid "11340    ### <a name=\"Rt-complete\"></a>T.21: Require a complete set of operations for a concept"
msgstr""

       
# CppCoreGuidelines.md:11341
msgid "11341    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11342
msgid "11342    Ease of comprehension."
msgstr""

# CppCoreGuidelines.md:11343
msgid "11343    Improved interoperability."
msgstr""

# CppCoreGuidelines.md:11344
msgid "11344    Helps implementers and maintainers."
msgstr""

       
# CppCoreGuidelines.md:11345
msgid "11345    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11346
msgid "11346    This is a specific variant of the general rule that [a concept must make semantic sense](#Rt-low)."
msgstr""

       
# CppCoreGuidelines.md:11347
msgid "11347    ##### Example, bad (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11348
msgid "11348        template<typename T> concept Subtractable = requires(T a, T, b) { a-b; };"
msgstr""

       
# CppCoreGuidelines.md:11349
msgid "11349    This makes no semantic sense."
msgstr""

# CppCoreGuidelines.md:11350
msgid "11350    You need at least `+` to make `-` meaningful and useful."
msgstr""

       
# CppCoreGuidelines.md:11351
msgid "11351    Examples of complete sets are"
msgstr""

       
# CppCoreGuidelines.md:11352
msgid "11352    * `Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`"
msgstr""

# CppCoreGuidelines.md:11353
msgid "11353    * `Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`"
msgstr""

       
# CppCoreGuidelines.md:11354
msgid "11354    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11355
msgid "11355    This rule applies whether we use direct language support for concepts or not."
msgstr""

# CppCoreGuidelines.md:11356
msgid "11356    It is a general design rule that even applies to non-templates:"
msgstr""

       
# CppCoreGuidelines.md:11357
msgid "11357        class Minimal {"
msgstr""

# CppCoreGuidelines.md:11358
msgid "11358            // ..."
msgstr""

# CppCoreGuidelines.md:11359
msgid "11359        };"
msgstr""

       
# CppCoreGuidelines.md:11360
msgid "11360        bool operator==(const Minimal&, const Minimal&);"
msgstr""

# CppCoreGuidelines.md:11361
msgid "11361        bool operator<(const Minimal&, const Minimal&);"
msgstr""

       
# CppCoreGuidelines.md:11362
msgid "11362        Minimal operator+(const Minimal&, const Minimal&);"
msgstr""

# CppCoreGuidelines.md:11363
msgid "11363        // no other operators"
msgstr""

       
# CppCoreGuidelines.md:11364
msgid "11364        void f(const Minimal& x, const Minimal& y)"
msgstr""

# CppCoreGuidelines.md:11365
msgid "11365        {"
msgstr""

# CppCoreGuidelines.md:11366
msgid "11366            if (!(x == y)) { /* ... */ }    // OK"
msgstr""

# CppCoreGuidelines.md:11367
msgid "11367            if (x != y) { /* ... */ }       // surprise! error"
msgstr""

       
# CppCoreGuidelines.md:11368
msgid "11368            while (!(x < y)) { /* ... */ }  // OK"
msgstr""

# CppCoreGuidelines.md:11369
msgid "11369            while (x >= y) { /* ... */ }    // surprise! error"
msgstr""

       
# CppCoreGuidelines.md:11370
msgid "11370            x = x + y;          // OK"
msgstr""

# CppCoreGuidelines.md:11371
msgid "11371            x += y;             // surprise! error"
msgstr""

# CppCoreGuidelines.md:11372
msgid "11372        }"
msgstr""

       
# CppCoreGuidelines.md:11373
msgid "11373    This is minimal, but surprising and constraining for users."
msgstr""

# CppCoreGuidelines.md:11374
msgid "11374    It could even be less efficient."
msgstr""

       
# CppCoreGuidelines.md:11375
msgid "11375    The rule supports the view that a concept should reflect a (mathematically) coherent set of operations."
msgstr""

       
# CppCoreGuidelines.md:11376
msgid "11376    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11377
msgid "11377        class Convenient {"
msgstr""

# CppCoreGuidelines.md:11378
msgid "11378            // ..."
msgstr""

# CppCoreGuidelines.md:11379
msgid "11379        };"
msgstr""

       
# CppCoreGuidelines.md:11380
msgid "11380        bool operator==(const Convenient&, const Convenient&);"
msgstr""

# CppCoreGuidelines.md:11381
msgid "11381        bool operator<(const Convenient&, const Convenient&);"
msgstr""

# CppCoreGuidelines.md:11382
msgid "11382        // ... and the other comparison operators ..."
msgstr""

       
# CppCoreGuidelines.md:11383
msgid "11383        Minimal operator+(const Convenient&, const Convenient&);"
msgstr""

# CppCoreGuidelines.md:11384
msgid "11384        // .. and the other arithmetic operators ..."
msgstr""

       
# CppCoreGuidelines.md:11385
msgid "11385        void f(const Convenient& x, const Convenient& y)"
msgstr""

# CppCoreGuidelines.md:11386
msgid "11386        {"
msgstr""

# CppCoreGuidelines.md:11387
msgid "11387            if (!(x == y)) { /* ... */ }    // OK"
msgstr""

# CppCoreGuidelines.md:11388
msgid "11388            if (x != y) { /* ... */ }       // OK"
msgstr""

       
# CppCoreGuidelines.md:11389
msgid "11389            while (!(x < y)) { /* ... */ }  // OK"
msgstr""

# CppCoreGuidelines.md:11390
msgid "11390            while (x >= y) { /* ... */ }    // OK"
msgstr""

       
# CppCoreGuidelines.md:11391
msgid "11391            x = x + y;     // OK"
msgstr""

# CppCoreGuidelines.md:11392
msgid "11392            x += y;        // OK"
msgstr""

# CppCoreGuidelines.md:11393
msgid "11393        }"
msgstr""

       
# CppCoreGuidelines.md:11394
msgid "11394    It can be a nuisance to define all operators, but not hard."
msgstr""

# CppCoreGuidelines.md:11395
msgid "11395    Ideally, that rule should be language supported by giving you comparison operators by default."
msgstr""

       
# CppCoreGuidelines.md:11396
msgid "11396    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11397
msgid "11397    * Flag classes that support \"odd\" subsets of a set of operators, e.g., `==` but not `!=` or `+` but not `-`."
msgstr""

# CppCoreGuidelines.md:11398
msgid "11398      Yes, `std::string` is \"odd\", but it's too late to change that."
msgstr""

       
       
# CppCoreGuidelines.md:11399
msgid "11399    ### <a name=\"Rt-axiom\"></a>T.22: Specify axioms for concepts"
msgstr""

       
# CppCoreGuidelines.md:11400
msgid "11400    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11401
msgid "11401    A meaningful/useful concept has a semantic meaning."
msgstr""

# CppCoreGuidelines.md:11402
msgid "11402    Expressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors."
msgstr""

# CppCoreGuidelines.md:11403
msgid "11403    Specifying semantics is a powerful design tool."
msgstr""

       
# CppCoreGuidelines.md:11404
msgid "11404    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11405
msgid "11405        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11406
msgid "11406            // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules"
msgstr""

# CppCoreGuidelines.md:11407
msgid "11407            // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }"
msgstr""

# CppCoreGuidelines.md:11408
msgid "11408            concept Number = requires(T a, T b) {"
msgstr""

# CppCoreGuidelines.md:11409
msgid "11409                {a + b} -> T;   // the result of a + b is convertible to T"
msgstr""

# CppCoreGuidelines.md:11410
msgid "11410                {a - b} -> T;"
msgstr""

# CppCoreGuidelines.md:11411
msgid "11411                {a * b} -> T;"
msgstr""

# CppCoreGuidelines.md:11412
msgid "11412                {a / b} -> T;"
msgstr""

# CppCoreGuidelines.md:11413
msgid "11413            }"
msgstr""

       
# CppCoreGuidelines.md:11414
msgid "11414    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11415
msgid "11415    This is an axiom in the mathematical sense: something that may be assumed without proof."
msgstr""

# CppCoreGuidelines.md:11416
msgid "11416    In general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler."
msgstr""

# CppCoreGuidelines.md:11417
msgid "11417    An axiom may not be general, but the template writer may assume that it holds for all inputs actually used (similar to a precondition)."
msgstr""

       
# CppCoreGuidelines.md:11418
msgid "11418    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11419
msgid "11419    In this context axioms are Boolean expressions."
msgstr""

# CppCoreGuidelines.md:11420
msgid "11420    See the [Palo Alto TR](#S-references) for examples."
msgstr""

# CppCoreGuidelines.md:11421
msgid "11421    Currently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while."
msgstr""

# CppCoreGuidelines.md:11422
msgid "11422    Once language support is available, the `//` in front of the axiom can be removed"
msgstr""

       
# CppCoreGuidelines.md:11423
msgid "11423    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11424
msgid "11424    The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS."
msgstr""

       
# CppCoreGuidelines.md:11425
msgid "11425    ##### Exception (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11426
msgid "11426    Early versions of a new \"concept\" still under development will often just define simple sets of constraints without a well-specified semantics."
msgstr""

# CppCoreGuidelines.md:11427
msgid "11427    Finding good semantics can take effort and time."
msgstr""

# CppCoreGuidelines.md:11428
msgid "11428    An incomplete set of constraints can still be very useful:"
msgstr""

       
# CppCoreGuidelines.md:11429
msgid "11429        // balancer for a generic binary tree"
msgstr""

# CppCoreGuidelines.md:11430
msgid "11430        template<typename Node> concept bool Balancer = requires(Node* p) {"
msgstr""

# CppCoreGuidelines.md:11431
msgid "11431            add_fixup(p);"
msgstr""

# CppCoreGuidelines.md:11432
msgid "11432            touch(p);"
msgstr""

# CppCoreGuidelines.md:11433
msgid "11433            detach(p);"
msgstr""

# CppCoreGuidelines.md:11434
msgid "11434        }"
msgstr""

       
# CppCoreGuidelines.md:11435
msgid "11435    So a `Balancer` must supply at least thee operations on a tree `Node`,"
msgstr""

# CppCoreGuidelines.md:11436
msgid "11436    but we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations"
msgstr""

# CppCoreGuidelines.md:11437
msgid "11437    and the precise general semantics for all nodes is hard to pin down in the early stages of design."
msgstr""

       
# CppCoreGuidelines.md:11438
msgid "11438    A \"concept\" that is incomplete or without a well-specified semantics can still be useful."
msgstr""

# CppCoreGuidelines.md:11439
msgid "11439    For example, it allows for some checking during initial experimentation."
msgstr""

# CppCoreGuidelines.md:11440
msgid "11440    However, it should not be assumed to be stable."
msgstr""

# CppCoreGuidelines.md:11441
msgid "11441    Each new use case may require such an incomplete concepts to be improved."
msgstr""

       
# CppCoreGuidelines.md:11442
msgid "11442    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11443
msgid "11443    * Look for the word \"axiom\" in concept definition comments"
msgstr""

       
# CppCoreGuidelines.md:11444
msgid "11444    ### <a name=\"Rt-refine\"></a>T.23: Differentiate a refined concept from its more general case by adding new use patterns."
msgstr""

       
# CppCoreGuidelines.md:11445
msgid "11445    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11446
msgid "11446    Otherwise they cannot be distinguished automatically by the compiler."
msgstr""

       
# CppCoreGuidelines.md:11447
msgid "11447    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11448
msgid "11448        template<typename I>"
msgstr""

# CppCoreGuidelines.md:11449
msgid "11449        concept bool Input_iter = requires(I iter) { ++iter; };"
msgstr""

       
# CppCoreGuidelines.md:11450
msgid "11450        template<typename I>"
msgstr""

# CppCoreGuidelines.md:11451
msgid "11451        concept bool Fwd_iter = Input_iter<I> && requires(I iter) { iter++; }"
msgstr""

       
# CppCoreGuidelines.md:11452
msgid "11452    The compiler can determine refinement based on the sets of required operations (here, suffix `++`)."
msgstr""

# CppCoreGuidelines.md:11453
msgid "11453    This decreases the burden on implementers of these types since"
msgstr""

# CppCoreGuidelines.md:11454
msgid "11454    they do not need any special declarations to \"hook into the concept\"."
msgstr""

# CppCoreGuidelines.md:11455
msgid "11455    If two concepts have exactly the same requirements, they are logically equivalent (there is no refinement)."
msgstr""

       
# CppCoreGuidelines.md:11456
msgid "11456    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11457
msgid "11457    * Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined)."
msgstr""

# CppCoreGuidelines.md:11458
msgid "11458    To disambiguate them, see [T.24](#Rt-tag)."
msgstr""

       
# CppCoreGuidelines.md:11459
msgid "11459    ### <a name=\"Rt-tag\"></a>T.24: Use tag classes or traits to differentiate concepts that differ only in semantics."
msgstr""

       
# CppCoreGuidelines.md:11460
msgid "11460    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11461
msgid "11461    Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them."
msgstr""

       
# CppCoreGuidelines.md:11462
msgid "11462    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11463
msgid "11463        template<typename I>    // iterator providing random access"
msgstr""

# CppCoreGuidelines.md:11464
msgid "11464        concept bool RA_iter = ...;"
msgstr""

       
# CppCoreGuidelines.md:11465
msgid "11465        template<typename I>    // iterator providing random access to contiguous data"
msgstr""

# CppCoreGuidelines.md:11466
msgid "11466        concept bool Contiguous_iter ="
msgstr""

# CppCoreGuidelines.md:11467
msgid "11467            RA_iter<I> && is_contiguous<I>::value;  // using is_contiguous trait"
msgstr""

       
# CppCoreGuidelines.md:11468
msgid "11468    The programmer (in a library) must define `is_contiguous` (a trait) appropriately."
msgstr""

       
# CppCoreGuidelines.md:11469
msgid "11469    Wrapping a tag class into a concept leads to a simpler expression of this idea:"
msgstr""

       
# CppCoreGuidelines.md:11470
msgid "11470        template<typename I> concept Contiguous = is_contiguous<I>::value;"
msgstr""

       
# CppCoreGuidelines.md:11471
msgid "11471        template<typename I>"
msgstr""

# CppCoreGuidelines.md:11472
msgid "11472        concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>;"
msgstr""

       
# CppCoreGuidelines.md:11473
msgid "11473    The programmer (in a library) must define `is_contiguous` (a trait) appropriately."
msgstr""

       
# CppCoreGuidelines.md:11474
msgid "11474    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11475
msgid "11475    Traits can be trait classes or type traits."
msgstr""

# CppCoreGuidelines.md:11476
msgid "11476    These can be user-defined or standard-library ones."
msgstr""

# CppCoreGuidelines.md:11477
msgid "11477    Prefer the standard-library ones."
msgstr""

       
# CppCoreGuidelines.md:11478
msgid "11478    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11479
msgid "11479    * The compiler flags ambiguous use of identical concepts."
msgstr""

# CppCoreGuidelines.md:11480
msgid "11480    * Flag the definition of identical concepts."
msgstr""

       
# CppCoreGuidelines.md:11481
msgid "11481    ### <a name=\"Rt-not\"></a>T.25: Avoid complementary constraints"
msgstr""

       
# CppCoreGuidelines.md:11482
msgid "11482    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11483
msgid "11483    Clarity. Maintainability."
msgstr""

# CppCoreGuidelines.md:11484
msgid "11484    Functions with complementary requirements expressed using negation are brittle."
msgstr""

       
# CppCoreGuidelines.md:11485
msgid "11485    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11486
msgid "11486    Initially, people will try to define functions with complementary requirements:"
msgstr""

       
# CppCoreGuidelines.md:11487
msgid "11487        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11488
msgid "11488            requires !C<T>    // bad"
msgstr""

# CppCoreGuidelines.md:11489
msgid "11489        void f();"
msgstr""

       
# CppCoreGuidelines.md:11490
msgid "11490        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11491
msgid "11491            requires C<T>"
msgstr""

# CppCoreGuidelines.md:11492
msgid "11492        void f();"
msgstr""

       
# CppCoreGuidelines.md:11493
msgid "11493    This is better:"
msgstr""

       
# CppCoreGuidelines.md:11494
msgid "11494        template<typename T>   // general template"
msgstr""

# CppCoreGuidelines.md:11495
msgid "11495            void f();"
msgstr""

       
# CppCoreGuidelines.md:11496
msgid "11496        template<typename T>   // specialization by concept"
msgstr""

# CppCoreGuidelines.md:11497
msgid "11497            requires C<T>"
msgstr""

# CppCoreGuidelines.md:11498
msgid "11498        void f();"
msgstr""

       
# CppCoreGuidelines.md:11499
msgid "11499    The compiler will choose the unconstrained template only when `C<T>` is"
msgstr""

# CppCoreGuidelines.md:11500
msgid "11500    unsatisfied. If you do not want to (or cannot) define an unconstrained"
msgstr""

# CppCoreGuidelines.md:11501
msgid "11501    version of `f()`, then delete it."
msgstr""

       
# CppCoreGuidelines.md:11502
msgid "11502        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11503
msgid "11503        void f() = delete;"
msgstr""

       
# CppCoreGuidelines.md:11504
msgid "11504    The compiler will select the overload and emit an appropriate error."
msgstr""

       
# CppCoreGuidelines.md:11505
msgid "11505    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11506
msgid "11506    Complementary constraints are unfortunately common in `enable_if` code:"
msgstr""

       
# CppCoreGuidelines.md:11507
msgid "11507        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11508
msgid "11508        enable_if<!C<T>, void>   // bad"
msgstr""

# CppCoreGuidelines.md:11509
msgid "11509        f();"
msgstr""

       
# CppCoreGuidelines.md:11510
msgid "11510        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11511
msgid "11511        enable_if<C<T>, void>"
msgstr""

# CppCoreGuidelines.md:11512
msgid "11512        f();"
msgstr""

       
       
# CppCoreGuidelines.md:11513
msgid "11513    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11514
msgid "11514    Complementary requirements on one requirements is sometimes (wrongly) considered manageable."
msgstr""

# CppCoreGuidelines.md:11515
msgid "11515    However, for two or more requirements the number of definitions needs can go up exponentially (2,4,9,16,...):"
msgstr""

       
# CppCoreGuidelines.md:11516
msgid "11516        C1<T> && C2<T>"
msgstr""

# CppCoreGuidelines.md:11517
msgid "11517        !C1<T> && C2<T>"
msgstr""

# CppCoreGuidelines.md:11518
msgid "11518        C1<T> && !C2<T>"
msgstr""

# CppCoreGuidelines.md:11519
msgid "11519        !C1<T> && !C2<T>"
msgstr""

       
# CppCoreGuidelines.md:11520
msgid "11520    Now the opportunities for errors multiply."
msgstr""

       
# CppCoreGuidelines.md:11521
msgid "11521    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11522
msgid "11522    * Flag pairs of functions with `C<T>` and `!C<T>` constraints"
msgstr""

       
# CppCoreGuidelines.md:11523
msgid "11523    ### <a name=\"Rt-use\"></a>T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax"
msgstr""

       
# CppCoreGuidelines.md:11524
msgid "11524    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11525
msgid "11525    The definition is more readable and corresponds directly to what a user has to write."
msgstr""

# CppCoreGuidelines.md:11526
msgid "11526    Conversions are taken into account. You don't have to remember the names of all the type traits."
msgstr""

       
# CppCoreGuidelines.md:11527
msgid "11527    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11528
msgid "11528    You might be tempted to define a concept `Equality` like this:"
msgstr""

       
# CppCoreGuidelines.md:11529
msgid "11529        template<typename T> concept Equality = has_equal<T> && has_not_equal<T>;"
msgstr""

       
# CppCoreGuidelines.md:11530
msgid "11530    Obviously, it would be better and easier just to use the standard `EqualityComparable`,"
msgstr""

# CppCoreGuidelines.md:11531
msgid "11531    but - just as an example - if you had to define such a concept, prefer:"
msgstr""

       
# CppCoreGuidelines.md:11532
msgid "11532        template<typename T> concept Equality = requires(T a, T b) {"
msgstr""

# CppCoreGuidelines.md:11533
msgid "11533            bool == { a == b }"
msgstr""

# CppCoreGuidelines.md:11534
msgid "11534            bool == { a != b }"
msgstr""

# CppCoreGuidelines.md:11535
msgid "11535            // axiom { !(a == b) == (a != b) }"
msgstr""

# CppCoreGuidelines.md:11536
msgid "11536            // axiom { a = b; => a == b }  // => means \"implies\""
msgstr""

# CppCoreGuidelines.md:11537
msgid "11537        }"
msgstr""

       
# CppCoreGuidelines.md:11538
msgid "11538    as opposed to defining two meaningless concepts `has_equal` and `has_not_equal` just as helpers in the definition of `Equality`."
msgstr""

# CppCoreGuidelines.md:11539
msgid "11539    By \"meaningless\" we mean that we cannot specify the semantics of `has_equal` in isolation."
msgstr""

       
# CppCoreGuidelines.md:11540
msgid "11540    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11541
msgid "11541    ???"
msgstr""

       
# CppCoreGuidelines.md:11542
msgid "11542    ## <a name=\"SS-temp-interface\"></a>Template interfaces"
msgstr""

       
# CppCoreGuidelines.md:11543
msgid "11543    Over the years, programming with templates have suffered from a weak distinction between the interface of a template"
msgstr""

# CppCoreGuidelines.md:11544
msgid "11544    and its implementation."
msgstr""

# CppCoreGuidelines.md:11545
msgid "11545    Before concepts, that distinction had no direct language support."
msgstr""

# CppCoreGuidelines.md:11546
msgid "11546    However, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed."
msgstr""

       
# CppCoreGuidelines.md:11547
msgid "11547    ### <a name=\"Rt-fo\"></a>T.40: Use function objects to pass operations to algorithms"
msgstr""

       
# CppCoreGuidelines.md:11548
msgid "11548    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11549
msgid "11549    Function objects can carry more information through an interface than a \"plain\" pointer to function."
msgstr""

# CppCoreGuidelines.md:11550
msgid "11550    In general, passing function objects gives better performance than passing pointers to functions."
msgstr""

       
# CppCoreGuidelines.md:11551
msgid "11551    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11552
msgid "11552        bool greater(double x, double y) { return x > y; }"
msgstr""

# CppCoreGuidelines.md:11553
msgid "11553        sort(v, greater);                                    // pointer to function: potentially slow"
msgstr""

# CppCoreGuidelines.md:11554
msgid "11554        sort(v, [](double x, double y) { return x > y; });   // function object"
msgstr""

# CppCoreGuidelines.md:11555
msgid "11555        sort(v, std::greater<>);                             // function object"
msgstr""

       
# CppCoreGuidelines.md:11556
msgid "11556        bool greater_than_7(double x) { return x > 7; }"
msgstr""

# CppCoreGuidelines.md:11557
msgid "11557        auto x = find_if(v, greater_than_7);                 // pointer to function: inflexible"
msgstr""

# CppCoreGuidelines.md:11558
msgid "11558        auto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data"
msgstr""

# CppCoreGuidelines.md:11559
msgid "11559        auto z = find_if(v, Greater_than<double>(7));        // function object: carries the needed data"
msgstr""

       
# CppCoreGuidelines.md:11560
msgid "11560    You can, of course, generalize those functions using `auto` or (when and where available) concepts. For example:"
msgstr""

       
# CppCoreGuidelines.md:11561
msgid "11561        auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // require an ordered type"
msgstr""

# CppCoreGuidelines.md:11562
msgid "11562        auto z1 = find_if(v, [](auto x) { return x > 7; });    // hope that the type has a >"
msgstr""

       
# CppCoreGuidelines.md:11563
msgid "11563    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11564
msgid "11564    Lambdas generate function objects."
msgstr""

       
# CppCoreGuidelines.md:11565
msgid "11565    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11566
msgid "11566    The performance argument depends on compiler and optimizer technology."
msgstr""

       
# CppCoreGuidelines.md:11567
msgid "11567    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11568
msgid "11568    * Flag pointer to function template arguments."
msgstr""

# CppCoreGuidelines.md:11569
msgid "11569    * Flag pointers to functions passed as arguments to a template (risk of false positives)."
msgstr""

       
       
# CppCoreGuidelines.md:11570
msgid "11570    ### <a name=\"Rt-essential\"></a>T.41: Require only essential properties in a template's concepts"
msgstr""

       
# CppCoreGuidelines.md:11571
msgid "11571    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11572
msgid "11572    Keep interfaces simple and stable."
msgstr""

       
# CppCoreGuidelines.md:11573
msgid "11573    ##### Example (using TS concepts)"
msgstr""

       
# CppCoreGuidelines.md:11574
msgid "11574    Consider, a `sort` instrumented with (oversimplified) simple debug support:"
msgstr""

       
# CppCoreGuidelines.md:11575
msgid "11575        void sort(Sortable& s)  // sort sequence s"
msgstr""

# CppCoreGuidelines.md:11576
msgid "11576        {"
msgstr""

# CppCoreGuidelines.md:11577
msgid "11577            if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";"
msgstr""

# CppCoreGuidelines.md:11578
msgid "11578            // ..."
msgstr""

# CppCoreGuidelines.md:11579
msgid "11579            if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";"
msgstr""

# CppCoreGuidelines.md:11580
msgid "11580        }"
msgstr""

       
# CppCoreGuidelines.md:11581
msgid "11581    Should this be rewritten to:"
msgstr""

       
# CppCoreGuidelines.md:11582
msgid "11582        template<Sortable S>"
msgstr""

# CppCoreGuidelines.md:11583
msgid "11583            requires Streamable<S>"
msgstr""

# CppCoreGuidelines.md:11584
msgid "11584        void sort(S& s)  // sort sequence s"
msgstr""

# CppCoreGuidelines.md:11585
msgid "11585        {"
msgstr""

# CppCoreGuidelines.md:11586
msgid "11586            if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";"
msgstr""

# CppCoreGuidelines.md:11587
msgid "11587            // ..."
msgstr""

# CppCoreGuidelines.md:11588
msgid "11588            if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";"
msgstr""

# CppCoreGuidelines.md:11589
msgid "11589        }"
msgstr""

       
# CppCoreGuidelines.md:11590
msgid "11590    After all, there is nothing in `Sortable` that requires `iostream` support."
msgstr""

# CppCoreGuidelines.md:11591
msgid "11591    On the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging."
msgstr""

       
# CppCoreGuidelines.md:11592
msgid "11592    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11593
msgid "11593    If we require every operation used to be listed among the requirements, the interface becomes unstable:"
msgstr""

# CppCoreGuidelines.md:11594
msgid "11594    Every time we change the debug facilities, the usage data gathering, testing support, error reporting, etc."
msgstr""

# CppCoreGuidelines.md:11595
msgid "11595    The definition of the template would need change and every use of the template would have to be recompiled."
msgstr""

# CppCoreGuidelines.md:11596
msgid "11596    This is cumbersome, and in some environments infeasible."
msgstr""

       
# CppCoreGuidelines.md:11597
msgid "11597    Conversely, if we use an operation in the implementation that is not guaranteed by concept checking,"
msgstr""

# CppCoreGuidelines.md:11598
msgid "11598    we may get a late compile-time error."
msgstr""

       
# CppCoreGuidelines.md:11599
msgid "11599    By not using concept checking for properties of a template argument that is not considered essential,"
msgstr""

# CppCoreGuidelines.md:11600
msgid "11600    we delay checking until instantiation time."
msgstr""

# CppCoreGuidelines.md:11601
msgid "11601    We consider this a worthwhile tradeoff."
msgstr""

       
# CppCoreGuidelines.md:11602
msgid "11602    Note that using non-local, non-dependent names (such as `debug` and `cerr`) also introduces context dependencies that may lead to \"mysterious\" errors."
msgstr""

       
# CppCoreGuidelines.md:11603
msgid "11603    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11604
msgid "11604    It can be hard to decide which properties of a type is essential and which are not."
msgstr""

       
# CppCoreGuidelines.md:11605
msgid "11605    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11606
msgid "11606    ???"
msgstr""

       
# CppCoreGuidelines.md:11607
msgid "11607    ### <a name=\"Rt-alias\"></a>T.42: Use template aliases to simplify notation and hide implementation details"
msgstr""

       
# CppCoreGuidelines.md:11608
msgid "11608    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11609
msgid "11609    Improved readability."
msgstr""

# CppCoreGuidelines.md:11610
msgid "11610    Implementation hiding."
msgstr""

# CppCoreGuidelines.md:11611
msgid "11611    Note that template aliases replace many uses of traits to compute a type."
msgstr""

# CppCoreGuidelines.md:11612
msgid "11612    They can also be used to wrap a trait."
msgstr""

       
# CppCoreGuidelines.md:11613
msgid "11613    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11614
msgid "11614        template<typename T, size_t N>"
msgstr""

# CppCoreGuidelines.md:11615
msgid "11615        class Matrix {"
msgstr""

# CppCoreGuidelines.md:11616
msgid "11616            // ..."
msgstr""

# CppCoreGuidelines.md:11617
msgid "11617            using Iterator = typename std::vector<T>::iterator;"
msgstr""

# CppCoreGuidelines.md:11618
msgid "11618            // ..."
msgstr""

# CppCoreGuidelines.md:11619
msgid "11619        };"
msgstr""

       
# CppCoreGuidelines.md:11620
msgid "11620    This saves the user of `Matrix` from having to know that its elements are stored in a `vector` and also saves the user from repeatedly typing `typename std::vector<T>::`."
msgstr""

       
# CppCoreGuidelines.md:11621
msgid "11621    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11622
msgid "11622        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11623
msgid "11623        void user(T& c)"
msgstr""

# CppCoreGuidelines.md:11624
msgid "11624        {"
msgstr""

# CppCoreGuidelines.md:11625
msgid "11625            // ..."
msgstr""

# CppCoreGuidelines.md:11626
msgid "11626            typename container_traits<T>::value_type x; // bad, verbose"
msgstr""

# CppCoreGuidelines.md:11627
msgid "11627            // ..."
msgstr""

# CppCoreGuidelines.md:11628
msgid "11628        }"
msgstr""

       
# CppCoreGuidelines.md:11629
msgid "11629        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11630
msgid "11630        using Value_type = typename container_traits<T>::value_type;"
msgstr""

       
       
# CppCoreGuidelines.md:11631
msgid "11631    This saves the user of `Value_type` from having to know the technique used to implement `value_type`s."
msgstr""

       
# CppCoreGuidelines.md:11632
msgid "11632        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11633
msgid "11633        void user2(T& c)"
msgstr""

# CppCoreGuidelines.md:11634
msgid "11634        {"
msgstr""

# CppCoreGuidelines.md:11635
msgid "11635            // ..."
msgstr""

# CppCoreGuidelines.md:11636
msgid "11636            Value_type<T> x;"
msgstr""

# CppCoreGuidelines.md:11637
msgid "11637            // ..."
msgstr""

# CppCoreGuidelines.md:11638
msgid "11638        }"
msgstr""

       
# CppCoreGuidelines.md:11639
msgid "11639    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11640
msgid "11640    A simple, common use could be expressed: \"Wrap traits!\""
msgstr""

       
# CppCoreGuidelines.md:11641
msgid "11641    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11642
msgid "11642    * Flag use of `typename` as a disambiguator outside `using` declarations."
msgstr""

# CppCoreGuidelines.md:11643
msgid "11643    * ???"
msgstr""

       
# CppCoreGuidelines.md:11644
msgid "11644    ### <a name=\"Rt-using\"></a>T.43: Prefer `using` over `typedef` for defining aliases"
msgstr""

       
# CppCoreGuidelines.md:11645
msgid "11645    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11646
msgid "11646    Improved readability: With `using`, the new name comes first rather than being embedded somewhere in a declaration."
msgstr""

# CppCoreGuidelines.md:11647
msgid "11647    Generality: `using` can be used for template aliases, whereas `typedef`s can't easily be templates."
msgstr""

# CppCoreGuidelines.md:11648
msgid "11648    Uniformity: `using` is syntactically similar to `auto`."
msgstr""

       
# CppCoreGuidelines.md:11649
msgid "11649    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11650
msgid "11650        typedef int (*PFI)(int);   // OK, but convoluted"
msgstr""

       
# CppCoreGuidelines.md:11651
msgid "11651        using PFI2 = int (*)(int);   // OK, preferred"
msgstr""

       
# CppCoreGuidelines.md:11652
msgid "11652        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11653
msgid "11653        typedef int (*PFT)(T);      // error"
msgstr""

       
# CppCoreGuidelines.md:11654
msgid "11654        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11655
msgid "11655        using PFT2 = int (*)(T);   // OK"
msgstr""

       
# CppCoreGuidelines.md:11656
msgid "11656    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11657
msgid "11657    * Flag uses of `typedef`. This will give a lot of \"hits\" :-("
msgstr""

       
# CppCoreGuidelines.md:11658
msgid "11658    ### <a name=\"Rt-deduce\"></a>T.44: Use function templates to deduce class template argument types (where feasible)"
msgstr""

       
# CppCoreGuidelines.md:11659
msgid "11659    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11660
msgid "11660    Writing the template argument types explicitly can be tedious and unnecessarily verbose."
msgstr""

       
# CppCoreGuidelines.md:11661
msgid "11661    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11662
msgid "11662        tuple<int, string, double> t1 = {1, \"Hamlet\", 3.14};   // explicit type"
msgstr""

# CppCoreGuidelines.md:11663
msgid "11663        auto t2 = make_tuple(1, \"Ophelia\"s, 3.14);         // better; deduced type"
msgstr""

       
# CppCoreGuidelines.md:11664
msgid "11664    Note the use of the `s` suffix to ensure that the string is a `std::string`, rather than a C-style string."
msgstr""

       
# CppCoreGuidelines.md:11665
msgid "11665    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11666
msgid "11666    Since you can trivially write a `make_T` function, so could the compiler. Thus, `make_T` functions may become redundant in the future."
msgstr""

       
# CppCoreGuidelines.md:11667
msgid "11667    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:11668
msgid "11668    Sometimes there isn't a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly:"
msgstr""

       
# CppCoreGuidelines.md:11669
msgid "11669        vector<double> v = { 1, 2, 3, 7.9, 15.99 };"
msgstr""

# CppCoreGuidelines.md:11670
msgid "11670        list<Record*> lst;"
msgstr""

       
# CppCoreGuidelines.md:11671
msgid "11671    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11672
msgid "11672    Note that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments:"
msgstr""

# CppCoreGuidelines.md:11673
msgid "11673    [Template parameter deduction for constructors (Rev. 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html)."
msgstr""

# CppCoreGuidelines.md:11674
msgid "11674    For example:"
msgstr""

       
# CppCoreGuidelines.md:11675
msgid "11675        tuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, string, double>"
msgstr""

       
# CppCoreGuidelines.md:11676
msgid "11676    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11677
msgid "11677    Flag uses where an explicitly specialized type exactly matches the types of the arguments used."
msgstr""

       
# CppCoreGuidelines.md:11678
msgid "11678    ### <a name=\"Rt-regular\"></a>T.46: Require template arguments to be at least `Regular` or `SemiRegular`"
msgstr""

       
# CppCoreGuidelines.md:11679
msgid "11679    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11680
msgid "11680     Readability."
msgstr""

# CppCoreGuidelines.md:11681
msgid "11681     Preventing surprises and errors."
msgstr""

# CppCoreGuidelines.md:11682
msgid "11682     Most uses support that anyway."
msgstr""

       
# CppCoreGuidelines.md:11683
msgid "11683    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11684
msgid "11684        class X {"
msgstr""

# CppCoreGuidelines.md:11685
msgid "11685                // ..."
msgstr""

# CppCoreGuidelines.md:11686
msgid "11686        public:"
msgstr""

# CppCoreGuidelines.md:11687
msgid "11687            explicit X(int);"
msgstr""

# CppCoreGuidelines.md:11688
msgid "11688            X(const X&);            // copy"
msgstr""

# CppCoreGuidelines.md:11689
msgid "11689            X operator=(const X&);"
msgstr""

# CppCoreGuidelines.md:11690
msgid "11690            X(X&&) noexcept;                 // move"
msgstr""

# CppCoreGuidelines.md:11691
msgid "11691            X& operator=(X&&) noexcept;"
msgstr""

# CppCoreGuidelines.md:11692
msgid "11692            ~X();"
msgstr""

# CppCoreGuidelines.md:11693
msgid "11693            // ... no more constructors ..."
msgstr""

# CppCoreGuidelines.md:11694
msgid "11694        };"
msgstr""

       
# CppCoreGuidelines.md:11695
msgid "11695        X x {1};    // fine"
msgstr""

# CppCoreGuidelines.md:11696
msgid "11696        X y = x;      // fine"
msgstr""

# CppCoreGuidelines.md:11697
msgid "11697        std::vector<X> v(10); // error: no default constructor"
msgstr""

       
# CppCoreGuidelines.md:11698
msgid "11698    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11699
msgid "11699    Semiregular requires default constructible."
msgstr""

       
# CppCoreGuidelines.md:11700
msgid "11700    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11701
msgid "11701    * Flag types that are not at least `SemiRegular`."
msgstr""

       
# CppCoreGuidelines.md:11702
msgid "11702    ### <a name=\"Rt-visible\"></a>T.47: Avoid highly visible unconstrained templates with common names"
msgstr""

       
# CppCoreGuidelines.md:11703
msgid "11703    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11704
msgid "11704     An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions."
msgstr""

# CppCoreGuidelines.md:11705
msgid "11705     This is particularly annoying/dangerous when ADL is used."
msgstr""

# CppCoreGuidelines.md:11706
msgid "11706     Common names make this problem more likely."
msgstr""

       
# CppCoreGuidelines.md:11707
msgid "11707    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11708
msgid "11708        namespace Bad {"
msgstr""

# CppCoreGuidelines.md:11709
msgid "11709            struct S { int m; };"
msgstr""

# CppCoreGuidelines.md:11710
msgid "11710            template<typename T1, typename T2>"
msgstr""

# CppCoreGuidelines.md:11711
msgid "11711            bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; }"
msgstr""

# CppCoreGuidelines.md:11712
msgid "11712        }"
msgstr""

       
# CppCoreGuidelines.md:11713
msgid "11713        namespace T0 {"
msgstr""

# CppCoreGuidelines.md:11714
msgid "11714            bool operator==(int, Bad::S) { cout << \"T0\\n\"; return true; }  // compare to int"
msgstr""

       
# CppCoreGuidelines.md:11715
msgid "11715            void test()"
msgstr""

# CppCoreGuidelines.md:11716
msgid "11716            {"
msgstr""

# CppCoreGuidelines.md:11717
msgid "11717                Bad::S bad{ 1 };"
msgstr""

# CppCoreGuidelines.md:11718
msgid "11718                vector<int> v(10);"
msgstr""

# CppCoreGuidelines.md:11719
msgid "11719                bool b = 1 == bad;"
msgstr""

# CppCoreGuidelines.md:11720
msgid "11720                bool b2 = v.size() == bad;"
msgstr""

# CppCoreGuidelines.md:11721
msgid "11721            }"
msgstr""

# CppCoreGuidelines.md:11722
msgid "11722        }"
msgstr""

       
# CppCoreGuidelines.md:11723
msgid "11723    This prints `T0` and `Bad`."
msgstr""

       
# CppCoreGuidelines.md:11724
msgid "11724    Now the `==` in `Bad` was designed to cause trouble, but would you have spotted the problem in real code?"
msgstr""

# CppCoreGuidelines.md:11725
msgid "11725    The problem is that `v.size()` returns an `unsigned` integer so that a conversion is needed to call the local `==`;"
msgstr""

# CppCoreGuidelines.md:11726
msgid "11726    the `==` in `Bad` requires no conversions."
msgstr""

# CppCoreGuidelines.md:11727
msgid "11727    Realistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies."
msgstr""

       
# CppCoreGuidelines.md:11728
msgid "11728    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11729
msgid "11729    If an unconstrained template is defined in the same namespace as a type,"
msgstr""

# CppCoreGuidelines.md:11730
msgid "11730    that unconstrained template can be found by ADL (as happened in the example)."
msgstr""

# CppCoreGuidelines.md:11731
msgid "11731    That is, it is highly visible."
msgstr""

       
# CppCoreGuidelines.md:11732
msgid "11732    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11733
msgid "11733    This rule should not be necessary, but the committee cannot agree to exclude unconstrained templated from ADL."
msgstr""

       
# CppCoreGuidelines.md:11734
msgid "11734    Unfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace `std`."
msgstr""

       
       
# CppCoreGuidelines.md:11735
msgid "11735    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11736
msgid "11736    Flag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts)."
msgstr""

       
       
# CppCoreGuidelines.md:11737
msgid "11737    ### <a name=\"Rt-concept-def\"></a>T.48: If your compiler does not support concepts, fake them with `enable_if`"
msgstr""

       
# CppCoreGuidelines.md:11738
msgid "11738    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11739
msgid "11739    Because that's the best we can do without direct concept support."
msgstr""

# CppCoreGuidelines.md:11740
msgid "11740    `enable_if` can be used to conditionally define functions and to select among a set of functions."
msgstr""

       
# CppCoreGuidelines.md:11741
msgid "11741    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11742
msgid "11742        enable_if<???>"
msgstr""

       
# CppCoreGuidelines.md:11743
msgid "11743    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11744
msgid "11744    Beware of [complementary constraints](# T.25)."
msgstr""

# CppCoreGuidelines.md:11745
msgid "11745    Faking concept overloading using `enable_if` sometimes forces us to use that error-prone design technique."
msgstr""

       
# CppCoreGuidelines.md:11746
msgid "11746    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11747
msgid "11747    ???"
msgstr""

       
# CppCoreGuidelines.md:11748
msgid "11748    ### <a name=\"Rt-erasure\"></a>T.49: Where possible, avoid type-erasure"
msgstr""

       
# CppCoreGuidelines.md:11749
msgid "11749    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11750
msgid "11750    Type erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary."
msgstr""

       
# CppCoreGuidelines.md:11751
msgid "11751    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11752
msgid "11752        ???"
msgstr""

       
# CppCoreGuidelines.md:11753
msgid "11753    **Exceptions**: Type erasure is sometimes appropriate, such as for `std::function`."
msgstr""

       
# CppCoreGuidelines.md:11754
msgid "11754    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11755
msgid "11755    ???"
msgstr""

       
       
# CppCoreGuidelines.md:11756
msgid "11756    ##### Note"
msgstr""

       
       
# CppCoreGuidelines.md:11757
msgid "11757    ## <a name=\"SS-temp-def\"></a>T.def: Template definitions"
msgstr""

       
# CppCoreGuidelines.md:11758
msgid "11758    A template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic."
msgstr""

# CppCoreGuidelines.md:11759
msgid "11759    However, this section focuses on what is specific to template implementation."
msgstr""

# CppCoreGuidelines.md:11760
msgid "11760    In particular, it focuses on a template definition's dependence on its context."
msgstr""

       
# CppCoreGuidelines.md:11761
msgid "11761    ### <a name=\"Rt-depend\"></a>T.60: Minimize a template's context dependencies"
msgstr""

       
# CppCoreGuidelines.md:11762
msgid "11762    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11763
msgid "11763    Eases understanding."
msgstr""

# CppCoreGuidelines.md:11764
msgid "11764    Minimizes errors from unexpected dependencies."
msgstr""

# CppCoreGuidelines.md:11765
msgid "11765    Eases tool creation."
msgstr""

       
# CppCoreGuidelines.md:11766
msgid "11766    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11767
msgid "11767        template<typename C>"
msgstr""

# CppCoreGuidelines.md:11768
msgid "11768        void sort(C& c)"
msgstr""

# CppCoreGuidelines.md:11769
msgid "11769        {"
msgstr""

# CppCoreGuidelines.md:11770
msgid "11770            std::sort(begin(c), end(c)); // necessary and useful dependency"
msgstr""

# CppCoreGuidelines.md:11771
msgid "11771        }"
msgstr""

       
# CppCoreGuidelines.md:11772
msgid "11772        template<typename Iter>"
msgstr""

# CppCoreGuidelines.md:11773
msgid "11773        Iter algo(Iter first, Iter last) {"
msgstr""

# CppCoreGuidelines.md:11774
msgid "11774            for (; first != last; ++first) {"
msgstr""

# CppCoreGuidelines.md:11775
msgid "11775                auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?"
msgstr""

# CppCoreGuidelines.md:11776
msgid "11776                helper(first, x);      // potentially surprising dependency:"
msgstr""

# CppCoreGuidelines.md:11777
msgid "11777                                       // helper is chosen based on first and x"
msgstr""

# CppCoreGuidelines.md:11778
msgid "11778                TT var = 7;            // potentially surprising dependency: which TT?"
msgstr""

# CppCoreGuidelines.md:11779
msgid "11779            }"
msgstr""

# CppCoreGuidelines.md:11780
msgid "11780        }"
msgstr""

       
# CppCoreGuidelines.md:11781
msgid "11781    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11782
msgid "11782    Templates typically appear in header files so their context dependencies are more vulnerable to `#include` order dependencies than functions in `.cpp` files."
msgstr""

       
# CppCoreGuidelines.md:11783
msgid "11783    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11784
msgid "11784    Having a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable."
msgstr""

# CppCoreGuidelines.md:11785
msgid "11785    For example, an algorithm usually uses other algorithms and invoke operations that does not exclusively operate on arguments."
msgstr""

# CppCoreGuidelines.md:11786
msgid "11786    And don't get us started on macros!"
msgstr""

       
# CppCoreGuidelines.md:11787
msgid "11787    **See also**: [T.69](#Rt-customization)"
msgstr""

       
# CppCoreGuidelines.md:11788
msgid "11788    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11789
msgid "11789    ??? Tricky"
msgstr""

       
# CppCoreGuidelines.md:11790
msgid "11790    ### <a name=\"Rt-scary\"></a>T.61: Do not over-parameterize members (SCARY)"
msgstr""

       
# CppCoreGuidelines.md:11791
msgid "11791    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11792
msgid "11792    A member that does not depend on a template parameter cannot be used except for a specific template argument."
msgstr""

# CppCoreGuidelines.md:11793
msgid "11793    This limits use and typically increases code size."
msgstr""

       
# CppCoreGuidelines.md:11794
msgid "11794    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:11795
msgid "11795        template<typename T, typename A = std::allocator{}>"
msgstr""

# CppCoreGuidelines.md:11796
msgid "11796            // requires Regular<T> && Allocator<A>"
msgstr""

# CppCoreGuidelines.md:11797
msgid "11797        class List {"
msgstr""

# CppCoreGuidelines.md:11798
msgid "11798        public:"
msgstr""

# CppCoreGuidelines.md:11799
msgid "11799            struct Link {   // does not depend on A"
msgstr""

# CppCoreGuidelines.md:11800
msgid "11800                T elem;"
msgstr""

# CppCoreGuidelines.md:11801
msgid "11801                T* pre;"
msgstr""

# CppCoreGuidelines.md:11802
msgid "11802                T* suc;"
msgstr""

# CppCoreGuidelines.md:11803
msgid "11803            };"
msgstr""

       
# CppCoreGuidelines.md:11804
msgid "11804            using iterator = Link*;"
msgstr""

       
# CppCoreGuidelines.md:11805
msgid "11805            iterator first() const { return head; }"
msgstr""

       
# CppCoreGuidelines.md:11806
msgid "11806            // ..."
msgstr""

# CppCoreGuidelines.md:11807
msgid "11807        private:"
msgstr""

# CppCoreGuidelines.md:11808
msgid "11808            Link* head;"
msgstr""

# CppCoreGuidelines.md:11809
msgid "11809        };"
msgstr""

       
# CppCoreGuidelines.md:11810
msgid "11810        List<int> lst1;"
msgstr""

# CppCoreGuidelines.md:11811
msgid "11811        List<int, My_allocator> lst2;"
msgstr""

       
# CppCoreGuidelines.md:11812
msgid "11812        ???"
msgstr""

       
# CppCoreGuidelines.md:11813
msgid "11813    This looks innocent enough, but ???"
msgstr""

       
# CppCoreGuidelines.md:11814
msgid "11814        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11815
msgid "11815        struct Link {"
msgstr""

# CppCoreGuidelines.md:11816
msgid "11816            T elem;"
msgstr""

# CppCoreGuidelines.md:11817
msgid "11817            T* pre;"
msgstr""

# CppCoreGuidelines.md:11818
msgid "11818            T* suc;"
msgstr""

# CppCoreGuidelines.md:11819
msgid "11819        };"
msgstr""

       
# CppCoreGuidelines.md:11820
msgid "11820        template<typename T, typename A = std::allocator{}>"
msgstr""

# CppCoreGuidelines.md:11821
msgid "11821            // requires Regular<T> && Allocator<A>"
msgstr""

# CppCoreGuidelines.md:11822
msgid "11822        class List2 {"
msgstr""

# CppCoreGuidelines.md:11823
msgid "11823        public:"
msgstr""

# CppCoreGuidelines.md:11824
msgid "11824            using iterator = Link<T>*;"
msgstr""

       
# CppCoreGuidelines.md:11825
msgid "11825            iterator first() const { return head; }"
msgstr""

       
# CppCoreGuidelines.md:11826
msgid "11826            // ..."
msgstr""

# CppCoreGuidelines.md:11827
msgid "11827        private:"
msgstr""

# CppCoreGuidelines.md:11828
msgid "11828            Link* head;"
msgstr""

# CppCoreGuidelines.md:11829
msgid "11829        };"
msgstr""

       
# CppCoreGuidelines.md:11830
msgid "11830        List<int> lst1;"
msgstr""

# CppCoreGuidelines.md:11831
msgid "11831        List<int, My_allocator> lst2;"
msgstr""

       
# CppCoreGuidelines.md:11832
msgid "11832        ???"
msgstr""

       
# CppCoreGuidelines.md:11833
msgid "11833    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11834
msgid "11834    * Flag member types that do not depend on every template argument"
msgstr""

# CppCoreGuidelines.md:11835
msgid "11835    * Flag member functions that do not depend on every template argument"
msgstr""

       
# CppCoreGuidelines.md:11836
msgid "11836    ### <a name=\"Rt-nondependent\"></a>T.62: Place non-dependent class template members in a non-templated base class"
msgstr""

       
# CppCoreGuidelines.md:11837
msgid "11837    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11838
msgid "11838     Allow the base class members to be used without specifying template arguments and without template instantiation."
msgstr""

       
# CppCoreGuidelines.md:11839
msgid "11839    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11840
msgid "11840        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11841
msgid "11841        class Foo {"
msgstr""

# CppCoreGuidelines.md:11842
msgid "11842        public:"
msgstr""

# CppCoreGuidelines.md:11843
msgid "11843            enum { v1, v2 };"
msgstr""

# CppCoreGuidelines.md:11844
msgid "11844            // ..."
msgstr""

# CppCoreGuidelines.md:11845
msgid "11845        };"
msgstr""

       
# CppCoreGuidelines.md:11846
msgid "11846    ???"
msgstr""

       
# CppCoreGuidelines.md:11847
msgid "11847        struct Foo_base {"
msgstr""

# CppCoreGuidelines.md:11848
msgid "11848            enum { v1, v2 };"
msgstr""

# CppCoreGuidelines.md:11849
msgid "11849            // ..."
msgstr""

# CppCoreGuidelines.md:11850
msgid "11850        };"
msgstr""

       
# CppCoreGuidelines.md:11851
msgid "11851        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11852
msgid "11852        class Foo : public Foo_base {"
msgstr""

# CppCoreGuidelines.md:11853
msgid "11853        public:"
msgstr""

# CppCoreGuidelines.md:11854
msgid "11854            // ..."
msgstr""

# CppCoreGuidelines.md:11855
msgid "11855        };"
msgstr""

       
# CppCoreGuidelines.md:11856
msgid "11856    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11857
msgid "11857    A more general version of this rule would be"
msgstr""

# CppCoreGuidelines.md:11858
msgid "11858    \"If a template class member depends on only N template parameters out of M, place it in a base class with only N parameters.\""
msgstr""

# CppCoreGuidelines.md:11859
msgid "11859    For N == 1, we have a choice of a base class of a class in the surrounding scope as in [T.61](#Rt-scary)."
msgstr""

       
# CppCoreGuidelines.md:11860
msgid "11860    ??? What about constants? class statics?"
msgstr""

       
# CppCoreGuidelines.md:11861
msgid "11861    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11862
msgid "11862    * Flag ???"
msgstr""

       
# CppCoreGuidelines.md:11863
msgid "11863    ### <a name=\"Rt-specialization\"></a>T.64: Use specialization to provide alternative implementations of class templates"
msgstr""

       
# CppCoreGuidelines.md:11864
msgid "11864    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11865
msgid "11865    A template defines a general interface."
msgstr""

# CppCoreGuidelines.md:11866
msgid "11866    Specialization offers a powerful mechanism for providing alternative implementations of that interface."
msgstr""

       
# CppCoreGuidelines.md:11867
msgid "11867    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11868
msgid "11868        ??? string specialization (==)"
msgstr""

       
# CppCoreGuidelines.md:11869
msgid "11869        ??? representation specialization ?"
msgstr""

       
# CppCoreGuidelines.md:11870
msgid "11870    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11871
msgid "11871    ???"
msgstr""

       
# CppCoreGuidelines.md:11872
msgid "11872    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11873
msgid "11873    ???"
msgstr""

       
# CppCoreGuidelines.md:11874
msgid "11874    ### <a name=\"Rt-tag-dispatch\"></a>T.65: Use tag dispatch to provide alternative implementations of a function"
msgstr""

       
# CppCoreGuidelines.md:11875
msgid "11875    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11876
msgid "11876    * A template defines a general interface."
msgstr""

# CppCoreGuidelines.md:11877
msgid "11877    * Tag dispatch allows us to select implementations based on specific properties of an argument type."
msgstr""

# CppCoreGuidelines.md:11878
msgid "11878    * Performance."
msgstr""

       
# CppCoreGuidelines.md:11879
msgid "11879    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11880
msgid "11880    This is a simplified version of `std::copy` (ignoring the possibility of non-contiguous sequences)"
msgstr""

       
# CppCoreGuidelines.md:11881
msgid "11881        struct pod_tag {};"
msgstr""

# CppCoreGuidelines.md:11882
msgid "11882        struct non_pod_tag {};"
msgstr""

       
# CppCoreGuidelines.md:11883
msgid "11883        template<class T> struct copy_trait { using tag = non_pod_tag; };   // T is not \"plain old data\""
msgstr""

       
# CppCoreGuidelines.md:11884
msgid "11884        template<> struct copy_trait<int> { using tag = pod_tag; };         // int is \"plain old data\""
msgstr""

       
# CppCoreGuidelines.md:11885
msgid "11885        template<class Iter>"
msgstr""

# CppCoreGuidelines.md:11886
msgid "11886        Out copy_helper(Iter first, Iter last, Iter out, pod_tag)"
msgstr""

# CppCoreGuidelines.md:11887
msgid "11887        {"
msgstr""

# CppCoreGuidelines.md:11888
msgid "11888            // use memmove"
msgstr""

# CppCoreGuidelines.md:11889
msgid "11889        }"
msgstr""

       
# CppCoreGuidelines.md:11890
msgid "11890        template<class Iter>"
msgstr""

# CppCoreGuidelines.md:11891
msgid "11891        Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)"
msgstr""

# CppCoreGuidelines.md:11892
msgid "11892        {"
msgstr""

# CppCoreGuidelines.md:11893
msgid "11893            // use loop calling copy constructors"
msgstr""

# CppCoreGuidelines.md:11894
msgid "11894        }"
msgstr""

       
# CppCoreGuidelines.md:11895
msgid "11895        template<class Itert>"
msgstr""

# CppCoreGuidelines.md:11896
msgid "11896        Out copy(Iter first, Iter last, Iter out)"
msgstr""

# CppCoreGuidelines.md:11897
msgid "11897        {"
msgstr""

# CppCoreGuidelines.md:11898
msgid "11898            return copy_helper(first, last, out, typename copy_trait<Iter>::tag{})"
msgstr""

# CppCoreGuidelines.md:11899
msgid "11899        }"
msgstr""

       
# CppCoreGuidelines.md:11900
msgid "11900        void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2)"
msgstr""

# CppCoreGuidelines.md:11901
msgid "11901        {"
msgstr""

# CppCoreGuidelines.md:11902
msgid "11902            copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove"
msgstr""

# CppCoreGuidelines.md:11903
msgid "11903            copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors"
msgstr""

# CppCoreGuidelines.md:11904
msgid "11904        }"
msgstr""

       
# CppCoreGuidelines.md:11905
msgid "11905    This is a general and powerful technique for compile-time algorithm selection."
msgstr""

       
# CppCoreGuidelines.md:11906
msgid "11906    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11907
msgid "11907    When `concept`s become widely available such alternatives can be distinguished directly:"
msgstr""

       
# CppCoreGuidelines.md:11908
msgid "11908        template<class Iter>"
msgstr""

# CppCoreGuidelines.md:11909
msgid "11909            requires Pod<Value_type<iter>>"
msgstr""

# CppCoreGuidelines.md:11910
msgid "11910        Out copy_helper(In, first, In last, Out out)"
msgstr""

# CppCoreGuidelines.md:11911
msgid "11911        {"
msgstr""

# CppCoreGuidelines.md:11912
msgid "11912            // use memmove"
msgstr""

# CppCoreGuidelines.md:11913
msgid "11913        }"
msgstr""

       
# CppCoreGuidelines.md:11914
msgid "11914        template<class Iter>"
msgstr""

# CppCoreGuidelines.md:11915
msgid "11915        Out copy_helper(In, first, In last, Out out)"
msgstr""

# CppCoreGuidelines.md:11916
msgid "11916        {"
msgstr""

# CppCoreGuidelines.md:11917
msgid "11917            // use loop calling copy constructors"
msgstr""

# CppCoreGuidelines.md:11918
msgid "11918        }"
msgstr""

       
# CppCoreGuidelines.md:11919
msgid "11919    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11920
msgid "11920    ???"
msgstr""

       
       
# CppCoreGuidelines.md:11921
msgid "11921    ### <a name=\"Rt-specialization2\"></a>T.67: Use specialization to provide alternative implementations for irregular types"
msgstr""

       
# CppCoreGuidelines.md:11922
msgid "11922    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11923
msgid "11923     ???"
msgstr""

       
# CppCoreGuidelines.md:11924
msgid "11924    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11925
msgid "11925        ???"
msgstr""

       
# CppCoreGuidelines.md:11926
msgid "11926    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11927
msgid "11927    ???"
msgstr""

       
# CppCoreGuidelines.md:11928
msgid "11928    ### <a name=\"Rt-cast\"></a>T.68: Use `{}` rather than `()` within templates to avoid ambiguities"
msgstr""

       
# CppCoreGuidelines.md:11929
msgid "11929    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11930
msgid "11930     `()` is vulnerable to grammar ambiguities."
msgstr""

       
# CppCoreGuidelines.md:11931
msgid "11931    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11932
msgid "11932        template<typename T, typename U>"
msgstr""

# CppCoreGuidelines.md:11933
msgid "11933        void f(T t, U u)"
msgstr""

# CppCoreGuidelines.md:11934
msgid "11934        {"
msgstr""

# CppCoreGuidelines.md:11935
msgid "11935            T v1(x);    // is v1 a function of a variable?"
msgstr""

# CppCoreGuidelines.md:11936
msgid "11936            T v2 {x};   // variable"
msgstr""

# CppCoreGuidelines.md:11937
msgid "11937            auto x = T(u);  // construction or cast?"
msgstr""

# CppCoreGuidelines.md:11938
msgid "11938        }"
msgstr""

       
# CppCoreGuidelines.md:11939
msgid "11939        f(1, \"asdf\"); // bad: cast from const char* to int"
msgstr""

       
# CppCoreGuidelines.md:11940
msgid "11940    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11941
msgid "11941    * flag `()` initializers"
msgstr""

# CppCoreGuidelines.md:11942
msgid "11942    * flag function-style casts"
msgstr""

       
       
# CppCoreGuidelines.md:11943
msgid "11943    ### <a name=\"Rt-customization\"></a>T.69: Inside a template, don't make an unqualified nonmember function call unless you intend it to be a customization point"
msgstr""

       
# CppCoreGuidelines.md:11944
msgid "11944    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11945
msgid "11945    * Provide only intended flexibility."
msgstr""

# CppCoreGuidelines.md:11946
msgid "11946    * Avoid vulnerability to accidental environmental changes."
msgstr""

       
# CppCoreGuidelines.md:11947
msgid "11947    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:11948
msgid "11948    There are three major ways to let calling code customize a template."
msgstr""

       
# CppCoreGuidelines.md:11949
msgid "11949        template<class T>"
msgstr""

# CppCoreGuidelines.md:11950
msgid "11950            // Call a member function"
msgstr""

# CppCoreGuidelines.md:11951
msgid "11951        void test1(T t)"
msgstr""

# CppCoreGuidelines.md:11952
msgid "11952        {"
msgstr""

# CppCoreGuidelines.md:11953
msgid "11953            t.f();    // require T to provide f()"
msgstr""

# CppCoreGuidelines.md:11954
msgid "11954        }"
msgstr""

       
# CppCoreGuidelines.md:11955
msgid "11955        template<class T>"
msgstr""

# CppCoreGuidelines.md:11956
msgid "11956        void test2(T t)"
msgstr""

# CppCoreGuidelines.md:11957
msgid "11957            // Call a nonmember function without qualification"
msgstr""

# CppCoreGuidelines.md:11958
msgid "11958        {"
msgstr""

# CppCoreGuidelines.md:11959
msgid "11959            f(t);  // require f(/*T*/) be available in caller's scope or in T's namespace"
msgstr""

# CppCoreGuidelines.md:11960
msgid "11960        }"
msgstr""

       
# CppCoreGuidelines.md:11961
msgid "11961        template<class T>"
msgstr""

# CppCoreGuidelines.md:11962
msgid "11962        void test3(T t)"
msgstr""

# CppCoreGuidelines.md:11963
msgid "11963            // Invoke a \"trait\""
msgstr""

# CppCoreGuidelines.md:11964
msgid "11964        {"
msgstr""

# CppCoreGuidelines.md:11965
msgid "11965            test_traits<T>::f(t); // require customizing test_traits<>"
msgstr""

# CppCoreGuidelines.md:11966
msgid "11966                                  // to get non-default functions/types"
msgstr""

# CppCoreGuidelines.md:11967
msgid "11967        }"
msgstr""

       
# CppCoreGuidelines.md:11968
msgid "11968    A trait is usually a type alias to compute a type,"
msgstr""

# CppCoreGuidelines.md:11969
msgid "11969    a `constexpr` function to compute a value,"
msgstr""

# CppCoreGuidelines.md:11970
msgid "11970    or a traditional traits template to be specialized on the user's type."
msgstr""

       
# CppCoreGuidelines.md:11971
msgid "11971    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:11972
msgid "11972    If you intend to call your own helper function `helper(t)` with a value `t` that depends on a template type parameter,"
msgstr""

# CppCoreGuidelines.md:11973
msgid "11973    put it in a `::detail` namespace and qualify the call as `detail::helper(t);`."
msgstr""

# CppCoreGuidelines.md:11974
msgid "11974    An unqualified call becomes a customization point where any function `helper` in the namespace of `t`'s type can be invoked;"
msgstr""

# CppCoreGuidelines.md:11975
msgid "11975    this can cause problems like [unintentionally invoking unconstrained function templates](#Rt-unconstrained-adl)."
msgstr""

       
       
# CppCoreGuidelines.md:11976
msgid "11976    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:11977
msgid "11977    * In a template, flag an unqualified call to a nonmember function that passes a variable of dependent type when there is a nonmember function of the same name in the template's namespace."
msgstr""

       
       
# CppCoreGuidelines.md:11978
msgid "11978    ## <a name=\"SS-temp-hier\"></a>T.temp-hier: Template and hierarchy rules:"
msgstr""

       
# CppCoreGuidelines.md:11979
msgid "11979    Templates are the backbone of C++'s support for generic programming and class hierarchies the backbone of its support"
msgstr""

# CppCoreGuidelines.md:11980
msgid "11980    for object-oriented programming."
msgstr""

# CppCoreGuidelines.md:11981
msgid "11981    The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided."
msgstr""

       
# CppCoreGuidelines.md:11982
msgid "11982    ### <a name=\"Rt-hier\"></a>T.80: Do not naively templatize a class hierarchy"
msgstr""

       
# CppCoreGuidelines.md:11983
msgid "11983    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:11984
msgid "11984    Templating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat."
msgstr""

       
# CppCoreGuidelines.md:11985
msgid "11985    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:11986
msgid "11986        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11987
msgid "11987        struct Container {         // an interface"
msgstr""

# CppCoreGuidelines.md:11988
msgid "11988            virtual T* get(int i);"
msgstr""

# CppCoreGuidelines.md:11989
msgid "11989            virtual T* first();"
msgstr""

# CppCoreGuidelines.md:11990
msgid "11990            virtual T* next();"
msgstr""

# CppCoreGuidelines.md:11991
msgid "11991            virtual void sort();"
msgstr""

# CppCoreGuidelines.md:11992
msgid "11992        };"
msgstr""

       
# CppCoreGuidelines.md:11993
msgid "11993        template<typename T>"
msgstr""

# CppCoreGuidelines.md:11994
msgid "11994        class Vector : public Container<T> {"
msgstr""

# CppCoreGuidelines.md:11995
msgid "11995        public:"
msgstr""

# CppCoreGuidelines.md:11996
msgid "11996            // ..."
msgstr""

# CppCoreGuidelines.md:11997
msgid "11997        };"
msgstr""

       
# CppCoreGuidelines.md:11998
msgid "11998        Vector<int> vi;"
msgstr""

# CppCoreGuidelines.md:11999
msgid "11999        Vector<string> vs;"
msgstr""

       
# CppCoreGuidelines.md:12000
msgid "12000    It is probably a dumb idea to define a `sort` as a member function of a container, but it is not unheard of and it makes a good example of what not to do."
msgstr""

       
# CppCoreGuidelines.md:12001
msgid "12001    Given this, the compiler cannot know if `vector<int>::sort()` is called, so it must generate code for it."
msgstr""

# CppCoreGuidelines.md:12002
msgid "12002    Similar for `vector<string>::sort()`."
msgstr""

# CppCoreGuidelines.md:12003
msgid "12003    Unless those two functions are called that's code bloat."
msgstr""

# CppCoreGuidelines.md:12004
msgid "12004    Imagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations."
msgstr""

       
# CppCoreGuidelines.md:12005
msgid "12005    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12006
msgid "12006    In many cases you can provide a stable interface by not parameterizing a base;"
msgstr""

# CppCoreGuidelines.md:12007
msgid "12007    see [\"stable base\"](#Rt-abi) and [OO and GP](#Rt-generic-oo)"
msgstr""

       
# CppCoreGuidelines.md:12008
msgid "12008    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12009
msgid "12009    * Flag virtual functions that depend on a template argument. ??? False positives"
msgstr""

       
# CppCoreGuidelines.md:12010
msgid "12010    ### <a name=\"Rt-array\"></a>T.81: Do not mix hierarchies and arrays"
msgstr""

       
# CppCoreGuidelines.md:12011
msgid "12011    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12012
msgid "12012    An array of derived classes can implicitly \"decay\" to a pointer to a base class with potential disastrous results."
msgstr""

       
# CppCoreGuidelines.md:12013
msgid "12013    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12014
msgid "12014    Assume that `Apple` and `Pear` are two kinds of `Fruit`s."
msgstr""

       
# CppCoreGuidelines.md:12015
msgid "12015        void maul(Fruit* p)"
msgstr""

# CppCoreGuidelines.md:12016
msgid "12016        {"
msgstr""

# CppCoreGuidelines.md:12017
msgid "12017            *p = Pear{};     // put a Pear into *p"
msgstr""

# CppCoreGuidelines.md:12018
msgid "12018            p[1] = Pear{};   // put a Pear into p[1]"
msgstr""

# CppCoreGuidelines.md:12019
msgid "12019        }"
msgstr""

       
# CppCoreGuidelines.md:12020
msgid "12020        Apple aa [] = { an_apple, another_apple };   // aa contains Apples (obviously!)"
msgstr""

       
# CppCoreGuidelines.md:12021
msgid "12021        maul(aa);"
msgstr""

# CppCoreGuidelines.md:12022
msgid "12022        Apple& a0 = &aa[0];   // a Pear?"
msgstr""

# CppCoreGuidelines.md:12023
msgid "12023        Apple& a1 = &aa[1];   // a Pear?"
msgstr""

       
# CppCoreGuidelines.md:12024
msgid "12024    Probably, `aa[0]` will be a `Pear` (without the use of a cast!)."
msgstr""

# CppCoreGuidelines.md:12025
msgid "12025    If `sizeof(Apple) != sizeof(Pear)` the access to `aa[1]` will not be aligned to the proper start of an object in the array."
msgstr""

# CppCoreGuidelines.md:12026
msgid "12026    We have a type violation and possibly (probably) a memory corruption."
msgstr""

# CppCoreGuidelines.md:12027
msgid "12027    Never write such code."
msgstr""

       
# CppCoreGuidelines.md:12028
msgid "12028    Note that `maul()` violates the a [`T*` points to an individual object rule](#Rf-ptr)."
msgstr""

       
# CppCoreGuidelines.md:12029
msgid "12029    **Alternative**: Use a proper (templatized) container:"
msgstr""

       
# CppCoreGuidelines.md:12030
msgid "12030        void maul2(Fruit* p)"
msgstr""

# CppCoreGuidelines.md:12031
msgid "12031        {"
msgstr""

# CppCoreGuidelines.md:12032
msgid "12032            *p = Pear{};   // put a Pear into *p"
msgstr""

# CppCoreGuidelines.md:12033
msgid "12033        }"
msgstr""

       
# CppCoreGuidelines.md:12034
msgid "12034        vector<Apple> va = { an_apple, another_apple };   // va contains Apples (obviously!)"
msgstr""

       
# CppCoreGuidelines.md:12035
msgid "12035        maul2(va);       // error: cannot convert a vector<Apple> to a Fruit*"
msgstr""

# CppCoreGuidelines.md:12036
msgid "12036        maul2(&va[0]);   // you asked for it"
msgstr""

       
# CppCoreGuidelines.md:12037
msgid "12037        Apple& a0 = &va[0];   // a Pear?"
msgstr""

       
# CppCoreGuidelines.md:12038
msgid "12038    Note that the assignment in `maul2()` violated the [no-slicing rule](#Res-slice)."
msgstr""

       
# CppCoreGuidelines.md:12039
msgid "12039    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12040
msgid "12040    * Detect this horror!"
msgstr""

       
# CppCoreGuidelines.md:12041
msgid "12041    ### <a name=\"Rt-linear\"></a>T.82: Linearize a hierarchy when virtual functions are undesirable"
msgstr""

       
# CppCoreGuidelines.md:12042
msgid "12042    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12043
msgid "12043     ???"
msgstr""

       
# CppCoreGuidelines.md:12044
msgid "12044    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12045
msgid "12045        ???"
msgstr""

       
# CppCoreGuidelines.md:12046
msgid "12046    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12047
msgid "12047    ???"
msgstr""

       
# CppCoreGuidelines.md:12048
msgid "12048    ### <a name=\"Rt-virtual\"></a>T.83: Do not declare a member function template virtual"
msgstr""

       
# CppCoreGuidelines.md:12049
msgid "12049    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12050
msgid "12050    C++ does not support that."
msgstr""

# CppCoreGuidelines.md:12051
msgid "12051    If it did, vtbls could not be generated until link time."
msgstr""

# CppCoreGuidelines.md:12052
msgid "12052    And in general, implementations must deal with dynamic linking."
msgstr""

       
# CppCoreGuidelines.md:12053
msgid "12053    ##### Example, don't"
msgstr""

       
# CppCoreGuidelines.md:12054
msgid "12054        class Shape {"
msgstr""

# CppCoreGuidelines.md:12055
msgid "12055            // ..."
msgstr""

# CppCoreGuidelines.md:12056
msgid "12056            template<class T>"
msgstr""

# CppCoreGuidelines.md:12057
msgid "12057            virtual bool intersect(T* p);   // error: template cannot be virtual"
msgstr""

# CppCoreGuidelines.md:12058
msgid "12058        };"
msgstr""

       
# CppCoreGuidelines.md:12059
msgid "12059    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12060
msgid "12060    We need a rule because people keep asking about this"
msgstr""

       
# CppCoreGuidelines.md:12061
msgid "12061    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:12062
msgid "12062    Double dispatch, visitors, calculate which function to call"
msgstr""

       
# CppCoreGuidelines.md:12063
msgid "12063    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12064
msgid "12064    The compiler handles that."
msgstr""

       
# CppCoreGuidelines.md:12065
msgid "12065    ### <a name=\"Rt-abi\"></a>T.84: Use a non-template core implementation to provide an ABI-stable interface"
msgstr""

       
# CppCoreGuidelines.md:12066
msgid "12066    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12067
msgid "12067    Improve stability of code."
msgstr""

# CppCoreGuidelines.md:12068
msgid "12068    Avoid code bloat."
msgstr""

       
# CppCoreGuidelines.md:12069
msgid "12069    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12070
msgid "12070    It could be a base class:"
msgstr""

       
# CppCoreGuidelines.md:12071
msgid "12071        struct Link_base {   // stable"
msgstr""

# CppCoreGuidelines.md:12072
msgid "12072            Link_base* suc;"
msgstr""

# CppCoreGuidelines.md:12073
msgid "12073            Link_base* pre;"
msgstr""

# CppCoreGuidelines.md:12074
msgid "12074        };"
msgstr""

       
# CppCoreGuidelines.md:12075
msgid "12075        template<typename T>   // templated wrapper to add type safety"
msgstr""

# CppCoreGuidelines.md:12076
msgid "12076        struct Link : Link_base {"
msgstr""

# CppCoreGuidelines.md:12077
msgid "12077            T val;"
msgstr""

# CppCoreGuidelines.md:12078
msgid "12078        };"
msgstr""

       
# CppCoreGuidelines.md:12079
msgid "12079        struct List_base {"
msgstr""

# CppCoreGuidelines.md:12080
msgid "12080            Link_base* first;   // first element (if any)"
msgstr""

# CppCoreGuidelines.md:12081
msgid "12081            int sz;             // number of elements"
msgstr""

# CppCoreGuidelines.md:12082
msgid "12082            void add_front(Link_base* p);"
msgstr""

# CppCoreGuidelines.md:12083
msgid "12083            // ..."
msgstr""

# CppCoreGuidelines.md:12084
msgid "12084        };"
msgstr""

       
# CppCoreGuidelines.md:12085
msgid "12085        template<typename T>"
msgstr""

# CppCoreGuidelines.md:12086
msgid "12086        class List : List_base {"
msgstr""

# CppCoreGuidelines.md:12087
msgid "12087        public:"
msgstr""

# CppCoreGuidelines.md:12088
msgid "12088            void put_front(const T& e) { add_front(new Link<T>{e}); }   // implicit cast to Link_base"
msgstr""

# CppCoreGuidelines.md:12089
msgid "12089            T& front() { static_cast<Link<T>*>(first).val; }   // explicit cast back to Link<T>"
msgstr""

# CppCoreGuidelines.md:12090
msgid "12090            // ..."
msgstr""

# CppCoreGuidelines.md:12091
msgid "12091        };"
msgstr""

       
# CppCoreGuidelines.md:12092
msgid "12092        List<int> li;"
msgstr""

# CppCoreGuidelines.md:12093
msgid "12093        List<string> ls;"
msgstr""

       
# CppCoreGuidelines.md:12094
msgid "12094    Now there is only one copy of the operations linking and unlinking elements of a `List`."
msgstr""

# CppCoreGuidelines.md:12095
msgid "12095    The `Link` and `List` classes do nothing but type manipulation."
msgstr""

       
# CppCoreGuidelines.md:12096
msgid "12096    Instead of using a separate \"base\" type, another common technique is to specialize for `void` or `void*` and have the general template for `T` be just the safely-encapsulated casts to and from the core `void` implementation."
msgstr""

       
# CppCoreGuidelines.md:12097
msgid "12097    **Alternative**: Use a [Pimpl](#Ri-pimpl) implementation."
msgstr""

       
# CppCoreGuidelines.md:12098
msgid "12098    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12099
msgid "12099    ???"
msgstr""

       
# CppCoreGuidelines.md:12100
msgid "12100    ## <a name=\"SS-variadic\"></a>T.var: Variadic template rules"
msgstr""

       
# CppCoreGuidelines.md:12101
msgid "12101    ???"
msgstr""

       
# CppCoreGuidelines.md:12102
msgid "12102    ### <a name=\"Rt-variadic\"></a>T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types"
msgstr""

       
# CppCoreGuidelines.md:12103
msgid "12103    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12104
msgid "12104    Variadic templates is the most general mechanism for that, and is both efficient and type-safe. Don't use C varargs."
msgstr""

       
# CppCoreGuidelines.md:12105
msgid "12105    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12106
msgid "12106        ??? printf"
msgstr""

       
# CppCoreGuidelines.md:12107
msgid "12107    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12108
msgid "12108    * Flag uses of `va_arg` in user code."
msgstr""

       
# CppCoreGuidelines.md:12109
msgid "12109    ### <a name=\"Rt-variadic-pass\"></a>T.101: ??? How to pass arguments to a variadic template ???"
msgstr""

       
# CppCoreGuidelines.md:12110
msgid "12110    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12111
msgid "12111     ???"
msgstr""

       
# CppCoreGuidelines.md:12112
msgid "12112    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12113
msgid "12113        ??? beware of move-only and reference arguments"
msgstr""

       
# CppCoreGuidelines.md:12114
msgid "12114    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12115
msgid "12115    ???"
msgstr""

       
# CppCoreGuidelines.md:12116
msgid "12116    ### <a name=\"Rt-variadic-process\"></a>T.102: How to process arguments to a variadic template"
msgstr""

       
# CppCoreGuidelines.md:12117
msgid "12117    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12118
msgid "12118     ???"
msgstr""

       
# CppCoreGuidelines.md:12119
msgid "12119    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12120
msgid "12120        ??? forwarding, type checking, references"
msgstr""

       
# CppCoreGuidelines.md:12121
msgid "12121    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12122
msgid "12122    ???"
msgstr""

       
# CppCoreGuidelines.md:12123
msgid "12123    ### <a name=\"Rt-variadic-not\"></a>T.103: Don't use variadic templates for homogeneous argument lists"
msgstr""

       
# CppCoreGuidelines.md:12124
msgid "12124    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12125
msgid "12125    There are more precise ways of specifying a homogeneous sequence, such as an `initializer_list`."
msgstr""

       
# CppCoreGuidelines.md:12126
msgid "12126    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12127
msgid "12127        ???"
msgstr""

       
# CppCoreGuidelines.md:12128
msgid "12128    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12129
msgid "12129    ???"
msgstr""

       
# CppCoreGuidelines.md:12130
msgid "12130    ## <a name=\"SS-meta\"></a>T.meta: Template metaprogramming (TMP)"
msgstr""

       
# CppCoreGuidelines.md:12131
msgid "12131    Templates provide a general mechanism for compile-time programming."
msgstr""

       
# CppCoreGuidelines.md:12132
msgid "12132    Metaprogramming is programming where at least one input or one result is a type."
msgstr""

# CppCoreGuidelines.md:12133
msgid "12133    Templates offer Turing-complete (modulo memory capacity) duck typing at compile time."
msgstr""

# CppCoreGuidelines.md:12134
msgid "12134    The syntax and techniques needed are pretty horrendous."
msgstr""

       
# CppCoreGuidelines.md:12135
msgid "12135    ### <a name=\"Rt-metameta\"></a>T.120: Use template metaprogramming only when you really need to"
msgstr""

       
# CppCoreGuidelines.md:12136
msgid "12136    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12137
msgid "12137    Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain."
msgstr""

# CppCoreGuidelines.md:12138
msgid "12138    However, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code."
msgstr""

# CppCoreGuidelines.md:12139
msgid "12139    Also, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code."
msgstr""

# CppCoreGuidelines.md:12140
msgid "12140    For example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there may be no other way in C++."
msgstr""

       
# CppCoreGuidelines.md:12141
msgid "12141    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12142
msgid "12142        ???"
msgstr""

       
# CppCoreGuidelines.md:12143
msgid "12143    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12144
msgid "12144        enable_if"
msgstr""

       
# CppCoreGuidelines.md:12145
msgid "12145    Instead, use concepts. But see [How to emulate concepts if you don't have language support](#Rt-emulate)."
msgstr""

       
# CppCoreGuidelines.md:12146
msgid "12146    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12147
msgid "12147        ??? good"
msgstr""

       
# CppCoreGuidelines.md:12148
msgid "12148    **Alternative**: If the result is a value, rather than a type, use a [`constexpr` function](#Rt-fct)."
msgstr""

       
# CppCoreGuidelines.md:12149
msgid "12149    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12150
msgid "12150    If you feel the need to hide your template metaprogramming in macros, you have probably gone too far."
msgstr""

       
# CppCoreGuidelines.md:12151
msgid "12151    ### <a name=\"Rt-emulate\"></a>T.121: Use template metaprogramming primarily to emulate concepts"
msgstr""

       
# CppCoreGuidelines.md:12152
msgid "12152    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12153
msgid "12153    Until concepts become generally available, we need to emulate them using TMP."
msgstr""

# CppCoreGuidelines.md:12154
msgid "12154    Use cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP."
msgstr""

       
# CppCoreGuidelines.md:12155
msgid "12155    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12156
msgid "12156        template<typename Iter>"
msgstr""

# CppCoreGuidelines.md:12157
msgid "12157            /*requires*/ enable_if<random_access_iterator<Iter>, void>"
msgstr""

# CppCoreGuidelines.md:12158
msgid "12158        advance(Iter p, int n) { p += n; }"
msgstr""

       
# CppCoreGuidelines.md:12159
msgid "12159        template<typename Iter>"
msgstr""

# CppCoreGuidelines.md:12160
msgid "12160            /*requires*/ enable_if<forward_iterator<Iter>, void>"
msgstr""

# CppCoreGuidelines.md:12161
msgid "12161        advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;}"
msgstr""

       
# CppCoreGuidelines.md:12162
msgid "12162    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12163
msgid "12163    Such code is much simpler using concepts:"
msgstr""

       
# CppCoreGuidelines.md:12164
msgid "12164        void advance(RandomAccessIterator p, int n) { p += n; }"
msgstr""

       
# CppCoreGuidelines.md:12165
msgid "12165        void advance(ForwardIterator p, int n) { assert(n >= 0); while (n--) ++p;}"
msgstr""

       
# CppCoreGuidelines.md:12166
msgid "12166    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12167
msgid "12167    ???"
msgstr""

       
# CppCoreGuidelines.md:12168
msgid "12168    ### <a name=\"Rt-tmp\"></a>T.122: Use templates (usually template aliases) to compute types at compile time"
msgstr""

       
# CppCoreGuidelines.md:12169
msgid "12169    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12170
msgid "12170    Template metaprogramming is the only directly supported and half-way principled way of generating types at compile time."
msgstr""

       
# CppCoreGuidelines.md:12171
msgid "12171    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12172
msgid "12172    \"Traits\" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values."
msgstr""

       
# CppCoreGuidelines.md:12173
msgid "12173    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12174
msgid "12174        ??? big object / small object optimization"
msgstr""

       
# CppCoreGuidelines.md:12175
msgid "12175    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12176
msgid "12176    ???"
msgstr""

       
# CppCoreGuidelines.md:12177
msgid "12177    ### <a name=\"Rt-fct\"></a>T.123: Use `constexpr` functions to compute values at compile time"
msgstr""

       
# CppCoreGuidelines.md:12178
msgid "12178    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12179
msgid "12179    A function is the most obvious and conventional way of expressing the computation of a value."
msgstr""

# CppCoreGuidelines.md:12180
msgid "12180    Often a `constexpr` function implies less compile-time overhead than alternatives."
msgstr""

       
# CppCoreGuidelines.md:12181
msgid "12181    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12182
msgid "12182    \"Traits\" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values."
msgstr""

       
# CppCoreGuidelines.md:12183
msgid "12183    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12184
msgid "12184        template<typename T>"
msgstr""

# CppCoreGuidelines.md:12185
msgid "12185            // requires Number<T>"
msgstr""

# CppCoreGuidelines.md:12186
msgid "12186        constexpr T pow(T v, int n)   // power/exponential"
msgstr""

# CppCoreGuidelines.md:12187
msgid "12187        {"
msgstr""

# CppCoreGuidelines.md:12188
msgid "12188            T res = 1;"
msgstr""

# CppCoreGuidelines.md:12189
msgid "12189            while (n--) res *= v;"
msgstr""

# CppCoreGuidelines.md:12190
msgid "12190            return res;"
msgstr""

# CppCoreGuidelines.md:12191
msgid "12191        }"
msgstr""

       
# CppCoreGuidelines.md:12192
msgid "12192        constexpr auto f7 = pow(pi, 7);"
msgstr""

       
# CppCoreGuidelines.md:12193
msgid "12193    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12194
msgid "12194    * Flag template metaprograms yielding a value. These should be replaced with `constexpr` functions."
msgstr""

       
# CppCoreGuidelines.md:12195
msgid "12195    ### <a name=\"Rt-std-tmp\"></a>T.124: Prefer to use standard-library TMP facilities"
msgstr""

       
# CppCoreGuidelines.md:12196
msgid "12196    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12197
msgid "12197    Facilities defined in the standard, such as `conditional`, `enable_if`, and `tuple`, are portable and can be assumed to be known."
msgstr""

       
# CppCoreGuidelines.md:12198
msgid "12198    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12199
msgid "12199        ???"
msgstr""

       
# CppCoreGuidelines.md:12200
msgid "12200    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12201
msgid "12201    ???"
msgstr""

       
# CppCoreGuidelines.md:12202
msgid "12202    ### <a name=\"Rt-lib\"></a>T.125: If you need to go beyond the standard-library TMP facilities, use an existing library"
msgstr""

       
# CppCoreGuidelines.md:12203
msgid "12203    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12204
msgid "12204    Getting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community."
msgstr""

# CppCoreGuidelines.md:12205
msgid "12205    Write your own \"advanced TMP support\" only if you really have to."
msgstr""

       
# CppCoreGuidelines.md:12206
msgid "12206    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12207
msgid "12207        ???"
msgstr""

       
# CppCoreGuidelines.md:12208
msgid "12208    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12209
msgid "12209    ???"
msgstr""

       
# CppCoreGuidelines.md:12210
msgid "12210    ## <a name=\"SS-temp-other\"></a>Other template rules"
msgstr""

       
# CppCoreGuidelines.md:12211
msgid "12211    ### <a name=\"Rt-name\"></a>T.140: Name all operations with potential for reuse"
msgstr""

       
# CppCoreGuidelines.md:12212
msgid "12212    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12213
msgid "12213    Documentation, readability, opportunity for reuse."
msgstr""

       
# CppCoreGuidelines.md:12214
msgid "12214    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12215
msgid "12215        struct Rec {"
msgstr""

# CppCoreGuidelines.md:12216
msgid "12216            string name;"
msgstr""

# CppCoreGuidelines.md:12217
msgid "12217            string addr;"
msgstr""

# CppCoreGuidelines.md:12218
msgid "12218            int id;         // unique identifier"
msgstr""

# CppCoreGuidelines.md:12219
msgid "12219        };"
msgstr""

       
# CppCoreGuidelines.md:12220
msgid "12220        bool same(const Rec& a, const Rec& b)"
msgstr""

# CppCoreGuidelines.md:12221
msgid "12221        {"
msgstr""

# CppCoreGuidelines.md:12222
msgid "12222            return a.id == b.id;"
msgstr""

# CppCoreGuidelines.md:12223
msgid "12223        }"
msgstr""

       
# CppCoreGuidelines.md:12224
msgid "12224        vector<Rec*> find_id(const string& name);    // find all records for \"name\""
msgstr""

       
# CppCoreGuidelines.md:12225
msgid "12225        auto x = find_if(vr.begin(), vr.end(),"
msgstr""

# CppCoreGuidelines.md:12226
msgid "12226            [&](Rec& r) {"
msgstr""

# CppCoreGuidelines.md:12227
msgid "12227                if (r.name.size() != n.size()) return false; // name to compare to is in n"
msgstr""

# CppCoreGuidelines.md:12228
msgid "12228                for (int i = 0; i < r.name.size(); ++i)"
msgstr""

# CppCoreGuidelines.md:12229
msgid "12229                    if (tolower(r.name[i]) != tolower(n[i])) return false;"
msgstr""

# CppCoreGuidelines.md:12230
msgid "12230                return true;"
msgstr""

# CppCoreGuidelines.md:12231
msgid "12231            }"
msgstr""

# CppCoreGuidelines.md:12232
msgid "12232        );"
msgstr""

       
# CppCoreGuidelines.md:12233
msgid "12233    There is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large."
msgstr""

       
# CppCoreGuidelines.md:12234
msgid "12234        bool compare_insensitive(const string& a, const string& b)"
msgstr""

# CppCoreGuidelines.md:12235
msgid "12235        {"
msgstr""

# CppCoreGuidelines.md:12236
msgid "12236            if (a.size() != b.size()) return false;"
msgstr""

# CppCoreGuidelines.md:12237
msgid "12237            for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;"
msgstr""

# CppCoreGuidelines.md:12238
msgid "12238            return true;"
msgstr""

# CppCoreGuidelines.md:12239
msgid "12239        }"
msgstr""

       
# CppCoreGuidelines.md:12240
msgid "12240        auto x = find_if(vr.begin(), vr.end(),"
msgstr""

# CppCoreGuidelines.md:12241
msgid "12241            [&](Rec& r) { compare_insensitive(r.name, n); }"
msgstr""

# CppCoreGuidelines.md:12242
msgid "12242        );"
msgstr""

       
# CppCoreGuidelines.md:12243
msgid "12243    Or maybe (if you prefer to avoid the implicit name binding to n):"
msgstr""

       
# CppCoreGuidelines.md:12244
msgid "12244        auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); };"
msgstr""

       
# CppCoreGuidelines.md:12245
msgid "12245        auto x = find_if(vr.begin(), vr.end(),"
msgstr""

# CppCoreGuidelines.md:12246
msgid "12246            [](const Rec& r) { return cmp_to_n(r.name); }"
msgstr""

# CppCoreGuidelines.md:12247
msgid "12247        );"
msgstr""

       
# CppCoreGuidelines.md:12248
msgid "12248    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12249
msgid "12249    whether functions, lambdas, or operators."
msgstr""

       
# CppCoreGuidelines.md:12250
msgid "12250    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:12251
msgid "12251    * Lambdas logically used only locally, such as an argument to `for_each` and similar control flow algorithms."
msgstr""

# CppCoreGuidelines.md:12252
msgid "12252    * Lambdas as [initializers](#???)"
msgstr""

       
# CppCoreGuidelines.md:12253
msgid "12253    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12254
msgid "12254    * (hard) flag similar lambdas"
msgstr""

# CppCoreGuidelines.md:12255
msgid "12255    * ???"
msgstr""

       
# CppCoreGuidelines.md:12256
msgid "12256    ### <a name=\"Rt-lambda\"></a>T.141: Use an unnamed lambda if you need a simple function object in one place only"
msgstr""

       
# CppCoreGuidelines.md:12257
msgid "12257    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12258
msgid "12258    That makes the code concise and gives better locality than alternatives."
msgstr""

       
# CppCoreGuidelines.md:12259
msgid "12259    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12260
msgid "12260        auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),"
msgstr""

# CppCoreGuidelines.md:12261
msgid "12261                                            [](const User &a) { return a.id > 100; });"
msgstr""

       
       
# CppCoreGuidelines.md:12262
msgid "12262    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:12263
msgid "12263    Naming a lambda can be useful for clarity even if it is used only once."
msgstr""

       
# CppCoreGuidelines.md:12264
msgid "12264    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12265
msgid "12265    * Look for identical and near identical lambdas (to be replaced with named functions or named lambdas)."
msgstr""

       
# CppCoreGuidelines.md:12266
msgid "12266    ### <a name=\"Rt-var\"></a>T.142?: Use template variables to simplify notation"
msgstr""

       
# CppCoreGuidelines.md:12267
msgid "12267    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12268
msgid "12268    Improved readability."
msgstr""

       
# CppCoreGuidelines.md:12269
msgid "12269    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12270
msgid "12270        ???"
msgstr""

       
# CppCoreGuidelines.md:12271
msgid "12271    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12272
msgid "12272    ???"
msgstr""

       
# CppCoreGuidelines.md:12273
msgid "12273    ### <a name=\"Rt-nongeneric\"></a>T.143: Don't write unintentionally nongeneric code"
msgstr""

       
# CppCoreGuidelines.md:12274
msgid "12274    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12275
msgid "12275    Generality. Reusability. Don't gratuitously commit to details; use the most general facilities available."
msgstr""

       
# CppCoreGuidelines.md:12276
msgid "12276    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12277
msgid "12277    Use `!=` instead of `<` to compare iterators; `!=` works for more objects because it doesn't rely on ordering."
msgstr""

       
# CppCoreGuidelines.md:12278
msgid "12278        for (auto i = first; i < last; ++i) {   // less generic"
msgstr""

# CppCoreGuidelines.md:12279
msgid "12279            // ..."
msgstr""

# CppCoreGuidelines.md:12280
msgid "12280        }"
msgstr""

       
# CppCoreGuidelines.md:12281
msgid "12281        for (auto i = first; i != last; ++i) {   // good; more generic"
msgstr""

# CppCoreGuidelines.md:12282
msgid "12282            // ..."
msgstr""

# CppCoreGuidelines.md:12283
msgid "12283        }"
msgstr""

       
# CppCoreGuidelines.md:12284
msgid "12284    Of course, range-`for` is better still where it does what you want."
msgstr""

       
# CppCoreGuidelines.md:12285
msgid "12285    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12286
msgid "12286    Use the least-derived class that has the functionality you need."
msgstr""

       
# CppCoreGuidelines.md:12287
msgid "12287        class Base {"
msgstr""

# CppCoreGuidelines.md:12288
msgid "12288        public:"
msgstr""

# CppCoreGuidelines.md:12289
msgid "12289            Bar f();"
msgstr""

# CppCoreGuidelines.md:12290
msgid "12290            Bar g();"
msgstr""

# CppCoreGuidelines.md:12291
msgid "12291        };"
msgstr""

       
# CppCoreGuidelines.md:12292
msgid "12292        class Derived1 : public Base {"
msgstr""

# CppCoreGuidelines.md:12293
msgid "12293        public:"
msgstr""

# CppCoreGuidelines.md:12294
msgid "12294            Bar h();"
msgstr""

# CppCoreGuidelines.md:12295
msgid "12295        };"
msgstr""

       
# CppCoreGuidelines.md:12296
msgid "12296        class Derived2 : public Base {"
msgstr""

# CppCoreGuidelines.md:12297
msgid "12297        public:"
msgstr""

# CppCoreGuidelines.md:12298
msgid "12298            Bar j();"
msgstr""

# CppCoreGuidelines.md:12299
msgid "12299        };"
msgstr""

       
# CppCoreGuidelines.md:12300
msgid "12300        // bad, unless there is a specific reason for limiting to Derived1 objects only"
msgstr""

# CppCoreGuidelines.md:12301
msgid "12301        void my_func(Derived1& param)"
msgstr""

# CppCoreGuidelines.md:12302
msgid "12302        {"
msgstr""

# CppCoreGuidelines.md:12303
msgid "12303            use(param.f());"
msgstr""

# CppCoreGuidelines.md:12304
msgid "12304            use(param.g());"
msgstr""

# CppCoreGuidelines.md:12305
msgid "12305        }"
msgstr""

       
# CppCoreGuidelines.md:12306
msgid "12306        // good, uses only Base interface so only commit to that"
msgstr""

# CppCoreGuidelines.md:12307
msgid "12307        void my_func(Base& param)"
msgstr""

# CppCoreGuidelines.md:12308
msgid "12308        {"
msgstr""

# CppCoreGuidelines.md:12309
msgid "12309            use(param.f());"
msgstr""

# CppCoreGuidelines.md:12310
msgid "12310            use(param.g());"
msgstr""

# CppCoreGuidelines.md:12311
msgid "12311        }"
msgstr""

       
# CppCoreGuidelines.md:12312
msgid "12312    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12313
msgid "12313    * Flag comparison of iterators using `<` instead of `!=`."
msgstr""

# CppCoreGuidelines.md:12314
msgid "12314    * Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is available. Emptiness works for more containers than size(), because some containers don't know their size or are conceptually of unbounded size."
msgstr""

# CppCoreGuidelines.md:12315
msgid "12315    * Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type."
msgstr""

       
# CppCoreGuidelines.md:12316
msgid "12316    ### <a name=\"Rt-specialize-function\"></a>T.144: Don't specialize function templates"
msgstr""

       
# CppCoreGuidelines.md:12317
msgid "12317    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12318
msgid "12318    You can't partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead -- because function template specializations don't participate in overloading, they don't act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly."
msgstr""

       
# CppCoreGuidelines.md:12319
msgid "12319    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12320
msgid "12320        ???"
msgstr""

       
# CppCoreGuidelines.md:12321
msgid "12321    **Exceptions**: If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations)."
msgstr""

       
# CppCoreGuidelines.md:12322
msgid "12322    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12323
msgid "12323    * Flag all specializations of a function template. Overload instead."
msgstr""

       
       
# CppCoreGuidelines.md:12324
msgid "12324    ### <a name=\"Rt-check-class\"></a>T.150: Check that a class matches a concept using `static_assert`"
msgstr""

       
# CppCoreGuidelines.md:12325
msgid "12325    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12326
msgid "12326    If you intend for a class to match a concept, verifying that early saves users pain."
msgstr""

       
# CppCoreGuidelines.md:12327
msgid "12327    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12328
msgid "12328        class X {"
msgstr""

# CppCoreGuidelines.md:12329
msgid "12329        public:"
msgstr""

# CppCoreGuidelines.md:12330
msgid "12330            X() = delete;"
msgstr""

# CppCoreGuidelines.md:12331
msgid "12331            X(const X&) = default;"
msgstr""

# CppCoreGuidelines.md:12332
msgid "12332            X(X&&) = default;"
msgstr""

# CppCoreGuidelines.md:12333
msgid "12333            X& operator=(const X&) = default;"
msgstr""

# CppCoreGuidelines.md:12334
msgid "12334            // ..."
msgstr""

# CppCoreGuidelines.md:12335
msgid "12335        };"
msgstr""

       
# CppCoreGuidelines.md:12336
msgid "12336    Somewhere, possibly in an implementation file, let the compiler check the desired properties of `X`:"
msgstr""

       
# CppCoreGuidelines.md:12337
msgid "12337        static_assert(Default_constructible<X>);    // error: X has no default constructor"
msgstr""

# CppCoreGuidelines.md:12338
msgid "12338        static_assert(Copyable<X>);                 // error: we forgot to define X's move constructor"
msgstr""

       
       
# CppCoreGuidelines.md:12339
msgid "12339    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12340
msgid "12340    Not feasible."
msgstr""

       
# CppCoreGuidelines.md:12341
msgid "12341    # <a name=\"S-cpl\"></a>CPL: C-style programming"
msgstr""

       
# CppCoreGuidelines.md:12342
msgid "12342    C and C++ are closely related languages."
msgstr""

# CppCoreGuidelines.md:12343
msgid "12343    They both originate in \"Classic C\" from 1978 and have evolved in ISO committees since then."
msgstr""

# CppCoreGuidelines.md:12344
msgid "12344    Many attempts have been made to keep them compatible, but neither is a subset of the other."
msgstr""

       
# CppCoreGuidelines.md:12345
msgid "12345    C rule summary:"
msgstr""

       
# CppCoreGuidelines.md:12346
msgid "12346    * [CPL.1: Prefer C++ to C](#Rcpl-C)"
msgstr""

# CppCoreGuidelines.md:12347
msgid "12347    * [CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++](#Rcpl-subset)"
msgstr""

# CppCoreGuidelines.md:12348
msgid "12348    * [CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces](#Rcpl-interface)"
msgstr""

       
# CppCoreGuidelines.md:12349
msgid "12349    ### <a name=\"Rcpl-C\"></a>CPL.1: Prefer C++ to C"
msgstr""

       
# CppCoreGuidelines.md:12350
msgid "12350    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12351
msgid "12351    C++ provides better type checking and more notational support."
msgstr""

# CppCoreGuidelines.md:12352
msgid "12352    It provides better support for high-level programming and often generates faster code."
msgstr""

       
# CppCoreGuidelines.md:12353
msgid "12353    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12354
msgid "12354        char ch = 7;"
msgstr""

# CppCoreGuidelines.md:12355
msgid "12355        void* pv = &ch;"
msgstr""

# CppCoreGuidelines.md:12356
msgid "12356        int* pi = pv;   // not C++"
msgstr""

# CppCoreGuidelines.md:12357
msgid "12357        *pi = 999;      // overwrite sizeof(int) bytes near &ch"
msgstr""

       
# CppCoreGuidelines.md:12358
msgid "12358    The rules for implicit casting to and from `void*` in C are subtle and unenforced."
msgstr""

# CppCoreGuidelines.md:12359
msgid "12359    In particular, this example violates a rule against converting to a type with stricter alignment."
msgstr""

       
# CppCoreGuidelines.md:12360
msgid "12360    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12361
msgid "12361    Use a C++ compiler."
msgstr""

       
# CppCoreGuidelines.md:12362
msgid "12362    ### <a name=\"Rcpl-subset\"></a>CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++"
msgstr""

       
# CppCoreGuidelines.md:12363
msgid "12363    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12364
msgid "12364    That subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than \"pure C.\""
msgstr""

       
# CppCoreGuidelines.md:12365
msgid "12365    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12366
msgid "12366        int* p1 = malloc(10 * sizeof(int));                      // not C++"
msgstr""

# CppCoreGuidelines.md:12367
msgid "12367        int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // not C, C-style C++"
msgstr""

# CppCoreGuidelines.md:12368
msgid "12368        int* p3 = new int[10];                                   // not C"
msgstr""

# CppCoreGuidelines.md:12369
msgid "12369        int* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++"
msgstr""

       
# CppCoreGuidelines.md:12370
msgid "12370    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12371
msgid "12371    * Flag if using a build mode that compiles code as C."
msgstr""

       
# CppCoreGuidelines.md:12372
msgid "12372      * The C++ compiler will enforce that the code is valid C++ unless you use C extension options."
msgstr""

       
# CppCoreGuidelines.md:12373
msgid "12373    ### <a name=\"Rcpl-interface\"></a>CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces"
msgstr""

       
# CppCoreGuidelines.md:12374
msgid "12374    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12375
msgid "12375    C++ is more expressive than C and offers better support for many types of programming."
msgstr""

       
# CppCoreGuidelines.md:12376
msgid "12376    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12377
msgid "12377    For example, to use a 3rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking."
msgstr""

# CppCoreGuidelines.md:12378
msgid "12378    Whenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code."
msgstr""

       
# CppCoreGuidelines.md:12379
msgid "12379    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12380
msgid "12380    You can call C from C++:"
msgstr""

       
# CppCoreGuidelines.md:12381
msgid "12381        // in C:"
msgstr""

# CppCoreGuidelines.md:12382
msgid "12382        double sqrt(double);"
msgstr""

       
# CppCoreGuidelines.md:12383
msgid "12383        // in C++:"
msgstr""

# CppCoreGuidelines.md:12384
msgid "12384        extern \"C\" double sqrt(double);"
msgstr""

       
# CppCoreGuidelines.md:12385
msgid "12385        sqrt(2);"
msgstr""

       
# CppCoreGuidelines.md:12386
msgid "12386    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12387
msgid "12387    You can call C++ from C:"
msgstr""

       
# CppCoreGuidelines.md:12388
msgid "12388        // in C:"
msgstr""

# CppCoreGuidelines.md:12389
msgid "12389        X call_f(struct Y*, int);"
msgstr""

       
# CppCoreGuidelines.md:12390
msgid "12390        // in C++:"
msgstr""

# CppCoreGuidelines.md:12391
msgid "12391        extern \"C\" X call_f(Y* p, int i)"
msgstr""

# CppCoreGuidelines.md:12392
msgid "12392        {"
msgstr""

# CppCoreGuidelines.md:12393
msgid "12393            return p->f(i);   // possibly a virtual function call"
msgstr""

# CppCoreGuidelines.md:12394
msgid "12394        }"
msgstr""

       
# CppCoreGuidelines.md:12395
msgid "12395    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12396
msgid "12396    None needed"
msgstr""

       
# CppCoreGuidelines.md:12397
msgid "12397    # <a name=\"S-source\"></a>SF: Source files"
msgstr""

       
# CppCoreGuidelines.md:12398
msgid "12398    Distinguish between declarations (used as interfaces) and definitions (used as implementations)."
msgstr""

# CppCoreGuidelines.md:12399
msgid "12399    Use header files to represent interfaces and to emphasize logical structure."
msgstr""

       
# CppCoreGuidelines.md:12400
msgid "12400    Source file rule summary:"
msgstr""

       
# CppCoreGuidelines.md:12401
msgid "12401    * [SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention](#Rs-file-suffix)"
msgstr""

# CppCoreGuidelines.md:12402
msgid "12402    * [SF.2: A `.h` file may not contain object definitions or non-inline function definitions](#Rs-inline)"
msgstr""

# CppCoreGuidelines.md:12403
msgid "12403    * [SF.3: Use `.h` files for all declarations used in multiple source files](#Rs-declaration-header)"
msgstr""

# CppCoreGuidelines.md:12404
msgid "12404    * [SF.4: Include `.h` files before other declarations in a file](#Rs-include-order)"
msgstr""

# CppCoreGuidelines.md:12405
msgid "12405    * [SF.5: A `.cpp` file must include the `.h` file(s) that defines its interface](#Rs-consistency)"
msgstr""

# CppCoreGuidelines.md:12406
msgid "12406    * [SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)](#Rs-using)"
msgstr""

# CppCoreGuidelines.md:12407
msgid "12407    * [SF.7: Don't write `using namespace` at global scope in a header file](#Rs-using-directive)"
msgstr""

# CppCoreGuidelines.md:12408
msgid "12408    * [SF.8: Use `#include` guards for all `.h` files](#Rs-guards)"
msgstr""

# CppCoreGuidelines.md:12409
msgid "12409    * [SF.9: Avoid cyclic dependencies among source files](#Rs-cycles)"
msgstr""

# CppCoreGuidelines.md:12410
msgid "12410    * [SF.10: Avoid dependencies on implicitly `#include`d names](#Rs-implicit)"
msgstr""

# CppCoreGuidelines.md:12411
msgid "12411    * [SF.11: Header files should be self-contained](#Rs-contained)"
msgstr""

       
# CppCoreGuidelines.md:12412
msgid "12412    * [SF.20: Use `namespace`s to express logical structure](#Rs-namespace)"
msgstr""

# CppCoreGuidelines.md:12413
msgid "12413    * [SF.21: Don't use an unnamed (anonymous) namespace in a header](#Rs-unnamed)"
msgstr""

# CppCoreGuidelines.md:12414
msgid "12414    * [SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities](#Rs-unnamed2)"
msgstr""

       
# CppCoreGuidelines.md:12415
msgid "12415    ### <a name=\"Rs-file-suffix\"></a>SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention"
msgstr""

       
# CppCoreGuidelines.md:12416
msgid "12416    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12417
msgid "12417    It's a longstanding convention."
msgstr""

# CppCoreGuidelines.md:12418
msgid "12418    But consistency is more important, so if your project uses something else, follow that."
msgstr""

       
# CppCoreGuidelines.md:12419
msgid "12419    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12420
msgid "12420    This convention reflects a common use pattern:"
msgstr""

# CppCoreGuidelines.md:12421
msgid "12421    Headers are more often shared with C to compile as both C++ and C, which typically uses `.h`,"
msgstr""

# CppCoreGuidelines.md:12422
msgid "12422    and it's easier to name all headers `.h` instead of having different extensions for just those headers that are intended to be shared with C."
msgstr""

# CppCoreGuidelines.md:12423
msgid "12423    On the other hand, implementation files are rarely shared with C and so should typically be distinguished from `.c` files,"
msgstr""

# CppCoreGuidelines.md:12424
msgid "12424    so it's normally best to name all C++ implementation files something else (such as `.cpp`)."
msgstr""

       
# CppCoreGuidelines.md:12425
msgid "12425    The specific names `.h` and `.cpp` are not required (just recommended as a default) and other names are in widespread use."
msgstr""

# CppCoreGuidelines.md:12426
msgid "12426    Examples are `.hh`, `.C`, and `.cxx`. Use such names equivalently."
msgstr""

# CppCoreGuidelines.md:12427
msgid "12427    In this document, we refer to `.h` and `.cpp` as a shorthand for header and implementation files,"
msgstr""

# CppCoreGuidelines.md:12428
msgid "12428    even though the actual extension may be different."
msgstr""

       
# CppCoreGuidelines.md:12429
msgid "12429    Your IDE (if you use one) may have strong opinions about suffices."
msgstr""

       
# CppCoreGuidelines.md:12430
msgid "12430    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12431
msgid "12431        // foo.h:"
msgstr""

# CppCoreGuidelines.md:12432
msgid "12432        extern int a;   // a declaration"
msgstr""

# CppCoreGuidelines.md:12433
msgid "12433        extern void foo();"
msgstr""

       
# CppCoreGuidelines.md:12434
msgid "12434        // foo.cpp:"
msgstr""

# CppCoreGuidelines.md:12435
msgid "12435        int a;   // a definition"
msgstr""

# CppCoreGuidelines.md:12436
msgid "12436        void foo() { ++a; }"
msgstr""

       
# CppCoreGuidelines.md:12437
msgid "12437    `foo.h` provides the interface to `foo.cpp`. Global variables are best avoided."
msgstr""

       
# CppCoreGuidelines.md:12438
msgid "12438    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12439
msgid "12439        // foo.h:"
msgstr""

# CppCoreGuidelines.md:12440
msgid "12440        int a;   // a definition"
msgstr""

# CppCoreGuidelines.md:12441
msgid "12441        void foo() { ++a; }"
msgstr""

       
# CppCoreGuidelines.md:12442
msgid "12442    `#include <foo.h>` twice in a program and you get a linker error for two one-definition-rule violations."
msgstr""

       
# CppCoreGuidelines.md:12443
msgid "12443    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12444
msgid "12444    * Flag non-conventional file names."
msgstr""

# CppCoreGuidelines.md:12445
msgid "12445    * Check that `.h` and `.cpp` (and equivalents) follow the rules below."
msgstr""

       
# CppCoreGuidelines.md:12446
msgid "12446    ### <a name=\"Rs-inline\"></a>SF.2: A `.h` file may not contain object definitions or non-inline function definitions"
msgstr""

       
# CppCoreGuidelines.md:12447
msgid "12447    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12448
msgid "12448    Including entities subject to the one-definition rule leads to linkage errors."
msgstr""

       
# CppCoreGuidelines.md:12449
msgid "12449    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12450
msgid "12450        // file.h:"
msgstr""

# CppCoreGuidelines.md:12451
msgid "12451        namespace Foo {"
msgstr""

# CppCoreGuidelines.md:12452
msgid "12452            int x = 7;"
msgstr""

# CppCoreGuidelines.md:12453
msgid "12453            int xx() { return x+x; }"
msgstr""

# CppCoreGuidelines.md:12454
msgid "12454        }"
msgstr""

       
# CppCoreGuidelines.md:12455
msgid "12455        // file1.cpp:"
msgstr""

# CppCoreGuidelines.md:12456
msgid "12456        #include <file.h>"
msgstr""

# CppCoreGuidelines.md:12457
msgid "12457        // ... more ..."
msgstr""

       
# CppCoreGuidelines.md:12458
msgid "12458         // file2.cpp:"
msgstr""

# CppCoreGuidelines.md:12459
msgid "12459        #include <file.h>"
msgstr""

# CppCoreGuidelines.md:12460
msgid "12460        // ... more ..."
msgstr""

       
# CppCoreGuidelines.md:12461
msgid "12461    Linking `file1.cpp` and `file2.cpp` will give two linker errors."
msgstr""

       
# CppCoreGuidelines.md:12462
msgid "12462    **Alternative formulation**: A `.h` file must contain only:"
msgstr""

       
# CppCoreGuidelines.md:12463
msgid "12463    * `#include`s of other `.h` files (possibly with include guards)"
msgstr""

# CppCoreGuidelines.md:12464
msgid "12464    * templates"
msgstr""

# CppCoreGuidelines.md:12465
msgid "12465    * class definitions"
msgstr""

# CppCoreGuidelines.md:12466
msgid "12466    * function declarations"
msgstr""

# CppCoreGuidelines.md:12467
msgid "12467    * `extern` declarations"
msgstr""

# CppCoreGuidelines.md:12468
msgid "12468    * `inline` function definitions"
msgstr""

# CppCoreGuidelines.md:12469
msgid "12469    * `constexpr` definitions"
msgstr""

# CppCoreGuidelines.md:12470
msgid "12470    * `const` definitions"
msgstr""

# CppCoreGuidelines.md:12471
msgid "12471    * `using` alias definitions"
msgstr""

# CppCoreGuidelines.md:12472
msgid "12472    * ???"
msgstr""

       
# CppCoreGuidelines.md:12473
msgid "12473    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12474
msgid "12474    Check the positive list above."
msgstr""

       
# CppCoreGuidelines.md:12475
msgid "12475    ### <a name=\"Rs-declaration-header\"></a>SF.3: Use `.h` files for all declarations used in multiple source files"
msgstr""

       
# CppCoreGuidelines.md:12476
msgid "12476    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12477
msgid "12477    Maintainability. Readability."
msgstr""

       
# CppCoreGuidelines.md:12478
msgid "12478    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12479
msgid "12479        // bar.cpp:"
msgstr""

# CppCoreGuidelines.md:12480
msgid "12480        void bar() { cout << \"bar\\n\"; }"
msgstr""

       
# CppCoreGuidelines.md:12481
msgid "12481        // foo.cpp:"
msgstr""

# CppCoreGuidelines.md:12482
msgid "12482        extern void bar();"
msgstr""

# CppCoreGuidelines.md:12483
msgid "12483        void foo() { bar(); }"
msgstr""

       
# CppCoreGuidelines.md:12484
msgid "12484    A maintainer of `bar` cannot find all declarations of `bar` if its type needs changing."
msgstr""

# CppCoreGuidelines.md:12485
msgid "12485    The user of `bar` cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker."
msgstr""

       
# CppCoreGuidelines.md:12486
msgid "12486    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12487
msgid "12487    * Flag declarations of entities in other source files not placed in a `.h`."
msgstr""

       
# CppCoreGuidelines.md:12488
msgid "12488    ### <a name=\"Rs-include-order\"></a>SF.4: Include `.h` files before other declarations in a file"
msgstr""

       
# CppCoreGuidelines.md:12489
msgid "12489    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12490
msgid "12490    Minimize context dependencies and increase readability."
msgstr""

       
# CppCoreGuidelines.md:12491
msgid "12491    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12492
msgid "12492        #include <vector>"
msgstr""

# CppCoreGuidelines.md:12493
msgid "12493        #include <algorithm>"
msgstr""

# CppCoreGuidelines.md:12494
msgid "12494        #include <string>"
msgstr""

       
# CppCoreGuidelines.md:12495
msgid "12495        // ... my code here ..."
msgstr""

       
# CppCoreGuidelines.md:12496
msgid "12496    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12497
msgid "12497        #include <vector>"
msgstr""

       
# CppCoreGuidelines.md:12498
msgid "12498        // ... my code here ..."
msgstr""

       
# CppCoreGuidelines.md:12499
msgid "12499        #include <algorithm>"
msgstr""

# CppCoreGuidelines.md:12500
msgid "12500        #include <string>"
msgstr""

       
# CppCoreGuidelines.md:12501
msgid "12501    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12502
msgid "12502    This applies to both `.h` and `.cpp` files."
msgstr""

       
# CppCoreGuidelines.md:12503
msgid "12503    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12504
msgid "12504    There is an argument for insulating code from declarations and macros in header files by `#including` headers *after* the code we want to protect"
msgstr""

# CppCoreGuidelines.md:12505
msgid "12505    (as in the example labeled \"bad\")."
msgstr""

# CppCoreGuidelines.md:12506
msgid "12506    However"
msgstr""

       
# CppCoreGuidelines.md:12507
msgid "12507    * that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears."
msgstr""

# CppCoreGuidelines.md:12508
msgid "12508    * a namespace (an \"implementation namespace\") can protect against many context dependencies."
msgstr""

# CppCoreGuidelines.md:12509
msgid "12509    * full protection and flexibility require modules."
msgstr""

       
# CppCoreGuidelines.md:12510
msgid "12510    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:12511
msgid "12511    * [Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)"
msgstr""

# CppCoreGuidelines.md:12512
msgid "12512    * [Modules, Componentization, and Transition](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)"
msgstr""

       
# CppCoreGuidelines.md:12513
msgid "12513    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12514
msgid "12514    Easy."
msgstr""

       
# CppCoreGuidelines.md:12515
msgid "12515    ### <a name=\"Rs-consistency\"></a>SF.5: A `.cpp` file must include the `.h` file(s) that defines its interface"
msgstr""

       
# CppCoreGuidelines.md:12516
msgid "12516    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12517
msgid "12517    This enables the compiler to do an early consistency check."
msgstr""

       
# CppCoreGuidelines.md:12518
msgid "12518    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12519
msgid "12519        // foo.h:"
msgstr""

# CppCoreGuidelines.md:12520
msgid "12520        void foo(int);"
msgstr""

# CppCoreGuidelines.md:12521
msgid "12521        int bar(long);"
msgstr""

# CppCoreGuidelines.md:12522
msgid "12522        int foobar(int);"
msgstr""

       
# CppCoreGuidelines.md:12523
msgid "12523        // foo.cpp:"
msgstr""

# CppCoreGuidelines.md:12524
msgid "12524        void foo(int) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:12525
msgid "12525        int bar(double) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:12526
msgid "12526        double foobar(int);"
msgstr""

       
# CppCoreGuidelines.md:12527
msgid "12527    The errors will not be caught until link time for a program calling `bar` or `foobar`."
msgstr""

       
# CppCoreGuidelines.md:12528
msgid "12528    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12529
msgid "12529        // foo.h:"
msgstr""

# CppCoreGuidelines.md:12530
msgid "12530        void foo(int);"
msgstr""

# CppCoreGuidelines.md:12531
msgid "12531        int bar(long);"
msgstr""

# CppCoreGuidelines.md:12532
msgid "12532        int foobar(int);"
msgstr""

       
# CppCoreGuidelines.md:12533
msgid "12533        // foo.cpp:"
msgstr""

# CppCoreGuidelines.md:12534
msgid "12534        #include <foo.h>"
msgstr""

       
# CppCoreGuidelines.md:12535
msgid "12535        void foo(int) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:12536
msgid "12536        int bar(double) { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:12537
msgid "12537        double foobar(int);   // error: wrong return type"
msgstr""

       
# CppCoreGuidelines.md:12538
msgid "12538    The return-type error for `foobar` is now caught immediately when `foo.cpp` is compiled."
msgstr""

# CppCoreGuidelines.md:12539
msgid "12539    The argument-type error for `bar` cannot be caught until link time because of the possibility of overloading, but systematic use of `.h` files increases the likelihood that it is caught earlier by the programmer."
msgstr""

       
# CppCoreGuidelines.md:12540
msgid "12540    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12541
msgid "12541    ???"
msgstr""

       
# CppCoreGuidelines.md:12542
msgid "12542    ### <a name=\"Rs-using\"></a>SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)"
msgstr""

       
# CppCoreGuidelines.md:12543
msgid "12543    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12544
msgid "12544     `using namespace` can lead to name clashes, so it should be used sparingly."
msgstr""

# CppCoreGuidelines.md:12545
msgid "12545     However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition)"
msgstr""

# CppCoreGuidelines.md:12546
msgid "12546     and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting."
msgstr""

       
# CppCoreGuidelines.md:12547
msgid "12547    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12548
msgid "12548        #include <string>"
msgstr""

# CppCoreGuidelines.md:12549
msgid "12549        #include <vector>"
msgstr""

# CppCoreGuidelines.md:12550
msgid "12550        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:12551
msgid "12551        #include <memory>"
msgstr""

# CppCoreGuidelines.md:12552
msgid "12552        #include <algorithm>"
msgstr""

       
# CppCoreGuidelines.md:12553
msgid "12553        using namespace std;"
msgstr""

       
# CppCoreGuidelines.md:12554
msgid "12554        // ..."
msgstr""

       
# CppCoreGuidelines.md:12555
msgid "12555    Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring `std::` everywhere"
msgstr""

# CppCoreGuidelines.md:12556
msgid "12556    could be distracting."
msgstr""

       
# CppCoreGuidelines.md:12557
msgid "12557    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12558
msgid "12558    The use of `using namespace std;` leaves the programmer open to a name clash with a name from the standard library"
msgstr""

       
# CppCoreGuidelines.md:12559
msgid "12559        #include <cmath>"
msgstr""

# CppCoreGuidelines.md:12560
msgid "12560        using namespace std;"
msgstr""

       
# CppCoreGuidelines.md:12561
msgid "12561        int g(int x)"
msgstr""

# CppCoreGuidelines.md:12562
msgid "12562        {"
msgstr""

# CppCoreGuidelines.md:12563
msgid "12563            int sqrt = 7;"
msgstr""

# CppCoreGuidelines.md:12564
msgid "12564            // ..."
msgstr""

# CppCoreGuidelines.md:12565
msgid "12565            return sqrt(x); // error"
msgstr""

# CppCoreGuidelines.md:12566
msgid "12566        }"
msgstr""

       
# CppCoreGuidelines.md:12567
msgid "12567    However, this is not particularly likely to lead to a resolution that is not an error and"
msgstr""

# CppCoreGuidelines.md:12568
msgid "12568    people who use `using namespace std` are supposed to know about `std` and about this risk."
msgstr""

       
# CppCoreGuidelines.md:12569
msgid "12569    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12570
msgid "12570    A `.cpp` file is a form of local scope."
msgstr""

# CppCoreGuidelines.md:12571
msgid "12571    There is little difference in the opportunities for name clashes in an N-line `.cpp` containing a `using namespace X`,"
msgstr""

# CppCoreGuidelines.md:12572
msgid "12572    an N-line function containing a `using namespace X`,"
msgstr""

# CppCoreGuidelines.md:12573
msgid "12573    and M functions each containing a `using namespace X`with N lines of code in total."
msgstr""

       
# CppCoreGuidelines.md:12574
msgid "12574    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12575
msgid "12575    [Don't write `using namespace` in a header file](#Rs-using-directive)."
msgstr""

       
# CppCoreGuidelines.md:12576
msgid "12576    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12577
msgid "12577    Flag multiple `using namespace` directives for different namespaces in a single source file."
msgstr""

       
# CppCoreGuidelines.md:12578
msgid "12578    ### <a name=\"Rs-using-directive\"></a>SF.7: Don't write `using namespace` at global scope in a header file"
msgstr""

       
# CppCoreGuidelines.md:12579
msgid "12579    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12580
msgid "12580    Doing so takes away an `#include`r's ability to effectively disambiguate and to use alternatives. It also makes `#include`d headers order-dependent as they may have different meaning when included in different orders."
msgstr""

       
# CppCoreGuidelines.md:12581
msgid "12581    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12582
msgid "12582        // bad.h"
msgstr""

# CppCoreGuidelines.md:12583
msgid "12583        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:12584
msgid "12584        using namespace std; // bad"
msgstr""

       
# CppCoreGuidelines.md:12585
msgid "12585        // user.cpp"
msgstr""

# CppCoreGuidelines.md:12586
msgid "12586        #include \"bad.h\""
msgstr""

       
# CppCoreGuidelines.md:12587
msgid "12587        bool copy(/*... some parameters ...*/);    // some function that happens to be named copy"
msgstr""

       
# CppCoreGuidelines.md:12588
msgid "12588        int main() {"
msgstr""

# CppCoreGuidelines.md:12589
msgid "12589            copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous"
msgstr""

# CppCoreGuidelines.md:12590
msgid "12590        }"
msgstr""

       
# CppCoreGuidelines.md:12591
msgid "12591    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12592
msgid "12592    Flag `using namespace` at global scope in a header file."
msgstr""

       
# CppCoreGuidelines.md:12593
msgid "12593    ### <a name=\"Rs-guards\"></a>SF.8: Use `#include` guards for all `.h` files"
msgstr""

       
# CppCoreGuidelines.md:12594
msgid "12594    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12595
msgid "12595    To avoid files being `#include`d several times."
msgstr""

       
# CppCoreGuidelines.md:12596
msgid "12596    In order to avoid include guard collisions, do not just name the guard after the filename."
msgstr""

# CppCoreGuidelines.md:12597
msgid "12597    Be sure to also include a key and good differentiator, such as the name of library or component"
msgstr""

# CppCoreGuidelines.md:12598
msgid "12598    the header file is part of."
msgstr""

       
# CppCoreGuidelines.md:12599
msgid "12599    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12600
msgid "12600        // file foobar.h:"
msgstr""

# CppCoreGuidelines.md:12601
msgid "12601        #ifndef LIBRARY_FOOBAR_H"
msgstr""

# CppCoreGuidelines.md:12602
msgid "12602        #define LIBRARY_FOOBAR_H"
msgstr""

# CppCoreGuidelines.md:12603
msgid "12603        // ... declarations ..."
msgstr""

# CppCoreGuidelines.md:12604
msgid "12604        #endif // LIBRARY_FOOBAR_H"
msgstr""

       
# CppCoreGuidelines.md:12605
msgid "12605    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12606
msgid "12606    Flag `.h` files without `#include` guards."
msgstr""

       
# CppCoreGuidelines.md:12607
msgid "12607    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12608
msgid "12608    Some implementations offer vendor extensions like `#pragma once` as alternative to include guards."
msgstr""

# CppCoreGuidelines.md:12609
msgid "12609    It is not standard and it is not portable.  It injects the hosting machine's filesystem semantics"
msgstr""

# CppCoreGuidelines.md:12610
msgid "12610    into your program, in addition to locking you down to a vendor."
msgstr""

# CppCoreGuidelines.md:12611
msgid "12611    Our recommendation is to write in ISO C++: See [rule P.2](#Rp-Cplusplus)."
msgstr""

       
# CppCoreGuidelines.md:12612
msgid "12612    ### <a name=\"Rs-cycles\"></a>SF.9: Avoid cyclic dependencies among source files"
msgstr""

       
# CppCoreGuidelines.md:12613
msgid "12613    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12614
msgid "12614    Cycles complicates comprehension and slows down compilation."
msgstr""

# CppCoreGuidelines.md:12615
msgid "12615    Complicates conversion to use language-supported modules (when they become available)."
msgstr""

       
# CppCoreGuidelines.md:12616
msgid "12616    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12617
msgid "12617    Eliminate cycles; don't just break them with `#include` guards."
msgstr""

       
# CppCoreGuidelines.md:12618
msgid "12618    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12619
msgid "12619        // file1.h:"
msgstr""

# CppCoreGuidelines.md:12620
msgid "12620        #include \"file2.h\""
msgstr""

       
# CppCoreGuidelines.md:12621
msgid "12621        // file2.h:"
msgstr""

# CppCoreGuidelines.md:12622
msgid "12622        #include \"file3.h\""
msgstr""

       
# CppCoreGuidelines.md:12623
msgid "12623        // file3.h:"
msgstr""

# CppCoreGuidelines.md:12624
msgid "12624        #include \"file1.h\""
msgstr""

       
# CppCoreGuidelines.md:12625
msgid "12625    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12626
msgid "12626    Flag all cycles."
msgstr""

       
       
# CppCoreGuidelines.md:12627
msgid "12627    ### <a name=\"Rs-implicit\"></a>SF.10: Avoid dependencies on implicitly `#include`d names"
msgstr""

       
# CppCoreGuidelines.md:12628
msgid "12628    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12629
msgid "12629    Avoid surprises."
msgstr""

# CppCoreGuidelines.md:12630
msgid "12630    Avoid having to change `#include`s if an `#include`d header changes."
msgstr""

# CppCoreGuidelines.md:12631
msgid "12631    Avoid accidentally becoming dependent on implementation details and logically separate entities included in a header."
msgstr""

       
# CppCoreGuidelines.md:12632
msgid "12632    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12633
msgid "12633        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:12634
msgid "12634        using namespace std;"
msgstr""

       
# CppCoreGuidelines.md:12635
msgid "12635        void use()                  // bad"
msgstr""

# CppCoreGuidelines.md:12636
msgid "12636        {"
msgstr""

# CppCoreGuidelines.md:12637
msgid "12637            string s;"
msgstr""

# CppCoreGuidelines.md:12638
msgid "12638            cin >> s;               // fine"
msgstr""

# CppCoreGuidelines.md:12639
msgid "12639            getline(cin, s);        // error: getline() not defined"
msgstr""

# CppCoreGuidelines.md:12640
msgid "12640            if (s == \"surprise\") {  // error == not defined"
msgstr""

# CppCoreGuidelines.md:12641
msgid "12641                // ..."
msgstr""

# CppCoreGuidelines.md:12642
msgid "12642            }"
msgstr""

# CppCoreGuidelines.md:12643
msgid "12643        }"
msgstr""

       
# CppCoreGuidelines.md:12644
msgid "12644    `<iostream>` exposes the definition of `std::string` (\"why?\" makes for a fun trivia question),"
msgstr""

# CppCoreGuidelines.md:12645
msgid "12645    but it is not required to do so by transitively including the entire `<string>` header,"
msgstr""

# CppCoreGuidelines.md:12646
msgid "12646    resulting in the popular beginner question \"why doesn't `getline(cin,s);` work?\""
msgstr""

# CppCoreGuidelines.md:12647
msgid "12647    or even an occasional \"`string`s cannot be compared with `==`)."
msgstr""

       
# CppCoreGuidelines.md:12648
msgid "12648    The solution is to explicitly `#include <string>`:"
msgstr""

       
# CppCoreGuidelines.md:12649
msgid "12649        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:12650
msgid "12650        #include <string>"
msgstr""

# CppCoreGuidelines.md:12651
msgid "12651        using namespace std;"
msgstr""

       
# CppCoreGuidelines.md:12652
msgid "12652        void use()"
msgstr""

# CppCoreGuidelines.md:12653
msgid "12653        {"
msgstr""

# CppCoreGuidelines.md:12654
msgid "12654            string s;"
msgstr""

# CppCoreGuidelines.md:12655
msgid "12655            cin >> s;               // fine"
msgstr""

# CppCoreGuidelines.md:12656
msgid "12656            getline(cin, s);        // fine"
msgstr""

# CppCoreGuidelines.md:12657
msgid "12657            if (s == \"surprise\") {  // fine"
msgstr""

# CppCoreGuidelines.md:12658
msgid "12658                // ..."
msgstr""

# CppCoreGuidelines.md:12659
msgid "12659            }"
msgstr""

# CppCoreGuidelines.md:12660
msgid "12660        }"
msgstr""

       
# CppCoreGuidelines.md:12661
msgid "12661    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12662
msgid "12662    Some headers exist exactly to collect a set of consistent declarations from a variety of headers."
msgstr""

# CppCoreGuidelines.md:12663
msgid "12663    For example:"
msgstr""

       
# CppCoreGuidelines.md:12664
msgid "12664        // basic_std_lib.h:"
msgstr""

       
# CppCoreGuidelines.md:12665
msgid "12665        #include <vector>"
msgstr""

# CppCoreGuidelines.md:12666
msgid "12666        #include <string>"
msgstr""

# CppCoreGuidelines.md:12667
msgid "12667        #include <map>"
msgstr""

# CppCoreGuidelines.md:12668
msgid "12668        #include <iostream>"
msgstr""

# CppCoreGuidelines.md:12669
msgid "12669        #include <random>"
msgstr""

# CppCoreGuidelines.md:12670
msgid "12670        #include <vector>"
msgstr""

       
# CppCoreGuidelines.md:12671
msgid "12671    a user can now get that set of declarations with a single `#include`\""
msgstr""

       
# CppCoreGuidelines.md:12672
msgid "12672        #include \"basic_std_lib.h\""
msgstr""

       
# CppCoreGuidelines.md:12673
msgid "12673    This rule against implicit inclusion is not meant to prevent such deliberate aggregation."
msgstr""

       
# CppCoreGuidelines.md:12674
msgid "12674    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12675
msgid "12675    Enforcement would require some knowledge about what in a header is meant to be \"exported\" to users and what is there to enable implementation."
msgstr""

# CppCoreGuidelines.md:12676
msgid "12676    No really good solution is possible until we have modules."
msgstr""

       
# CppCoreGuidelines.md:12677
msgid "12677    ### <a name=\"Rs-contained\"></a>SF.11: Header files should be self-contained"
msgstr""

       
# CppCoreGuidelines.md:12678
msgid "12678    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12679
msgid "12679    Usability, headers should be simple to use and work when included on their own."
msgstr""

# CppCoreGuidelines.md:12680
msgid "12680    Headers should encapsulate the functionality they provide."
msgstr""

# CppCoreGuidelines.md:12681
msgid "12681    Avoid clients of a header having to manage that header's dependencies."
msgstr""

       
# CppCoreGuidelines.md:12682
msgid "12682    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12683
msgid "12683        #include \"helpers.h\""
msgstr""

# CppCoreGuidelines.md:12684
msgid "12684        // helpers.h depends on std::string and includes <string>"
msgstr""

       
# CppCoreGuidelines.md:12685
msgid "12685    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12686
msgid "12686    Failing to follow this results in difficult to diagnose errors for clients of a header."
msgstr""

       
# CppCoreGuidelines.md:12687
msgid "12687    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12688
msgid "12688    A test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles."
msgstr""

       
# CppCoreGuidelines.md:12689
msgid "12689    ### <a name=\"Rs-namespace\"></a>SF.20: Use `namespace`s to express logical structure"
msgstr""

       
# CppCoreGuidelines.md:12690
msgid "12690    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12691
msgid "12691     ???"
msgstr""

       
# CppCoreGuidelines.md:12692
msgid "12692    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12693
msgid "12693        ???"
msgstr""

       
# CppCoreGuidelines.md:12694
msgid "12694    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12695
msgid "12695    ???"
msgstr""

       
# CppCoreGuidelines.md:12696
msgid "12696    ### <a name=\"Rs-unnamed\"></a>SF.21: Don't use an unnamed (anonymous) namespace in a header"
msgstr""

       
# CppCoreGuidelines.md:12697
msgid "12697    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12698
msgid "12698    It is almost always a bug to mention an unnamed namespace in a header file."
msgstr""

       
# CppCoreGuidelines.md:12699
msgid "12699    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12700
msgid "12700        ???"
msgstr""

       
# CppCoreGuidelines.md:12701
msgid "12701    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12702
msgid "12702    * Flag any use of an anonymous namespace in a header file."
msgstr""

       
# CppCoreGuidelines.md:12703
msgid "12703    ### <a name=\"Rs-unnamed2\"></a>SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities"
msgstr""

       
# CppCoreGuidelines.md:12704
msgid "12704    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12705
msgid "12705    Nothing external can depend on an entity in a nested unnamed namespace."
msgstr""

# CppCoreGuidelines.md:12706
msgid "12706    Consider putting every definition in an implementation source file in an unnamed namespace unless that is defining an \"external/exported\" entity."
msgstr""

       
# CppCoreGuidelines.md:12707
msgid "12707    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12708
msgid "12708    An API class and its members can't live in an unnamed namespace; but any \"helper\" class or function that is defined in an implementation source file should be at an unnamed namespace scope."
msgstr""

       
# CppCoreGuidelines.md:12709
msgid "12709        ???"
msgstr""

       
# CppCoreGuidelines.md:12710
msgid "12710    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12711
msgid "12711    * ???"
msgstr""

       
# CppCoreGuidelines.md:12712
msgid "12712    # <a name=\"S-stdlib\"></a>SL: The Standard Library"
msgstr""

       
# CppCoreGuidelines.md:12713
msgid "12713    Using only the bare language, every task is tedious (in any language)."
msgstr""

# CppCoreGuidelines.md:12714
msgid "12714    Using a suitable library any task can be reasonably simple."
msgstr""

       
# CppCoreGuidelines.md:12715
msgid "12715    The standard library has steadily grown over the years."
msgstr""

# CppCoreGuidelines.md:12716
msgid "12716    Its description in the standard is now larger than that of the language features."
msgstr""

# CppCoreGuidelines.md:12717
msgid "12717    So, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest."
msgstr""

       
# CppCoreGuidelines.md:12718
msgid "12718    << ??? We need another level of rule numbering ??? >>"
msgstr""

       
# CppCoreGuidelines.md:12719
msgid "12719    C++ Standard Library component summary:"
msgstr""

       
# CppCoreGuidelines.md:12720
msgid "12720    * [SL.con: Containers](#SS-con)"
msgstr""

# CppCoreGuidelines.md:12721
msgid "12721    * [SL.str: String](#SS-string)"
msgstr""

# CppCoreGuidelines.md:12722
msgid "12722    * [SL.io: Iostream](#SS-io)"
msgstr""

# CppCoreGuidelines.md:12723
msgid "12723    * [SL.regex: Regex](#SS-regex)"
msgstr""

# CppCoreGuidelines.md:12724
msgid "12724    * [SL.chrono: Time](#SS-chrono)"
msgstr""

# CppCoreGuidelines.md:12725
msgid "12725    * [SL.C: The C Standard Library](#SS-clib)"
msgstr""

       
# CppCoreGuidelines.md:12726
msgid "12726    Standard-library rule summary:"
msgstr""

       
# CppCoreGuidelines.md:12727
msgid "12727    * [SL.1: Use libraries wherever possible](#Rsl-lib)"
msgstr""

# CppCoreGuidelines.md:12728
msgid "12728    * [SL.2: Prefer the standard library to other libraries](#Rsl-sl)"
msgstr""

# CppCoreGuidelines.md:12729
msgid "12729    * [SL.3: Do not add non-standard entities to namespace `std`](#sl-std)"
msgstr""

# CppCoreGuidelines.md:12730
msgid "12730    * [SL.4: Use the standard library in a type-safe manner](#sl-safe)"
msgstr""

# CppCoreGuidelines.md:12731
msgid "12731    * ???"
msgstr""

       
# CppCoreGuidelines.md:12732
msgid "12732    ### <a name=\"Rsl-lib\"></a>SL.1:  Use libraries wherever possible"
msgstr""

       
# CppCoreGuidelines.md:12733
msgid "12733    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12734
msgid "12734    Save time. Don't re-invent the wheel."
msgstr""

# CppCoreGuidelines.md:12735
msgid "12735    Don't replicate the work of others."
msgstr""

# CppCoreGuidelines.md:12736
msgid "12736    Benefit from other people's work when they make improvements."
msgstr""

# CppCoreGuidelines.md:12737
msgid "12737    Help other people when you make improvements."
msgstr""

       
# CppCoreGuidelines.md:12738
msgid "12738    ### <a name=\"Rsl-sl\"></a>SL.2: Prefer the standard library to other libraries"
msgstr""

       
# CppCoreGuidelines.md:12739
msgid "12739    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12740
msgid "12740    More people know the standard library."
msgstr""

# CppCoreGuidelines.md:12741
msgid "12741    It is more likely to be stable, well-maintained, and widely available than your own code or most other libraries."
msgstr""

       
       
# CppCoreGuidelines.md:12742
msgid "12742    ### <a name=\"sl-std\"></a>SL.3: Do not add non-standard entities to namespace `std`"
msgstr""

       
# CppCoreGuidelines.md:12743
msgid "12743    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12744
msgid "12744    Adding to `std` may change the meaning of otherwise standards conforming code."
msgstr""

# CppCoreGuidelines.md:12745
msgid "12745    Additions to `std` may clash with future versions of the standard."
msgstr""

       
# CppCoreGuidelines.md:12746
msgid "12746    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12747
msgid "12747        ???"
msgstr""

       
# CppCoreGuidelines.md:12748
msgid "12748    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12749
msgid "12749    Possible, but messy and likely to cause problems with platforms."
msgstr""

       
# CppCoreGuidelines.md:12750
msgid "12750    ### <a name=\"sl-safe\"></a>SL.4: Use the standard library in a type-safe manner"
msgstr""

       
# CppCoreGuidelines.md:12751
msgid "12751    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12752
msgid "12752    Because, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors."
msgstr""

       
# CppCoreGuidelines.md:12753
msgid "12753    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12754
msgid "12754    This is a semi-philosophical meta-rule, which needs many supporting concrete rules."
msgstr""

# CppCoreGuidelines.md:12755
msgid "12755    We need it as an umbrella for the more specific rules."
msgstr""

       
# CppCoreGuidelines.md:12756
msgid "12756    Summary of more specific rules:"
msgstr""

       
# CppCoreGuidelines.md:12757
msgid "12757    * [SL.4: Use the standard library in a type-safe manner](#sl-safe)"
msgstr""

       
       
# CppCoreGuidelines.md:12758
msgid "12758    ## <a name=\"SS-con\"></a>SL.con: Containers"
msgstr""

       
# CppCoreGuidelines.md:12759
msgid "12759    ???"
msgstr""

       
# CppCoreGuidelines.md:12760
msgid "12760    Container rule summary:"
msgstr""

       
# CppCoreGuidelines.md:12761
msgid "12761    * [SL.con.1: Prefer using STL `array` or `vector` instead of a C array](#Rsl-arrays)"
msgstr""

# CppCoreGuidelines.md:12762
msgid "12762    * [SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container](#Rsl-vector)"
msgstr""

# CppCoreGuidelines.md:12763
msgid "12763    * [SL.con.3: Avoid bounds errors](#Rsl-bounds)"
msgstr""

# CppCoreGuidelines.md:12764
msgid "12764    *  ???"
msgstr""

       
# CppCoreGuidelines.md:12765
msgid "12765    ### <a name=\"Rsl-arrays\"></a>SL.con.1: Prefer using STL `array` or `vector` instead of a C array"
msgstr""

       
# CppCoreGuidelines.md:12766
msgid "12766    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12767
msgid "12767    C arrays are less safe, and have no advantages over `array` and `vector`."
msgstr""

# CppCoreGuidelines.md:12768
msgid "12768    For a fixed-length array, use `std::array`, which does not degenerate to a pointer when passed to a function and does know its size."
msgstr""

# CppCoreGuidelines.md:12769
msgid "12769    Also, like a built-in array, a stack-allocated `std::array` keeps its elements on the stack."
msgstr""

# CppCoreGuidelines.md:12770
msgid "12770    For a variable-length array, use `std::vector`, which additionally can change its size and handles memory allocation."
msgstr""

       
# CppCoreGuidelines.md:12771
msgid "12771    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12772
msgid "12772        int v[SIZE];                        // BAD"
msgstr""

       
# CppCoreGuidelines.md:12773
msgid "12773        std::array<int, SIZE> w;             // ok"
msgstr""

       
# CppCoreGuidelines.md:12774
msgid "12774    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12775
msgid "12775        int* v = new int[initial_size];     // BAD, owning raw pointer"
msgstr""

# CppCoreGuidelines.md:12776
msgid "12776        delete[] v;                         // BAD, manual delete"
msgstr""

       
# CppCoreGuidelines.md:12777
msgid "12777        std::vector<int> w(initial_size);   // ok"
msgstr""

       
# CppCoreGuidelines.md:12778
msgid "12778    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12779
msgid "12779    Use `gsl::span` for non-owning references into a container."
msgstr""

       
# CppCoreGuidelines.md:12780
msgid "12780    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12781
msgid "12781    Comparing the performance of a fixed-sized array allocated on the stack against a `vector` with its elements on the free store is bogus."
msgstr""

# CppCoreGuidelines.md:12782
msgid "12782    You could just as well compare a `std::array` on the stack against the result of a `malloc()` accessed through a pointer."
msgstr""

# CppCoreGuidelines.md:12783
msgid "12783    For most code, even the difference between stack allocation and free-store allocation doesn't matter, but the convenience and safety of `vector` does."
msgstr""

# CppCoreGuidelines.md:12784
msgid "12784    People working with code for which that difference matters are quite capable of choosing between `array` and `vector`."
msgstr""

       
# CppCoreGuidelines.md:12785
msgid "12785    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12786
msgid "12786    * Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a `std::array`."
msgstr""

       
# CppCoreGuidelines.md:12787
msgid "12787    ### <a name=\"Rsl-vector\"></a>SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container"
msgstr""

       
# CppCoreGuidelines.md:12788
msgid "12788    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12789
msgid "12789    `vector` and `array` are the only standard containers that offer the fastest general-purpose access (random access, including being vectorization-friendly), the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly), and the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly)."
msgstr""

# CppCoreGuidelines.md:12790
msgid "12790    Usually you need to add and remove elements from the container, so use `vector` by default; if you don't need to modify the container's size, use `array`."
msgstr""

       
# CppCoreGuidelines.md:12791
msgid "12791    Even when other containers seem more suited, such a `map` for O(log N) lookup performance or a `list` for efficient insertion in the middle, a `vector` will usually still perform better for containers up to a few KB in size."
msgstr""

       
# CppCoreGuidelines.md:12792
msgid "12792    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12793
msgid "12793    `string` should not be used as a container of individual characters. A `string` is a textual string; if you want a container of characters, use `vector</*char_type*/>` or `array</*char_type*/>` instead."
msgstr""

       
# CppCoreGuidelines.md:12794
msgid "12794    ##### Exceptions"
msgstr""

       
# CppCoreGuidelines.md:12795
msgid "12795    If you have a good reason to use another container, use that instead. For example:"
msgstr""

       
# CppCoreGuidelines.md:12796
msgid "12796    * If `vector` suits your needs but you don't need the container to be variable size, use `array` instead."
msgstr""

       
# CppCoreGuidelines.md:12797
msgid "12797    * If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted `vector` is infeasible, go ahead and use an `unordered_map` or `map` instead."
msgstr""

       
# CppCoreGuidelines.md:12798
msgid "12798    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12799
msgid "12799    * Flag a `vector` whose size never changes after construction (such as because it's `const` or because no non-`const` functions are called on it). To fix: Use an `array` instead."
msgstr""

       
# CppCoreGuidelines.md:12800
msgid "12800    ### <a name=\"Rsl-bounds\"></a>SL.con.3: Avoid bounds errors"
msgstr""

       
# CppCoreGuidelines.md:12801
msgid "12801    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12802
msgid "12802    Read or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations."
msgstr""

       
# CppCoreGuidelines.md:12803
msgid "12803    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12804
msgid "12804    The standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take `span`."
msgstr""

# CppCoreGuidelines.md:12805
msgid "12805    Standard types such as `vector` can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with `at()`."
msgstr""

       
# CppCoreGuidelines.md:12806
msgid "12806    Ideally, the in-bounds guarantee should be statically enforced."
msgstr""

# CppCoreGuidelines.md:12807
msgid "12807    For example:"
msgstr""

       
# CppCoreGuidelines.md:12808
msgid "12808    * a range-`for` cannot loop beyond the range of the container to which it is applied"
msgstr""

# CppCoreGuidelines.md:12809
msgid "12809    * a `v.begin(),v.end()` is easily determined to be bounds safe"
msgstr""

       
# CppCoreGuidelines.md:12810
msgid "12810    Such loops are as fast as any unchecked/unsafe equivalent."
msgstr""

       
# CppCoreGuidelines.md:12811
msgid "12811    Often a simple pre-check can eliminate the need for checking of individual indices."
msgstr""

# CppCoreGuidelines.md:12812
msgid "12812    For example"
msgstr""

       
# CppCoreGuidelines.md:12813
msgid "12813    * for `v.begin(),v.begin()+i` the `i` can easily be checked against `v.size()`"
msgstr""

       
# CppCoreGuidelines.md:12814
msgid "12814    Such loops can be much faster than individually checked element accesses."
msgstr""

       
# CppCoreGuidelines.md:12815
msgid "12815    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12816
msgid "12816        void f()"
msgstr""

# CppCoreGuidelines.md:12817
msgid "12817        {"
msgstr""

# CppCoreGuidelines.md:12818
msgid "12818            array<int, 10> a, b;"
msgstr""

# CppCoreGuidelines.md:12819
msgid "12819            memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))"
msgstr""

# CppCoreGuidelines.md:12820
msgid "12820            memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))"
msgstr""

# CppCoreGuidelines.md:12821
msgid "12821        }"
msgstr""

       
# CppCoreGuidelines.md:12822
msgid "12822    Also, `std::array<>::fill()` or `std::fill()` or even an empty initializer are better candidate than `memset()`."
msgstr""

       
# CppCoreGuidelines.md:12823
msgid "12823    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:12824
msgid "12824        void f()"
msgstr""

# CppCoreGuidelines.md:12825
msgid "12825        {"
msgstr""

# CppCoreGuidelines.md:12826
msgid "12826            array<int, 10> a, b, c{};       // c is initialized to zero"
msgstr""

# CppCoreGuidelines.md:12827
msgid "12827            a.fill(0);"
msgstr""

# CppCoreGuidelines.md:12828
msgid "12828            fill(b.begin(), b.end(), 0);    // std::fill()"
msgstr""

# CppCoreGuidelines.md:12829
msgid "12829            fill(b, 0);                     // std::fill() + Ranges TS"
msgstr""

       
# CppCoreGuidelines.md:12830
msgid "12830            if ( a == b ) {"
msgstr""

# CppCoreGuidelines.md:12831
msgid "12831              // ..."
msgstr""

# CppCoreGuidelines.md:12832
msgid "12832            }"
msgstr""

# CppCoreGuidelines.md:12833
msgid "12833        }"
msgstr""

       
# CppCoreGuidelines.md:12834
msgid "12834    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12835
msgid "12835    If code is using an unmodified standard library, then there are still workarounds that enable use of `std::array` and `std::vector` in a bounds-safe manner. Code can call the `.at()` member function on each class, which will result in an `std::out_of_range` exception being thrown. Alternatively, code can call the `at()` free function, which will result in fail-fast (or a customized action) on a bounds violation."
msgstr""

       
# CppCoreGuidelines.md:12836
msgid "12836        void f(std::vector<int>& v, std::array<int, 12> a, int i)"
msgstr""

# CppCoreGuidelines.md:12837
msgid "12837        {"
msgstr""

# CppCoreGuidelines.md:12838
msgid "12838            v[0] = a[0];        // BAD"
msgstr""

# CppCoreGuidelines.md:12839
msgid "12839            v.at(0) = a[0];     // OK (alternative 1)"
msgstr""

# CppCoreGuidelines.md:12840
msgid "12840            at(v, 0) = a[0];    // OK (alternative 2)"
msgstr""

       
# CppCoreGuidelines.md:12841
msgid "12841            v.at(0) = a[i];     // BAD"
msgstr""

# CppCoreGuidelines.md:12842
msgid "12842            v.at(0) = a.at(i);  // OK (alternative 1)"
msgstr""

# CppCoreGuidelines.md:12843
msgid "12843            v.at(0) = at(a, i); // OK (alternative 2)"
msgstr""

# CppCoreGuidelines.md:12844
msgid "12844        }"
msgstr""

       
# CppCoreGuidelines.md:12845
msgid "12845    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12846
msgid "12846    * Issue a diagnostic for any call to a standard-library function that is not bounds-checked."
msgstr""

# CppCoreGuidelines.md:12847
msgid "12847    ??? insert link to a list of banned functions"
msgstr""

       
# CppCoreGuidelines.md:12848
msgid "12848    This rule is part of the [bounds profile](#SS-bounds)."
msgstr""

       
# CppCoreGuidelines.md:12849
msgid "12849    **TODO Notes**:"
msgstr""

       
# CppCoreGuidelines.md:12850
msgid "12850    * Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized."
msgstr""

# CppCoreGuidelines.md:12851
msgid "12851    * We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like `memcmp` and shipping them in the GSL."
msgstr""

# CppCoreGuidelines.md:12852
msgid "12852    * For existing stdlib functions and types like `vector` that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members)."
msgstr""

       
       
       
# CppCoreGuidelines.md:12853
msgid "12853    ## <a name=\"SS-string\"></a>SL.str: String"
msgstr""

       
# CppCoreGuidelines.md:12854
msgid "12854    Text manipulation is a huge topic."
msgstr""

# CppCoreGuidelines.md:12855
msgid "12855    `std::string` doesn't cover all of it."
msgstr""

# CppCoreGuidelines.md:12856
msgid "12856    This section primarily tries to clarify `std::string`'s relation to `char*`, `zstring`, `string_view`, and `gsl::string_span`."
msgstr""

# CppCoreGuidelines.md:12857
msgid "12857    The important issue of non-ASCII character sets and encodings (e.g., `wchar_t`, Unicode, and UTF-8) will be covered elsewhere."
msgstr""

       
# CppCoreGuidelines.md:12858
msgid "12858    **See also**: [regular expressions](#SS-regex)"
msgstr""

       
# CppCoreGuidelines.md:12859
msgid "12859    Here, we use \"sequence of characters\" or \"string\" to refer to a sequence of characters meant to be read as text (somehow, eventually)."
msgstr""

# CppCoreGuidelines.md:12860
msgid "12860    We don't consider"
msgstr""

       
# CppCoreGuidelines.md:12861
msgid "12861    String summary:"
msgstr""

       
# CppCoreGuidelines.md:12862
msgid "12862    * [SL.str.1: Use `std::string` to own character sequences](#Rstr-string)"
msgstr""

# CppCoreGuidelines.md:12863
msgid "12863    * [SL.str.2: Use `std::string_view` or `gsl::string_span` to refer to character sequences](#Rstr-view)"
msgstr""

# CppCoreGuidelines.md:12864
msgid "12864    * [SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters](#Rstr-zstring)"
msgstr""

# CppCoreGuidelines.md:12865
msgid "12865    * [SL.str.4: Use `char*` to refer to a single character](#Rstr-char*)"
msgstr""

# CppCoreGuidelines.md:12866
msgid "12866    * [SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters](#Rstr-byte)"
msgstr""

       
# CppCoreGuidelines.md:12867
msgid "12867    * [SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations](#Rstr-locale)"
msgstr""

# CppCoreGuidelines.md:12868
msgid "12868    * [SL.str.11: Use `gsl::string_span` rather than `std::string_view` when you need to mutate a string](#Rstr-span)"
msgstr""

# CppCoreGuidelines.md:12869
msgid "12869    * [SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s](#Rstr-s)"
msgstr""

       
# CppCoreGuidelines.md:12870
msgid "12870    **See also**:"
msgstr""

       
# CppCoreGuidelines.md:12871
msgid "12871    * [F.24 span](#Rf-range)"
msgstr""

# CppCoreGuidelines.md:12872
msgid "12872    * [F.25 zstring](#Rf-zstring)"
msgstr""

       
       
# CppCoreGuidelines.md:12873
msgid "12873    ### <a name=\"Rstr-string\"></a>SL.str.1: Use `std::string` to own character sequences"
msgstr""

       
# CppCoreGuidelines.md:12874
msgid "12874    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12875
msgid "12875    `string` correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations."
msgstr""

       
# CppCoreGuidelines.md:12876
msgid "12876    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12877
msgid "12877        vector<string> read_until(const string& terminator)"
msgstr""

# CppCoreGuidelines.md:12878
msgid "12878        {"
msgstr""

# CppCoreGuidelines.md:12879
msgid "12879            vector<string> res;"
msgstr""

# CppCoreGuidelines.md:12880
msgid "12880            for (string s; cin >> s && s != terminator; ) // read a word"
msgstr""

# CppCoreGuidelines.md:12881
msgid "12881                res.push_back(s);"
msgstr""

# CppCoreGuidelines.md:12882
msgid "12882            return res;"
msgstr""

# CppCoreGuidelines.md:12883
msgid "12883        }"
msgstr""

       
# CppCoreGuidelines.md:12884
msgid "12884    Note how `>>` and `!=` are provided for `string` (as examples of useful operations) and there are no explicit"
msgstr""

# CppCoreGuidelines.md:12885
msgid "12885    allocations, deallocations, or range checks (`string` takes care of those)."
msgstr""

       
# CppCoreGuidelines.md:12886
msgid "12886    In C++17, we might use `string_view` as the argument, rather than `const string*` to allow more flexibility to callers:"
msgstr""

       
# CppCoreGuidelines.md:12887
msgid "12887        vector<string> read_until(string_view terminator)   // C++17"
msgstr""

# CppCoreGuidelines.md:12888
msgid "12888        {"
msgstr""

# CppCoreGuidelines.md:12889
msgid "12889            vector<string> res;"
msgstr""

# CppCoreGuidelines.md:12890
msgid "12890            for (string s; cin >> s && s != terminator; ) // read a word"
msgstr""

# CppCoreGuidelines.md:12891
msgid "12891                res.push_back(s);"
msgstr""

# CppCoreGuidelines.md:12892
msgid "12892            return res;"
msgstr""

# CppCoreGuidelines.md:12893
msgid "12893        }"
msgstr""

       
# CppCoreGuidelines.md:12894
msgid "12894    The `gsl::string_span` is a current alternative offering most of the benefits of `std::string_view` for simple examples:"
msgstr""

       
# CppCoreGuidelines.md:12895
msgid "12895        vector<string> read_until(string_span terminator)"
msgstr""

# CppCoreGuidelines.md:12896
msgid "12896        {"
msgstr""

# CppCoreGuidelines.md:12897
msgid "12897            vector<string> res;"
msgstr""

# CppCoreGuidelines.md:12898
msgid "12898            for (string s; cin >> s && s != terminator; ) // read a word"
msgstr""

# CppCoreGuidelines.md:12899
msgid "12899                res.push_back(s);"
msgstr""

# CppCoreGuidelines.md:12900
msgid "12900            return res;"
msgstr""

# CppCoreGuidelines.md:12901
msgid "12901        }"
msgstr""

       
# CppCoreGuidelines.md:12902
msgid "12902    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12903
msgid "12903    Don't use C-style strings for operations that require non-trivial memory management"
msgstr""

       
# CppCoreGuidelines.md:12904
msgid "12904        char* cat(const char* s1, const char* s2)   // beware!"
msgstr""

# CppCoreGuidelines.md:12905
msgid "12905            // return s1 + '.' + s2"
msgstr""

# CppCoreGuidelines.md:12906
msgid "12906        {"
msgstr""

# CppCoreGuidelines.md:12907
msgid "12907            int l1 = strlen(s1);"
msgstr""

# CppCoreGuidelines.md:12908
msgid "12908            int l2 = strlen(s2);"
msgstr""

# CppCoreGuidelines.md:12909
msgid "12909            char* p = (char*) malloc(l1 + l2 + 2);"
msgstr""

# CppCoreGuidelines.md:12910
msgid "12910            strcpy(p, s1, l1);"
msgstr""

# CppCoreGuidelines.md:12911
msgid "12911            p[l1] = '.';"
msgstr""

# CppCoreGuidelines.md:12912
msgid "12912            strcpy(p + l1 + 1, s2, l2);"
msgstr""

# CppCoreGuidelines.md:12913
msgid "12913            p[l1 + l2 + 1] = 0;"
msgstr""

# CppCoreGuidelines.md:12914
msgid "12914            return p;"
msgstr""

# CppCoreGuidelines.md:12915
msgid "12915        }"
msgstr""

       
# CppCoreGuidelines.md:12916
msgid "12916    Did we get that right?"
msgstr""

# CppCoreGuidelines.md:12917
msgid "12917    Will the caller remember to `free()` the returned pointer?"
msgstr""

# CppCoreGuidelines.md:12918
msgid "12918    Will this code pass a security review?"
msgstr""

       
# CppCoreGuidelines.md:12919
msgid "12919    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12920
msgid "12920    Do not assume that `string` is slower than lower-level techniques without measurement and remember than not all code is performance critical."
msgstr""

# CppCoreGuidelines.md:12921
msgid "12921    [Don't optimize prematurely](#Rper-Knuth)"
msgstr""

       
# CppCoreGuidelines.md:12922
msgid "12922    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12923
msgid "12923    ???"
msgstr""

       
# CppCoreGuidelines.md:12924
msgid "12924    ### <a name=\"Rstr-view\"></a>SL.str.2: Use `std::string_view` or `gsl::string_span` to refer to character sequences"
msgstr""

       
# CppCoreGuidelines.md:12925
msgid "12925    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12926
msgid "12926    `std::string_view` or `gsl::string_span` provides simple and (potentially) safe access to character sequences independently of how"
msgstr""

# CppCoreGuidelines.md:12927
msgid "12927    those sequences are allocated and stored."
msgstr""

       
# CppCoreGuidelines.md:12928
msgid "12928    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12929
msgid "12929        vector<string> read_until(string_span terminator);"
msgstr""

       
# CppCoreGuidelines.md:12930
msgid "12930        void user(zstring p, const string& s, string_span ss)"
msgstr""

# CppCoreGuidelines.md:12931
msgid "12931        {"
msgstr""

# CppCoreGuidelines.md:12932
msgid "12932            auto v1 = read_until(p);"
msgstr""

# CppCoreGuidelines.md:12933
msgid "12933            auto v2 = read_until(s);"
msgstr""

# CppCoreGuidelines.md:12934
msgid "12934            auto v3 = read_until(ss);"
msgstr""

# CppCoreGuidelines.md:12935
msgid "12935            // ..."
msgstr""

# CppCoreGuidelines.md:12936
msgid "12936        }"
msgstr""

       
# CppCoreGuidelines.md:12937
msgid "12937    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12938
msgid "12938    `std::string_view` (C++17) is read-only."
msgstr""

       
# CppCoreGuidelines.md:12939
msgid "12939    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12940
msgid "12940    ???"
msgstr""

       
# CppCoreGuidelines.md:12941
msgid "12941    ### <a name=\"Rstr-zstring\"></a>SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters"
msgstr""

       
# CppCoreGuidelines.md:12942
msgid "12942    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12943
msgid "12943    Readability."
msgstr""

# CppCoreGuidelines.md:12944
msgid "12944    Statement of intent."
msgstr""

# CppCoreGuidelines.md:12945
msgid "12945    A plain `char*` can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer."
msgstr""

# CppCoreGuidelines.md:12946
msgid "12946    Distinguishing these alternatives prevents misunderstandings and bugs."
msgstr""

       
# CppCoreGuidelines.md:12947
msgid "12947    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12948
msgid "12948        void f1(const char* s); // s is probably a string"
msgstr""

       
# CppCoreGuidelines.md:12949
msgid "12949    All we know is that it is supposed to be the nullptr or point to at least one character"
msgstr""

       
# CppCoreGuidelines.md:12950
msgid "12950        void f1(zstring s);     // s is a C-style string or the nullptr"
msgstr""

# CppCoreGuidelines.md:12951
msgid "12951        void f1(czstring s);    // s is a C-style string constant or the nullptr"
msgstr""

# CppCoreGuidelines.md:12952
msgid "12952        void f1(std::byte* s);  // s is a pointer to a byte (C++17)"
msgstr""

       
# CppCoreGuidelines.md:12953
msgid "12953    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12954
msgid "12954    Don't convert a C-style string to `string` unless there is a reason to."
msgstr""

       
# CppCoreGuidelines.md:12955
msgid "12955    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12956
msgid "12956    Like any other \"plain pointer\", a `zstring` should not represent ownership."
msgstr""

       
# CppCoreGuidelines.md:12957
msgid "12957    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12958
msgid "12958    There are billions of lines of C++ \"out there\", most use `char*` and `const char*` without documenting intent."
msgstr""

# CppCoreGuidelines.md:12959
msgid "12959    They are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of `void*`)."
msgstr""

# CppCoreGuidelines.md:12960
msgid "12960    It is hard to separate these uses, so this guideline is hard to follow."
msgstr""

# CppCoreGuidelines.md:12961
msgid "12961    This is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible.."
msgstr""

       
# CppCoreGuidelines.md:12962
msgid "12962    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12963
msgid "12963    * Flag uses of `[]` on a `char*`"
msgstr""

# CppCoreGuidelines.md:12964
msgid "12964    * Flag uses of `delete` on a `char*`"
msgstr""

# CppCoreGuidelines.md:12965
msgid "12965    * Flag uses of `free()` on a `char*`"
msgstr""

       
# CppCoreGuidelines.md:12966
msgid "12966    ### <a name=\"Rstr-char*\"></a>SL.str.4: Use `char*` to refer to a single character"
msgstr""

       
# CppCoreGuidelines.md:12967
msgid "12967    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12968
msgid "12968    The variety of uses of `char*` in current code is a major source of errors."
msgstr""

       
# CppCoreGuidelines.md:12969
msgid "12969    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:12970
msgid "12970        char arr[] = {'a', 'b', 'c'};"
msgstr""

       
# CppCoreGuidelines.md:12971
msgid "12971        void print(const char* p)"
msgstr""

# CppCoreGuidelines.md:12972
msgid "12972        {"
msgstr""

# CppCoreGuidelines.md:12973
msgid "12973            cout << p << '\\n';"
msgstr""

# CppCoreGuidelines.md:12974
msgid "12974        }"
msgstr""

       
# CppCoreGuidelines.md:12975
msgid "12975        void use()"
msgstr""

# CppCoreGuidelines.md:12976
msgid "12976        {"
msgstr""

# CppCoreGuidelines.md:12977
msgid "12977            print(arr);   // run-time error; potentially very bad"
msgstr""

# CppCoreGuidelines.md:12978
msgid "12978        }"
msgstr""

       
# CppCoreGuidelines.md:12979
msgid "12979    The array `arr` is not a C-style string because it is not zero-terminated."
msgstr""

       
# CppCoreGuidelines.md:12980
msgid "12980    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:12981
msgid "12981    See [`zstring`](#Rstr-zstring), [`string`](#Rstr-string), and [`string_span`](#Rstr-view)."
msgstr""

       
# CppCoreGuidelines.md:12982
msgid "12982    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12983
msgid "12983    * Flag uses of `[]` on a `char*`"
msgstr""

       
# CppCoreGuidelines.md:12984
msgid "12984    ### <a name=\"Rstr-byte\"></a>SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters"
msgstr""

       
# CppCoreGuidelines.md:12985
msgid "12985    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12986
msgid "12986    Use of `char*` to represent a pointer to something that is not necessarily a character causes confusion"
msgstr""

# CppCoreGuidelines.md:12987
msgid "12987    and disables valuable optimizations."
msgstr""

       
# CppCoreGuidelines.md:12988
msgid "12988    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12989
msgid "12989        ???"
msgstr""

       
# CppCoreGuidelines.md:12990
msgid "12990    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:12991
msgid "12991    C++17"
msgstr""

       
# CppCoreGuidelines.md:12992
msgid "12992    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:12993
msgid "12993    ???"
msgstr""

       
       
# CppCoreGuidelines.md:12994
msgid "12994    ### <a name=\"Rstr-locale\"></a>SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations"
msgstr""

       
# CppCoreGuidelines.md:12995
msgid "12995    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:12996
msgid "12996    `std::string` supports standard-library [`locale` facilities](#Rstr-locale)"
msgstr""

       
# CppCoreGuidelines.md:12997
msgid "12997    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:12998
msgid "12998        ???"
msgstr""

       
# CppCoreGuidelines.md:12999
msgid "12999    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13000
msgid "13000    ???"
msgstr""

       
# CppCoreGuidelines.md:13001
msgid "13001    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13002
msgid "13002    ???"
msgstr""

       
# CppCoreGuidelines.md:13003
msgid "13003    ### <a name=\"Rstr-span\"></a>SL.str.11: Use `gsl::string_span` rather than `std::string_view` when you need to mutate a string"
msgstr""

       
# CppCoreGuidelines.md:13004
msgid "13004    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13005
msgid "13005    `std::string_view` is read-only."
msgstr""

       
# CppCoreGuidelines.md:13006
msgid "13006    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13007
msgid "13007    ???"
msgstr""

       
# CppCoreGuidelines.md:13008
msgid "13008    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13009
msgid "13009    ???"
msgstr""

       
# CppCoreGuidelines.md:13010
msgid "13010    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13011
msgid "13011    The compiler will flag attempts to write to a `string_view`."
msgstr""

       
# CppCoreGuidelines.md:13012
msgid "13012    ### <a name=\"Rstr-s\"></a>SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s"
msgstr""

       
# CppCoreGuidelines.md:13013
msgid "13013    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13014
msgid "13014    Direct expression of an idea minimizes mistakes."
msgstr""

       
# CppCoreGuidelines.md:13015
msgid "13015    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13016
msgid "13016        auto pp1 = make_pair(\"Tokyo\", 9.00);         // {C-style string,double} intended?"
msgstr""

# CppCoreGuidelines.md:13017
msgid "13017        pair<string, double> pp2 = {\"Tokyo\", 9.00};  // a bit verbose"
msgstr""

# CppCoreGuidelines.md:13018
msgid "13018        auto pp3 = make_pair(\"Tokyo\"s, 9.00);        // {std::string,double}    // C++14"
msgstr""

# CppCoreGuidelines.md:13019
msgid "13019        pair pp4 = {\"Tokyo\"s, 9.00};                 // {std::string,double}    // C++17"
msgstr""

       
       
# CppCoreGuidelines.md:13020
msgid "13020    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13021
msgid "13021    C++14"
msgstr""

       
# CppCoreGuidelines.md:13022
msgid "13022    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13023
msgid "13023    ???"
msgstr""

       
       
# CppCoreGuidelines.md:13024
msgid "13024    ## <a name=\"SS-io\"></a>SL.io: Iostream"
msgstr""

       
# CppCoreGuidelines.md:13025
msgid "13025    `iostream`s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O."
msgstr""

# CppCoreGuidelines.md:13026
msgid "13026    It supports multiple (and user extensible) buffering strategies and multiple locales."
msgstr""

# CppCoreGuidelines.md:13027
msgid "13027    It can be used for conventional I/O, reading and writing to memory (string streams),"
msgstr""

# CppCoreGuidelines.md:13028
msgid "13028    and user-defines extensions, such as streaming across networks (asio: not yet standardized)."
msgstr""

       
# CppCoreGuidelines.md:13029
msgid "13029    Iostream rule summary:"
msgstr""

       
# CppCoreGuidelines.md:13030
msgid "13030    * [SL.io.1: Use character-level input only when you have to](#Rio-low)"
msgstr""

# CppCoreGuidelines.md:13031
msgid "13031    * [SL.io.2: When reading, always consider ill-formed input](#Rio-validate)"
msgstr""

# CppCoreGuidelines.md:13032
msgid "13032    * [SL.io.3: Prefer iostreams for I/O](#Rio-streams)"
msgstr""

# CppCoreGuidelines.md:13033
msgid "13033    * [SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`](#Rio-sync)"
msgstr""

# CppCoreGuidelines.md:13034
msgid "13034    * [SL.io.50: Avoid `endl`](#Rio-endl)"
msgstr""

# CppCoreGuidelines.md:13035
msgid "13035    * [???](#???)"
msgstr""

       
# CppCoreGuidelines.md:13036
msgid "13036    ### <a name=\"Rio-low\"></a>SL.io.1: Use character-level input only when you have to"
msgstr""

       
# CppCoreGuidelines.md:13037
msgid "13037    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13038
msgid "13038    Unless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone"
msgstr""

# CppCoreGuidelines.md:13039
msgid "13039    and potentially inefficient composition of tokens out of characters."
msgstr""

       
# CppCoreGuidelines.md:13040
msgid "13040    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13041
msgid "13041        char c;"
msgstr""

# CppCoreGuidelines.md:13042
msgid "13042        char buf[128];"
msgstr""

# CppCoreGuidelines.md:13043
msgid "13043        int i = 0;"
msgstr""

# CppCoreGuidelines.md:13044
msgid "13044        while (cin.get(c) && !isspace(c) && i < 128)"
msgstr""

# CppCoreGuidelines.md:13045
msgid "13045            buf[i++] = c;"
msgstr""

# CppCoreGuidelines.md:13046
msgid "13046        if (i == 128) {"
msgstr""

# CppCoreGuidelines.md:13047
msgid "13047            // ... handle too long string ...."
msgstr""

# CppCoreGuidelines.md:13048
msgid "13048        }"
msgstr""

       
# CppCoreGuidelines.md:13049
msgid "13049    Better (much simpler and probably faster):"
msgstr""

       
# CppCoreGuidelines.md:13050
msgid "13050        string s;"
msgstr""

# CppCoreGuidelines.md:13051
msgid "13051        s.reserve(128);"
msgstr""

# CppCoreGuidelines.md:13052
msgid "13052        cin >> s;"
msgstr""

       
# CppCoreGuidelines.md:13053
msgid "13053    and the `reserve(128)` is probably not worthwhile."
msgstr""

       
# CppCoreGuidelines.md:13054
msgid "13054    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13055
msgid "13055    ???"
msgstr""

       
       
# CppCoreGuidelines.md:13056
msgid "13056    ### <a name=\"Rio-validate\"></a>SL.io.2: When reading, always consider ill-formed input"
msgstr""

       
# CppCoreGuidelines.md:13057
msgid "13057    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13058
msgid "13058    Errors are typically best handled as soon as possible."
msgstr""

# CppCoreGuidelines.md:13059
msgid "13059    If input isn't validated, every function must be written to cope with bad data (and that is not practical)."
msgstr""

       
# CppCoreGuidelines.md:13060
msgid "13060    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13061
msgid "13061        ???"
msgstr""

       
# CppCoreGuidelines.md:13062
msgid "13062    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13063
msgid "13063    ???"
msgstr""

       
# CppCoreGuidelines.md:13064
msgid "13064    ### <a name=\"Rio-streams\"></a>SL.io.3: Prefer `iostream`s for I/O"
msgstr""

       
# CppCoreGuidelines.md:13065
msgid "13065    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13066
msgid "13066    `iostream`s are safe, flexible, and extensible."
msgstr""

       
# CppCoreGuidelines.md:13067
msgid "13067    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13068
msgid "13068        // write a complex number:"
msgstr""

# CppCoreGuidelines.md:13069
msgid "13069        complex<double> z{ 3, 4 };"
msgstr""

# CppCoreGuidelines.md:13070
msgid "13070        cout << z << '\\n';"
msgstr""

       
# CppCoreGuidelines.md:13071
msgid "13071    `complex` is a user-defined type and its I/O is defined without modifying the `iostream` library."
msgstr""

       
# CppCoreGuidelines.md:13072
msgid "13072    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13073
msgid "13073        // read a file of complex numbers:"
msgstr""

# CppCoreGuidelines.md:13074
msgid "13074        for (complex<double> z; cin >> z; )"
msgstr""

# CppCoreGuidelines.md:13075
msgid "13075            v.push_back(z);"
msgstr""

       
# CppCoreGuidelines.md:13076
msgid "13076    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:13077
msgid "13077    ??? performance ???"
msgstr""

       
# CppCoreGuidelines.md:13078
msgid "13078    ##### Discussion: `iostream`s vs. the `printf()` family"
msgstr""

       
# CppCoreGuidelines.md:13079
msgid "13079    It is often (and often correctly) pointed out that the `printf()` family has two advantages compared to `iostream`s:"
msgstr""

# CppCoreGuidelines.md:13080
msgid "13080    flexibility of formatting and performance."
msgstr""

# CppCoreGuidelines.md:13081
msgid "13081    This has to be weighed against `iostream`s advantages of extensibility to handle user-defined types, resilient against security violations,"
msgstr""

# CppCoreGuidelines.md:13082
msgid "13082    implicit memory management, and `locale` handling."
msgstr""

       
# CppCoreGuidelines.md:13083
msgid "13083    If you need I/O performance, you can almost always do better than `printf()`."
msgstr""

       
# CppCoreGuidelines.md:13084
msgid "13084    `gets()` `scanf()` using `s`, and `printf()` using `%s` are security hazards (vulnerable to buffer overflow and generally error-prone)."
msgstr""

# CppCoreGuidelines.md:13085
msgid "13085    In C11, they are replaced by `gets_s()`, `scanf_s()`, and `printf_s()` as safer alternatives, but they are still not type safe."
msgstr""

       
# CppCoreGuidelines.md:13086
msgid "13086    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13087
msgid "13087    Optionally flag `<cstdio>` and `<stdio.h>`."
msgstr""

       
# CppCoreGuidelines.md:13088
msgid "13088    ### <a name=\"Rio-sync\"></a>SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`"
msgstr""

       
# CppCoreGuidelines.md:13089
msgid "13089    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13090
msgid "13090    Synchronizing `iostreams` with `printf-style` I/O can be costly."
msgstr""

# CppCoreGuidelines.md:13091
msgid "13091    `cin` and `cout` are by default synchronized with `printf`."
msgstr""

       
# CppCoreGuidelines.md:13092
msgid "13092    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13093
msgid "13093        int main()"
msgstr""

# CppCoreGuidelines.md:13094
msgid "13094        {"
msgstr""

# CppCoreGuidelines.md:13095
msgid "13095            ios_base::sync_with_stdio(false);"
msgstr""

# CppCoreGuidelines.md:13096
msgid "13096            // ... use iostreams ..."
msgstr""

# CppCoreGuidelines.md:13097
msgid "13097        }"
msgstr""

       
# CppCoreGuidelines.md:13098
msgid "13098    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13099
msgid "13099    ???"
msgstr""

       
# CppCoreGuidelines.md:13100
msgid "13100    ### <a name=\"Rio-endl\"></a>SL.io.50: Avoid `endl`"
msgstr""

       
# CppCoreGuidelines.md:13101
msgid "13101    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13102
msgid "13102    The `endl` manipulator is mostly equivalent to `'\\n'` and `\"\\n\"`;"
msgstr""

# CppCoreGuidelines.md:13103
msgid "13103    as most commonly used it simply slows down output by doing redundant `flush()`s."
msgstr""

# CppCoreGuidelines.md:13104
msgid "13104    This slowdown can be significant compared to `printf`-style output."
msgstr""

       
# CppCoreGuidelines.md:13105
msgid "13105    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13106
msgid "13106        cout << \"Hello, World!\" << endl;    // two output operations and a flush"
msgstr""

# CppCoreGuidelines.md:13107
msgid "13107        cout << \"Hello, World!\\n\";          // one output operation and no flush"
msgstr""

       
# CppCoreGuidelines.md:13108
msgid "13108    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13109
msgid "13109    For `cin`/`cout` (and equivalent) interaction, there is no reason to flush; that's done automatically."
msgstr""

# CppCoreGuidelines.md:13110
msgid "13110    For writing to a file, there is rarely a need to `flush`."
msgstr""

       
# CppCoreGuidelines.md:13111
msgid "13111    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13112
msgid "13112    Apart from the (occasionally important) issue of performance,"
msgstr""

# CppCoreGuidelines.md:13113
msgid "13113    the choice between `'\\n'` and `endl` is almost completely aesthetic."
msgstr""

       
# CppCoreGuidelines.md:13114
msgid "13114    ## <a name=\"SS-regex\"></a>SL.regex: Regex"
msgstr""

       
# CppCoreGuidelines.md:13115
msgid "13115    `<regex>` is the standard C++ regular expression library."
msgstr""

# CppCoreGuidelines.md:13116
msgid "13116    It supports a variety of regular expression pattern conventions."
msgstr""

       
# CppCoreGuidelines.md:13117
msgid "13117    ## <a name=\"SS-chrono\"></a>SL.chrono: Time"
msgstr""

       
# CppCoreGuidelines.md:13118
msgid "13118    `<chrono>` (defined in namespace `std::chrono`) provides the notions of `time_point` and `duration` together with functions for"
msgstr""

# CppCoreGuidelines.md:13119
msgid "13119    outputting time in various units."
msgstr""

# CppCoreGuidelines.md:13120
msgid "13120    It provides clocks for registering `time_points`."
msgstr""

       
# CppCoreGuidelines.md:13121
msgid "13121    ## <a name=\"SS-clib\"></a>SL.C: The C Standard Library"
msgstr""

       
# CppCoreGuidelines.md:13122
msgid "13122    ???"
msgstr""

       
# CppCoreGuidelines.md:13123
msgid "13123    C Standard Library rule summary:"
msgstr""

       
# CppCoreGuidelines.md:13124
msgid "13124    * [S.C.1: Don't use setjmp/longjmp](#Rclib-jmp)"
msgstr""

# CppCoreGuidelines.md:13125
msgid "13125    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13126
msgid "13126    * [???](#???)"
msgstr""

       
# CppCoreGuidelines.md:13127
msgid "13127    ### <a name=\"Rclib-jmp\"></a>SL.C.1: Don't use setjmp/longjmp"
msgstr""

       
# CppCoreGuidelines.md:13128
msgid "13128    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13129
msgid "13129    a `longjmp` ignores destructors, thus invalidating all resource-management strategies relying on RAII"
msgstr""

       
# CppCoreGuidelines.md:13130
msgid "13130    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13131
msgid "13131    Flag all occurrences of `longjmp`and `setjmp`"
msgstr""

       
       
       
# CppCoreGuidelines.md:13132
msgid "13132    # <a name=\"S-A\"></a>A: Architectural ideas"
msgstr""

       
# CppCoreGuidelines.md:13133
msgid "13133    This section contains ideas about higher-level architectural ideas and libraries."
msgstr""

       
# CppCoreGuidelines.md:13134
msgid "13134    Architectural rule summary:"
msgstr""

       
# CppCoreGuidelines.md:13135
msgid "13135    * [A.1: Separate stable from less stable part of code](#Ra-stable)"
msgstr""

# CppCoreGuidelines.md:13136
msgid "13136    * [A.2: Express potentially reusable parts as a library](#Ra-lib)"
msgstr""

# CppCoreGuidelines.md:13137
msgid "13137    * [A.4: There should be no cycles among libraries](#?Ra-dag)"
msgstr""

# CppCoreGuidelines.md:13138
msgid "13138    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13139
msgid "13139    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13140
msgid "13140    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13141
msgid "13141    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13142
msgid "13142    * [???](#???)"
msgstr""

# CppCoreGuidelines.md:13143
msgid "13143    * [???](#???)"
msgstr""

       
# CppCoreGuidelines.md:13144
msgid "13144    ### <a name=\"Ra-stable\"></a>A.1: Separate stable from less stable part of code"
msgstr""

       
# CppCoreGuidelines.md:13145
msgid "13145    ???"
msgstr""

       
# CppCoreGuidelines.md:13146
msgid "13146    ### <a name=\"Ra-lib\"></a>A.2: Express potentially reusable parts as a library"
msgstr""

       
# CppCoreGuidelines.md:13147
msgid "13147    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13148
msgid "13148    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13149
msgid "13149    A library is a collection of declarations and definitions maintained, documented, and shipped together."
msgstr""

# CppCoreGuidelines.md:13150
msgid "13150    A library could be a set of headers (a \"header only library\") or a set of headers plus a set of object files."
msgstr""

# CppCoreGuidelines.md:13151
msgid "13151    A library can be statically or dynamically linked into a program, or it may be `#include`d"
msgstr""

       
       
# CppCoreGuidelines.md:13152
msgid "13152    ### <a name=\"Ra-dag\"></a>A.4: There should be no cycles among libraries"
msgstr""

       
# CppCoreGuidelines.md:13153
msgid "13153    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13154
msgid "13154    * A cycle implies complication of the build process."
msgstr""

# CppCoreGuidelines.md:13155
msgid "13155    * Cycles are hard to understand and may introduce indeterminism (unspecified behavior)."
msgstr""

       
# CppCoreGuidelines.md:13156
msgid "13156    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13157
msgid "13157    A library can contain cyclic references in the definition of its components."
msgstr""

# CppCoreGuidelines.md:13158
msgid "13158    For example:"
msgstr""

       
# CppCoreGuidelines.md:13159
msgid "13159        ???"
msgstr""

       
# CppCoreGuidelines.md:13160
msgid "13160    However, a library should not depend on another that depends on it."
msgstr""

       
       
# CppCoreGuidelines.md:13161
msgid "13161    # <a name=\"S-not\"></a>NR: Non-Rules and myths"
msgstr""

       
# CppCoreGuidelines.md:13162
msgid "13162    This section contains rules and guidelines that are popular somewhere, but that we deliberately don't recommend."
msgstr""

# CppCoreGuidelines.md:13163
msgid "13163    We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times."
msgstr""

# CppCoreGuidelines.md:13164
msgid "13164    However, in the context of the styles of programming we recommend and support with the guidelines, these \"non-rules\" would do harm."
msgstr""

       
# CppCoreGuidelines.md:13165
msgid "13165    Even today, there can be contexts where the rules make sense."
msgstr""

# CppCoreGuidelines.md:13166
msgid "13166    For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems,"
msgstr""

# CppCoreGuidelines.md:13167
msgid "13167    but please don't blindly trust \"common wisdom\" (e.g., unsupported statements about \"efficiency\");"
msgstr""

# CppCoreGuidelines.md:13168
msgid "13168    such \"wisdom\" may be based on decades-old information or experienced from languages with very different properties than C++"
msgstr""

# CppCoreGuidelines.md:13169
msgid "13169    (e.g., C or Java)."
msgstr""

       
# CppCoreGuidelines.md:13170
msgid "13170    The positive arguments for alternatives to these non-rules are listed in the rules offered as \"Alternatives\"."
msgstr""

       
# CppCoreGuidelines.md:13171
msgid "13171    Non-rule summary:"
msgstr""

       
# CppCoreGuidelines.md:13172
msgid "13172    * [NR.1: Don't: All declarations should be at the top of a function](#Rnr-top)"
msgstr""

# CppCoreGuidelines.md:13173
msgid "13173    * [NR.2: Don't: Have only a single `return`-statement in a function](#Rnr-single-return)"
msgstr""

# CppCoreGuidelines.md:13174
msgid "13174    * [NR.3: Don't: Don't use exceptions](#Rnr-no-exceptions)"
msgstr""

# CppCoreGuidelines.md:13175
msgid "13175    * [NR.4: Don't: Place each class declaration in its own source file](#Rnr-lots-of-files)"
msgstr""

# CppCoreGuidelines.md:13176
msgid "13176    * [NR.5: Don't: Don't do substantive work in a constructor; instead use two-phase initialization](#Rnr-two-phase-init)"
msgstr""

# CppCoreGuidelines.md:13177
msgid "13177    * [NR.6: Don't: Place all cleanup actions at the end of a function and `goto exit`](#Rnr-goto-exit)"
msgstr""

# CppCoreGuidelines.md:13178
msgid "13178    * [NR.7: Don't: Make all data members `protected`](#Rnr-protected-data)"
msgstr""

# CppCoreGuidelines.md:13179
msgid "13179    * ???"
msgstr""

       
# CppCoreGuidelines.md:13180
msgid "13180    ### <a name=\"Rnr-top\"></a>NR.1: Don't: All declarations should be at the top of a function"
msgstr""

       
# CppCoreGuidelines.md:13181
msgid "13181    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13182
msgid "13182    This rule is a legacy of old programming languages that didn't allow initialization of variables and constants after a statement."
msgstr""

# CppCoreGuidelines.md:13183
msgid "13183    This leads to longer programs and more errors caused by uninitialized and wrongly initialized variables."
msgstr""

       
# CppCoreGuidelines.md:13184
msgid "13184    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13185
msgid "13185        int use(int x)"
msgstr""

# CppCoreGuidelines.md:13186
msgid "13186        {"
msgstr""

# CppCoreGuidelines.md:13187
msgid "13187            int i;"
msgstr""

# CppCoreGuidelines.md:13188
msgid "13188            char c;"
msgstr""

# CppCoreGuidelines.md:13189
msgid "13189            double d;"
msgstr""

       
# CppCoreGuidelines.md:13190
msgid "13190            // ... some stuff ..."
msgstr""

       
# CppCoreGuidelines.md:13191
msgid "13191            if (x < i) {"
msgstr""

# CppCoreGuidelines.md:13192
msgid "13192                // ..."
msgstr""

# CppCoreGuidelines.md:13193
msgid "13193                i = f(x, d);"
msgstr""

# CppCoreGuidelines.md:13194
msgid "13194            }"
msgstr""

# CppCoreGuidelines.md:13195
msgid "13195            if (i < x) {"
msgstr""

# CppCoreGuidelines.md:13196
msgid "13196                // ..."
msgstr""

# CppCoreGuidelines.md:13197
msgid "13197                i = g(x, c);"
msgstr""

# CppCoreGuidelines.md:13198
msgid "13198            }"
msgstr""

# CppCoreGuidelines.md:13199
msgid "13199            return i;"
msgstr""

# CppCoreGuidelines.md:13200
msgid "13200        }"
msgstr""

       
# CppCoreGuidelines.md:13201
msgid "13201    The larger the distance between the uninitialized variable and its use, the larger the chance of a bug."
msgstr""

# CppCoreGuidelines.md:13202
msgid "13202    Fortunately, compilers catch many \"used before set\" errors."
msgstr""

# CppCoreGuidelines.md:13203
msgid "13203    Unfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren't always as simple to spot as in this small example."
msgstr""

       
       
# CppCoreGuidelines.md:13204
msgid "13204    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13205
msgid "13205    * [Always initialize an object](#Res-always)"
msgstr""

# CppCoreGuidelines.md:13206
msgid "13206    * [ES.21: Don't introduce a variable (or constant) before you need to use it](#Res-introduce)"
msgstr""

       
# CppCoreGuidelines.md:13207
msgid "13207    ### <a name=\"Rnr-single-return\"></a>NR.2: Don't: Have only a single `return`-statement in a function"
msgstr""

       
# CppCoreGuidelines.md:13208
msgid "13208    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13209
msgid "13209    The single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables."
msgstr""

# CppCoreGuidelines.md:13210
msgid "13210    In particular, the single-return rule makes it harder to concentrate error checking at the top of a function."
msgstr""

       
# CppCoreGuidelines.md:13211
msgid "13211    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13212
msgid "13212        template<class T>"
msgstr""

# CppCoreGuidelines.md:13213
msgid "13213        //  requires Number<T>"
msgstr""

# CppCoreGuidelines.md:13214
msgid "13214        string sign(T x)"
msgstr""

# CppCoreGuidelines.md:13215
msgid "13215        {"
msgstr""

# CppCoreGuidelines.md:13216
msgid "13216            if (x < 0)"
msgstr""

# CppCoreGuidelines.md:13217
msgid "13217                return \"negative\";"
msgstr""

# CppCoreGuidelines.md:13218
msgid "13218            else if (x > 0)"
msgstr""

# CppCoreGuidelines.md:13219
msgid "13219                return \"positive\";"
msgstr""

# CppCoreGuidelines.md:13220
msgid "13220            return \"zero\";"
msgstr""

# CppCoreGuidelines.md:13221
msgid "13221        }"
msgstr""

       
# CppCoreGuidelines.md:13222
msgid "13222    to use a single return only we would have to do something like"
msgstr""

       
# CppCoreGuidelines.md:13223
msgid "13223        template<class T>"
msgstr""

# CppCoreGuidelines.md:13224
msgid "13224        //  requires Number<T>"
msgstr""

# CppCoreGuidelines.md:13225
msgid "13225        string sign(T x)        // bad"
msgstr""

# CppCoreGuidelines.md:13226
msgid "13226        {"
msgstr""

# CppCoreGuidelines.md:13227
msgid "13227            string res;"
msgstr""

# CppCoreGuidelines.md:13228
msgid "13228            if (x < 0)"
msgstr""

# CppCoreGuidelines.md:13229
msgid "13229                res = \"negative\";"
msgstr""

# CppCoreGuidelines.md:13230
msgid "13230            else if (x > 0)"
msgstr""

# CppCoreGuidelines.md:13231
msgid "13231                res = \"positive\";"
msgstr""

# CppCoreGuidelines.md:13232
msgid "13232            else"
msgstr""

# CppCoreGuidelines.md:13233
msgid "13233                res = \"zero\";"
msgstr""

# CppCoreGuidelines.md:13234
msgid "13234            return res;"
msgstr""

# CppCoreGuidelines.md:13235
msgid "13235        }"
msgstr""

       
# CppCoreGuidelines.md:13236
msgid "13236    This is both longer and likely to be less efficient."
msgstr""

# CppCoreGuidelines.md:13237
msgid "13237    The larger and more complicated the function is, the more painful the workarounds get."
msgstr""

# CppCoreGuidelines.md:13238
msgid "13238    Of course many simple functions will naturally have just one `return` because of their simpler inherent logic."
msgstr""

       
# CppCoreGuidelines.md:13239
msgid "13239    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13240
msgid "13240        int index(const char* p)"
msgstr""

# CppCoreGuidelines.md:13241
msgid "13241        {"
msgstr""

# CppCoreGuidelines.md:13242
msgid "13242            if (!p) return -1;  // error indicator: alternatively \"throw nullptr_error{}\""
msgstr""

# CppCoreGuidelines.md:13243
msgid "13243            // ... do a lookup to find the index for p"
msgstr""

# CppCoreGuidelines.md:13244
msgid "13244            return i;"
msgstr""

# CppCoreGuidelines.md:13245
msgid "13245        }"
msgstr""

       
# CppCoreGuidelines.md:13246
msgid "13246    If we applied the rule, we'd get something like"
msgstr""

       
# CppCoreGuidelines.md:13247
msgid "13247        int index2(const char* p)"
msgstr""

# CppCoreGuidelines.md:13248
msgid "13248        {"
msgstr""

# CppCoreGuidelines.md:13249
msgid "13249            int i;"
msgstr""

# CppCoreGuidelines.md:13250
msgid "13250            if (!p)"
msgstr""

# CppCoreGuidelines.md:13251
msgid "13251                i = -1;  // error indicator"
msgstr""

# CppCoreGuidelines.md:13252
msgid "13252            else {"
msgstr""

# CppCoreGuidelines.md:13253
msgid "13253                // ... do a lookup to find the index for p"
msgstr""

# CppCoreGuidelines.md:13254
msgid "13254            }"
msgstr""

# CppCoreGuidelines.md:13255
msgid "13255            return i;"
msgstr""

# CppCoreGuidelines.md:13256
msgid "13256        }"
msgstr""

       
# CppCoreGuidelines.md:13257
msgid "13257    Note that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that."
msgstr""

# CppCoreGuidelines.md:13258
msgid "13258    Also, this style is a temptation to use the [goto exit](#Rnr-goto-exit) non-rule."
msgstr""

       
# CppCoreGuidelines.md:13259
msgid "13259    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13260
msgid "13260    * Keep functions short and simple"
msgstr""

# CppCoreGuidelines.md:13261
msgid "13261    * Feel free to use multiple `return` statements (and to throw exceptions)."
msgstr""

       
# CppCoreGuidelines.md:13262
msgid "13262    ### <a name=\"Rnr-no-exceptions\"></a>NR.3: Don't: Don't use exceptions"
msgstr""

       
# CppCoreGuidelines.md:13263
msgid "13263    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13264
msgid "13264    There seem to be three main reasons given for this non-rule:"
msgstr""

       
# CppCoreGuidelines.md:13265
msgid "13265    * exceptions are inefficient"
msgstr""

# CppCoreGuidelines.md:13266
msgid "13266    * exceptions lead to leaks and errors"
msgstr""

# CppCoreGuidelines.md:13267
msgid "13267    * exception performance is not predictable"
msgstr""

       
# CppCoreGuidelines.md:13268
msgid "13268    There is no way we can settle this issue to the satisfaction of everybody."
msgstr""

# CppCoreGuidelines.md:13269
msgid "13269    After all, the discussions about exceptions have been going on for 40+ years."
msgstr""

# CppCoreGuidelines.md:13270
msgid "13270    Some languages cannot be used without exceptions, but others do not support them."
msgstr""

# CppCoreGuidelines.md:13271
msgid "13271    This leads to strong traditions for the use and non-use of exceptions, and to heated debates."
msgstr""

       
# CppCoreGuidelines.md:13272
msgid "13272    However, we can briefly outline why we consider exceptions the best alternative for general-purpose programming"
msgstr""

# CppCoreGuidelines.md:13273
msgid "13273    and in the context of these guidelines."
msgstr""

# CppCoreGuidelines.md:13274
msgid "13274    Simple arguments for and against are often inconclusive."
msgstr""

# CppCoreGuidelines.md:13275
msgid "13275    There are specialized applications where exceptions indeed can be inappropriate"
msgstr""

# CppCoreGuidelines.md:13276
msgid "13276    (e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception)."
msgstr""

       
# CppCoreGuidelines.md:13277
msgid "13277    Consider the major objections to exceptions in turn"
msgstr""

       
# CppCoreGuidelines.md:13278
msgid "13278    * Exceptions are inefficient:"
msgstr""

# CppCoreGuidelines.md:13279
msgid "13279    Compared to what?"
msgstr""

# CppCoreGuidelines.md:13280
msgid "13280    When comparing make sure that the same set of errors are handled and that they are handled equivalently."
msgstr""

# CppCoreGuidelines.md:13281
msgid "13281    In particular, do not compare a program that immediately terminate on seeing an error with a program"
msgstr""

# CppCoreGuidelines.md:13282
msgid "13282    that carefully cleans up resources before logging an error."
msgstr""

# CppCoreGuidelines.md:13283
msgid "13283    Yes, some systems have poor exception handling implementations; sometimes, such implementations force us to use"
msgstr""

# CppCoreGuidelines.md:13284
msgid "13284    other error-handling approaches, but that's not a fundamental problem with exceptions."
msgstr""

# CppCoreGuidelines.md:13285
msgid "13285    When using an efficiency argument - in any context - be careful that you have good data that actually provides"
msgstr""

# CppCoreGuidelines.md:13286
msgid "13286    insight into the problem under discussion."
msgstr""

# CppCoreGuidelines.md:13287
msgid "13287    * Exceptions lead to leaks and errors."
msgstr""

# CppCoreGuidelines.md:13288
msgid "13288    They do not."
msgstr""

# CppCoreGuidelines.md:13289
msgid "13289    If your program is a rat's nest of pointers without an overall strategy for resource management,"
msgstr""

# CppCoreGuidelines.md:13290
msgid "13290    you have a problem whatever you do."
msgstr""

# CppCoreGuidelines.md:13291
msgid "13291    If your system consists of a million lines of such code,"
msgstr""

# CppCoreGuidelines.md:13292
msgid "13292    you probably will not be able to use exceptions,"
msgstr""

# CppCoreGuidelines.md:13293
msgid "13293    but that's a problem with excessive and undisciplined pointer use, rather than with exceptions."
msgstr""

# CppCoreGuidelines.md:13294
msgid "13294    In our opinion, you need RAII to make exception-based error handling simple and safe -- simpler and safer than alternatives."
msgstr""

# CppCoreGuidelines.md:13295
msgid "13295    * Exception performance is not predictable."
msgstr""

# CppCoreGuidelines.md:13296
msgid "13296    If you are in a hard-real-time system where you must guarantee completion of a task in a given time,"
msgstr""

# CppCoreGuidelines.md:13297
msgid "13297    you need tools to back up such guarantees."
msgstr""

# CppCoreGuidelines.md:13298
msgid "13298    As far as we know such tools are not available (at least not to most programmers)."
msgstr""

       
# CppCoreGuidelines.md:13299
msgid "13299    Many, possibly most, problems with exceptions stem from historical needs to interact with messy old code."
msgstr""

       
# CppCoreGuidelines.md:13300
msgid "13300    The fundamental arguments for the use of exceptions are"
msgstr""

       
# CppCoreGuidelines.md:13301
msgid "13301    * They clearly differentiate between erroneous return and ordinary return"
msgstr""

# CppCoreGuidelines.md:13302
msgid "13302    * They cannot be forgotten or ignored"
msgstr""

# CppCoreGuidelines.md:13303
msgid "13303    * They can be used systematically"
msgstr""

       
# CppCoreGuidelines.md:13304
msgid "13304    Remember"
msgstr""

       
# CppCoreGuidelines.md:13305
msgid "13305    * Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions)."
msgstr""

# CppCoreGuidelines.md:13306
msgid "13306    * Exceptions are not for errors that can be handled locally."
msgstr""

# CppCoreGuidelines.md:13307
msgid "13307    * Don't try to catch every exception in every function (that's tedious, clumsy, and leads to slow code)."
msgstr""

# CppCoreGuidelines.md:13308
msgid "13308    * Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error."
msgstr""

       
# CppCoreGuidelines.md:13309
msgid "13309    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13310
msgid "13310        ???"
msgstr""

       
# CppCoreGuidelines.md:13311
msgid "13311    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13312
msgid "13312    * [RAII](#Re-raii)"
msgstr""

# CppCoreGuidelines.md:13313
msgid "13313    * Contracts/assertions: Use GSL's `Expects` and `Ensures` (until we get language support for contracts)"
msgstr""

       
# CppCoreGuidelines.md:13314
msgid "13314    ### <a name=\"Rnr-lots-of-files\"></a>NR.4: Don't: Place each class declaration in its own source file"
msgstr""

       
# CppCoreGuidelines.md:13315
msgid "13315    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13316
msgid "13316    The resulting number of files are hard to manage and can slow down compilation."
msgstr""

# CppCoreGuidelines.md:13317
msgid "13317    Individual classes are rarely a good logical unit of maintenance and distribution."
msgstr""

       
# CppCoreGuidelines.md:13318
msgid "13318    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13319
msgid "13319        ???"
msgstr""

       
# CppCoreGuidelines.md:13320
msgid "13320    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13321
msgid "13321    * Use namespaces containing logically cohesive sets of classes and functions."
msgstr""

       
# CppCoreGuidelines.md:13322
msgid "13322    ### <a name=\"Rnr-two-phase-init\"></a>NR.5: Don't: Don't do substantive work in a constructor; instead use two-phase initialization"
msgstr""

       
# CppCoreGuidelines.md:13323
msgid "13323    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13324
msgid "13324    Following this rule leads to weaker invariants,"
msgstr""

# CppCoreGuidelines.md:13325
msgid "13325    more complicated code (having to deal with semi-constructed objects),"
msgstr""

# CppCoreGuidelines.md:13326
msgid "13326    and errors (when we didn't deal correctly with semi-constructed objects consistently)."
msgstr""

       
# CppCoreGuidelines.md:13327
msgid "13327    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13328
msgid "13328        ???"
msgstr""

       
# CppCoreGuidelines.md:13329
msgid "13329    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13330
msgid "13330    * Always establish a class invariant in a constructor."
msgstr""

# CppCoreGuidelines.md:13331
msgid "13331    * Don't define an object before it is needed."
msgstr""

       
# CppCoreGuidelines.md:13332
msgid "13332    ### <a name=\"Rnr-goto-exit\"></a>NR.6: Don't: Place all cleanup actions at the end of a function and `goto exit`"
msgstr""

       
# CppCoreGuidelines.md:13333
msgid "13333    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13334
msgid "13334    `goto` is error-prone."
msgstr""

# CppCoreGuidelines.md:13335
msgid "13335    This technique is a pre-exception technique for RAII-like resource and error handling."
msgstr""

       
# CppCoreGuidelines.md:13336
msgid "13336    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13337
msgid "13337        void do_something(int n)"
msgstr""

# CppCoreGuidelines.md:13338
msgid "13338        {"
msgstr""

# CppCoreGuidelines.md:13339
msgid "13339            if (n < 100) goto exit;"
msgstr""

# CppCoreGuidelines.md:13340
msgid "13340            // ..."
msgstr""

# CppCoreGuidelines.md:13341
msgid "13341            int* p = (int*) malloc(n);"
msgstr""

# CppCoreGuidelines.md:13342
msgid "13342            // ..."
msgstr""

# CppCoreGuidelines.md:13343
msgid "13343            if (some_error) goto_exit;"
msgstr""

# CppCoreGuidelines.md:13344
msgid "13344            // ..."
msgstr""

# CppCoreGuidelines.md:13345
msgid "13345        exit:"
msgstr""

# CppCoreGuidelines.md:13346
msgid "13346            free(p);"
msgstr""

# CppCoreGuidelines.md:13347
msgid "13347        }"
msgstr""

       
# CppCoreGuidelines.md:13348
msgid "13348    and spot the bug."
msgstr""

       
# CppCoreGuidelines.md:13349
msgid "13349    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13350
msgid "13350    * Use exceptions and [RAII](#Re-raii)"
msgstr""

# CppCoreGuidelines.md:13351
msgid "13351    * for non-RAII resources, use [`finally`](#Re-finally)."
msgstr""

       
# CppCoreGuidelines.md:13352
msgid "13352    ### <a name=\"Rnr-protected-data\"></a>NR.7: Don't: Make all data members `protected`"
msgstr""

       
# CppCoreGuidelines.md:13353
msgid "13353    ##### Reason (not to follow this rule)"
msgstr""

       
# CppCoreGuidelines.md:13354
msgid "13354    `protected` data is a source of errors."
msgstr""

# CppCoreGuidelines.md:13355
msgid "13355    `protected` data can be manipulated from an unbounded amount of code in various places."
msgstr""

# CppCoreGuidelines.md:13356
msgid "13356    `protected` data is the class hierarchy equivalent to global data."
msgstr""

       
# CppCoreGuidelines.md:13357
msgid "13357    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13358
msgid "13358        ???"
msgstr""

       
# CppCoreGuidelines.md:13359
msgid "13359    ##### Alternative"
msgstr""

       
# CppCoreGuidelines.md:13360
msgid "13360    * [Make member data `public` or (preferably) `private`](#Rh-protected)"
msgstr""

       
       
# CppCoreGuidelines.md:13361
msgid "13361    # <a name=\"S-references\"></a>RF: References"
msgstr""

       
# CppCoreGuidelines.md:13362
msgid "13362    Many coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++."
msgstr""

# CppCoreGuidelines.md:13363
msgid "13363    Many"
msgstr""

       
# CppCoreGuidelines.md:13364
msgid "13364    * focus on lower-level issues, such as the spelling of identifiers"
msgstr""

# CppCoreGuidelines.md:13365
msgid "13365    * are written by C++ novices"
msgstr""

# CppCoreGuidelines.md:13366
msgid "13366    * see \"stopping programmers from doing unusual things\" as their primary aim"
msgstr""

# CppCoreGuidelines.md:13367
msgid "13367    * aim at portability across many compilers (some 10 years old)"
msgstr""

# CppCoreGuidelines.md:13368
msgid "13368    * are written to preserve decades old code bases"
msgstr""

# CppCoreGuidelines.md:13369
msgid "13369    * aim at a single application domain"
msgstr""

# CppCoreGuidelines.md:13370
msgid "13370    * are downright counterproductive"
msgstr""

# CppCoreGuidelines.md:13371
msgid "13371    * are ignored (must be ignored by programmers to get their work done well)"
msgstr""

       
# CppCoreGuidelines.md:13372
msgid "13372    A bad coding standard is worse than no coding standard."
msgstr""

# CppCoreGuidelines.md:13373
msgid "13373    However an appropriate set of guidelines are much better than no standards: \"Form is liberating.\""
msgstr""

       
# CppCoreGuidelines.md:13374
msgid "13374    Why can't we just have a language that allows all we want and disallows all we don't want (\"a perfect language\")?"
msgstr""

# CppCoreGuidelines.md:13375
msgid "13375    Fundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today."
msgstr""

# CppCoreGuidelines.md:13376
msgid "13376    Also, your needs change over time and a general-purpose language is needed to allow you to adapt."
msgstr""

# CppCoreGuidelines.md:13377
msgid "13377    A language that is ideal for today would be overly restrictive tomorrow."
msgstr""

       
# CppCoreGuidelines.md:13378
msgid "13378    Coding guidelines adapt the use of a language to specific needs."
msgstr""

# CppCoreGuidelines.md:13379
msgid "13379    Thus, there cannot be a single coding style for everybody."
msgstr""

# CppCoreGuidelines.md:13380
msgid "13380    We expect different organizations to provide additions, typically with more restrictions and firmer style rules."
msgstr""

       
# CppCoreGuidelines.md:13381
msgid "13381    Reference sections:"
msgstr""

       
# CppCoreGuidelines.md:13382
msgid "13382    * [RF.rules: Coding rules](#SS-rules)"
msgstr""

# CppCoreGuidelines.md:13383
msgid "13383    * [RF.books: Books with coding guidelines](#SS-books)"
msgstr""

# CppCoreGuidelines.md:13384
msgid "13384    * [RF.C++: C++ Programming (C++11/C++14)](#SS-Cplusplus)"
msgstr""

# CppCoreGuidelines.md:13385
msgid "13385    * [RF.web: Websites](#SS-web)"
msgstr""

# CppCoreGuidelines.md:13386
msgid "13386    * [RS.video: Videos about \"modern C++\"](#SS-vid)"
msgstr""

# CppCoreGuidelines.md:13387
msgid "13387    * [RF.man: Manuals](#SS-man)"
msgstr""

# CppCoreGuidelines.md:13388
msgid "13388    * [RF.core: Core Guidelines materials](#SS-core)"
msgstr""

       
# CppCoreGuidelines.md:13389
msgid "13389    ## <a name=\"SS-rules\"></a>RF.rules: Coding rules"
msgstr""

       
# CppCoreGuidelines.md:13390
msgid "13390    * [Boost Library Requirements and Guidelines](http://www.boost.org/development/requirements.html)."
msgstr""

# CppCoreGuidelines.md:13391
msgid "13391      ???."
msgstr""

# CppCoreGuidelines.md:13392
msgid "13392    * [Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf)."
msgstr""

# CppCoreGuidelines.md:13393
msgid "13393      Has a strong emphasis on code organization and layout."
msgstr""

# CppCoreGuidelines.md:13394
msgid "13394    * Facebook: ???"
msgstr""

# CppCoreGuidelines.md:13395
msgid "13395    * [GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html)."
msgstr""

# CppCoreGuidelines.md:13396
msgid "13396      C++03 and (reasonably) a bit backwards looking."
msgstr""

# CppCoreGuidelines.md:13397
msgid "13397    * [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)."
msgstr""

# CppCoreGuidelines.md:13398
msgid "13398      Geared toward C++03 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend."
msgstr""

# CppCoreGuidelines.md:13399
msgid "13399    * [JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](http://www.stroustrup.com/JSF-AV-rules.pdf)."
msgstr""

# CppCoreGuidelines.md:13400
msgid "13400      Document Number 2RDU00001 Rev C. December 2005."
msgstr""

# CppCoreGuidelines.md:13401
msgid "13401      For flight control software."
msgstr""

# CppCoreGuidelines.md:13402
msgid "13402      For hard-real-time."
msgstr""

# CppCoreGuidelines.md:13403
msgid "13403      This means that it is necessarily very restrictive (\"if the program fails somebody dies\")."
msgstr""

# CppCoreGuidelines.md:13404
msgid "13404      For example, no free store allocation or deallocation may occur after the plane takes off (no memory overflow and no fragmentation allowed)."
msgstr""

# CppCoreGuidelines.md:13405
msgid "13405      No exception may be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time)."
msgstr""

# CppCoreGuidelines.md:13406
msgid "13406      Libraries used have to have been approved for mission critical applications."
msgstr""

# CppCoreGuidelines.md:13407
msgid "13407      Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++."
msgstr""

# CppCoreGuidelines.md:13408
msgid "13408      Recommended, but note its very specific focus."
msgstr""

# CppCoreGuidelines.md:13409
msgid "13409    * [Mozilla Portability Guide](https://developer.mozilla.org/en-US/docs/Mozilla/C%2B%2B_Portability_Guide)."
msgstr""

# CppCoreGuidelines.md:13410
msgid "13410      As the name indicates, this aims for portability across many (old) compilers."
msgstr""

# CppCoreGuidelines.md:13411
msgid "13411      As such, it is restrictive."
msgstr""

# CppCoreGuidelines.md:13412
msgid "13412    * [Geosoft.no: C++ Programming Style Guidelines](http://geosoft.no/development/cppstyle.html)."
msgstr""

# CppCoreGuidelines.md:13413
msgid "13413      ???."
msgstr""

# CppCoreGuidelines.md:13414
msgid "13414    * [Possibility.com: C++ Coding Standard](http://www.possibility.com/Cpp/CppCodingStandard.html)."
msgstr""

# CppCoreGuidelines.md:13415
msgid "13415      ???."
msgstr""

# CppCoreGuidelines.md:13416
msgid "13416    * [SEI CERT: Secure C++ Coding Standard](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637)."
msgstr""

# CppCoreGuidelines.md:13417
msgid "13417      A very nicely done set of rules (with examples and rationales) done for security-sensitive code."
msgstr""

# CppCoreGuidelines.md:13418
msgid "13418      Many of their rules apply generally."
msgstr""

# CppCoreGuidelines.md:13419
msgid "13419    * [High Integrity C++ Coding Standard](http://www.codingstandard.com/)."
msgstr""

# CppCoreGuidelines.md:13420
msgid "13420    * [llvm](http://llvm.org/docs/CodingStandards.html)."
msgstr""

# CppCoreGuidelines.md:13421
msgid "13421      Somewhat brief, pre-C++11, and (not unreasonably) adjusted to its domain."
msgstr""

# CppCoreGuidelines.md:13422
msgid "13422    * ???"
msgstr""

       
# CppCoreGuidelines.md:13423
msgid "13423    ## <a name=\"SS-books\"></a>RF.books: Books with coding guidelines"
msgstr""

       
# CppCoreGuidelines.md:13424
msgid "13424    * [Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996."
msgstr""

# CppCoreGuidelines.md:13425
msgid "13425    * [Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley 1997."
msgstr""

# CppCoreGuidelines.md:13426
msgid "13426    * [Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001."
msgstr""

# CppCoreGuidelines.md:13427
msgid "13427    * [Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley 2005."
msgstr""

# CppCoreGuidelines.md:13428
msgid "13428    * [Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O'Reilly 2015."
msgstr""

# CppCoreGuidelines.md:13429
msgid "13429    * [SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding Standards*. Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11."
msgstr""

# CppCoreGuidelines.md:13430
msgid "13430    * [Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf)."
msgstr""

# CppCoreGuidelines.md:13431
msgid "13431      LCSD05. October 2005."
msgstr""

# CppCoreGuidelines.md:13432
msgid "13432    * [Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](http://www.stroustrup.com/Tour.html)."
msgstr""

# CppCoreGuidelines.md:13433
msgid "13433      Addison Wesley 2014."
msgstr""

# CppCoreGuidelines.md:13434
msgid "13434      Each chapter ends with an advice section consisting of a set of recommendations."
msgstr""

# CppCoreGuidelines.md:13435
msgid "13435    * [Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html)."
msgstr""

# CppCoreGuidelines.md:13436
msgid "13436      Addison Wesley 2013."
msgstr""

# CppCoreGuidelines.md:13437
msgid "13437      Each chapter ends with an advice section consisting of a set of recommendations."
msgstr""

# CppCoreGuidelines.md:13438
msgid "13438    * Stroustrup: [Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)"
msgstr""

# CppCoreGuidelines.md:13439
msgid "13439      for [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html)."
msgstr""

# CppCoreGuidelines.md:13440
msgid "13440      Mostly low-level naming and layout rules."
msgstr""

# CppCoreGuidelines.md:13441
msgid "13441      Primarily a teaching tool."
msgstr""

       
# CppCoreGuidelines.md:13442
msgid "13442    ## <a name=\"SS-Cplusplus\"></a>RF.C++: C++ Programming (C++11/C++14)"
msgstr""

       
# CppCoreGuidelines.md:13443
msgid "13443    * [TC++PL4](http://www.stroustrup.com/4th.html):"
msgstr""

# CppCoreGuidelines.md:13444
msgid "13444    A thorough description of the C++ language and standard libraries for experienced programmers."
msgstr""

# CppCoreGuidelines.md:13445
msgid "13445    * [Tour++](http://www.stroustrup.com/Tour.html):"
msgstr""

# CppCoreGuidelines.md:13446
msgid "13446    An overview of the C++ language and standard libraries for experienced programmers."
msgstr""

# CppCoreGuidelines.md:13447
msgid "13447    * [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html):"
msgstr""

# CppCoreGuidelines.md:13448
msgid "13448    A textbook for beginners and relative novices."
msgstr""

       
# CppCoreGuidelines.md:13449
msgid "13449    ## <a name=\"SS-web\"></a>RF.web: Websites"
msgstr""

       
# CppCoreGuidelines.md:13450
msgid "13450    * [isocpp.org](https://isocpp.org)"
msgstr""

# CppCoreGuidelines.md:13451
msgid "13451    * [Bjarne Stroustrup's home pages](http://www.stroustrup.com)"
msgstr""

# CppCoreGuidelines.md:13452
msgid "13452    * [WG21](http://www.open-std.org/jtc1/sc22/wg21/)"
msgstr""

# CppCoreGuidelines.md:13453
msgid "13453    * [Boost](http://www.boost.org)<a name=\"Boost\"></a>"
msgstr""

# CppCoreGuidelines.md:13454
msgid "13454    * [Adobe open source](http://www.adobe.com/open-source.html)"
msgstr""

# CppCoreGuidelines.md:13455
msgid "13455    * [Poco libraries](http://pocoproject.org/)"
msgstr""

# CppCoreGuidelines.md:13456
msgid "13456    * Sutter's Mill?"
msgstr""

# CppCoreGuidelines.md:13457
msgid "13457    * ???"
msgstr""

       
# CppCoreGuidelines.md:13458
msgid "13458    ## <a name=\"SS-vid\"></a>RS.video: Videos about \"modern C++\""
msgstr""

       
# CppCoreGuidelines.md:13459
msgid "13459    * Bjarne Stroustrup: [C++11 Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style). 2012."
msgstr""

# CppCoreGuidelines.md:13460
msgid "13460    * Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11, and C++14](http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup). 2013"
msgstr""

# CppCoreGuidelines.md:13461
msgid "13461    * All the talks from [CppCon '14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)"
msgstr""

# CppCoreGuidelines.md:13462
msgid "13462    * Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE) at the University of Edinburgh. 2014."
msgstr""

# CppCoreGuidelines.md:13463
msgid "13463    * Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs). CppCon 2016 keynote."
msgstr""

# CppCoreGuidelines.md:13464
msgid "13464    * Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ). CppCon 2014 keynote."
msgstr""

# CppCoreGuidelines.md:13465
msgid "13465    * Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote about the Core Guidelines."
msgstr""

# CppCoreGuidelines.md:13466
msgid "13466    * Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote about the Core Guidelines."
msgstr""

# CppCoreGuidelines.md:13467
msgid "13467    * CppCon 15"
msgstr""

# CppCoreGuidelines.md:13468
msgid "13468    * ??? C++ Next"
msgstr""

# CppCoreGuidelines.md:13469
msgid "13469    * ??? Meting C++"
msgstr""

# CppCoreGuidelines.md:13470
msgid "13470    * ??? more ???"
msgstr""

       
# CppCoreGuidelines.md:13471
msgid "13471    ## <a name=\"SS-man\"></a>RF.man: Manuals"
msgstr""

       
# CppCoreGuidelines.md:13472
msgid "13472    * ISO C++ Standard C++11."
msgstr""

# CppCoreGuidelines.md:13473
msgid "13473    * ISO C++ Standard C++14."
msgstr""

# CppCoreGuidelines.md:13474
msgid "13474    * [ISO C++ Standard C++17 CD](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf). Committee Draft."
msgstr""

# CppCoreGuidelines.md:13475
msgid "13475    * [Palo Alto \"Concepts\" TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf)."
msgstr""

# CppCoreGuidelines.md:13476
msgid "13476    * [ISO C++ Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:13477
msgid "13477    * [WG21 Ranges report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf). Draft."
msgstr""

       
       
# CppCoreGuidelines.md:13478
msgid "13478    ## <a name=\"SS-core\"></a>RF.core: Core Guidelines materials"
msgstr""

       
# CppCoreGuidelines.md:13479
msgid "13479    This section contains materials that has been useful for presenting the core guidelines and the ideas behind them:"
msgstr""

       
# CppCoreGuidelines.md:13480
msgid "13480    * [Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)"
msgstr""

# CppCoreGuidelines.md:13481
msgid "13481    * Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](http://www.stroustrup.com/resource-model.pdf). A paper with lots of examples."
msgstr""

# CppCoreGuidelines.md:13482
msgid "13482    * Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)"
msgstr""

# CppCoreGuidelines.md:13483
msgid "13483    and here are the [slides](http://2017.cppconf.ru/talks/sergey-zubkov). In Russian. 2017."
msgstr""

# CppCoreGuidelines.md:13484
msgid "13484    * Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo). CppCon 2016."
msgstr""

# CppCoreGuidelines.md:13485
msgid "13485    * Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote."
msgstr""

# CppCoreGuidelines.md:13486
msgid "13486    * Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote."
msgstr""

# CppCoreGuidelines.md:13487
msgid "13487    * Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM). ACCU 2017."
msgstr""

# CppCoreGuidelines.md:13488
msgid "13488    * Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c). Bay Area ACCU 2016."
msgstr""

# CppCoreGuidelines.md:13489
msgid "13489    It gives some idea of the ambition level for the Core Guidelines."
msgstr""

       
# CppCoreGuidelines.md:13490
msgid "13490    Note that slides for CppCon presentations are available (links with the posted videos)."
msgstr""

       
# CppCoreGuidelines.md:13491
msgid "13491    Contributions to this list would be most welcome."
msgstr""

       
# CppCoreGuidelines.md:13492
msgid "13492    ## <a name=\"SS-ack\"></a>Acknowledgements"
msgstr""

       
# CppCoreGuidelines.md:13493
msgid "13493    Thanks to the many people who contributed rules, suggestions, supporting information, references, etc.:"
msgstr""

       
# CppCoreGuidelines.md:13494
msgid "13494    * Peter Juhl"
msgstr""

# CppCoreGuidelines.md:13495
msgid "13495    * Neil MacIntosh"
msgstr""

# CppCoreGuidelines.md:13496
msgid "13496    * Axel Naumann"
msgstr""

# CppCoreGuidelines.md:13497
msgid "13497    * Andrew Pardoe"
msgstr""

# CppCoreGuidelines.md:13498
msgid "13498    * Gabriel Dos Reis"
msgstr""

# CppCoreGuidelines.md:13499
msgid "13499    * Zhuang, Jiangang (Jeff)"
msgstr""

# CppCoreGuidelines.md:13500
msgid "13500    * Sergey Zubkov"
msgstr""

       
# CppCoreGuidelines.md:13501
msgid "13501    and see the contributor list on the github."
msgstr""

       
# CppCoreGuidelines.md:13502
msgid "13502    # <a name=\"S-profile\"></a>Pro: Profiles"
msgstr""

       
# CppCoreGuidelines.md:13503
msgid "13503    Ideally, we would follow all of the guidelines."
msgstr""

# CppCoreGuidelines.md:13504
msgid "13504    That would give the cleanest, most regular, least error-prone, and often the fastest code."
msgstr""

# CppCoreGuidelines.md:13505
msgid "13505    Unfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries."
msgstr""

# CppCoreGuidelines.md:13506
msgid "13506    Often, such code has been written over decades and does not follow these guidelines."
msgstr""

# CppCoreGuidelines.md:13507
msgid "13507    We must aim for [gradual adoption](#S-modernizing)."
msgstr""

       
# CppCoreGuidelines.md:13508
msgid "13508    Whatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set"
msgstr""

# CppCoreGuidelines.md:13509
msgid "13509    of problems first and leave the rest until later."
msgstr""

# CppCoreGuidelines.md:13510
msgid "13510    A similar idea of \"related guidelines\" becomes important when some, but not all, guidelines are considered relevant to a code base"
msgstr""

# CppCoreGuidelines.md:13511
msgid "13511    or if a set of specialized guidelines is to be applied for a specialized application area."
msgstr""

# CppCoreGuidelines.md:13512
msgid "13512    We call such a set of related guidelines a \"profile\"."
msgstr""

# CppCoreGuidelines.md:13513
msgid "13513    We aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as \"absence of range errors\""
msgstr""

# CppCoreGuidelines.md:13514
msgid "13514    or \"static type safety.\""
msgstr""

# CppCoreGuidelines.md:13515
msgid "13515    Each profile is designed to eliminate a class of errors."
msgstr""

# CppCoreGuidelines.md:13516
msgid "13516    Enforcement of \"random\" rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement."
msgstr""

       
# CppCoreGuidelines.md:13517
msgid "13517    A \"profile\" is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee."
msgstr""

# CppCoreGuidelines.md:13518
msgid "13518    \"Deterministic\" means they require only local analysis and could be implemented in a compiler (though they don't need to be)."
msgstr""

# CppCoreGuidelines.md:13519
msgid "13519    \"Portably enforceable\" means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code."
msgstr""

       
# CppCoreGuidelines.md:13520
msgid "13520    Code written to be warning-free using such a language profile is considered to conform to the profile."
msgstr""

# CppCoreGuidelines.md:13521
msgid "13521    Conforming code is considered to be safe by construction with regard to the safety properties targeted by that profile."
msgstr""

# CppCoreGuidelines.md:13522
msgid "13522    Conforming code will not be the root cause of errors for that property,"
msgstr""

# CppCoreGuidelines.md:13523
msgid "13523    although such errors may be introduced into a program by other code, libraries or the external environment."
msgstr""

# CppCoreGuidelines.md:13524
msgid "13524    A profile may also introduce additional library types to ease conformance and encourage correct code."
msgstr""

       
# CppCoreGuidelines.md:13525
msgid "13525    Profiles summary:"
msgstr""

       
# CppCoreGuidelines.md:13526
msgid "13526    * [Pro.type: Type safety](#SS-type)"
msgstr""

# CppCoreGuidelines.md:13527
msgid "13527    * [Pro.bounds: Bounds safety](#SS-bounds)"
msgstr""

# CppCoreGuidelines.md:13528
msgid "13528    * [Pro.lifetime: Lifetime safety](#SS-lifetime)"
msgstr""

       
# CppCoreGuidelines.md:13529
msgid "13529    In the future, we expect to define many more profiles and add more checks to existing profiles."
msgstr""

# CppCoreGuidelines.md:13530
msgid "13530    Candidates include:"
msgstr""

       
# CppCoreGuidelines.md:13531
msgid "13531    * narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile)"
msgstr""

# CppCoreGuidelines.md:13532
msgid "13532    * arithmetic cast from negative floating point to unsigned integral type (ditto)"
msgstr""

# CppCoreGuidelines.md:13533
msgid "13533    * selected undefined behavior: Start with Gabriel Dos Reis's UB list developed for the WG21 study group"
msgstr""

# CppCoreGuidelines.md:13534
msgid "13534    * selected unspecified behavior: Addressing portability concerns."
msgstr""

# CppCoreGuidelines.md:13535
msgid "13535    * `const` violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of `const`."
msgstr""

       
# CppCoreGuidelines.md:13536
msgid "13536    Enabling a profile is implementation defined; typically, it is set in the analysis tool used."
msgstr""

       
# CppCoreGuidelines.md:13537
msgid "13537    To suppress enforcement of a profile check, place a `suppress` annotation on a language contract. For example:"
msgstr""

       
# CppCoreGuidelines.md:13538
msgid "13538        [[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]"
msgstr""

# CppCoreGuidelines.md:13539
msgid "13539        {"
msgstr""

# CppCoreGuidelines.md:13540
msgid "13540            // ..."
msgstr""

# CppCoreGuidelines.md:13541
msgid "13541        }"
msgstr""

       
# CppCoreGuidelines.md:13542
msgid "13542    Now `raw_find()` can scramble memory to its heart's content."
msgstr""

# CppCoreGuidelines.md:13543
msgid "13543    Obviously, suppression should be very rare."
msgstr""

       
# CppCoreGuidelines.md:13544
msgid "13544    ## <a name=\"SS-type\"></a>Pro.safety: Type-safety profile"
msgstr""

       
# CppCoreGuidelines.md:13545
msgid "13545    This profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning."
msgstr""

# CppCoreGuidelines.md:13546
msgid "13546    It does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions."
msgstr""

       
# CppCoreGuidelines.md:13547
msgid "13547    For the purposes of this section,"
msgstr""

# CppCoreGuidelines.md:13548
msgid "13548    type-safety is defined to be the property that a variable is not used in a way that doesn't obey the rules for the type of its definition."
msgstr""

# CppCoreGuidelines.md:13549
msgid "13549    Memory accessed as a type `T` should not be valid memory that actually contains an object of an unrelated type `U`."
msgstr""

# CppCoreGuidelines.md:13550
msgid "13550    Note that the safety is intended to be complete when combined also with [Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime)."
msgstr""

       
# CppCoreGuidelines.md:13551
msgid "13551    An implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic."
msgstr""

       
# CppCoreGuidelines.md:13552
msgid "13552    Type safety profile summary:"
msgstr""

       
# CppCoreGuidelines.md:13553
msgid "13553    * <a name=\"Pro-type-avoidcasts\"></a>Type.1: [Avoid casts](#Res-casts):"
msgstr""

# CppCoreGuidelines.md:13554
msgid "13554    <a name=\"Pro-type-reinterpretcast\">a. </a>Don't use `reinterpret_cast`; A strict version of [Avoid casts](#Res-casts) and [prefer named casts](#Res-casts-named)."
msgstr""

# CppCoreGuidelines.md:13555
msgid "13555    <a name=\"Pro-type-arithmeticcast\">b. </a>Don't use `static_cast` for arithmetic types; A strict version of [Avoid casts](#Res-casts) and [prefer named casts](#Res-casts-named)."
msgstr""

# CppCoreGuidelines.md:13556
msgid "13556    <a name=\"Pro-type-identitycast\">c. </a>Don't cast between pointer types where the source type and the target type are the same; A strict version of [Avoid casts](#Res-casts)."
msgstr""

# CppCoreGuidelines.md:13557
msgid "13557    <a name=\"Pro-type-implicitpointercast\">d. </a>Don't cast between pointer types when the conversion could be implicit; A strict version of [Avoid casts](#Res-casts)."
msgstr""

# CppCoreGuidelines.md:13558
msgid "13558    * <a name=\"Pro-type-downcast\"></a>Type.2: Don't use `static_cast` to downcast:"
msgstr""

# CppCoreGuidelines.md:13559
msgid "13559    [Use `dynamic_cast` instead](#Rh-dynamic_cast)."
msgstr""

# CppCoreGuidelines.md:13560
msgid "13560    * <a name=\"Pro-type-constcast\"></a>Type.3: Don't use `const_cast` to cast away `const` (i.e., at all):"
msgstr""

# CppCoreGuidelines.md:13561
msgid "13561    [Don't cast away const](#Res-casts-const)."
msgstr""

# CppCoreGuidelines.md:13562
msgid "13562    * <a name=\"Pro-type-cstylecast\"></a>Type.4: Don't use C-style `(T)expression` or functional `T(expression)` casts:"
msgstr""

# CppCoreGuidelines.md:13563
msgid "13563    Prefer [construction](#Res-construct) or [named casts](#Res-cast-named)."
msgstr""

# CppCoreGuidelines.md:13564
msgid "13564    * <a name=\"Pro-type-init\"></a>Type.5: Don't use a variable before it has been initialized:"
msgstr""

# CppCoreGuidelines.md:13565
msgid "13565    [always initialize](#Res-always)."
msgstr""

# CppCoreGuidelines.md:13566
msgid "13566    * <a name=\"Pro-type-memberinit\"></a>Type.6: Always initialize a member variable:"
msgstr""

# CppCoreGuidelines.md:13567
msgid "13567    [always initialize](#Res-always),"
msgstr""

# CppCoreGuidelines.md:13568
msgid "13568    possibly using [default constructors](#Rc-default0) or"
msgstr""

# CppCoreGuidelines.md:13569
msgid "13569    [default member initializers](#Rc-in-class-initializers)."
msgstr""

# CppCoreGuidelines.md:13570
msgid "13570    * <a name=\"Pro-type-unon\"></a>Type.7: Avoid naked union:"
msgstr""

# CppCoreGuidelines.md:13571
msgid "13571    [Use `variant` instead](#Ru-naked)."
msgstr""

# CppCoreGuidelines.md:13572
msgid "13572    * <a name=\"Pro-type-varargs\"></a>Type.8: Avoid varargs:"
msgstr""

# CppCoreGuidelines.md:13573
msgid "13573    [Don't use `va_arg` arguments](#F-varargs)."
msgstr""

       
# CppCoreGuidelines.md:13574
msgid "13574    ##### Impact"
msgstr""

       
# CppCoreGuidelines.md:13575
msgid "13575    With the type-safety profile you can trust that every operation is applied to a valid object."
msgstr""

# CppCoreGuidelines.md:13576
msgid "13576    Exception may be thrown to indicate errors that cannot be detected statically (at compile time)."
msgstr""

# CppCoreGuidelines.md:13577
msgid "13577    Note that this type-safety can be complete only if we also have [Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime)."
msgstr""

# CppCoreGuidelines.md:13578
msgid "13578    Without those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it."
msgstr""

       
       
# CppCoreGuidelines.md:13579
msgid "13579    ## <a name=\"SS-bounds\"></a>Pro.bounds: Bounds safety profile"
msgstr""

       
# CppCoreGuidelines.md:13580
msgid "13580    This profile makes it easier to construct code that operates within the bounds of allocated blocks of memory."
msgstr""

# CppCoreGuidelines.md:13581
msgid "13581    It does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing."
msgstr""

# CppCoreGuidelines.md:13582
msgid "13582    One of the core features of this profile is to restrict pointers to only refer to single objects, not arrays."
msgstr""

       
# CppCoreGuidelines.md:13583
msgid "13583    We define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it."
msgstr""

# CppCoreGuidelines.md:13584
msgid "13584    Bounds safety is intended to be complete only when combined with [Type safety](#SS-type) and [Lifetime safety](#SS-lifetime),"
msgstr""

# CppCoreGuidelines.md:13585
msgid "13585    which cover other unsafe operations that allow bounds violations."
msgstr""

       
# CppCoreGuidelines.md:13586
msgid "13586    Bounds safety profile summary:"
msgstr""

       
# CppCoreGuidelines.md:13587
msgid "13587    * <a href=\"Pro-bounds-arithmetic\"></a>Bounds.1: Don't use pointer arithmetic. Use `span` instead:"
msgstr""

# CppCoreGuidelines.md:13588
msgid "13588    [Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-simple)."
msgstr""

# CppCoreGuidelines.md:13589
msgid "13589    * <a href=\"Pro-bounds-arrayindex\"></a>Bounds.2: Only index into arrays using constant expressions:"
msgstr""

# CppCoreGuidelines.md:13590
msgid "13590    [Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-simple)."
msgstr""

# CppCoreGuidelines.md:13591
msgid "13591    * <a href=\"Pro-bounds-decay\"></a>Bounds.3: No array-to-pointer decay:"
msgstr""

# CppCoreGuidelines.md:13592
msgid "13592    [Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-simple)."
msgstr""

# CppCoreGuidelines.md:13593
msgid "13593    * <a href=\"Pro-bounds-stdlib\"></a>Bounds.4: Don't use standard-library functions and types that are not bounds-checked:"
msgstr""

# CppCoreGuidelines.md:13594
msgid "13594    [Use the standard library in a type-safe manner](#Rsl-bounds)."
msgstr""

       
# CppCoreGuidelines.md:13595
msgid "13595    ##### Impact"
msgstr""

       
# CppCoreGuidelines.md:13596
msgid "13596    Bounds safety implies that access to an object - notably arrays - does not access beyond the object's memory allocation."
msgstr""

# CppCoreGuidelines.md:13597
msgid "13597    This eliminates a large class of insidious and hard-to-find errors, including the (in)famous \"buffer overflow\" errors."
msgstr""

# CppCoreGuidelines.md:13598
msgid "13598    This closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds)."
msgstr""

# CppCoreGuidelines.md:13599
msgid "13599    Even an out-of-bounds access is \"just a read\", it can lead to invariant violations (when the accessed isn't of the assumed type)"
msgstr""

# CppCoreGuidelines.md:13600
msgid "13600    and \"mysterious values.\""
msgstr""

       
       
# CppCoreGuidelines.md:13601
msgid "13601    ## <a name=\"SS-lifetime\"></a>Pro.lifetime: Lifetime safety profile"
msgstr""

       
# CppCoreGuidelines.md:13602
msgid "13602    Accessing through a pointer that doesn't point to anything is a major source of errors,"
msgstr""

# CppCoreGuidelines.md:13603
msgid "13603    and very hard to avoid in many traditional C or C++ styles of programming."
msgstr""

# CppCoreGuidelines.md:13604
msgid "13604    For example, a pointer may be uninitialized, the `nullptr`, point beyond the range of an array, or to a deleted object."
msgstr""

       
# CppCoreGuidelines.md:13605
msgid "13605    See /docs folder for the initial design. The detailed formal rules are in progress (as of May 2017)."
msgstr""

       
# CppCoreGuidelines.md:13606
msgid "13606    Lifetime safety profile summary:"
msgstr""

       
# CppCoreGuidelines.md:13607
msgid "13607    * <a href=\"Pro-lifetime-invalid-deref\"></a>Lifetime.1: Don't dereference a possibly invalid pointer:"
msgstr""

# CppCoreGuidelines.md:13608
msgid "13608    [detect or avoid](#Res-deref)."
msgstr""

       
# CppCoreGuidelines.md:13609
msgid "13609    ##### Impact"
msgstr""

       
# CppCoreGuidelines.md:13610
msgid "13610    Once completely enforced through a combination of style rules, static analysis, and library support, this profile"
msgstr""

       
# CppCoreGuidelines.md:13611
msgid "13611    * eliminates one of the major sources of nasty errors in C++"
msgstr""

# CppCoreGuidelines.md:13612
msgid "13612    * eliminates a major source of potential security violations"
msgstr""

# CppCoreGuidelines.md:13613
msgid "13613    * improves performance by eliminating redundant \"paranoia\" checks"
msgstr""

# CppCoreGuidelines.md:13614
msgid "13614    * increases confidence in correctness of code"
msgstr""

# CppCoreGuidelines.md:13615
msgid "13615    * avoids undefined behavior by enforcing a key C++ language rule"
msgstr""

       
       
# CppCoreGuidelines.md:13616
msgid "13616    # <a name=\"S-gsl\"></a>GSL: Guidelines support library"
msgstr""

       
# CppCoreGuidelines.md:13617
msgid "13617    The GSL is a small library of facilities designed to support this set of guidelines."
msgstr""

# CppCoreGuidelines.md:13618
msgid "13618    Without these facilities, the guidelines would have to be far more restrictive on language details."
msgstr""

       
# CppCoreGuidelines.md:13619
msgid "13619    The Core Guidelines support library is defined in namespace `gsl` and the names may be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the `gsl` namespace allows for experimentation and for local variants of the support facilities."
msgstr""

       
# CppCoreGuidelines.md:13620
msgid "13620    The GSL is header only, and can be found at [GSL: Guidelines support library](https://github.com/Microsoft/GSL)."
msgstr""

# CppCoreGuidelines.md:13621
msgid "13621    The support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives."
msgstr""

# CppCoreGuidelines.md:13622
msgid "13622    Where desirable, they can be \"instrumented\" with additional functionality (e.g., checks) for tasks such as debugging."
msgstr""

       
# CppCoreGuidelines.md:13623
msgid "13623    These Guidelines assume a `variant` type, but this is not currently in GSL."
msgstr""

# CppCoreGuidelines.md:13624
msgid "13624    Eventually, use [the one voted into C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html)."
msgstr""

       
# CppCoreGuidelines.md:13625
msgid "13625    Summary of GSL components:"
msgstr""

       
# CppCoreGuidelines.md:13626
msgid "13626    * [GSL.view: Views](#SS-views)"
msgstr""

# CppCoreGuidelines.md:13627
msgid "13627    * [GSL.owner](#SS-ownership)"
msgstr""

# CppCoreGuidelines.md:13628
msgid "13628    * [GSL.assert: Assertions](#SS-assertions)"
msgstr""

# CppCoreGuidelines.md:13629
msgid "13629    * [GSL.util: Utilities](#SS-utilities)"
msgstr""

# CppCoreGuidelines.md:13630
msgid "13630    * [GSL.concept: Concepts](#SS-gsl-concepts)"
msgstr""

       
# CppCoreGuidelines.md:13631
msgid "13631    We plan for a \"ISO C++ standard style\" semi-formal specification of the GSL."
msgstr""

       
# CppCoreGuidelines.md:13632
msgid "13632    We rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library."
msgstr""

       
# CppCoreGuidelines.md:13633
msgid "13633    ## <a name=\"SS-views\"></a>GSL.view: Views"
msgstr""

       
# CppCoreGuidelines.md:13634
msgid "13634    These types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence."
msgstr""

       
# CppCoreGuidelines.md:13635
msgid "13635    These \"views\" are never owners."
msgstr""

       
# CppCoreGuidelines.md:13636
msgid "13636    References are never owners (see [R.4](#Rr-ref). Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing `push_back`, binding to `std::max(x, y + 1)`, etc. The Lifetime safety profile aims to address those things, but even so `owner<T&>` does not make sense and is discouraged."
msgstr""

       
# CppCoreGuidelines.md:13637
msgid "13637    The names are mostly ISO standard-library style (lower case and underscore):"
msgstr""

       
# CppCoreGuidelines.md:13638
msgid "13638    * `T*`      // The `T*` is not an owner, may be null; assumed to be pointing to a single element."
msgstr""

# CppCoreGuidelines.md:13639
msgid "13639    * `T&`      // The `T&` is not an owner and can never be a \"null reference\"; references are always bound to objects."
msgstr""

       
# CppCoreGuidelines.md:13640
msgid "13640    The \"raw-pointer\" notation (e.g. `int*`) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it."
msgstr""

# CppCoreGuidelines.md:13641
msgid "13641    Owners should be converted to resource handles (e.g., `unique_ptr` or `vector<T>`) or marked `owner<T*>`."
msgstr""

       
# CppCoreGuidelines.md:13642
msgid "13642    * `owner<T*>`   // a `T*` that owns the object pointed/referred to; may be `nullptr`."
msgstr""

       
# CppCoreGuidelines.md:13643
msgid "13643    `owner` is used to mark owning pointers in code that cannot be upgraded to use proper resource handles."
msgstr""

# CppCoreGuidelines.md:13644
msgid "13644    Reasons for that include:"
msgstr""

       
# CppCoreGuidelines.md:13645
msgid "13645    * Cost of conversion."
msgstr""

# CppCoreGuidelines.md:13646
msgid "13646    * The pointer is used with an ABI."
msgstr""

# CppCoreGuidelines.md:13647
msgid "13647    * The pointer is part of the implementation of a resource handle."
msgstr""

       
# CppCoreGuidelines.md:13648
msgid "13648    An `owner<T>` differs from a resource handle for a `T` by still requiring an explicit `delete`."
msgstr""

       
# CppCoreGuidelines.md:13649
msgid "13649    An `owner<T>` is assumed to refer to an object on the free store (heap)."
msgstr""

       
# CppCoreGuidelines.md:13650
msgid "13650    If something is not supposed to be `nullptr`, say so:"
msgstr""

       
# CppCoreGuidelines.md:13651
msgid "13651    * `not_null<T>`   // `T` is usually a pointer type (e.g., `not_null<int*>` and `not_null<owner<Foo*>>`) that may not be `nullptr`."
msgstr""

# CppCoreGuidelines.md:13652
msgid "13652      `T` can be any type for which `==nullptr` is meaningful."
msgstr""

       
# CppCoreGuidelines.md:13653
msgid "13653    * `span<T>`       // `[p:p+n)`, constructor from `{p, q}` and `{p, n}`; `T` is the pointer type"
msgstr""

# CppCoreGuidelines.md:13654
msgid "13654    * `span_p<T>`     // `{p, predicate}` `[p:q)` where `q` is the first element for which `predicate(*p)` is true"
msgstr""

# CppCoreGuidelines.md:13655
msgid "13655    * `string_span`   // `span<char>`"
msgstr""

# CppCoreGuidelines.md:13656
msgid "13656    * `cstring_span`  // `span<const char>`"
msgstr""

       
# CppCoreGuidelines.md:13657
msgid "13657    A `span<T>` refers to zero or more mutable `T`s unless `T` is a `const` type."
msgstr""

       
# CppCoreGuidelines.md:13658
msgid "13658    \"Pointer arithmetic\" is best done within `span`s."
msgstr""

# CppCoreGuidelines.md:13659
msgid "13659    A `char*` that points to more than one `char` but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a `span`."
msgstr""

       
# CppCoreGuidelines.md:13660
msgid "13660    * `zstring`    // a `char*` supposed to be a C-style string; that is, a zero-terminated sequence of `char` or `nullptr`"
msgstr""

# CppCoreGuidelines.md:13661
msgid "13661    * `czstring`   // a `const char*` supposed to be a C-style string; that is, a zero-terminated sequence of `const` `char` or `nullptr`"
msgstr""

       
# CppCoreGuidelines.md:13662
msgid "13662    Logically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one `char` and a pointer to a C-style string explicit."
msgstr""

# CppCoreGuidelines.md:13663
msgid "13663    A sequence of characters that is not assumed to be zero-terminated should be a `char*`, rather than a `zstring`."
msgstr""

# CppCoreGuidelines.md:13664
msgid "13664    French accent optional."
msgstr""

       
# CppCoreGuidelines.md:13665
msgid "13665    Use `not_null<zstring>` for C-style strings that cannot be `nullptr`. ??? Do we need a name for `not_null<zstring>`? or is its ugliness a feature?"
msgstr""

       
# CppCoreGuidelines.md:13666
msgid "13666    ## <a name=\"SS-ownership\"></a>GSL.owner: Ownership pointers"
msgstr""

       
# CppCoreGuidelines.md:13667
msgid "13667    * `unique_ptr<T>`     // unique ownership: `std::unique_ptr<T>`"
msgstr""

# CppCoreGuidelines.md:13668
msgid "13668    * `shared_ptr<T>`     // shared ownership: `std::shared_ptr<T>` (a counted pointer)"
msgstr""

# CppCoreGuidelines.md:13669
msgid "13669    * `stack_array<T>`    // A stack-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless `T` is a `const` type."
msgstr""

# CppCoreGuidelines.md:13670
msgid "13670    * `dyn_array<T>`      // ??? needed ??? A heap-allocated array. The number of elements are determined at construction and fixed thereafter."
msgstr""

# CppCoreGuidelines.md:13671
msgid "13671      The elements are mutable unless `T` is a `const` type. Basically a `span` that allocates and owns its elements."
msgstr""

       
# CppCoreGuidelines.md:13672
msgid "13672    ## <a name=\"SS-assertions\"></a>GSL.assert: Assertions"
msgstr""

       
# CppCoreGuidelines.md:13673
msgid "13673    * `Expects`     // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations."
msgstr""

# CppCoreGuidelines.md:13674
msgid "13674                    // `Expects(p)` terminates the program unless `p == true`"
msgstr""

# CppCoreGuidelines.md:13675
msgid "13675                    // `Expect` in under control of some options (enforcement, error message, alternatives to terminate)"
msgstr""

# CppCoreGuidelines.md:13676
msgid "13676    * `Ensures`     // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations."
msgstr""

       
# CppCoreGuidelines.md:13677
msgid "13677    These assertions are currently macros (yuck!) and must appear in function definitions (only)"
msgstr""

# CppCoreGuidelines.md:13678
msgid "13678    pending standard committee decisions on contracts and assertion syntax."
msgstr""

# CppCoreGuidelines.md:13679
msgid "13679    See [the contract proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf); using the attribute syntax,"
msgstr""

# CppCoreGuidelines.md:13680
msgid "13680    for example, `Expects(p)` will become `[[expects: p]]`."
msgstr""

       
# CppCoreGuidelines.md:13681
msgid "13681    ## <a name=\"SS-utilities\"></a>GSL.util: Utilities"
msgstr""

       
# CppCoreGuidelines.md:13682
msgid "13682    * `finally`        // `finally(f)` makes a `final_action{f}` with a destructor that invokes `f`"
msgstr""

# CppCoreGuidelines.md:13683
msgid "13683    * `narrow_cast`    // `narrow_cast<T>(x)` is `static_cast<T>(x)`"
msgstr""

# CppCoreGuidelines.md:13684
msgid "13684    * `narrow`         // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) == x` or it throws `narrowing_error`"
msgstr""

# CppCoreGuidelines.md:13685
msgid "13685    * `[[implicit]]`   // \"Marker\" to put on single-argument constructors to explicitly make them non-explicit."
msgstr""

# CppCoreGuidelines.md:13686
msgid "13686    * `move_owner`     // `p = move_owner(q)` means `p = q` but ???"
msgstr""

# CppCoreGuidelines.md:13687
msgid "13687    * `joining_thread` // a RAII style version of `std::thread` that joins."
msgstr""

# CppCoreGuidelines.md:13688
msgid "13688    * `index`          // a type to use for all container and array indexing (currently an alias for `ptrdiff_t`)"
msgstr""

       
# CppCoreGuidelines.md:13689
msgid "13689    ## <a name=\"SS-gsl-concepts\"></a>GSL.concept: Concepts"
msgstr""

       
# CppCoreGuidelines.md:13690
msgid "13690    These concepts (type predicates) are borrowed from"
msgstr""

# CppCoreGuidelines.md:13691
msgid "13691    Andrew Sutton's Origin library,"
msgstr""

# CppCoreGuidelines.md:13692
msgid "13692    the Range proposal,"
msgstr""

# CppCoreGuidelines.md:13693
msgid "13693    and the ISO WG21 Palo Alto TR."
msgstr""

# CppCoreGuidelines.md:13694
msgid "13694    They are likely to be very similar to what will become part of the ISO C++ standard."
msgstr""

# CppCoreGuidelines.md:13695
msgid "13695    The notation is that of the ISO WG21 [Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)."
msgstr""

# CppCoreGuidelines.md:13696
msgid "13696    Most of the concepts below are defined in [the Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)."
msgstr""

       
# CppCoreGuidelines.md:13697
msgid "13697    * `Range`"
msgstr""

# CppCoreGuidelines.md:13698
msgid "13698    * `String`   // ???"
msgstr""

# CppCoreGuidelines.md:13699
msgid "13699    * `Number`   // ???"
msgstr""

# CppCoreGuidelines.md:13700
msgid "13700    * `Sortable`"
msgstr""

# CppCoreGuidelines.md:13701
msgid "13701    * `Pointer`  // A type with `*`, `->`, `==`, and default construction (default construction is assumed to set the singular \"null\" value); see [smart pointers](#SS-gsl-smartptrconcepts)"
msgstr""

# CppCoreGuidelines.md:13702
msgid "13702    * `Unique_ptr`  // A type that matches `Pointer`, has move (not copy), and matches the Lifetime profile criteria for a `unique` owner type; see [smart pointers](#SS-gsl-smartptrconcepts)"
msgstr""

# CppCoreGuidelines.md:13703
msgid "13703    * `Shared_ptr`   // A type that matches `Pointer`, has copy, and matches the Lifetime profile criteria for a `shared` owner type; see [smart pointers](#SS-gsl-smartptrconcepts)"
msgstr""

# CppCoreGuidelines.md:13704
msgid "13704    * `EqualityComparable`   // ???Must we suffer CaMelcAse???"
msgstr""

# CppCoreGuidelines.md:13705
msgid "13705    * `Convertible`"
msgstr""

# CppCoreGuidelines.md:13706
msgid "13706    * `Common`"
msgstr""

# CppCoreGuidelines.md:13707
msgid "13707    * `Boolean`"
msgstr""

# CppCoreGuidelines.md:13708
msgid "13708    * `Integral`"
msgstr""

# CppCoreGuidelines.md:13709
msgid "13709    * `SignedIntegral`"
msgstr""

# CppCoreGuidelines.md:13710
msgid "13710    * `SemiRegular` // ??? Copyable?"
msgstr""

# CppCoreGuidelines.md:13711
msgid "13711    * `Regular`"
msgstr""

# CppCoreGuidelines.md:13712
msgid "13712    * `TotallyOrdered`"
msgstr""

# CppCoreGuidelines.md:13713
msgid "13713    * `Function`"
msgstr""

# CppCoreGuidelines.md:13714
msgid "13714    * `RegularFunction`"
msgstr""

# CppCoreGuidelines.md:13715
msgid "13715    * `Predicate`"
msgstr""

# CppCoreGuidelines.md:13716
msgid "13716    * `Relation`"
msgstr""

# CppCoreGuidelines.md:13717
msgid "13717    * ..."
msgstr""

       
# CppCoreGuidelines.md:13718
msgid "13718    ### <a name=\"SS-gsl-smartptrconcepts\"></a>GSL.ptr: Smart pointer concepts"
msgstr""

       
# CppCoreGuidelines.md:13719
msgid "13719    See [Lifetimes paper](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetimes%20I%20and%20II%20-%20v0.9.1.pdf)."
msgstr""

       
# CppCoreGuidelines.md:13720
msgid "13720    # <a name=\"S-naming\"></a>NL: Naming and layout rules"
msgstr""

       
# CppCoreGuidelines.md:13721
msgid "13721    Consistent naming and layout are helpful."
msgstr""

# CppCoreGuidelines.md:13722
msgid "13722    If for no other reason because it minimizes \"my style is better than your style\" arguments."
msgstr""

# CppCoreGuidelines.md:13723
msgid "13723    However, there are many, many, different styles around and people are passionate about them (pro and con)."
msgstr""

# CppCoreGuidelines.md:13724
msgid "13724    Also, most real-world projects includes code from many sources, so standardizing on a single style for all code is often impossible."
msgstr""

# CppCoreGuidelines.md:13725
msgid "13725    We present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set."
msgstr""

# CppCoreGuidelines.md:13726
msgid "13726    IDEs and tools can help (as well as hinder)."
msgstr""

       
# CppCoreGuidelines.md:13727
msgid "13727    Naming and layout rules:"
msgstr""

       
# CppCoreGuidelines.md:13728
msgid "13728    * [NL.1: Don't say in comments what can be clearly stated in code](#Rl-comments)"
msgstr""

# CppCoreGuidelines.md:13729
msgid "13729    * [NL.2: State intent in comments](#Rl-comments-intent)"
msgstr""

# CppCoreGuidelines.md:13730
msgid "13730    * [NL.3: Keep comments crisp](#Rl-comments-crisp)"
msgstr""

# CppCoreGuidelines.md:13731
msgid "13731    * [NL.4: Maintain a consistent indentation style](#Rl-indent)"
msgstr""

# CppCoreGuidelines.md:13732
msgid "13732    * [NL.5: Avoid encoding type information in names](#Rl-name-type)"
msgstr""

# CppCoreGuidelines.md:13733
msgid "13733    * [NL.7: Make the length of a name roughly proportional to the length of its scope](#Rl-name-length)"
msgstr""

# CppCoreGuidelines.md:13734
msgid "13734    * [NL.8: Use a consistent naming style](#Rl-name)"
msgstr""

# CppCoreGuidelines.md:13735
msgid "13735    * [NL.9: Use `ALL_CAPS` for macro names only](#Rl-all-caps)"
msgstr""

# CppCoreGuidelines.md:13736
msgid "13736    * [NL.10: Prefer `underscore_style` names](#Rl-camel)"
msgstr""

# CppCoreGuidelines.md:13737
msgid "13737    * [NL.11: Make literals readable](#Rl-literals)"
msgstr""

# CppCoreGuidelines.md:13738
msgid "13738    * [NL.15: Use spaces sparingly](#Rl-space)"
msgstr""

# CppCoreGuidelines.md:13739
msgid "13739    * [NL.16: Use a conventional class member declaration order](#Rl-order)"
msgstr""

# CppCoreGuidelines.md:13740
msgid "13740    * [NL.17: Use K&R-derived layout](#Rl-knr)"
msgstr""

# CppCoreGuidelines.md:13741
msgid "13741    * [NL.18: Use C++-style declarator layout](#Rl-ptr)"
msgstr""

# CppCoreGuidelines.md:13742
msgid "13742    * [NL.19: Avoid names that are easily misread](#Rl-misread)"
msgstr""

# CppCoreGuidelines.md:13743
msgid "13743    * [NL.20: Don't place two statements on the same line](#Rl-stmt)"
msgstr""

# CppCoreGuidelines.md:13744
msgid "13744    * [NL.21: Declare one name (only) per declaration](#Rl-dcl)"
msgstr""

# CppCoreGuidelines.md:13745
msgid "13745    * [NL.25: Don't use `void` as an argument type](#Rl-void)"
msgstr""

# CppCoreGuidelines.md:13746
msgid "13746    * [NL.26: Use conventional `const` notation](#Rl-const)"
msgstr""

       
# CppCoreGuidelines.md:13747
msgid "13747    Most of these rules are aesthetic and programmers hold strong opinions."
msgstr""

# CppCoreGuidelines.md:13748
msgid "13748    IDEs also tend to have defaults and a range of alternatives."
msgstr""

# CppCoreGuidelines.md:13749
msgid "13749    These rules are suggested defaults to follow unless you have reasons not to."
msgstr""

       
# CppCoreGuidelines.md:13750
msgid "13750    We have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to \"legislate\" them."
msgstr""

# CppCoreGuidelines.md:13751
msgid "13751    We are not \"legislating\" (see the previous paragraph)."
msgstr""

# CppCoreGuidelines.md:13752
msgid "13752    However, we have had many requests for a set of naming and layout conventions to use when there are no external constraints."
msgstr""

       
# CppCoreGuidelines.md:13753
msgid "13753    More specific and detailed rules are easier to enforce."
msgstr""

       
# CppCoreGuidelines.md:13754
msgid "13754    These rules bear a strong resemblance to the recommendations in the [PPP Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)"
msgstr""

# CppCoreGuidelines.md:13755
msgid "13755    written in support of Stroustrup's [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html)."
msgstr""

       
# CppCoreGuidelines.md:13756
msgid "13756    ### <a name=\"Rl-comments\"></a>NL.1: Don't say in comments what can be clearly stated in code"
msgstr""

       
# CppCoreGuidelines.md:13757
msgid "13757    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13758
msgid "13758    Compilers do not read comments."
msgstr""

# CppCoreGuidelines.md:13759
msgid "13759    Comments are less precise than code."
msgstr""

# CppCoreGuidelines.md:13760
msgid "13760    Comments are not updated as consistently as code."
msgstr""

       
# CppCoreGuidelines.md:13761
msgid "13761    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13762
msgid "13762        auto x = m * v1 + vv;   // multiply m with v1 and add the result to vv"
msgstr""

       
# CppCoreGuidelines.md:13763
msgid "13763    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13764
msgid "13764    Build an AI program that interprets colloquial English text and see if what is said could be better expressed in C++."
msgstr""

       
# CppCoreGuidelines.md:13765
msgid "13765    ### <a name=\"Rl-comments-intent\"></a>NL.2: State intent in comments"
msgstr""

       
# CppCoreGuidelines.md:13766
msgid "13766    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13767
msgid "13767    Code says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation."
msgstr""

       
# CppCoreGuidelines.md:13768
msgid "13768    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13769
msgid "13769        void stable_sort(Sortable& c)"
msgstr""

# CppCoreGuidelines.md:13770
msgid "13770            // sort c in the order determined by <, keep equal elements (as defined by ==) in"
msgstr""

# CppCoreGuidelines.md:13771
msgid "13771            // their original relative order"
msgstr""

# CppCoreGuidelines.md:13772
msgid "13772        {"
msgstr""

# CppCoreGuidelines.md:13773
msgid "13773            // ... quite a few lines of non-trivial code ..."
msgstr""

# CppCoreGuidelines.md:13774
msgid "13774        }"
msgstr""

       
# CppCoreGuidelines.md:13775
msgid "13775    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13776
msgid "13776    If the comment and the code disagree, both are likely to be wrong."
msgstr""

       
# CppCoreGuidelines.md:13777
msgid "13777    ### <a name=\"Rl-comments-crisp\"></a>NL.3: Keep comments crisp"
msgstr""

       
# CppCoreGuidelines.md:13778
msgid "13778    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13779
msgid "13779    Verbosity slows down understanding and makes the code harder to read by spreading it around in the source file."
msgstr""

       
# CppCoreGuidelines.md:13780
msgid "13780    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13781
msgid "13781    Use intelligible English."
msgstr""

# CppCoreGuidelines.md:13782
msgid "13782    I may be fluent in Danish, but most programmers are not; the maintainers of my code may not be."
msgstr""

# CppCoreGuidelines.md:13783
msgid "13783    Avoid SMS lingo and watch your grammar, punctuation, and capitalization."
msgstr""

# CppCoreGuidelines.md:13784
msgid "13784    Aim for professionalism, not \"cool.\""
msgstr""

       
# CppCoreGuidelines.md:13785
msgid "13785    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13786
msgid "13786    not possible."
msgstr""

       
# CppCoreGuidelines.md:13787
msgid "13787    ### <a name=\"Rl-indent\"></a>NL.4: Maintain a consistent indentation style"
msgstr""

       
# CppCoreGuidelines.md:13788
msgid "13788    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13789
msgid "13789    Readability. Avoidance of \"silly mistakes.\""
msgstr""

       
# CppCoreGuidelines.md:13790
msgid "13790    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13791
msgid "13791        int i;"
msgstr""

# CppCoreGuidelines.md:13792
msgid "13792        for (i = 0; i < max; ++i); // bug waiting to happen"
msgstr""

# CppCoreGuidelines.md:13793
msgid "13793        if (i == j)"
msgstr""

# CppCoreGuidelines.md:13794
msgid "13794            return i;"
msgstr""

       
# CppCoreGuidelines.md:13795
msgid "13795    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13796
msgid "13796    Always indenting the statement after `if (...)`, `for (...)`, and `while (...)` is usually a good idea:"
msgstr""

       
# CppCoreGuidelines.md:13797
msgid "13797        if (i < 0) error(\"negative argument\");"
msgstr""

       
# CppCoreGuidelines.md:13798
msgid "13798        if (i < 0)"
msgstr""

# CppCoreGuidelines.md:13799
msgid "13799            error(\"negative argument\");"
msgstr""

       
# CppCoreGuidelines.md:13800
msgid "13800    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13801
msgid "13801    Use a tool."
msgstr""

       
# CppCoreGuidelines.md:13802
msgid "13802    ### <a name=\"Rl-name-type\"></a>NL.5: Avoid encoding type information in names"
msgstr""

       
# CppCoreGuidelines.md:13803
msgid "13803    ##### Rationale"
msgstr""

       
# CppCoreGuidelines.md:13804
msgid "13804    If names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality."
msgstr""

# CppCoreGuidelines.md:13805
msgid "13805    Also, if the type of a variable is changed, code using it will have to be modified."
msgstr""

# CppCoreGuidelines.md:13806
msgid "13806    Minimize unintentional conversions."
msgstr""

       
# CppCoreGuidelines.md:13807
msgid "13807    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13808
msgid "13808        void print_int(int i);"
msgstr""

# CppCoreGuidelines.md:13809
msgid "13809        void print_string(const char*);"
msgstr""

       
# CppCoreGuidelines.md:13810
msgid "13810        print_int(1);          // repetitive, manual type matching"
msgstr""

# CppCoreGuidelines.md:13811
msgid "13811        print_string(\"xyzzy\"); // repetitive, manual type matching"
msgstr""

       
# CppCoreGuidelines.md:13812
msgid "13812    ##### Example, good"
msgstr""

       
# CppCoreGuidelines.md:13813
msgid "13813        void print(int i);"
msgstr""

# CppCoreGuidelines.md:13814
msgid "13814        void print(string_view);    // also works on any string-like sequence"
msgstr""

       
# CppCoreGuidelines.md:13815
msgid "13815        print(1);              // clear, automatic type matching"
msgstr""

# CppCoreGuidelines.md:13816
msgid "13816        print(\"xyzzy\");        // clear, automatic type matching"
msgstr""

       
# CppCoreGuidelines.md:13817
msgid "13817    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13818
msgid "13818    Names with types encoded are either verbose or cryptic."
msgstr""

       
# CppCoreGuidelines.md:13819
msgid "13819        printS  // print a std::string"
msgstr""

# CppCoreGuidelines.md:13820
msgid "13820        prints  // print a C-style string"
msgstr""

# CppCoreGuidelines.md:13821
msgid "13821        printi  // print an int"
msgstr""

       
# CppCoreGuidelines.md:13822
msgid "13822    Requiring techniques like Hungarian notation to encode a type in a name is needed in C, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead)."
msgstr""

       
# CppCoreGuidelines.md:13823
msgid "13823    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13824
msgid "13824    Some styles use very general (not type-specific) prefixes to denote the general use of a variable."
msgstr""

       
# CppCoreGuidelines.md:13825
msgid "13825        auto p = new User();"
msgstr""

# CppCoreGuidelines.md:13826
msgid "13826        auto p = make_unique<User>();"
msgstr""

# CppCoreGuidelines.md:13827
msgid "13827        // note: \"p\" is not being used to say \"raw pointer to type User,\""
msgstr""

# CppCoreGuidelines.md:13828
msgid "13828        //       just generally to say \"this is an indirection\""
msgstr""

       
# CppCoreGuidelines.md:13829
msgid "13829        auto cntHits = calc_total_of_hits(/*...*/);"
msgstr""

# CppCoreGuidelines.md:13830
msgid "13830        // note: \"cnt\" is not being used to encode a type,"
msgstr""

# CppCoreGuidelines.md:13831
msgid "13831        //       just generally to say \"this is a count of something\""
msgstr""

       
# CppCoreGuidelines.md:13832
msgid "13832    This is not harmful and does not fall under this guideline because it does not encode type information."
msgstr""

       
# CppCoreGuidelines.md:13833
msgid "13833    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13834
msgid "13834    Some styles distinguishes members from local variable, and/or from global variable."
msgstr""

       
# CppCoreGuidelines.md:13835
msgid "13835        struct S {"
msgstr""

# CppCoreGuidelines.md:13836
msgid "13836            int m_;"
msgstr""

# CppCoreGuidelines.md:13837
msgid "13837            S(int m) :m_{abs(m)} { }"
msgstr""

# CppCoreGuidelines.md:13838
msgid "13838        };"
msgstr""

       
# CppCoreGuidelines.md:13839
msgid "13839    This is not harmful and does not fall under this guideline because it does not encode type information."
msgstr""

       
# CppCoreGuidelines.md:13840
msgid "13840    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13841
msgid "13841    Like C++, some styles distinguishes types from non-types."
msgstr""

# CppCoreGuidelines.md:13842
msgid "13842    For example, by capitalizing type names, but not the names of functions and variables."
msgstr""

       
# CppCoreGuidelines.md:13843
msgid "13843        typename<typename T>"
msgstr""

# CppCoreGuidelines.md:13844
msgid "13844        class HashTable {   // maps string to T"
msgstr""

# CppCoreGuidelines.md:13845
msgid "13845            // ..."
msgstr""

# CppCoreGuidelines.md:13846
msgid "13846        };"
msgstr""

       
# CppCoreGuidelines.md:13847
msgid "13847        HashTable<int> index;"
msgstr""

       
# CppCoreGuidelines.md:13848
msgid "13848    This is not harmful and does not fall under this guideline because it does not encode type information."
msgstr""

       
# CppCoreGuidelines.md:13849
msgid "13849    ### <a name=\"Rl-name-length\"></a>NL.7: Make the length of a name roughly proportional to the length of its scope"
msgstr""

       
# CppCoreGuidelines.md:13850
msgid "13850    **Rationale**: The larger the scope the greater the chance of confusion and of an unintended name clash."
msgstr""

       
# CppCoreGuidelines.md:13851
msgid "13851    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13852
msgid "13852        double sqrt(double x);   // return the square root of x; x must be non-negative"
msgstr""

       
# CppCoreGuidelines.md:13853
msgid "13853        int length(const char* p);  // return the number of characters in a zero-terminated C-style string"
msgstr""

       
# CppCoreGuidelines.md:13854
msgid "13854        int length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose"
msgstr""

       
# CppCoreGuidelines.md:13855
msgid "13855        int g;      // bad: global variable with a cryptic name"
msgstr""

       
# CppCoreGuidelines.md:13856
msgid "13856        int open;   // bad: global variable with a short, popular name"
msgstr""

       
# CppCoreGuidelines.md:13857
msgid "13857    The use of `p` for pointer and `x` for a floating-point variable is conventional and non-confusing in a restricted scope."
msgstr""

       
# CppCoreGuidelines.md:13858
msgid "13858    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13859
msgid "13859    ???"
msgstr""

       
# CppCoreGuidelines.md:13860
msgid "13860    ### <a name=\"Rl-name\"></a>NL.8: Use a consistent naming style"
msgstr""

       
# CppCoreGuidelines.md:13861
msgid "13861    **Rationale**: Consistence in naming and naming style increases readability."
msgstr""

       
# CppCoreGuidelines.md:13862
msgid "13862    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13863
msgid "13863    There are many styles and when you use multiple libraries, you can't follow all their different conventions."
msgstr""

# CppCoreGuidelines.md:13864
msgid "13864    Choose a \"house style\", but leave \"imported\" libraries with their original style."
msgstr""

       
# CppCoreGuidelines.md:13865
msgid "13865    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13866
msgid "13866    ISO Standard, use lower case only and digits, separate words with underscores:"
msgstr""

       
# CppCoreGuidelines.md:13867
msgid "13867    * `int`"
msgstr""

# CppCoreGuidelines.md:13868
msgid "13868    * `vector`"
msgstr""

# CppCoreGuidelines.md:13869
msgid "13869    * `my_map`"
msgstr""

       
# CppCoreGuidelines.md:13870
msgid "13870    Avoid double underscores `__`."
msgstr""

       
# CppCoreGuidelines.md:13871
msgid "13871    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13872
msgid "13872    [Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):"
msgstr""

# CppCoreGuidelines.md:13873
msgid "13873    ISO Standard, but with upper case used for your own types and concepts:"
msgstr""

       
# CppCoreGuidelines.md:13874
msgid "13874    * `int`"
msgstr""

# CppCoreGuidelines.md:13875
msgid "13875    * `vector`"
msgstr""

# CppCoreGuidelines.md:13876
msgid "13876    * `My_map`"
msgstr""

       
# CppCoreGuidelines.md:13877
msgid "13877    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13878
msgid "13878    CamelCase: capitalize each word in a multi-word identifier:"
msgstr""

       
# CppCoreGuidelines.md:13879
msgid "13879    * `int`"
msgstr""

# CppCoreGuidelines.md:13880
msgid "13880    * `vector`"
msgstr""

# CppCoreGuidelines.md:13881
msgid "13881    * `MyMap`"
msgstr""

# CppCoreGuidelines.md:13882
msgid "13882    * `myMap`"
msgstr""

       
# CppCoreGuidelines.md:13883
msgid "13883    Some conventions capitalize the first letter, some don't."
msgstr""

       
# CppCoreGuidelines.md:13884
msgid "13884    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13885
msgid "13885    Try to be consistent in your use of acronyms and lengths of identifiers:"
msgstr""

       
# CppCoreGuidelines.md:13886
msgid "13886        int mtbf {12};"
msgstr""

# CppCoreGuidelines.md:13887
msgid "13887        int mean_time_between_failures {12}; // make up your mind"
msgstr""

       
# CppCoreGuidelines.md:13888
msgid "13888    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13889
msgid "13889    Would be possible except for the use of libraries with varying conventions."
msgstr""

       
# CppCoreGuidelines.md:13890
msgid "13890    ### <a name=\"Rl-all-caps\"></a>NL.9: Use `ALL_CAPS` for macro names only"
msgstr""

       
# CppCoreGuidelines.md:13891
msgid "13891    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13892
msgid "13892    To avoid confusing macros with names that obey scope and type rules."
msgstr""

       
# CppCoreGuidelines.md:13893
msgid "13893    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13894
msgid "13894        void f()"
msgstr""

# CppCoreGuidelines.md:13895
msgid "13895        {"
msgstr""

# CppCoreGuidelines.md:13896
msgid "13896            const int SIZE{1000};  // Bad, use 'size' instead"
msgstr""

# CppCoreGuidelines.md:13897
msgid "13897            int v[SIZE];"
msgstr""

# CppCoreGuidelines.md:13898
msgid "13898        }"
msgstr""

       
# CppCoreGuidelines.md:13899
msgid "13899    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13900
msgid "13900    This rule applies to non-macro symbolic constants:"
msgstr""

       
# CppCoreGuidelines.md:13901
msgid "13901        enum bad { BAD, WORSE, HORRIBLE }; // BAD"
msgstr""

       
# CppCoreGuidelines.md:13902
msgid "13902    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13903
msgid "13903    * Flag macros with lower-case letters"
msgstr""

# CppCoreGuidelines.md:13904
msgid "13904    * Flag `ALL_CAPS` non-macro names"
msgstr""

       
# CppCoreGuidelines.md:13905
msgid "13905    ### <a name=\"Rl-camel\"></a>NL.10: Prefer `underscore_style` names"
msgstr""

       
# CppCoreGuidelines.md:13906
msgid "13906    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13907
msgid "13907    The use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library."
msgstr""

       
# CppCoreGuidelines.md:13908
msgid "13908    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13909
msgid "13909    This rule is a default to use only if you have a choice."
msgstr""

# CppCoreGuidelines.md:13910
msgid "13910    Often, you don't have a choice and must follow an established style for [consistency](#Rl-name)."
msgstr""

# CppCoreGuidelines.md:13911
msgid "13911    The need for consistency beats personal taste."
msgstr""

       
# CppCoreGuidelines.md:13912
msgid "13912    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13913
msgid "13913    [Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):"
msgstr""

# CppCoreGuidelines.md:13914
msgid "13914    ISO Standard, but with upper case used for your own types and concepts:"
msgstr""

       
# CppCoreGuidelines.md:13915
msgid "13915    * `int`"
msgstr""

# CppCoreGuidelines.md:13916
msgid "13916    * `vector`"
msgstr""

# CppCoreGuidelines.md:13917
msgid "13917    * `My_map`"
msgstr""

       
# CppCoreGuidelines.md:13918
msgid "13918    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13919
msgid "13919    Impossible."
msgstr""

       
# CppCoreGuidelines.md:13920
msgid "13920    ### <a name=\"Rl-space\"></a>NL.15: Use spaces sparingly"
msgstr""

       
# CppCoreGuidelines.md:13921
msgid "13921    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13922
msgid "13922    Too much space makes the text larger and distracts."
msgstr""

       
# CppCoreGuidelines.md:13923
msgid "13923    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13924
msgid "13924        #include < map >"
msgstr""

       
# CppCoreGuidelines.md:13925
msgid "13925        int main(int argc, char * argv [ ])"
msgstr""

# CppCoreGuidelines.md:13926
msgid "13926        {"
msgstr""

# CppCoreGuidelines.md:13927
msgid "13927            // ..."
msgstr""

# CppCoreGuidelines.md:13928
msgid "13928        }"
msgstr""

       
# CppCoreGuidelines.md:13929
msgid "13929    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13930
msgid "13930        #include <map>"
msgstr""

       
# CppCoreGuidelines.md:13931
msgid "13931        int main(int argc, char* argv[])"
msgstr""

# CppCoreGuidelines.md:13932
msgid "13932        {"
msgstr""

# CppCoreGuidelines.md:13933
msgid "13933            // ..."
msgstr""

# CppCoreGuidelines.md:13934
msgid "13934        }"
msgstr""

       
# CppCoreGuidelines.md:13935
msgid "13935    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13936
msgid "13936    Some IDEs have their own opinions and add distracting space."
msgstr""

       
# CppCoreGuidelines.md:13937
msgid "13937    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13938
msgid "13938    We value well-placed whitespace as a significant help for readability. Just don't overdo it."
msgstr""

       
# CppCoreGuidelines.md:13939
msgid "13939    ### <a name=\"Rl-literals\"></a>NL.11: Make literals readable"
msgstr""

       
# CppCoreGuidelines.md:13940
msgid "13940    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13941
msgid "13941    Readability."
msgstr""

       
# CppCoreGuidelines.md:13942
msgid "13942    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13943
msgid "13943    Use digit separators to avoid long strings of digits"
msgstr""

       
# CppCoreGuidelines.md:13944
msgid "13944        auto c = 299'792'458; // m/s2"
msgstr""

# CppCoreGuidelines.md:13945
msgid "13945        auto q2 = 0b0000'1111'0000'0000;"
msgstr""

# CppCoreGuidelines.md:13946
msgid "13946        auto ss_number = 123'456'7890;"
msgstr""

       
# CppCoreGuidelines.md:13947
msgid "13947    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13948
msgid "13948    Use literal suffixes where clarification is needed"
msgstr""

       
# CppCoreGuidelines.md:13949
msgid "13949        auto hello = \"Hello!\"s; // a std::string"
msgstr""

# CppCoreGuidelines.md:13950
msgid "13950        auto world = \"world\";   // a C-style string"
msgstr""

# CppCoreGuidelines.md:13951
msgid "13951        auto interval = 100ms;  // using <chrono>"
msgstr""

       
# CppCoreGuidelines.md:13952
msgid "13952    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:13953
msgid "13953    Literals should not be sprinkled all over the code as [\"magic constants\"](#Res-magic),"
msgstr""

# CppCoreGuidelines.md:13954
msgid "13954    but it is still a good idea to make them readable where they are defined."
msgstr""

# CppCoreGuidelines.md:13955
msgid "13955    It is easy to make a typo in a long string of integers."
msgstr""

       
# CppCoreGuidelines.md:13956
msgid "13956    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13957
msgid "13957    Flag long digit sequences. The trouble is to define \"long\"; maybe 7."
msgstr""

       
# CppCoreGuidelines.md:13958
msgid "13958    ### <a name=\"Rl-order\"></a>NL.16: Use a conventional class member declaration order"
msgstr""

       
# CppCoreGuidelines.md:13959
msgid "13959    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:13960
msgid "13960    A conventional order of members improves readability."
msgstr""

       
# CppCoreGuidelines.md:13961
msgid "13961    When declaring a class use the following order"
msgstr""

       
# CppCoreGuidelines.md:13962
msgid "13962    * types: classes, enums, and aliases (`using`)"
msgstr""

# CppCoreGuidelines.md:13963
msgid "13963    * constructors, assignments, destructor"
msgstr""

# CppCoreGuidelines.md:13964
msgid "13964    * functions"
msgstr""

# CppCoreGuidelines.md:13965
msgid "13965    * data"
msgstr""

       
# CppCoreGuidelines.md:13966
msgid "13966    Use the `public` before `protected` before `private` order."
msgstr""

       
# CppCoreGuidelines.md:13967
msgid "13967    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13968
msgid "13968        class X {"
msgstr""

# CppCoreGuidelines.md:13969
msgid "13969        public:"
msgstr""

# CppCoreGuidelines.md:13970
msgid "13970            // interface"
msgstr""

# CppCoreGuidelines.md:13971
msgid "13971        protected:"
msgstr""

# CppCoreGuidelines.md:13972
msgid "13972            // unchecked function for use by derived class implementations"
msgstr""

# CppCoreGuidelines.md:13973
msgid "13973        private:"
msgstr""

# CppCoreGuidelines.md:13974
msgid "13974            // implementation details"
msgstr""

# CppCoreGuidelines.md:13975
msgid "13975        };"
msgstr""

       
# CppCoreGuidelines.md:13976
msgid "13976    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:13977
msgid "13977    Sometimes, the default order of members conflicts with a desire to separate the public interface from implementation details."
msgstr""

# CppCoreGuidelines.md:13978
msgid "13978    In such cases, private types and functions can be placed with private data."
msgstr""

       
# CppCoreGuidelines.md:13979
msgid "13979        class X {"
msgstr""

# CppCoreGuidelines.md:13980
msgid "13980        public:"
msgstr""

# CppCoreGuidelines.md:13981
msgid "13981            // interface"
msgstr""

# CppCoreGuidelines.md:13982
msgid "13982        protected:"
msgstr""

# CppCoreGuidelines.md:13983
msgid "13983            // unchecked function for use by derived class implementations"
msgstr""

# CppCoreGuidelines.md:13984
msgid "13984        private:"
msgstr""

# CppCoreGuidelines.md:13985
msgid "13985            // implementation details (types, functions, and data)"
msgstr""

# CppCoreGuidelines.md:13986
msgid "13986        };"
msgstr""

       
# CppCoreGuidelines.md:13987
msgid "13987    ##### Example, bad"
msgstr""

       
# CppCoreGuidelines.md:13988
msgid "13988    Avoid multiple blocks of declarations of one access (e.g., `public`) dispersed among blocks of declarations with different access (e.g. `private`)."
msgstr""

       
# CppCoreGuidelines.md:13989
msgid "13989        class X {   // bad"
msgstr""

# CppCoreGuidelines.md:13990
msgid "13990        public:"
msgstr""

# CppCoreGuidelines.md:13991
msgid "13991            void f();"
msgstr""

# CppCoreGuidelines.md:13992
msgid "13992        public:"
msgstr""

# CppCoreGuidelines.md:13993
msgid "13993            int g();"
msgstr""

# CppCoreGuidelines.md:13994
msgid "13994            // ..."
msgstr""

# CppCoreGuidelines.md:13995
msgid "13995        };"
msgstr""

       
# CppCoreGuidelines.md:13996
msgid "13996    The use of macros to declare groups of members often leads to violation of any ordering rules."
msgstr""

# CppCoreGuidelines.md:13997
msgid "13997    However, macros obscures what is being expressed anyway."
msgstr""

       
# CppCoreGuidelines.md:13998
msgid "13998    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:13999
msgid "13999    Flag departures from the suggested order. There will be a lot of old code that doesn't follow this rule."
msgstr""

       
# CppCoreGuidelines.md:14000
msgid "14000    ### <a name=\"Rl-knr\"></a>NL.17: Use K&R-derived layout"
msgstr""

       
# CppCoreGuidelines.md:14001
msgid "14001    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14002
msgid "14002    This is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well."
msgstr""

       
# CppCoreGuidelines.md:14003
msgid "14003    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14004
msgid "14004    In the context of C++, this style is often called \"Stroustrup\"."
msgstr""

       
# CppCoreGuidelines.md:14005
msgid "14005    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14006
msgid "14006        struct Cable {"
msgstr""

# CppCoreGuidelines.md:14007
msgid "14007            int x;"
msgstr""

# CppCoreGuidelines.md:14008
msgid "14008            // ..."
msgstr""

# CppCoreGuidelines.md:14009
msgid "14009        };"
msgstr""

       
# CppCoreGuidelines.md:14010
msgid "14010        double foo(int x)"
msgstr""

# CppCoreGuidelines.md:14011
msgid "14011        {"
msgstr""

# CppCoreGuidelines.md:14012
msgid "14012            if (0 < x) {"
msgstr""

# CppCoreGuidelines.md:14013
msgid "14013                // ..."
msgstr""

# CppCoreGuidelines.md:14014
msgid "14014            }"
msgstr""

       
# CppCoreGuidelines.md:14015
msgid "14015            switch (x) {"
msgstr""

# CppCoreGuidelines.md:14016
msgid "14016            case 0:"
msgstr""

# CppCoreGuidelines.md:14017
msgid "14017                // ..."
msgstr""

# CppCoreGuidelines.md:14018
msgid "14018                break;"
msgstr""

# CppCoreGuidelines.md:14019
msgid "14019            case amazing:"
msgstr""

# CppCoreGuidelines.md:14020
msgid "14020                // ..."
msgstr""

# CppCoreGuidelines.md:14021
msgid "14021                break;"
msgstr""

# CppCoreGuidelines.md:14022
msgid "14022            default:"
msgstr""

# CppCoreGuidelines.md:14023
msgid "14023                // ..."
msgstr""

# CppCoreGuidelines.md:14024
msgid "14024                break;"
msgstr""

# CppCoreGuidelines.md:14025
msgid "14025            }"
msgstr""

       
# CppCoreGuidelines.md:14026
msgid "14026            if (0 < x)"
msgstr""

# CppCoreGuidelines.md:14027
msgid "14027                ++x;"
msgstr""

       
# CppCoreGuidelines.md:14028
msgid "14028            if (x < 0)"
msgstr""

# CppCoreGuidelines.md:14029
msgid "14029                something();"
msgstr""

# CppCoreGuidelines.md:14030
msgid "14030            else"
msgstr""

# CppCoreGuidelines.md:14031
msgid "14031                something_else();"
msgstr""

       
# CppCoreGuidelines.md:14032
msgid "14032            return some_value;"
msgstr""

# CppCoreGuidelines.md:14033
msgid "14033        }"
msgstr""

       
# CppCoreGuidelines.md:14034
msgid "14034    Note the space between `if` and `(`"
msgstr""

       
# CppCoreGuidelines.md:14035
msgid "14035    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14036
msgid "14036    Use separate lines for each statement, the branches of an `if`, and the body of a `for`."
msgstr""

       
# CppCoreGuidelines.md:14037
msgid "14037    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14038
msgid "14038    The `{` for a `class` and a `struct` is *not* on a separate line, but the `{` for a function is."
msgstr""

       
# CppCoreGuidelines.md:14039
msgid "14039    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14040
msgid "14040    Capitalize the names of your user-defined types to distinguish them from standards-library types."
msgstr""

       
# CppCoreGuidelines.md:14041
msgid "14041    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14042
msgid "14042    Do not capitalize function names."
msgstr""

       
# CppCoreGuidelines.md:14043
msgid "14043    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14044
msgid "14044    If you want enforcement, use an IDE to reformat."
msgstr""

       
# CppCoreGuidelines.md:14045
msgid "14045    ### <a name=\"Rl-ptr\"></a>NL.18: Use C++-style declarator layout"
msgstr""

       
# CppCoreGuidelines.md:14046
msgid "14046    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14047
msgid "14047    The C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types."
msgstr""

# CppCoreGuidelines.md:14048
msgid "14048    The use in expressions argument doesn't hold for references."
msgstr""

       
# CppCoreGuidelines.md:14049
msgid "14049    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14050
msgid "14050        T& operator[](size_t);   // OK"
msgstr""

# CppCoreGuidelines.md:14051
msgid "14051        T &operator[](size_t);   // just strange"
msgstr""

# CppCoreGuidelines.md:14052
msgid "14052        T & operator[](size_t);   // undecided"
msgstr""

       
# CppCoreGuidelines.md:14053
msgid "14053    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14054
msgid "14054    Impossible in the face of history."
msgstr""

       
       
# CppCoreGuidelines.md:14055
msgid "14055    ### <a name=\"Rl-misread\"></a>NL.19: Avoid names that are easily misread"
msgstr""

       
# CppCoreGuidelines.md:14056
msgid "14056    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14057
msgid "14057    Readability."
msgstr""

# CppCoreGuidelines.md:14058
msgid "14058    Not everyone has screens and printers that make it easy to distinguish all characters."
msgstr""

# CppCoreGuidelines.md:14059
msgid "14059    We easily confuse similarly spelled and slightly misspelled words."
msgstr""

       
# CppCoreGuidelines.md:14060
msgid "14060    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14061
msgid "14061        int oO01lL = 6; // bad"
msgstr""

       
# CppCoreGuidelines.md:14062
msgid "14062        int splunk = 7;"
msgstr""

# CppCoreGuidelines.md:14063
msgid "14063        int splonk = 8; // bad: splunk and splonk are easily confused"
msgstr""

       
# CppCoreGuidelines.md:14064
msgid "14064    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14065
msgid "14065    ???"
msgstr""

       
# CppCoreGuidelines.md:14066
msgid "14066    ### <a name=\"Rl-stmt\"></a>NL.20: Don't place two statements on the same line"
msgstr""

       
# CppCoreGuidelines.md:14067
msgid "14067    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14068
msgid "14068    Readability."
msgstr""

# CppCoreGuidelines.md:14069
msgid "14069    It is really easy to overlook a statement when there is more on a line."
msgstr""

       
# CppCoreGuidelines.md:14070
msgid "14070    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14071
msgid "14071        int x = 7; char* p = 29;    // don't"
msgstr""

# CppCoreGuidelines.md:14072
msgid "14072        int x = 7; f(x);  ++x;      // don't"
msgstr""

       
# CppCoreGuidelines.md:14073
msgid "14073    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14074
msgid "14074    Easy."
msgstr""

       
# CppCoreGuidelines.md:14075
msgid "14075    ### <a name=\"Rl-dcl\"></a>NL.21: Declare one name (only) per declaration"
msgstr""

       
# CppCoreGuidelines.md:14076
msgid "14076    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14077
msgid "14077    Readability."
msgstr""

# CppCoreGuidelines.md:14078
msgid "14078    Minimizing confusion with the declarator syntax."
msgstr""

       
# CppCoreGuidelines.md:14079
msgid "14079    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14080
msgid "14080    For details, see [ES.10](#Res-name-one)."
msgstr""

       
       
# CppCoreGuidelines.md:14081
msgid "14081    ### <a name=\"Rl-void\"></a>NL.25: Don't use `void` as an argument type"
msgstr""

       
# CppCoreGuidelines.md:14082
msgid "14082    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14083
msgid "14083    It's verbose and only needed where C compatibility matters."
msgstr""

       
# CppCoreGuidelines.md:14084
msgid "14084    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14085
msgid "14085        void f(void);   // bad"
msgstr""

       
# CppCoreGuidelines.md:14086
msgid "14086        void g();       // better"
msgstr""

       
# CppCoreGuidelines.md:14087
msgid "14087    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14088
msgid "14088    Even Dennis Ritchie deemed `void f(void)` an abomination."
msgstr""

# CppCoreGuidelines.md:14089
msgid "14089    You can make an argument for that abomination in C when function prototypes were rare so that banning:"
msgstr""

       
# CppCoreGuidelines.md:14090
msgid "14090        int f();"
msgstr""

# CppCoreGuidelines.md:14091
msgid "14091        f(1, 2, \"weird but valid C89\");   // hope that f() is defined int f(a, b, c) char* c; { /* ... */ }"
msgstr""

       
# CppCoreGuidelines.md:14092
msgid "14092    would have caused major problems, but not in the 21st century and in C++."
msgstr""

       
# CppCoreGuidelines.md:14093
msgid "14093    ### <a name=\"Rl-const\"></a>NL.26: Use conventional `const` notation"
msgstr""

       
# CppCoreGuidelines.md:14094
msgid "14094    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14095
msgid "14095    Conventional notation is more familiar to more programmers."
msgstr""

# CppCoreGuidelines.md:14096
msgid "14096    Consistency in large code bases."
msgstr""

       
# CppCoreGuidelines.md:14097
msgid "14097    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14098
msgid "14098        const int x = 7;    // OK"
msgstr""

# CppCoreGuidelines.md:14099
msgid "14099        int const y = 9;    // bad"
msgstr""

       
# CppCoreGuidelines.md:14100
msgid "14100        const int *const p = nullptr;   // OK, constant pointer to constant int"
msgstr""

# CppCoreGuidelines.md:14101
msgid "14101        int const *const p = nullptr;   // bad, constant pointer to constant int"
msgstr""

       
# CppCoreGuidelines.md:14102
msgid "14102    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14103
msgid "14103    We are well aware that you could claim the \"bad\" examples more logical than the ones marked \"OK\","
msgstr""

# CppCoreGuidelines.md:14104
msgid "14104    but they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style."
msgstr""

       
# CppCoreGuidelines.md:14105
msgid "14105    As ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely."
msgstr""

       
# CppCoreGuidelines.md:14106
msgid "14106    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14107
msgid "14107    Flag `const` used as a suffix for a type."
msgstr""

       
# CppCoreGuidelines.md:14108
msgid "14108    # <a name=\"S-faq\"></a>FAQ: Answers to frequently asked questions"
msgstr""

       
# CppCoreGuidelines.md:14109
msgid "14109    This section covers answers to frequently asked questions about these guidelines."
msgstr""

       
# CppCoreGuidelines.md:14110
msgid "14110    ### <a name=\"Faq-aims\"></a>FAQ.1: What do these guidelines aim to achieve?"
msgstr""

       
# CppCoreGuidelines.md:14111
msgid "14111    See the <a href=\"#S-abstract\">top of this page</a>. This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard (as of this writing, C++14). The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines."
msgstr""

       
# CppCoreGuidelines.md:14112
msgid "14112    ### <a name=\"Faq-announced\"></a>FAQ.2: When and where was this work first announced?"
msgstr""

       
# CppCoreGuidelines.md:14113
msgid "14113    It was announced by [Bjarne Stroustrup in his CppCon 2015 opening keynote, \"Writing Good C++14\"](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote). See also the [accompanying isocpp.org blog post](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines), and for the rationale of the type and memory safety guidelines see [Herb Sutter's follow-up CppCon 2015 talk, \"Writing Good C++14 ... By Default\"](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary)."
msgstr""

       
# CppCoreGuidelines.md:14114
msgid "14114    ### <a name=\"Faq-maintainers\"></a>FAQ.3: Who are the authors and maintainers of these guidelines?"
msgstr""

       
# CppCoreGuidelines.md:14115
msgid "14115    The initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a \"0.6\" state, and contributions are welcome. As Stroustrup said in his announcement: \"We need help!\""
msgstr""

       
# CppCoreGuidelines.md:14116
msgid "14116    ### <a name=\"Faq-contribute\"></a>FAQ.4: How can I contribute?"
msgstr""

       
# CppCoreGuidelines.md:14117
msgid "14117    See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!"
msgstr""

       
# CppCoreGuidelines.md:14118
msgid "14118    ### <a name=\"Faq-maintainer\"></a>FAQ.5: How can I become an editor/maintainer?"
msgstr""

       
# CppCoreGuidelines.md:14119
msgid "14119    By contributing a lot first and having the consistent quality of your contributions recognized. See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!"
msgstr""

       
# CppCoreGuidelines.md:14120
msgid "14120    ### <a name=\"Faq-iso\"></a>FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?"
msgstr""

       
# CppCoreGuidelines.md:14121
msgid "14121    No. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee."
msgstr""

       
# CppCoreGuidelines.md:14122
msgid "14122    ### <a name=\"Faq-isocpp\"></a>FAQ.7: If these guidelines are not approved by the committee, why are they under `github.com/isocpp`?"
msgstr""

       
# CppCoreGuidelines.md:14123
msgid "14123    Because `isocpp` is the Standard C++ Foundation; the committee's repositories are under [github.com/*cplusplus*](https://github.com/cplusplus). Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the [C++ FAQ](https://isocpp.org/faq), which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way."
msgstr""

       
# CppCoreGuidelines.md:14124
msgid "14124    ### <a name=\"Faq-cpp98\"></a>FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version?"
msgstr""

       
# CppCoreGuidelines.md:14125
msgid "14125    No. These guidelines are about how to best use Standard C++14 (and, if you have an implementation available, the Concepts Technical Specification) and write code assuming you have a modern conforming compiler."
msgstr""

       
# CppCoreGuidelines.md:14126
msgid "14126    ### <a name=\"Faq-language-extensions\"></a>FAQ.9: Do these guidelines propose new language features?"
msgstr""

       
# CppCoreGuidelines.md:14127
msgid "14127    No. These guidelines are about how to best use Standard C++14 + the Concepts Technical Specification, and they limit themselves to recommending only those features."
msgstr""

       
# CppCoreGuidelines.md:14128
msgid "14128    ### <a name=\"Faq-markdown\"></a>FAQ.10: What version of Markdown do these guidelines use?"
msgstr""

       
# CppCoreGuidelines.md:14129
msgid "14129    These coding standards are written using [CommonMark](http://commonmark.org), and `<a>` HTML anchors."
msgstr""

       
# CppCoreGuidelines.md:14130
msgid "14130    We are considering the following extensions from [GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/):"
msgstr""

       
# CppCoreGuidelines.md:14131
msgid "14131    * fenced code blocks (consistently using indented vs. fenced is under discussion)"
msgstr""

# CppCoreGuidelines.md:14132
msgid "14132    * tables (none yet but we'll likely need them, and this is a GFM extension)"
msgstr""

       
# CppCoreGuidelines.md:14133
msgid "14133    Avoid other HTML tags and other extensions."
msgstr""

       
# CppCoreGuidelines.md:14134
msgid "14134    Note: We are not yet consistent with this style."
msgstr""

       
# CppCoreGuidelines.md:14135
msgid "14135    ### <a name=\"Faq-gsl\"></a>FAQ.50: What is the GSL (guidelines support library)?"
msgstr""

       
# CppCoreGuidelines.md:14136
msgid "14136    The GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject."
msgstr""

       
# CppCoreGuidelines.md:14137
msgid "14137    ### <a name=\"Faq-msgsl\"></a>FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the GSL?"
msgstr""

       
# CppCoreGuidelines.md:14138
msgid "14138    No. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree."
msgstr""

       
# CppCoreGuidelines.md:14139
msgid "14139    ### <a name=\"Faq-gsl-implementation\"></a>FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?"
msgstr""

       
# CppCoreGuidelines.md:14140
msgid "14140    We are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many."
msgstr""

       
# CppCoreGuidelines.md:14141
msgid "14141    ### <a name=\"Faq-boost\"></a>FAQ.53: Why weren't the GSL types proposed through Boost?"
msgstr""

       
# CppCoreGuidelines.md:14142
msgid "14142    Because we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library."
msgstr""

       
# CppCoreGuidelines.md:14143
msgid "14143    ### <a name=\"Faq-gsl-iso\"></a>FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee?"
msgstr""

       
# CppCoreGuidelines.md:14144
msgid "14144    No. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL."
msgstr""

       
# CppCoreGuidelines.md:14145
msgid "14145    ### <a name=\"Faq-gsl-string-view\"></a>FAQ.55: If you're using the standard types where available, why is the GSL `string_span` different from the `string_view` in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved `string_view`?"
msgstr""

       
# CppCoreGuidelines.md:14146
msgid "14146    The consensus on the taxonomy of views for the C++ Standard Library was that \"view\" means \"read-only\", and \"span\" means \"read/write\". The read-only `string_view` was the first such component to complete the standardization process, while `span` and `string_span` are currently being considered for standardization."
msgstr""

       
# CppCoreGuidelines.md:14147
msgid "14147    ### <a name=\"Faq-gsl-owner\"></a>FAQ.56: Is `owner` the same as the proposed `observer_ptr`?"
msgstr""

       
# CppCoreGuidelines.md:14148
msgid "14148    No. `owner` owns, is an alias, and can be applied to any indirection type. The main intent of `observer_ptr` is to signify a *non*-owning pointer."
msgstr""

       
# CppCoreGuidelines.md:14149
msgid "14149    ### <a name=\"Faq-gsl-stack-array\"></a>FAQ.57: Is `stack_array` the same as the standard `array`?"
msgstr""

       
# CppCoreGuidelines.md:14150
msgid "14150    No. `stack_array` is guaranteed to be allocated on the stack. Although a `std::array` contains its storage directly inside itself, the `array` object can be put anywhere, including the heap."
msgstr""

       
# CppCoreGuidelines.md:14151
msgid "14151    ### <a name=\"Faq-gsl-dyn-array\"></a>FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?"
msgstr""

       
# CppCoreGuidelines.md:14152
msgid "14152    No. `dyn_array` is not resizable, and is a safe way to refer to a heap-allocated fixed-size array. Unlike `vector`, it is intended to replace array-`new[]`. Unlike the `dynarray` that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a \"dynamic\" or heap-based array."
msgstr""

       
# CppCoreGuidelines.md:14153
msgid "14153    ### <a name=\"Faq-gsl-expects\"></a>FAQ.59: Is `Expects` the same as `assert`?"
msgstr""

       
# CppCoreGuidelines.md:14154
msgid "14154    No. It is a placeholder for language support for contract preconditions."
msgstr""

       
# CppCoreGuidelines.md:14155
msgid "14155    ### <a name=\"Faq-gsl-ensures\"></a>FAQ.60: Is `Ensures` the same as `assert`?"
msgstr""

       
# CppCoreGuidelines.md:14156
msgid "14156    No. It is a placeholder for language support for contract postconditions."
msgstr""

       
# CppCoreGuidelines.md:14157
msgid "14157    # <a name=\"S-libraries\"></a>Appendix A: Libraries"
msgstr""

       
# CppCoreGuidelines.md:14158
msgid "14158    This section lists recommended libraries, and explicitly recommends a few."
msgstr""

       
# CppCoreGuidelines.md:14159
msgid "14159    ??? Suitable for the general guide? I think not ???"
msgstr""

       
# CppCoreGuidelines.md:14160
msgid "14160    # <a name=\"S-modernizing\"></a>Appendix B: Modernizing code"
msgstr""

       
# CppCoreGuidelines.md:14161
msgid "14161    Ideally, we follow all rules in all code."
msgstr""

# CppCoreGuidelines.md:14162
msgid "14162    Realistically, we have to deal with a lot of old code:"
msgstr""

       
# CppCoreGuidelines.md:14163
msgid "14163    * application code written before the guidelines were formulated or known"
msgstr""

# CppCoreGuidelines.md:14164
msgid "14164    * libraries written to older/different standards"
msgstr""

# CppCoreGuidelines.md:14165
msgid "14165    * code written under \"unusual\" constraints"
msgstr""

# CppCoreGuidelines.md:14166
msgid "14166    * code that we just haven't gotten around to modernizing"
msgstr""

       
# CppCoreGuidelines.md:14167
msgid "14167    If we have a million lines of new code, the idea of \"just changing it all at once\" is typically unrealistic."
msgstr""

# CppCoreGuidelines.md:14168
msgid "14168    Thus, we need a way of gradually modernizing a code base."
msgstr""

       
# CppCoreGuidelines.md:14169
msgid "14169    Upgrading older code to modern style can be a daunting task."
msgstr""

# CppCoreGuidelines.md:14170
msgid "14170    Often, the old code is both a mess (hard to understand) and working correctly (for the current range of uses)."
msgstr""

# CppCoreGuidelines.md:14171
msgid "14171    Typically, the original programmer is not around and the test cases incomplete."
msgstr""

# CppCoreGuidelines.md:14172
msgid "14172    The fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors."
msgstr""

# CppCoreGuidelines.md:14173
msgid "14173    Often, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware."
msgstr""

# CppCoreGuidelines.md:14174
msgid "14174    In many cases, automated \"modernizer\"-style tool support would be required for major upgrade efforts."
msgstr""

       
# CppCoreGuidelines.md:14175
msgid "14175    The purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware."
msgstr""

# CppCoreGuidelines.md:14176
msgid "14176    Making code \"look pretty\" or \"follow modern style\" are not by themselves reasons for change."
msgstr""

# CppCoreGuidelines.md:14177
msgid "14177    There are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base."
msgstr""

# CppCoreGuidelines.md:14178
msgid "14178    The cost reductions must outweigh the risks."
msgstr""

       
# CppCoreGuidelines.md:14179
msgid "14179    But how?"
msgstr""

       
# CppCoreGuidelines.md:14180
msgid "14180    There is no one approach to modernizing code."
msgstr""

# CppCoreGuidelines.md:14181
msgid "14181    How best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool."
msgstr""

# CppCoreGuidelines.md:14182
msgid "14182    Here are some (very general) ideas:"
msgstr""

       
# CppCoreGuidelines.md:14183
msgid "14183    * The ideal is \"just upgrade everything.\" That gives the most benefits for the shortest total time."
msgstr""

# CppCoreGuidelines.md:14184
msgid "14184      In most circumstances, it is also impossible."
msgstr""

# CppCoreGuidelines.md:14185
msgid "14185    * We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as [use `span`](#SS-views), cannot be done on a per-module basis."
msgstr""

# CppCoreGuidelines.md:14186
msgid "14186    * We could convert code \"bottom up\" starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base."
msgstr""

# CppCoreGuidelines.md:14187
msgid "14187    * We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused."
msgstr""

# CppCoreGuidelines.md:14188
msgid "14188      This would be a set of changes across the whole code base, but would most likely have huge benefits."
msgstr""

# CppCoreGuidelines.md:14189
msgid "14189      Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code."
msgstr""

       
# CppCoreGuidelines.md:14190
msgid "14190    Whichever way you choose, please note that the most advantages come with the highest conformance to the guidelines."
msgstr""

# CppCoreGuidelines.md:14191
msgid "14191    The guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success."
msgstr""

       
# CppCoreGuidelines.md:14192
msgid "14192    We would dearly love to hear about experience and about tools used."
msgstr""

# CppCoreGuidelines.md:14193
msgid "14193    Modernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools."
msgstr""

       
# CppCoreGuidelines.md:14194
msgid "14194    # <a name=\"S-discussion\"></a>Appendix C: Discussion"
msgstr""

       
# CppCoreGuidelines.md:14195
msgid "14195    This section contains follow-up material on rules and sets of rules."
msgstr""

# CppCoreGuidelines.md:14196
msgid "14196    In particular, here we present further rationale, longer examples, and discussions of alternatives."
msgstr""

       
# CppCoreGuidelines.md:14197
msgid "14197    ### <a name=\"Sd-order\"></a>Discussion: Define and initialize member variables in the order of member declaration"
msgstr""

       
# CppCoreGuidelines.md:14198
msgid "14198    Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won't run in the order you see, and that can make it hard to see order-dependent bugs."
msgstr""

       
# CppCoreGuidelines.md:14199
msgid "14199        class Employee {"
msgstr""

# CppCoreGuidelines.md:14200
msgid "14200            string email, first, last;"
msgstr""

# CppCoreGuidelines.md:14201
msgid "14201        public:"
msgstr""

# CppCoreGuidelines.md:14202
msgid "14202            Employee(const char* firstName, const char* lastName);"
msgstr""

# CppCoreGuidelines.md:14203
msgid "14203            // ..."
msgstr""

# CppCoreGuidelines.md:14204
msgid "14204        };"
msgstr""

       
# CppCoreGuidelines.md:14205
msgid "14205        Employee::Employee(const char* firstName, const char* lastName)"
msgstr""

# CppCoreGuidelines.md:14206
msgid "14206          : first(firstName),"
msgstr""

# CppCoreGuidelines.md:14207
msgid "14207            last(lastName),"
msgstr""

# CppCoreGuidelines.md:14208
msgid "14208            // BAD: first and last not yet constructed"
msgstr""

# CppCoreGuidelines.md:14209
msgid "14209            email(first + \".\" + last + \"@acme.com\")"
msgstr""

# CppCoreGuidelines.md:14210
msgid "14210        {}"
msgstr""

       
# CppCoreGuidelines.md:14211
msgid "14211    In this example, `email` will be constructed before `first` and `last` because it is declared first. That means its constructor will attempt to use `first` and `last` too soon -- not just before they are set to the desired values, but before they are constructed at all."
msgstr""

       
# CppCoreGuidelines.md:14212
msgid "14212    If the class definition and the constructor body are in separate files, the long-distance influence that the order of member variable declarations has over the constructor's correctness will be even harder to spot."
msgstr""

       
# CppCoreGuidelines.md:14213
msgid "14213    **References**:"
msgstr""

       
# CppCoreGuidelines.md:14214
msgid "14214    [\\[Cline99\\]](#Cline99) §22.03-11, [\\[Dewhurst03\\]](#Dewhurst03) §52-53, [\\[Koenig97\\]](#Koenig97) §4, [\\[Lakos96\\]](#Lakos96) §10.3.5, [\\[Meyers97\\]](#Meyers97) §13, [\\[Murray93\\]](#Murray93) §2.1.3, [\\[Sutter00\\]](#Sutter00) §47"
msgstr""

       
# CppCoreGuidelines.md:14215
msgid "14215    ### <a name=\"Sd-init\"></a>Discussion: Use of `=`, `{}`, and `()` as initializers"
msgstr""

       
# CppCoreGuidelines.md:14216
msgid "14216    ???"
msgstr""

       
# CppCoreGuidelines.md:14217
msgid "14217    ### <a name=\"Sd-factory\"></a>Discussion: Use a factory function if you need \"virtual behavior\" during initialization"
msgstr""

       
# CppCoreGuidelines.md:14218
msgid "14218    If your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like `f` and `g`, you need other techniques, such as a post-constructor -- a separate member function the caller must invoke to complete initialization, which can safely call `f` and `g` because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here's a non-exhaustive list of options:"
msgstr""

       
# CppCoreGuidelines.md:14219
msgid "14219    * *Pass the buck:* Just document that user code must call the post-initialization function right after constructing an object."
msgstr""

# CppCoreGuidelines.md:14220
msgid "14220    * *Post-initialize lazily:* Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet."
msgstr""

# CppCoreGuidelines.md:14221
msgid "14221    * *Use virtual base class semantics:* Language rules dictate that the constructor most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See [\\[Taligent94\\]](#Taligent94).)"
msgstr""

# CppCoreGuidelines.md:14222
msgid "14222    * *Use a factory function:* This way, you can easily force a mandatory invocation of a post-constructor function."
msgstr""

       
# CppCoreGuidelines.md:14223
msgid "14223    Here is an example of the last option:"
msgstr""

       
# CppCoreGuidelines.md:14224
msgid "14224        class B {"
msgstr""

# CppCoreGuidelines.md:14225
msgid "14225        public:"
msgstr""

# CppCoreGuidelines.md:14226
msgid "14226            B() { /* ... */ f(); /* ... */ }   // BAD: see Item 49.1"
msgstr""

       
# CppCoreGuidelines.md:14227
msgid "14227            virtual void f() = 0;"
msgstr""

       
# CppCoreGuidelines.md:14228
msgid "14228            // ..."
msgstr""

# CppCoreGuidelines.md:14229
msgid "14229        };"
msgstr""

       
# CppCoreGuidelines.md:14230
msgid "14230        class B {"
msgstr""

# CppCoreGuidelines.md:14231
msgid "14231        protected:"
msgstr""

# CppCoreGuidelines.md:14232
msgid "14232            B() { /* ... */ }"
msgstr""

# CppCoreGuidelines.md:14233
msgid "14233            virtual void post_initialize()    // called right after construction"
msgstr""

# CppCoreGuidelines.md:14234
msgid "14234                { /* ... */ f(); /* ... */ }   // GOOD: virtual dispatch is safe"
msgstr""

# CppCoreGuidelines.md:14235
msgid "14235        public:"
msgstr""

# CppCoreGuidelines.md:14236
msgid "14236            virtual void f() = 0;"
msgstr""

       
# CppCoreGuidelines.md:14237
msgid "14237            template<class T>"
msgstr""

# CppCoreGuidelines.md:14238
msgid "14238            static shared_ptr<T> create()    // interface for creating objects"
msgstr""

# CppCoreGuidelines.md:14239
msgid "14239            {"
msgstr""

# CppCoreGuidelines.md:14240
msgid "14240                auto p = make_shared<T>();"
msgstr""

# CppCoreGuidelines.md:14241
msgid "14241                p->post_initialize();"
msgstr""

# CppCoreGuidelines.md:14242
msgid "14242                return p;"
msgstr""

# CppCoreGuidelines.md:14243
msgid "14243            }"
msgstr""

# CppCoreGuidelines.md:14244
msgid "14244        };"
msgstr""

       
       
# CppCoreGuidelines.md:14245
msgid "14245        class D : public B {                 // some derived class"
msgstr""

# CppCoreGuidelines.md:14246
msgid "14246        public:"
msgstr""

# CppCoreGuidelines.md:14247
msgid "14247            void f() override { /* ...  */ };"
msgstr""

       
# CppCoreGuidelines.md:14248
msgid "14248        protected:"
msgstr""

# CppCoreGuidelines.md:14249
msgid "14249            D() {}"
msgstr""

       
# CppCoreGuidelines.md:14250
msgid "14250            template<class T>"
msgstr""

# CppCoreGuidelines.md:14251
msgid "14251            friend shared_ptr<T> B::Create();"
msgstr""

# CppCoreGuidelines.md:14252
msgid "14252        };"
msgstr""

       
# CppCoreGuidelines.md:14253
msgid "14253        shared_ptr<D> p = D::Create<D>();    // creating a D object"
msgstr""

       
# CppCoreGuidelines.md:14254
msgid "14254    This design requires the following discipline:"
msgstr""

       
# CppCoreGuidelines.md:14255
msgid "14255    * Derived classes such as `D` must not expose a public constructor. Otherwise, `D`'s users could create `D` objects that don't invoke `PostInitialize`."
msgstr""

# CppCoreGuidelines.md:14256
msgid "14256    * Allocation is limited to `operator new`. `B` can, however, override `new` (see Items 45 and 46)."
msgstr""

# CppCoreGuidelines.md:14257
msgid "14257    * `D` must define a constructor with the same parameters that `B` selected. Defining several overloads of `Create` can assuage this problem, however; and the overloads can even be templated on the argument types."
msgstr""

       
# CppCoreGuidelines.md:14258
msgid "14258    If the requirements above are met, the design guarantees that `PostInitialize` has been called for any fully constructed `B`-derived object. `PostInitialize` doesn't need to be virtual; it can, however, invoke virtual functions freely."
msgstr""

       
# CppCoreGuidelines.md:14259
msgid "14259    In summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time)."
msgstr""

       
# CppCoreGuidelines.md:14260
msgid "14260    **References**: [\\[Alexandrescu01\\]](#Alexandrescu01) §3, [\\[Boost\\]](#Boost), [\\[Dewhurst03\\]](#Dewhurst03) §75, [\\[Meyers97\\]](#Meyers97) §46, [\\[Stroustrup00\\]](#Stroustrup00) §15.4.3, [\\[Taligent94\\]](#Taligent94)"
msgstr""

       
# CppCoreGuidelines.md:14261
msgid "14261    ### <a name=\"Sd-dtor\"></a>Discussion: Make base class destructors public and virtual, or protected and nonvirtual"
msgstr""

       
# CppCoreGuidelines.md:14262
msgid "14262    Should destruction behave virtually? That is, should destruction through a pointer to a `base` class be allowed? If yes, then `base`'s destructor must be public in order to be callable, and virtual otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and nonvirtual since it doesn't need to behave virtually virtual."
msgstr""

       
# CppCoreGuidelines.md:14263
msgid "14263    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14264
msgid "14264    The common case for a base class is that it's intended to have publicly derived classes, and so calling code is just about sure to use something like a `shared_ptr<base>`:"
msgstr""

       
# CppCoreGuidelines.md:14265
msgid "14265        class Base {"
msgstr""

# CppCoreGuidelines.md:14266
msgid "14266        public:"
msgstr""

# CppCoreGuidelines.md:14267
msgid "14267            ~Base();                   // BAD, not virtual"
msgstr""

# CppCoreGuidelines.md:14268
msgid "14268            virtual ~Base();           // GOOD"
msgstr""

# CppCoreGuidelines.md:14269
msgid "14269            // ..."
msgstr""

# CppCoreGuidelines.md:14270
msgid "14270        };"
msgstr""

       
# CppCoreGuidelines.md:14271
msgid "14271        class Derived : public Base { /* ... */ };"
msgstr""

       
# CppCoreGuidelines.md:14272
msgid "14272        {"
msgstr""

# CppCoreGuidelines.md:14273
msgid "14273            unique_ptr<Base> pb = make_unique<Derived>();"
msgstr""

# CppCoreGuidelines.md:14274
msgid "14274            // ..."
msgstr""

# CppCoreGuidelines.md:14275
msgid "14275        } // ~pb invokes correct destructor only when ~Base is virtual"
msgstr""

       
# CppCoreGuidelines.md:14276
msgid "14276    In rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and nonvirtual:"
msgstr""

       
# CppCoreGuidelines.md:14277
msgid "14277        class My_policy {"
msgstr""

# CppCoreGuidelines.md:14278
msgid "14278        public:"
msgstr""

# CppCoreGuidelines.md:14279
msgid "14279            virtual ~My_policy();      // BAD, public and virtual"
msgstr""

# CppCoreGuidelines.md:14280
msgid "14280        protected:"
msgstr""

# CppCoreGuidelines.md:14281
msgid "14281            ~My_policy();              // GOOD"
msgstr""

# CppCoreGuidelines.md:14282
msgid "14282            // ..."
msgstr""

# CppCoreGuidelines.md:14283
msgid "14283        };"
msgstr""

       
# CppCoreGuidelines.md:14284
msgid "14284        template<class Policy>"
msgstr""

# CppCoreGuidelines.md:14285
msgid "14285        class customizable : Policy { /* ... */ }; // note: private inheritance"
msgstr""

       
# CppCoreGuidelines.md:14286
msgid "14286    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14287
msgid "14287    This simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles."
msgstr""

       
# CppCoreGuidelines.md:14288
msgid "14288    For a base class `Base`, calling code might try to destroy derived objects through pointers to `Base`, such as when using a `unique_ptr<Base>`. If `Base`'s destructor is public and nonvirtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public."
msgstr""

       
# CppCoreGuidelines.md:14289
msgid "14289    To write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide:"
msgstr""

       
# CppCoreGuidelines.md:14290
msgid "14290    * Whether it should behave virtually or not."
msgstr""

# CppCoreGuidelines.md:14291
msgid "14291    * Whether it should be publicly available to all callers using a pointer to `Base` or else be a hidden internal implementation detail."
msgstr""

       
# CppCoreGuidelines.md:14292
msgid "14292    As described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to `Base` nonvirtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions."
msgstr""

       
# CppCoreGuidelines.md:14293
msgid "14293    Destruction can be viewed as just another operation, albeit with special semantics that make nonvirtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to `Base` virtually or not at all; \"nonvirtually\" is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and nonvirtual otherwise."
msgstr""

       
# CppCoreGuidelines.md:14294
msgid "14294    Note that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.)"
msgstr""

       
# CppCoreGuidelines.md:14295
msgid "14295    Corollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and nonvirtual. You can always `=default` the implementation if the default body is fine and you're just writing the function to give it the proper visibility and virtuality."
msgstr""

       
# CppCoreGuidelines.md:14296
msgid "14296    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:14297
msgid "14297    Some component architectures (e.g., COM and CORBA) don't use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate."
msgstr""

       
# CppCoreGuidelines.md:14298
msgid "14298    Consider also this rare case:"
msgstr""

       
# CppCoreGuidelines.md:14299
msgid "14299    * `B` is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for `B` objects to be created and destroyed."
msgstr""

# CppCoreGuidelines.md:14300
msgid "14300    * Yet `B` also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual."
msgstr""

       
# CppCoreGuidelines.md:14301
msgid "14301    Then, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed."
msgstr""

       
# CppCoreGuidelines.md:14302
msgid "14302    In this rare case, you could make the destructor public and nonvirtual but clearly document that further-derived objects must not be used polymorphically as `B`'s. This is what was done with `std::unary_function`."
msgstr""

       
# CppCoreGuidelines.md:14303
msgid "14303    In general, however, avoid concrete base classes (see Item 35). For example, `unary_function` is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item's advice and give it a protected nonvirtual destructor."
msgstr""

       
# CppCoreGuidelines.md:14304
msgid "14304    **References**: [\\[C++CS\\]](#CplusplusCS) Item 50, [\\[Cargill92\\]](#Cargill92) pp. 77-79, 207, [\\[Cline99\\]](#Cline99) §21.06, 21.12-13, [\\[Henricson97\\]](#Henricson97) pp. 110-114, [\\[Koenig97\\]](#Koenig97) Chapters 4, 11, [\\[Meyers97\\]](#Meyers97) §14, [\\[Stroustrup00\\]](#Stroustrup00) §12.4.2, [\\[Sutter02\\]](#Sutter02) §27, [\\[Sutter04\\]](#Sutter04) §18"
msgstr""

       
# CppCoreGuidelines.md:14305
msgid "14305    ### <a name=\"Sd-noexcept\"></a>Discussion: Usage of noexcept"
msgstr""

       
# CppCoreGuidelines.md:14306
msgid "14306    ???"
msgstr""

       
# CppCoreGuidelines.md:14307
msgid "14307    ### <a name=\"Sd-never-fail\"></a>Discussion: Destructors, deallocation, and swap must never fail"
msgstr""

       
# CppCoreGuidelines.md:14308
msgid "14308    Never allow an error to be reported from a destructor, a resource deallocation function (e.g., `operator delete`), or a `swap` function using `throw`. It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly `noexcept` by default."
msgstr""

       
# CppCoreGuidelines.md:14309
msgid "14309    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14310
msgid "14310        class Nefarious {"
msgstr""

# CppCoreGuidelines.md:14311
msgid "14311        public:"
msgstr""

# CppCoreGuidelines.md:14312
msgid "14312            Nefarious()  { /* code that could throw */ }   // ok"
msgstr""

# CppCoreGuidelines.md:14313
msgid "14313            ~Nefarious() { /* code that could throw */ }   // BAD, should not throw"
msgstr""

# CppCoreGuidelines.md:14314
msgid "14314            // ..."
msgstr""

# CppCoreGuidelines.md:14315
msgid "14315        };"
msgstr""

       
# CppCoreGuidelines.md:14316
msgid "14316    1. `Nefarious` objects are hard to use safely even as local variables:"
msgstr""

       
       
# CppCoreGuidelines.md:14317
msgid "14317            void test(string& s)"
msgstr""

# CppCoreGuidelines.md:14318
msgid "14318            {"
msgstr""

# CppCoreGuidelines.md:14319
msgid "14319                Nefarious n;          // trouble brewing"
msgstr""

# CppCoreGuidelines.md:14320
msgid "14320                string copy = s;      // copy the string"
msgstr""

# CppCoreGuidelines.md:14321
msgid "14321            } // destroy copy and then n"
msgstr""

       
# CppCoreGuidelines.md:14322
msgid "14322        Here, copying `s` could throw, and if that throws and if `n`'s destructor then also throws, the program will exit via `std::terminate` because two exceptions can't be propagated simultaneously."
msgstr""

       
# CppCoreGuidelines.md:14323
msgid "14323    2. Classes with `Nefarious` members or bases are also hard to use safely, because their destructors must invoke `Nefarious`' destructor, and are similarly poisoned by its poor behavior:"
msgstr""

       
       
# CppCoreGuidelines.md:14324
msgid "14324            class Innocent_bystander {"
msgstr""

# CppCoreGuidelines.md:14325
msgid "14325                Nefarious member;     // oops, poisons the enclosing class's destructor"
msgstr""

# CppCoreGuidelines.md:14326
msgid "14326                // ..."
msgstr""

# CppCoreGuidelines.md:14327
msgid "14327            };"
msgstr""

       
# CppCoreGuidelines.md:14328
msgid "14328            void test(string& s)"
msgstr""

# CppCoreGuidelines.md:14329
msgid "14329            {"
msgstr""

# CppCoreGuidelines.md:14330
msgid "14330                Innocent_bystander i; // more trouble brewing"
msgstr""

# CppCoreGuidelines.md:14331
msgid "14331                string copy2 = s;      // copy the string"
msgstr""

# CppCoreGuidelines.md:14332
msgid "14332            } // destroy copy and then i"
msgstr""

       
# CppCoreGuidelines.md:14333
msgid "14333        Here, if constructing `copy2` throws, we have the same problem because `i`'s destructor now also can throw, and if so we'll invoke `std::terminate`."
msgstr""

       
# CppCoreGuidelines.md:14334
msgid "14334    3. You can't reliably create global or static `Nefarious` objects either:"
msgstr""

       
       
# CppCoreGuidelines.md:14335
msgid "14335            static Nefarious n;       // oops, any destructor exception can't be caught"
msgstr""

       
# CppCoreGuidelines.md:14336
msgid "14336    4. You can't reliably create arrays of `Nefarious`:"
msgstr""

       
       
# CppCoreGuidelines.md:14337
msgid "14337            void test()"
msgstr""

# CppCoreGuidelines.md:14338
msgid "14338            {"
msgstr""

# CppCoreGuidelines.md:14339
msgid "14339                std::array<Nefarious, 10> arr; // this line can std::terminate(!)"
msgstr""

# CppCoreGuidelines.md:14340
msgid "14340            }"
msgstr""

       
# CppCoreGuidelines.md:14341
msgid "14341        The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an `arr` where, if the fourth object's constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects ... and one or more of those destructors throws? There is no satisfactory answer."
msgstr""

       
# CppCoreGuidelines.md:14342
msgid "14342    5. You can't use `Nefarious` objects in standard containers:"
msgstr""

       
       
# CppCoreGuidelines.md:14343
msgid "14343            std::vector<Nefarious> vec(10);   // this line can std::terminate()"
msgstr""

       
# CppCoreGuidelines.md:14344
msgid "14344        The standard library forbids all destructors used with it from throwing. You can't store `Nefarious` objects in standard containers or use them with any other part of the standard library."
msgstr""

       
# CppCoreGuidelines.md:14345
msgid "14345    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14346
msgid "14346    These are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there's no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there's no way to safely commit state changes using a no-fail operation (notably, but not limited to, `swap`), then no-fail commit is impossible to implement."
msgstr""

       
# CppCoreGuidelines.md:14347
msgid "14347    Consider the following advice and requirements found in the C++ Standard:"
msgstr""

       
# CppCoreGuidelines.md:14348
msgid "14348    > If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. --[\\[C++03\\]](#Cplusplus03) §15.2(3)"
msgstr""

# CppCoreGuidelines.md:14349
msgid "14349    >"
msgstr""

# CppCoreGuidelines.md:14350
msgid "14350    > No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. --[\\[C++03\\]](#Cplusplus03) §17.4.4.8(3)"
msgstr""

       
# CppCoreGuidelines.md:14351
msgid "14351    Deallocation functions, including specifically overloaded `operator delete` and `operator delete[]`, fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone."
msgstr""

# CppCoreGuidelines.md:14352
msgid "14352    Besides destructors and deallocation functions, common error-safety techniques rely also on `swap` operations never failing -- in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of `operator=` for a type `T` that performs copy construction followed by a call to a no-fail `swap`:"
msgstr""

       
# CppCoreGuidelines.md:14353
msgid "14353        T& T::operator=(const T& other) {"
msgstr""

# CppCoreGuidelines.md:14354
msgid "14354            auto temp = other;"
msgstr""

# CppCoreGuidelines.md:14355
msgid "14355            swap(temp);"
msgstr""

# CppCoreGuidelines.md:14356
msgid "14356        }"
msgstr""

       
# CppCoreGuidelines.md:14357
msgid "14357    (See also Item 56. ???)"
msgstr""

       
# CppCoreGuidelines.md:14358
msgid "14358    Fortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a `try/catch(...)` block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects)."
msgstr""

       
# CppCoreGuidelines.md:14359
msgid "14359    When using exceptions as your error handling mechanism, always document this behavior by declaring these functions `noexcept`. (See Item 75.)"
msgstr""

       
# CppCoreGuidelines.md:14360
msgid "14360    **References**: [\\[C++CS\\]](#CplusplusCS) Item 51; [\\[C++03\\]](#Cplusplus03) §15.2(3), §17.4.4.8(3), [\\[Meyers96\\]](#Meyers96) §11, [\\[Stroustrup00\\]](#Stroustrup00) §14.4.7, §E.2-4, [\\[Sutter00\\]](#Sutter00) §8, §16, [\\[Sutter02\\]](#Sutter02) §18-19"
msgstr""

       
# CppCoreGuidelines.md:14361
msgid "14361    ## <a name=\"Sd-consistent\"></a>Define Copy, move, and destroy consistently"
msgstr""

       
# CppCoreGuidelines.md:14362
msgid "14362    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14363
msgid "14363     ???"
msgstr""

       
# CppCoreGuidelines.md:14364
msgid "14364    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14365
msgid "14365    If you define a copy constructor, you must also define a copy assignment operator."
msgstr""

       
# CppCoreGuidelines.md:14366
msgid "14366    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14367
msgid "14367    If you define a move constructor, you must also define a move assignment operator."
msgstr""

       
# CppCoreGuidelines.md:14368
msgid "14368    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14369
msgid "14369        class X {"
msgstr""

# CppCoreGuidelines.md:14370
msgid "14370            // ..."
msgstr""

# CppCoreGuidelines.md:14371
msgid "14371        public:"
msgstr""

# CppCoreGuidelines.md:14372
msgid "14372            X(const X&) { /* stuff */ }"
msgstr""

       
# CppCoreGuidelines.md:14373
msgid "14373            // BAD: failed to also define a copy assignment operator"
msgstr""

       
# CppCoreGuidelines.md:14374
msgid "14374            X(x&&) noexcept { /* stuff */ }"
msgstr""

       
# CppCoreGuidelines.md:14375
msgid "14375            // BAD: failed to also define a move assignment operator"
msgstr""

# CppCoreGuidelines.md:14376
msgid "14376        };"
msgstr""

       
# CppCoreGuidelines.md:14377
msgid "14377        X x1;"
msgstr""

# CppCoreGuidelines.md:14378
msgid "14378        X x2 = x1; // ok"
msgstr""

# CppCoreGuidelines.md:14379
msgid "14379        x2 = x1;   // pitfall: either fails to compile, or does something suspicious"
msgstr""

       
# CppCoreGuidelines.md:14380
msgid "14380    If you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move."
msgstr""

       
# CppCoreGuidelines.md:14381
msgid "14381        class X {"
msgstr""

# CppCoreGuidelines.md:14382
msgid "14382            HANDLE hnd;"
msgstr""

# CppCoreGuidelines.md:14383
msgid "14383            // ..."
msgstr""

# CppCoreGuidelines.md:14384
msgid "14384        public:"
msgstr""

# CppCoreGuidelines.md:14385
msgid "14385            ~X() { /* custom stuff, such as closing hnd */ }"
msgstr""

# CppCoreGuidelines.md:14386
msgid "14386            // suspicious: no mention of copying or moving -- what happens to hnd?"
msgstr""

# CppCoreGuidelines.md:14387
msgid "14387        };"
msgstr""

       
# CppCoreGuidelines.md:14388
msgid "14388        X x1;"
msgstr""

# CppCoreGuidelines.md:14389
msgid "14389        X x2 = x1; // pitfall: either fails to compile, or does something suspicious"
msgstr""

# CppCoreGuidelines.md:14390
msgid "14390        x2 = x1;   // pitfall: either fails to compile, or does something suspicious"
msgstr""

       
# CppCoreGuidelines.md:14391
msgid "14391    If you define copying, and any base or member has a type that defines a move operation, you should also define a move operation."
msgstr""

       
# CppCoreGuidelines.md:14392
msgid "14392        class X {"
msgstr""

# CppCoreGuidelines.md:14393
msgid "14393            string s; // defines more efficient move operations"
msgstr""

# CppCoreGuidelines.md:14394
msgid "14394            // ... other data members ..."
msgstr""

# CppCoreGuidelines.md:14395
msgid "14395        public:"
msgstr""

# CppCoreGuidelines.md:14396
msgid "14396            X(const X&) { /* stuff */ }"
msgstr""

# CppCoreGuidelines.md:14397
msgid "14397            X& operator=(const X&) { /* stuff */ }"
msgstr""

       
# CppCoreGuidelines.md:14398
msgid "14398            // BAD: failed to also define a move construction and move assignment"
msgstr""

# CppCoreGuidelines.md:14399
msgid "14399            // (why wasn't the custom \"stuff\" repeated here?)"
msgstr""

# CppCoreGuidelines.md:14400
msgid "14400        };"
msgstr""

       
# CppCoreGuidelines.md:14401
msgid "14401        X test()"
msgstr""

# CppCoreGuidelines.md:14402
msgid "14402        {"
msgstr""

# CppCoreGuidelines.md:14403
msgid "14403            X local;"
msgstr""

# CppCoreGuidelines.md:14404
msgid "14404            // ..."
msgstr""

# CppCoreGuidelines.md:14405
msgid "14405            return local;  // pitfall: will be inefficient and/or do the wrong thing"
msgstr""

# CppCoreGuidelines.md:14406
msgid "14406        }"
msgstr""

       
# CppCoreGuidelines.md:14407
msgid "14407    If you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others."
msgstr""

       
# CppCoreGuidelines.md:14408
msgid "14408    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14409
msgid "14409    If you need to define any of these five functions, it means you need it to do more than its default behavior -- and the five are asymmetrically interrelated. Here's how:"
msgstr""

       
# CppCoreGuidelines.md:14410
msgid "14410    * If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does \"special\" work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.)"
msgstr""

# CppCoreGuidelines.md:14411
msgid "14411    * If you explicitly write the copying functions, you probably need to write the destructor: If the \"special\" work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor."
msgstr""

# CppCoreGuidelines.md:14412
msgid "14412    * If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it's often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely."
msgstr""

       
# CppCoreGuidelines.md:14413
msgid "14413    In many cases, holding properly encapsulated resources using RAII \"owning\" objects can eliminate the need to write these operations yourself. (See Item 13.)"
msgstr""

       
# CppCoreGuidelines.md:14414
msgid "14414    Prefer compiler-generated (including `=default`) special members; only these can be classified as \"trivial\", and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice."
msgstr""

       
# CppCoreGuidelines.md:14415
msgid "14415    **Exceptions**: When any of the special functions are declared only to make them nonpublic or virtual, but without special semantics, it doesn't imply that the others are needed."
msgstr""

# CppCoreGuidelines.md:14416
msgid "14416    In rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics."
msgstr""

# CppCoreGuidelines.md:14417
msgid "14417    In a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.)"
msgstr""

       
# CppCoreGuidelines.md:14418
msgid "14418    **References**: [\\[C++CS\\]](#CplusplusCS) Item 52; [\\[Cline99\\]](#Cline99) §30.01-14, [\\[Koenig97\\]](#Koenig97) §4, [\\[Stroustrup00\\]](#Stroustrup00) §5.5, §10.4, [\\[SuttHysl04b\\]](#SuttHysl04b)"
msgstr""

       
# CppCoreGuidelines.md:14419
msgid "14419    Resource management rule summary:"
msgstr""

       
# CppCoreGuidelines.md:14420
msgid "14420    * [Provide strong resource safety; that is, never leak anything that you think of as a resource](#Cr-safety)"
msgstr""

# CppCoreGuidelines.md:14421
msgid "14421    * [Never throw while holding a resource not owned by a handle](#Cr-never)"
msgstr""

# CppCoreGuidelines.md:14422
msgid "14422    * [A \"raw\" pointer or reference is never a resource handle](#Cr-raw)"
msgstr""

# CppCoreGuidelines.md:14423
msgid "14423    * [Never let a pointer outlive the object it points to](#Cr-outlive)"
msgstr""

# CppCoreGuidelines.md:14424
msgid "14424    * [Use templates to express containers (and other resource handles)](#Cr-templates)"
msgstr""

# CppCoreGuidelines.md:14425
msgid "14425    * [Return containers by value (relying on move or copy elision for efficiency)](#Cr-value-return)"
msgstr""

# CppCoreGuidelines.md:14426
msgid "14426    * [If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations](#Cr-handle)"
msgstr""

# CppCoreGuidelines.md:14427
msgid "14427    * [If a class is a container, give it an initializer-list constructor](#Cr-list)"
msgstr""

       
# CppCoreGuidelines.md:14428
msgid "14428    ### <a name=\"Cr-safety\"></a>Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource"
msgstr""

       
# CppCoreGuidelines.md:14429
msgid "14429    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14430
msgid "14430    Prevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations."
msgstr""

       
# CppCoreGuidelines.md:14431
msgid "14431    **Alternative formulation**: Have every resource represented as an object of some class managing its lifetime."
msgstr""

       
# CppCoreGuidelines.md:14432
msgid "14432    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14433
msgid "14433        template<class T>"
msgstr""

# CppCoreGuidelines.md:14434
msgid "14434        class Vector {"
msgstr""

# CppCoreGuidelines.md:14435
msgid "14435        // ..."
msgstr""

# CppCoreGuidelines.md:14436
msgid "14436        private:"
msgstr""

# CppCoreGuidelines.md:14437
msgid "14437            T* elem;   // sz elements on the free store, owned by the class object"
msgstr""

# CppCoreGuidelines.md:14438
msgid "14438            int sz;"
msgstr""

# CppCoreGuidelines.md:14439
msgid "14439        };"
msgstr""

       
# CppCoreGuidelines.md:14440
msgid "14440    This class is a resource handle. It manages the lifetime of the `T`s. To do so, `Vector` must define or delete [the set of special operations](???) (constructors, a destructor, etc.)."
msgstr""

       
# CppCoreGuidelines.md:14441
msgid "14441    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14442
msgid "14442        ??? \"odd\" non-memory resource ???"
msgstr""

       
# CppCoreGuidelines.md:14443
msgid "14443    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14444
msgid "14444    The basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find \"naked `new`s\". Given a list of C-style allocation functions (e.g., `fopen()`), a checker can also find uses that are not managed by a resource handle. In general, \"naked pointers\" can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of \"a resource\" is necessarily too general), but a tool can be \"parameterized\" with a resource list."
msgstr""

       
# CppCoreGuidelines.md:14445
msgid "14445    ### <a name=\"Cr-never\"></a>Discussion: Never throw while holding a resource not owned by a handle"
msgstr""

       
# CppCoreGuidelines.md:14446
msgid "14446    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14447
msgid "14447    That would be a leak."
msgstr""

       
# CppCoreGuidelines.md:14448
msgid "14448    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14449
msgid "14449        void f(int i)"
msgstr""

# CppCoreGuidelines.md:14450
msgid "14450        {"
msgstr""

# CppCoreGuidelines.md:14451
msgid "14451            FILE* f = fopen(\"a file\", \"r\");"
msgstr""

# CppCoreGuidelines.md:14452
msgid "14452            ifstream is { \"another file\" };"
msgstr""

# CppCoreGuidelines.md:14453
msgid "14453            // ..."
msgstr""

# CppCoreGuidelines.md:14454
msgid "14454            if (i == 0) return;"
msgstr""

# CppCoreGuidelines.md:14455
msgid "14455            // ..."
msgstr""

# CppCoreGuidelines.md:14456
msgid "14456            fclose(f);"
msgstr""

# CppCoreGuidelines.md:14457
msgid "14457        }"
msgstr""

       
# CppCoreGuidelines.md:14458
msgid "14458    If `i == 0` the file handle for `a file` is leaked. On the other hand, the `ifstream` for `another file` will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a `unique_ptr` or a `shared_ptr` with a custom deleter:"
msgstr""

       
# CppCoreGuidelines.md:14459
msgid "14459        void f(int i)"
msgstr""

# CppCoreGuidelines.md:14460
msgid "14460        {"
msgstr""

# CppCoreGuidelines.md:14461
msgid "14461            unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), fclose);"
msgstr""

# CppCoreGuidelines.md:14462
msgid "14462            // ..."
msgstr""

# CppCoreGuidelines.md:14463
msgid "14463            if (i == 0) return;"
msgstr""

# CppCoreGuidelines.md:14464
msgid "14464            // ..."
msgstr""

# CppCoreGuidelines.md:14465
msgid "14465        }"
msgstr""

       
# CppCoreGuidelines.md:14466
msgid "14466    Better:"
msgstr""

       
# CppCoreGuidelines.md:14467
msgid "14467        void f(int i)"
msgstr""

# CppCoreGuidelines.md:14468
msgid "14468        {"
msgstr""

# CppCoreGuidelines.md:14469
msgid "14469            ifstream input {\"a file\"};"
msgstr""

# CppCoreGuidelines.md:14470
msgid "14470            // ..."
msgstr""

# CppCoreGuidelines.md:14471
msgid "14471            if (i == 0) return;"
msgstr""

# CppCoreGuidelines.md:14472
msgid "14472            // ..."
msgstr""

# CppCoreGuidelines.md:14473
msgid "14473        }"
msgstr""

       
# CppCoreGuidelines.md:14474
msgid "14474    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14475
msgid "14475    A checker must consider all \"naked pointers\" suspicious."
msgstr""

# CppCoreGuidelines.md:14476
msgid "14476    A checker probably must rely on a human-provided list of resources."
msgstr""

# CppCoreGuidelines.md:14477
msgid "14477    For starters, we know about the standard-library containers, `string`, and smart pointers."
msgstr""

# CppCoreGuidelines.md:14478
msgid "14478    The use of `span` and `string_span` should help a lot (they are not resource handles)."
msgstr""

       
# CppCoreGuidelines.md:14479
msgid "14479    ### <a name=\"Cr-raw\"></a>Discussion: A \"raw\" pointer or reference is never a resource handle"
msgstr""

       
# CppCoreGuidelines.md:14480
msgid "14480    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14481
msgid "14481    To be able to distinguish owners from views."
msgstr""

       
# CppCoreGuidelines.md:14482
msgid "14482    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14483
msgid "14483    This is independent of how you \"spell\" pointer: `T*`, `T&`, `Ptr<T>` and `Range<T>` are not owners."
msgstr""

       
# CppCoreGuidelines.md:14484
msgid "14484    ### <a name=\"Cr-outlive\"></a>Discussion: Never let a pointer outlive the object it points to"
msgstr""

       
# CppCoreGuidelines.md:14485
msgid "14485    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14486
msgid "14486    To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system."
msgstr""

       
# CppCoreGuidelines.md:14487
msgid "14487    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14488
msgid "14488        string* bad()   // really bad"
msgstr""

# CppCoreGuidelines.md:14489
msgid "14489        {"
msgstr""

# CppCoreGuidelines.md:14490
msgid "14490            vector<string> v = { \"This\", \"will\", \"cause\", \"trouble\", \"!\" };"
msgstr""

# CppCoreGuidelines.md:14491
msgid "14491            // leaking a pointer into a destroyed member of a destroyed object (v)"
msgstr""

# CppCoreGuidelines.md:14492
msgid "14492            return &v[0];"
msgstr""

# CppCoreGuidelines.md:14493
msgid "14493        }"
msgstr""

       
# CppCoreGuidelines.md:14494
msgid "14494        void use()"
msgstr""

# CppCoreGuidelines.md:14495
msgid "14495        {"
msgstr""

# CppCoreGuidelines.md:14496
msgid "14496            string* p = bad();"
msgstr""

# CppCoreGuidelines.md:14497
msgid "14497            vector<int> xx = {7, 8, 9};"
msgstr""

# CppCoreGuidelines.md:14498
msgid "14498            // undefined behavior: x may not be the string \"This\""
msgstr""

# CppCoreGuidelines.md:14499
msgid "14499            string x = *p;"
msgstr""

# CppCoreGuidelines.md:14500
msgid "14500            // undefined behavior: we don't know what (if anything) is allocated a location p"
msgstr""

# CppCoreGuidelines.md:14501
msgid "14501            *p = \"Evil!\";"
msgstr""

# CppCoreGuidelines.md:14502
msgid "14502        }"
msgstr""

       
# CppCoreGuidelines.md:14503
msgid "14503    The `string`s of `v` are destroyed upon exit from `bad()` and so is `v` itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by `p`) may have been reallocated by the time `*p` is executed. There may be no `string` to read and a write through `p` could easily corrupt objects of unrelated types."
msgstr""

       
# CppCoreGuidelines.md:14504
msgid "14504    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14505
msgid "14505    Most compilers already warn about simple cases and has the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., `span` known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle."
msgstr""

       
# CppCoreGuidelines.md:14506
msgid "14506    ### <a name=\"Cr-templates\"></a>Discussion: Use templates to express containers (and other resource handles)"
msgstr""

       
# CppCoreGuidelines.md:14507
msgid "14507    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14508
msgid "14508    To provide statically type-safe manipulation of elements."
msgstr""

       
# CppCoreGuidelines.md:14509
msgid "14509    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14510
msgid "14510        template<typename T> class Vector {"
msgstr""

# CppCoreGuidelines.md:14511
msgid "14511            // ..."
msgstr""

# CppCoreGuidelines.md:14512
msgid "14512            T* elem;   // point to sz elements of type T"
msgstr""

# CppCoreGuidelines.md:14513
msgid "14513            int sz;"
msgstr""

# CppCoreGuidelines.md:14514
msgid "14514        };"
msgstr""

       
# CppCoreGuidelines.md:14515
msgid "14515    ### <a name=\"Cr-value-return\"></a>Discussion: Return containers by value (relying on move or copy elision for efficiency)"
msgstr""

       
# CppCoreGuidelines.md:14516
msgid "14516    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14517
msgid "14517    To simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime."
msgstr""

       
# CppCoreGuidelines.md:14518
msgid "14518    **See also**: [F.20, the general item about \"out\" output values](#Rf-out)"
msgstr""

       
# CppCoreGuidelines.md:14519
msgid "14519    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14520
msgid "14520        vector<int> get_large_vector()"
msgstr""

# CppCoreGuidelines.md:14521
msgid "14521        {"
msgstr""

# CppCoreGuidelines.md:14522
msgid "14522            return ...;"
msgstr""

# CppCoreGuidelines.md:14523
msgid "14523        }"
msgstr""

       
# CppCoreGuidelines.md:14524
msgid "14524        auto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision"
msgstr""

       
# CppCoreGuidelines.md:14525
msgid "14525    ##### Exception"
msgstr""

       
# CppCoreGuidelines.md:14526
msgid "14526    See the Exceptions in [F.20](#Rf-out)."
msgstr""

       
# CppCoreGuidelines.md:14527
msgid "14527    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14528
msgid "14528    Check for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a `unique_ptr`)."
msgstr""

       
# CppCoreGuidelines.md:14529
msgid "14529    ### <a name=\"Cr-handle\"></a>Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations"
msgstr""

       
# CppCoreGuidelines.md:14530
msgid "14530    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14531
msgid "14531    To provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource."
msgstr""

       
# CppCoreGuidelines.md:14532
msgid "14532    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14533
msgid "14533        ??? Messing with pointers"
msgstr""

       
# CppCoreGuidelines.md:14534
msgid "14534    ##### Note"
msgstr""

       
# CppCoreGuidelines.md:14535
msgid "14535    If all members are resource handles, rely on the default special operations where possible."
msgstr""

       
# CppCoreGuidelines.md:14536
msgid "14536        template<typename T> struct Named {"
msgstr""

# CppCoreGuidelines.md:14537
msgid "14537            string name;"
msgstr""

# CppCoreGuidelines.md:14538
msgid "14538            T value;"
msgstr""

# CppCoreGuidelines.md:14539
msgid "14539        };"
msgstr""

       
# CppCoreGuidelines.md:14540
msgid "14540    Now `Named` has a default constructor, a destructor, and efficient copy and move operations, provided `T` has."
msgstr""

       
# CppCoreGuidelines.md:14541
msgid "14541    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14542
msgid "14542    In general, a tool cannot know if a class is a resource handle. However, if a class has some of [the default operations](#SS-ctor), it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle."
msgstr""

       
# CppCoreGuidelines.md:14543
msgid "14543    ### <a name=\"Cr-list\"></a>Discussion: If a class is a container, give it an initializer-list constructor"
msgstr""

       
# CppCoreGuidelines.md:14544
msgid "14544    ##### Reason"
msgstr""

       
# CppCoreGuidelines.md:14545
msgid "14545    It is common to need an initial set of elements."
msgstr""

       
# CppCoreGuidelines.md:14546
msgid "14546    ##### Example"
msgstr""

       
# CppCoreGuidelines.md:14547
msgid "14547        template<typename T> class Vector {"
msgstr""

# CppCoreGuidelines.md:14548
msgid "14548        public:"
msgstr""

# CppCoreGuidelines.md:14549
msgid "14549            Vector(std::initializer_list<T>);"
msgstr""

# CppCoreGuidelines.md:14550
msgid "14550            // ..."
msgstr""

# CppCoreGuidelines.md:14551
msgid "14551        };"
msgstr""

       
# CppCoreGuidelines.md:14552
msgid "14552        Vector<string> vs { \"Nygaard\", \"Ritchie\" };"
msgstr""

       
# CppCoreGuidelines.md:14553
msgid "14553    ##### Enforcement"
msgstr""

       
# CppCoreGuidelines.md:14554
msgid "14554    When is a class a container? ???"
msgstr""

       
# CppCoreGuidelines.md:14555
msgid "14555    # <a name=\"S-tools\"></a>Appendix D: Supporting tools"
msgstr""

       
# CppCoreGuidelines.md:14556
msgid "14556    This section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools"
msgstr""

# CppCoreGuidelines.md:14557
msgid "14557    that are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion."
msgstr""

       
# CppCoreGuidelines.md:14558
msgid "14558    ### <a name=\"St-clangtidy\"></a>Tools: [Clang-tidy](http://clang.llvm.org/extra/clang-tidy/checks/list.html)"
msgstr""

       
# CppCoreGuidelines.md:14559
msgid "14559    Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern `cppcoreguidelines-*`."
msgstr""

       
# CppCoreGuidelines.md:14560
msgid "14560    ### <a name=\"St-cppcorecheck\"></a>Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)"
msgstr""

       
# CppCoreGuidelines.md:14561
msgid "14561    The Microsoft compiler's C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines."
msgstr""

       
# CppCoreGuidelines.md:14562
msgid "14562    # <a name=\"S-glossary\"></a>Glossary"
msgstr""

       
# CppCoreGuidelines.md:14563
msgid "14563    A relatively informal definition of terms used in the guidelines"
msgstr""

# CppCoreGuidelines.md:14564
msgid "14564    (based of the glossary in [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html))"
msgstr""

       
# CppCoreGuidelines.md:14565
msgid "14565    More information on many topics about C++ can be found on the [Standard C++ Foundation](https://isocpp.org)'s site."
msgstr""

       
# CppCoreGuidelines.md:14566
msgid "14566    * *ABI*: Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API."
msgstr""

# CppCoreGuidelines.md:14567
msgid "14567    * *abstract class*: a class that cannot be directly used to create objects; often used to define an interface to derived classes."
msgstr""

# CppCoreGuidelines.md:14568
msgid "14568      A class is made abstract by having a pure virtual function or only protected constructors."
msgstr""

# CppCoreGuidelines.md:14569
msgid "14569    * *abstraction*: a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance."
msgstr""

# CppCoreGuidelines.md:14570
msgid "14570    * *address*: a value that allows us to find an object in a computer's memory."
msgstr""

# CppCoreGuidelines.md:14571
msgid "14571    * *algorithm*: a procedure or formula for solving a problem; a finite series of computational steps to produce a result."
msgstr""

# CppCoreGuidelines.md:14572
msgid "14572    * *alias*: an alternative way of referring to an object; often a name, pointer, or reference."
msgstr""

# CppCoreGuidelines.md:14573
msgid "14573    * *API*: Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI."
msgstr""

# CppCoreGuidelines.md:14574
msgid "14574    * *application*: a program or a collection of programs that is considered an entity by its users."
msgstr""

# CppCoreGuidelines.md:14575
msgid "14575    * *approximation*: something (e.g., a value or a design) that is close to the perfect or ideal (value or design)."
msgstr""

# CppCoreGuidelines.md:14576
msgid "14576      Often an approximation is a result of trade-offs among ideals."
msgstr""

# CppCoreGuidelines.md:14577
msgid "14577    * *argument*: a value passed to a function or a template, in which it is accessed through a parameter."
msgstr""

# CppCoreGuidelines.md:14578
msgid "14578    * *array*: a homogeneous sequence of elements, usually numbered, e.g., `[0:max)`."
msgstr""

# CppCoreGuidelines.md:14579
msgid "14579    * *assertion*: a statement inserted into a program to state (assert) that something must always be true at this point in the program."
msgstr""

# CppCoreGuidelines.md:14580
msgid "14580    * *base class*: a class used as the base of a class hierarchy. Typically a base class has one or more virtual functions."
msgstr""

# CppCoreGuidelines.md:14581
msgid "14581    * *bit*: the basic unit of information in a computer. A bit can have the value 0 or the value 1."
msgstr""

# CppCoreGuidelines.md:14582
msgid "14582    * *bug*: an error in a program."
msgstr""

# CppCoreGuidelines.md:14583
msgid "14583    * *byte*: the basic unit of addressing in most computers. Typically, a byte holds 8 bits."
msgstr""

# CppCoreGuidelines.md:14584
msgid "14584    * *class*: a user-defined type that may contain data members, function members, and member types."
msgstr""

# CppCoreGuidelines.md:14585
msgid "14585    * *code*: a program or a part of a program; ambiguously used for both source code and object code."
msgstr""

# CppCoreGuidelines.md:14586
msgid "14586    * *compiler*: a program that turns source code into object code."
msgstr""

# CppCoreGuidelines.md:14587
msgid "14587    * *complexity*: a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself."
msgstr""

# CppCoreGuidelines.md:14588
msgid "14588      Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm."
msgstr""

# CppCoreGuidelines.md:14589
msgid "14589    * *computation*: the execution of some code, usually taking some input and producing some output."
msgstr""

# CppCoreGuidelines.md:14590
msgid "14590    * *concept*: (1) a notion, and idea; (2) a set of requirements, usually for a template argument."
msgstr""

# CppCoreGuidelines.md:14591
msgid "14591    * *concrete class*: class for which objects can be created."
msgstr""

# CppCoreGuidelines.md:14592
msgid "14592    * *constant*: a value that cannot be changed (in a given scope); not mutable."
msgstr""

# CppCoreGuidelines.md:14593
msgid "14593    * *constructor*: an operation that initializes (\"constructs\") an object."
msgstr""

# CppCoreGuidelines.md:14594
msgid "14594      Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor)."
msgstr""

# CppCoreGuidelines.md:14595
msgid "14595    * *container*: an object that holds elements (other objects)."
msgstr""

# CppCoreGuidelines.md:14596
msgid "14596    * *copy*: an operation that makes two object have values that compare equal. See also move."
msgstr""

# CppCoreGuidelines.md:14597
msgid "14597    * *correctness*: a program or a piece of a program is correct if it meets its specification."
msgstr""

# CppCoreGuidelines.md:14598
msgid "14598      Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users' reasonable expectations."
msgstr""

# CppCoreGuidelines.md:14599
msgid "14599      Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification."
msgstr""

# CppCoreGuidelines.md:14600
msgid "14600    * *cost*: the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it."
msgstr""

# CppCoreGuidelines.md:14601
msgid "14601      Ideally, cost should be a function of complexity."
msgstr""

# CppCoreGuidelines.md:14602
msgid "14602    * *customization point*: ???"
msgstr""

# CppCoreGuidelines.md:14603
msgid "14603    * *data*: values used in a computation."
msgstr""

# CppCoreGuidelines.md:14604
msgid "14604    * *debugging*: the act of searching for and removing errors from a program; usually far less systematic than testing."
msgstr""

# CppCoreGuidelines.md:14605
msgid "14605    * *declaration*: the specification of a name with its type in a program."
msgstr""

# CppCoreGuidelines.md:14606
msgid "14606    * *definition*: a declaration of an entity that supplies all information necessary to complete a program using the entity."
msgstr""

# CppCoreGuidelines.md:14607
msgid "14607      Simplified definition: a declaration that allocates memory."
msgstr""

# CppCoreGuidelines.md:14608
msgid "14608    * *derived class*: a class derived from one or more base classes."
msgstr""

# CppCoreGuidelines.md:14609
msgid "14609    * *design*: an overall description of how a piece of software should operate to meet its specification."
msgstr""

# CppCoreGuidelines.md:14610
msgid "14610    * *destructor*: an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources."
msgstr""

# CppCoreGuidelines.md:14611
msgid "14611    * *encapsulation*: protecting something meant to be private (e.g., implementation details) from unauthorized access."
msgstr""

# CppCoreGuidelines.md:14612
msgid "14612    * *error*: a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users' guide) and what a program actually does."
msgstr""

# CppCoreGuidelines.md:14613
msgid "14613    * *executable*: a program ready to be run (executed) on a computer."
msgstr""

# CppCoreGuidelines.md:14614
msgid "14614    * *feature creep*: a tendency to add excess functionality to a program \"just in case.\""
msgstr""

# CppCoreGuidelines.md:14615
msgid "14615    * *file*: a container of permanent information in a computer."
msgstr""

# CppCoreGuidelines.md:14616
msgid "14616    * *floating-point number*: a computer's approximation of a real number, such as 7.93 and 10.78e-3."
msgstr""

# CppCoreGuidelines.md:14617
msgid "14617    * *function*: a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation."
msgstr""

# CppCoreGuidelines.md:14618
msgid "14618    * *generic programming*: a style of programming focused on the design and efficient implementation of algorithms."
msgstr""

# CppCoreGuidelines.md:14619
msgid "14619      A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates."
msgstr""

# CppCoreGuidelines.md:14620
msgid "14620    * *global variable*: technically, a named object in namespace scope."
msgstr""

# CppCoreGuidelines.md:14621
msgid "14621    * *handle*: a class that allows access to another through a member pointer or reference. See also resource, copy, move."
msgstr""

# CppCoreGuidelines.md:14622
msgid "14622    * *header*: a file containing declarations used to share interfaces between parts of a program."
msgstr""

# CppCoreGuidelines.md:14623
msgid "14623    * *hiding*: the act of preventing a piece of information from being directly seen or accessed."
msgstr""

# CppCoreGuidelines.md:14624
msgid "14624      For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used."
msgstr""

# CppCoreGuidelines.md:14625
msgid "14625    * *ideal*: the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation."
msgstr""

# CppCoreGuidelines.md:14626
msgid "14626    * *implementation*: (1) the act of writing and testing code; (2) the code that implements a program."
msgstr""

# CppCoreGuidelines.md:14627
msgid "14627    * *infinite loop*: a loop where the termination condition never becomes true. See iteration."
msgstr""

# CppCoreGuidelines.md:14628
msgid "14628    * *infinite recursion*: a recursion that doesn't end until the machine runs out of memory to hold the calls."
msgstr""

# CppCoreGuidelines.md:14629
msgid "14629      In reality, such recursion is never infinite but is terminated by some hardware error."
msgstr""

# CppCoreGuidelines.md:14630
msgid "14630    * *information hiding*: the act of separating interface and implementation, thus hiding implementation details not meant for the user's attention and providing an abstraction."
msgstr""

# CppCoreGuidelines.md:14631
msgid "14631    * *initialize*: giving an object its first (initial) value."
msgstr""

# CppCoreGuidelines.md:14632
msgid "14632    * *input*: values used by a computation (e.g., function arguments and characters typed on a keyboard)."
msgstr""

# CppCoreGuidelines.md:14633
msgid "14633    * *integer*: a whole number, such as 42 and -99."
msgstr""

# CppCoreGuidelines.md:14634
msgid "14634    * *interface*: a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called."
msgstr""

# CppCoreGuidelines.md:14635
msgid "14635    * *invariant*: something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement."
msgstr""

# CppCoreGuidelines.md:14636
msgid "14636    * *iteration*: the act of repeatedly executing a piece of code; see recursion."
msgstr""

# CppCoreGuidelines.md:14637
msgid "14637    * *iterator*: an object that identifies an element of a sequence."
msgstr""

# CppCoreGuidelines.md:14638
msgid "14638    * *ISO*: International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at [iso.org](http://iso.org)."
msgstr""

# CppCoreGuidelines.md:14639
msgid "14639    * *library*: a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more that one program."
msgstr""

# CppCoreGuidelines.md:14640
msgid "14640    * *lifetime*: the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates)."
msgstr""

# CppCoreGuidelines.md:14641
msgid "14641    * *linker*: a program that combines object code files and libraries into an executable program."
msgstr""

# CppCoreGuidelines.md:14642
msgid "14642    * *literal*: a notation that directly specifies a value, such as 12 specifying the integer value \"twelve.\""
msgstr""

# CppCoreGuidelines.md:14643
msgid "14643    * *loop*: a piece of code executed repeatedly; in C++, typically a for-statement or a `while`-statement."
msgstr""

# CppCoreGuidelines.md:14644
msgid "14644    * *move*: an operation that transfers a value from one object to another leaving behind a value representing \"empty.\" See also copy."
msgstr""

# CppCoreGuidelines.md:14645
msgid "14645    * *mutable*: changeable; the opposite of immutable, constant, and invariable."
msgstr""

# CppCoreGuidelines.md:14646
msgid "14646    * *object*: (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory."
msgstr""

# CppCoreGuidelines.md:14647
msgid "14647    * *object code*: output from a compiler intended as input for a linker (for the linker to produce executable code)."
msgstr""

# CppCoreGuidelines.md:14648
msgid "14648    * *object file*: a file containing object code."
msgstr""

# CppCoreGuidelines.md:14649
msgid "14649    * *object-oriented programming*: (OOP) a style of programming focused on the design and use of classes and class hierarchies."
msgstr""

# CppCoreGuidelines.md:14650
msgid "14650    * *operation*: something that can perform some action, such as a function and an operator."
msgstr""

# CppCoreGuidelines.md:14651
msgid "14651    * *output*: values produced by a computation (e.g., a function result or lines of characters written on a screen)."
msgstr""

# CppCoreGuidelines.md:14652
msgid "14652    * *overflow*: producing a value that cannot be stored in its intended target."
msgstr""

# CppCoreGuidelines.md:14653
msgid "14653    * *overload*: defining two functions or operators with the same name but different argument (operand) types."
msgstr""

# CppCoreGuidelines.md:14654
msgid "14654    * *override*: defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class."
msgstr""

# CppCoreGuidelines.md:14655
msgid "14655    * *owner*: an object responsible for releasing a resource."
msgstr""

# CppCoreGuidelines.md:14656
msgid "14656    * *paradigm*: a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others."
msgstr""

# CppCoreGuidelines.md:14657
msgid "14657    * *parameter*: a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters."
msgstr""

# CppCoreGuidelines.md:14658
msgid "14658    * *pointer*: (1) a value used to identify a typed object in memory; (2) a variable holding such a value."
msgstr""

# CppCoreGuidelines.md:14659
msgid "14659    * *post-condition*: a condition that must hold upon exit from a piece of code, such as a function or a loop."
msgstr""

# CppCoreGuidelines.md:14660
msgid "14660    * *pre-condition*: a condition that must hold upon entry into a piece of code, such as a function or a loop."
msgstr""

# CppCoreGuidelines.md:14661
msgid "14661    * *program*: code (possibly with associated data) that is sufficiently complete to be executed by a computer."
msgstr""

# CppCoreGuidelines.md:14662
msgid "14662    * *programming*: the art of expressing solutions to problems as code."
msgstr""

# CppCoreGuidelines.md:14663
msgid "14663    * *programming language*: a language for expressing programs."
msgstr""

# CppCoreGuidelines.md:14664
msgid "14664    * *pseudo code*: a description of a computation written in an informal notation rather than a programming language."
msgstr""

# CppCoreGuidelines.md:14665
msgid "14665    * *pure virtual function*: a virtual function that must be overridden in a derived class."
msgstr""

# CppCoreGuidelines.md:14666
msgid "14666    * *RAII*: (\"Resource Acquisition Is Initialization\") a basic technique for resource management based on scopes."
msgstr""

# CppCoreGuidelines.md:14667
msgid "14667    * *range*: a sequence of values that can be described by a start point and an end point. For example, `[0:5)` means the values 0, 1, 2, 3, and 4."
msgstr""

# CppCoreGuidelines.md:14668
msgid "14668    * *recursion*: the act of a function calling itself; see also iteration."
msgstr""

# CppCoreGuidelines.md:14669
msgid "14669    * *reference*: (1) a value describing the location of a typed value in memory; (2) a variable holding such a value."
msgstr""

# CppCoreGuidelines.md:14670
msgid "14670    * *regular expression*: a notation for patterns in character strings."
msgstr""

# CppCoreGuidelines.md:14671
msgid "14671    * *regular*: a type that behaves similarly to built-in types like `int` and can be compared with `==`."
msgstr""

# CppCoreGuidelines.md:14672
msgid "14672    In particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also *semiregular type*."
msgstr""

# CppCoreGuidelines.md:14673
msgid "14673    * *requirement*: (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments."
msgstr""

# CppCoreGuidelines.md:14674
msgid "14674    * *resource*: something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner."
msgstr""

# CppCoreGuidelines.md:14675
msgid "14675    * *rounding*: conversion of a value to the mathematically nearest value of a less precise type."
msgstr""

# CppCoreGuidelines.md:14676
msgid "14676    * *RTTI*: Run-Time Type Information. ???"
msgstr""

# CppCoreGuidelines.md:14677
msgid "14677    * *scope*: the region of program text (source code) in which a name can be referred to."
msgstr""

# CppCoreGuidelines.md:14678
msgid "14678    * *semiregular*: a type that behaves roughly like an built-in type like `int`, but possibly without a `==` operator. See also *regular type*."
msgstr""

# CppCoreGuidelines.md:14679
msgid "14679    * *sequence*: elements that can be visited in a linear order."
msgstr""

# CppCoreGuidelines.md:14680
msgid "14680    * *software*: a collection of pieces of code and associated data; often used interchangeably with program."
msgstr""

# CppCoreGuidelines.md:14681
msgid "14681    * *source code*: code as produced by a programmer and (in principle) readable by other programmers."
msgstr""

# CppCoreGuidelines.md:14682
msgid "14682    * *source file*: a file containing source code."
msgstr""

# CppCoreGuidelines.md:14683
msgid "14683    * *specification*: a description of what a piece of code should do."
msgstr""

# CppCoreGuidelines.md:14684
msgid "14684    * *standard*: an officially agreed upon definition of something, such as a programming language."
msgstr""

# CppCoreGuidelines.md:14685
msgid "14685    * *state*: a set of values."
msgstr""

# CppCoreGuidelines.md:14686
msgid "14686    * *STL*: the containers, iterators, and algorithms part of the standard library."
msgstr""

# CppCoreGuidelines.md:14687
msgid "14687    * *string*: a sequence of characters."
msgstr""

# CppCoreGuidelines.md:14688
msgid "14688    * *style*: a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code."
msgstr""

# CppCoreGuidelines.md:14689
msgid "14689    * *subtype*: derived type; a type that has all the properties of a type and possibly more."
msgstr""

# CppCoreGuidelines.md:14690
msgid "14690    * *supertype*: base type; a type that has a subset of the properties of a type."
msgstr""

# CppCoreGuidelines.md:14691
msgid "14691    * *system*: (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for \"operating system\", that is, the fundamental execution environment and tools for a computer."
msgstr""

# CppCoreGuidelines.md:14692
msgid "14692    * *TS*: [Technical Specification](https://www.iso.org/deliverables-all.html?type=ts), A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard."
msgstr""

# CppCoreGuidelines.md:14693
msgid "14693    * *template*: a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming."
msgstr""

# CppCoreGuidelines.md:14694
msgid "14694    * *testing*: a systematic search for errors in a program."
msgstr""

# CppCoreGuidelines.md:14695
msgid "14695    * *trade-off*: the result of balancing several design and implementation criteria."
msgstr""

# CppCoreGuidelines.md:14696
msgid "14696    * *truncation*: loss of information in a conversion from a type into another that cannot exactly represent the value to be converted."
msgstr""

# CppCoreGuidelines.md:14697
msgid "14697    * *type*: something that defines a set of possible values and a set of operations for an object."
msgstr""

# CppCoreGuidelines.md:14698
msgid "14698    * *uninitialized*: the (undefined) state of an object before it is initialized."
msgstr""

# CppCoreGuidelines.md:14699
msgid "14699    * *unit*: (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole."
msgstr""

# CppCoreGuidelines.md:14700
msgid "14700    * *use case*: a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose."
msgstr""

# CppCoreGuidelines.md:14701
msgid "14701    * *value*: a set of bits in memory interpreted according to a type."
msgstr""

# CppCoreGuidelines.md:14702
msgid "14702    * *variable*: a named object of a given type; contains a value unless uninitialized."
msgstr""

# CppCoreGuidelines.md:14703
msgid "14703    * *virtual function*: a member function that can be overridden in a derived class."
msgstr""

# CppCoreGuidelines.md:14704
msgid "14704    * *word*: a basic unit of memory in a computer, often the unit used to hold an integer."
msgstr""

       
# CppCoreGuidelines.md:14705
msgid "14705    # <a name=\"S-unclassified\"></a>To-do: Unclassified proto-rules"
msgstr""

       
# CppCoreGuidelines.md:14706
msgid "14706    This is our to-do list."
msgstr""

# CppCoreGuidelines.md:14707
msgid "14707    Eventually, the entries will become rules or parts of rules."
msgstr""

# CppCoreGuidelines.md:14708
msgid "14708    Alternatively, we will decide that no change is needed and delete the entry."
msgstr""

       
# CppCoreGuidelines.md:14709
msgid "14709    * No long-distance friendship"
msgstr""

# CppCoreGuidelines.md:14710
msgid "14710    * Should physical design (what's in a file) and large-scale design (libraries, groups of libraries) be addressed?"
msgstr""

# CppCoreGuidelines.md:14711
msgid "14711    * Namespaces"
msgstr""

# CppCoreGuidelines.md:14712
msgid "14712    * Avoid using directives in the global scope (except for std, and other \"fundamental\" namespaces (e.g. experimental))"
msgstr""

# CppCoreGuidelines.md:14713
msgid "14713    * How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider?"
msgstr""

# CppCoreGuidelines.md:14714
msgid "14714    * Should there be inline namespaces (à la `std::literals::*_literals`)?"
msgstr""

# CppCoreGuidelines.md:14715
msgid "14715    * Avoid implicit conversions"
msgstr""

# CppCoreGuidelines.md:14716
msgid "14716    * Const member functions should be thread safe ... aka, but I don't really change the variable, just assign it a value the first time it's called ... argh"
msgstr""

# CppCoreGuidelines.md:14717
msgid "14717    * Always initialize variables, use initialization lists for member variables."
msgstr""

# CppCoreGuidelines.md:14718
msgid "14718    * Anyone writing a public interface which takes or returns `void*` should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :)"
msgstr""

# CppCoreGuidelines.md:14719
msgid "14719    * Use `const`-ness wherever possible: member functions, variables and (yippee) `const_iterators`"
msgstr""

# CppCoreGuidelines.md:14720
msgid "14720    * Use `auto`"
msgstr""

# CppCoreGuidelines.md:14721
msgid "14721    * `(size)` vs. `{initializers}` vs. `{Extent{size}}`"
msgstr""

# CppCoreGuidelines.md:14722
msgid "14722    * Don't overabstract"
msgstr""

# CppCoreGuidelines.md:14723
msgid "14723    * Never pass a pointer down the call stack"
msgstr""

# CppCoreGuidelines.md:14724
msgid "14724    * falling through a function bottom"
msgstr""

# CppCoreGuidelines.md:14725
msgid "14725    * Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like `std::function`)  vs. CRTP/static? YES Perhaps even vs. tag dispatch?"
msgstr""

# CppCoreGuidelines.md:14726
msgid "14726    * should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it's a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE?"
msgstr""

# CppCoreGuidelines.md:14727
msgid "14727    * Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios?"
msgstr""

# CppCoreGuidelines.md:14728
msgid "14728    * And speaking of `std::bind`, Stephen T. Lavavej criticizes it so much I'm starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead?"
msgstr""

# CppCoreGuidelines.md:14729
msgid "14729    * What to do with leaks out of temporaries? : `p = (s1 + s2).c_str();`"
msgstr""

# CppCoreGuidelines.md:14730
msgid "14730    * pointer/iterator invalidation leading to dangling pointers:"
msgstr""

       
# CppCoreGuidelines.md:14731
msgid "14731            void bad()"
msgstr""

# CppCoreGuidelines.md:14732
msgid "14732            {"
msgstr""

# CppCoreGuidelines.md:14733
msgid "14733                int* p = new int[700];"
msgstr""

# CppCoreGuidelines.md:14734
msgid "14734                int* q = &p[7];"
msgstr""

# CppCoreGuidelines.md:14735
msgid "14735                delete p;"
msgstr""

       
# CppCoreGuidelines.md:14736
msgid "14736                vector<int> v(700);"
msgstr""

# CppCoreGuidelines.md:14737
msgid "14737                int* q2 = &v[7];"
msgstr""

# CppCoreGuidelines.md:14738
msgid "14738                v.resize(900);"
msgstr""

       
# CppCoreGuidelines.md:14739
msgid "14739                // ... use q and q2 ..."
msgstr""

# CppCoreGuidelines.md:14740
msgid "14740            }"
msgstr""

       
# CppCoreGuidelines.md:14741
msgid "14741    * LSP"
msgstr""

# CppCoreGuidelines.md:14742
msgid "14742    * private inheritance vs/and membership"
msgstr""

# CppCoreGuidelines.md:14743
msgid "14743    * avoid static class members variables (race conditions, almost-global variables)"
msgstr""

       
# CppCoreGuidelines.md:14744
msgid "14744    * Use RAII lock guards (`lock_guard`, `unique_lock`, `shared_lock`), never call `mutex.lock` and `mutex.unlock` directly (RAII)"
msgstr""

# CppCoreGuidelines.md:14745
msgid "14745    * Prefer non-recursive locks (often used to work around bad reasoning, overhead)"
msgstr""

# CppCoreGuidelines.md:14746
msgid "14746    * Join your threads! (because of `std::terminate` in destructor if not joined or detached ... is there a good reason to detach threads?) -- ??? could support library provide a RAII wrapper for `std::thread`?"
msgstr""

# CppCoreGuidelines.md:14747
msgid "14747    * If two or more mutexes must be acquired at the same time, use `std::lock` (or another deadlock avoidance algorithm?)"
msgstr""

# CppCoreGuidelines.md:14748
msgid "14748    * When using a `condition_variable`, always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself."
msgstr""

# CppCoreGuidelines.md:14749
msgid "14749    * Never use `atomic_compare_exchange_strong` with `std::atomic<user-defined-struct>` (differences in padding matter, while `compare_exchange_weak` in a loop converges to stable padding)"
msgstr""

# CppCoreGuidelines.md:14750
msgid "14750    * individual `shared_future` objects are not thread-safe: two threads cannot wait on the same `shared_future` object (they can wait on copies of a `shared_future` that refer to the same shared state)"
msgstr""

# CppCoreGuidelines.md:14751
msgid "14751    * individual `shared_ptr` objects are not thread-safe: different threads can call non-`const` member functions on *different* `shared_ptr`s that refer to the same shared object, but one thread cannot call a non-`const` member function of a `shared_ptr` object while another thread accesses that same `shared_ptr` object (if you need that, consider `atomic_shared_ptr` instead)"
msgstr""

       
# CppCoreGuidelines.md:14752
msgid "14752    * rules for arithmetic"
msgstr""

       
# CppCoreGuidelines.md:14753
msgid "14753    # Bibliography"
msgstr""

       
# CppCoreGuidelines.md:14754
msgid "14754    * <a name=\"Abrahams01\"></a>"
msgstr""

# CppCoreGuidelines.md:14755
msgid "14755      \\[Abrahams01]:  D. Abrahams. [Exception-Safety in Generic Components](http://www.boost.org/community/exception_safety.html)."
msgstr""

# CppCoreGuidelines.md:14756
msgid "14756    * <a name=\"Alexandrescu01\"></a>"
msgstr""

# CppCoreGuidelines.md:14757
msgid "14757      \\[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001)."
msgstr""

# CppCoreGuidelines.md:14758
msgid "14758    * <a name=\"Cplusplus03\"></a>"
msgstr""

# CppCoreGuidelines.md:14759
msgid "14759      \\[C++03]:           ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections)."
msgstr""

# CppCoreGuidelines.md:14760
msgid "14760    * <a name=\"CplusplusCS\"></a>"
msgstr""

# CppCoreGuidelines.md:14761
msgid "14761      \\[C++CS]:           ???"
msgstr""

# CppCoreGuidelines.md:14762
msgid "14762    * <a name=\"Cargill92\"></a>"
msgstr""

# CppCoreGuidelines.md:14763
msgid "14763      \\[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992)."
msgstr""

# CppCoreGuidelines.md:14764
msgid "14764    * <a name=\"Cline99\"></a>"
msgstr""

# CppCoreGuidelines.md:14765
msgid "14765      \\[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999)."
msgstr""

# CppCoreGuidelines.md:14766
msgid "14766    * <a name=\"Dewhurst03\"></a>"
msgstr""

# CppCoreGuidelines.md:14767
msgid "14767      \\[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003)."
msgstr""

# CppCoreGuidelines.md:14768
msgid "14768    * <a name=\"Henricson97\"></a>"
msgstr""

# CppCoreGuidelines.md:14769
msgid "14769      \\[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997)."
msgstr""

# CppCoreGuidelines.md:14770
msgid "14770    * <a name=\"Koenig97\"></a>"
msgstr""

# CppCoreGuidelines.md:14771
msgid "14771      \\[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997)."
msgstr""

# CppCoreGuidelines.md:14772
msgid "14772    * <a name=\"Lakos96\"></a>"
msgstr""

# CppCoreGuidelines.md:14773
msgid "14773      \\[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996)."
msgstr""

# CppCoreGuidelines.md:14774
msgid "14774    * <a name=\"Meyers96\"></a>"
msgstr""

# CppCoreGuidelines.md:14775
msgid "14775      \\[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996)."
msgstr""

# CppCoreGuidelines.md:14776
msgid "14776    * <a name=\"Meyers97\"></a>"
msgstr""

# CppCoreGuidelines.md:14777
msgid "14777      \\[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997)."
msgstr""

# CppCoreGuidelines.md:14778
msgid "14778    * <a name=\"Meyers15\"></a>"
msgstr""

# CppCoreGuidelines.md:14779
msgid "14779      \\[Meyers15]:        S. Meyers. Effective Modern C++ (O'Reilly, 2015)."
msgstr""

# CppCoreGuidelines.md:14780
msgid "14780    * <a name=\"Murray93\"></a>"
msgstr""

# CppCoreGuidelines.md:14781
msgid "14781      \\[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993)."
msgstr""

# CppCoreGuidelines.md:14782
msgid "14782    * <a name=\"Stroustrup94\"></a>"
msgstr""

# CppCoreGuidelines.md:14783
msgid "14783      \\[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994)."
msgstr""

# CppCoreGuidelines.md:14784
msgid "14784    * <a name=\"Stroustrup00\"></a>"
msgstr""

# CppCoreGuidelines.md:14785
msgid "14785      \\[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000)."
msgstr""

# CppCoreGuidelines.md:14786
msgid "14786    * <a name=\"Stroustrup05\"></a>"
msgstr""

# CppCoreGuidelines.md:14787
msgid "14787      \\[Stroustrup05]:    B. Stroustrup. [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf)."
msgstr""

# CppCoreGuidelines.md:14788
msgid "14788    * <a name=\"Stroustrup13\"></a>"
msgstr""

# CppCoreGuidelines.md:14789
msgid "14789      \\[Stroustrup13]:    B. Stroustrup. [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html). Addison Wesley 2013."
msgstr""

# CppCoreGuidelines.md:14790
msgid "14790    * <a name=\"Stroustrup14\"></a>"
msgstr""

# CppCoreGuidelines.md:14791
msgid "14791      \\[Stroustrup14]:    B. Stroustrup. [A Tour of C++](http://www.stroustrup.com/Tour.html)."
msgstr""

# CppCoreGuidelines.md:14792
msgid "14792      Addison Wesley 2014."
msgstr""

# CppCoreGuidelines.md:14793
msgid "14793    * <a name=\"Stroustrup15\"></a>"
msgstr""

# CppCoreGuidelines.md:14794
msgid "14794      \\[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf)."
msgstr""

# CppCoreGuidelines.md:14795
msgid "14795    * <a name=\"SuttHysl04b\"></a>"
msgstr""

# CppCoreGuidelines.md:14796
msgid "14796      \\[SuttHysl04b]:     H. Sutter and J. Hyslop. \"Collecting Shared Objects\" (C/C++ Users Journal, 22(8), August 2004)."
msgstr""

# CppCoreGuidelines.md:14797
msgid "14797    * <a name=\"SuttAlex05\"></a>"
msgstr""

# CppCoreGuidelines.md:14798
msgid "14798      \\[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005."
msgstr""

# CppCoreGuidelines.md:14799
msgid "14799    * <a name=\"Sutter00\"></a>"
msgstr""

# CppCoreGuidelines.md:14800
msgid "14800      \\[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000)."
msgstr""

# CppCoreGuidelines.md:14801
msgid "14801    * <a name=\"Sutter02\"></a>"
msgstr""

# CppCoreGuidelines.md:14802
msgid "14802      \\[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002)."
msgstr""

# CppCoreGuidelines.md:14803
msgid "14803    * <a name=\"Sutter04\"></a>"
msgstr""

# CppCoreGuidelines.md:14804
msgid "14804      \\[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004)."
msgstr""

# CppCoreGuidelines.md:14805
msgid "14805    * <a name=\"Taligent94\"></a>"
msgstr""

# CppCoreGuidelines.md:14806
msgid "14806      \\[Taligent94]: Taligent's Guide to Designing Programs (Addison-Wesley, 1994)."
msgstr""

